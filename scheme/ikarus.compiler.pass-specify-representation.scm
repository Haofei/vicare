;;;Ikarus Scheme -- A compiler for R6RS Scheme.
;;;Copyright (C) 2006,2007,2008  Abdulaziz Ghuloum
;;;Modified by Marco Maggi <marco.maggi-ipsu@poste.it>
;;;
;;;This program is free software:  you can redistribute it and/or modify
;;;it under  the terms of  the GNU General  Public License version  3 as
;;;published by the Free Software Foundation.
;;;
;;;This program is  distributed in the hope that it  will be useful, but
;;;WITHOUT  ANY   WARRANTY;  without   even  the  implied   warranty  of
;;;MERCHANTABILITY  or FITNESS FOR  A PARTICULAR  PURPOSE.  See  the GNU
;;;General Public License for more details.
;;;
;;;You should  have received  a copy of  the GNU General  Public License
;;;along with this program.  If not, see <http://www.gnu.org/licenses/>.


(module (specify-representation)
  ;;
  ;;
  ;;This module  accepts as  input a  struct instance of  type CODES,  whose internal
  ;;recordized code must be composed by struct instances of the following types:
  ;;
  ;;   bind		closure-maker	conditional
  ;;   constant		fix		forcall
  ;;   funcall		jmpcall		known
  ;;   primref		seq		var
  ;;
  (import CORE-PRIMITIVE-OPERATION-NAMES SCHEME-OBJECTS-ONTOLOGY)

  (define-syntax __module_who__
    (identifier-syntax 'specify-representation))

  (define (specify-representation x)
    ;;Perform code transformation traversing the whole  hierarchy in X, which must be
    ;;a  CODES struct  representing recordised  code; build  and return  a new  CODES
    ;;struct.
    ;;
    (V-codes x))


;;;; process CODES struct

(module (V-codes)

  (define (V-codes x)
    (struct-case x
      ((codes code* body)
       (let ((code* (map V-clambda code*))
	     (body  (V body)))
	 (make-codes code* body)))))

  (define (V-clambda x)
    (struct-case x
      ((clambda label clause* cp free* name)
       (make-clambda label (map V-clambda-clause clause*) cp free* name))))

  (define (V-clambda-clause x)
    (struct-case x
      ((clambda-case info body)
       (make-clambda-case info (V body)))))

  #| end of module: V-codes |# )


;;;; internal representation of primitive operations
;;
;;The internal  representation of a  primitive operation  is a symbol  whose property
;;list contains an instance of  struct PRIMITIVE-HANDLER.  For example $VECTOR-LENGTH
;;is represented by:
;;
;;   (set-primop! '$vector-length
;;                (make-primitive-handler #f
;;                  cogen-pred-$vector-length    #t
;;                  cogen-value-$vector-length   #t
;;                  cogen-effect-$vector-length  #t))
;;
;;where the  bindings COGEN-*-$VECTOR-LENGTH are CASE-LAMBDA  functions that generate
;;high-level  assembly  code for  the  specified  execution context.   The  execution
;;context functions  are usually generated by  the syntax DEFINE-PRIMITIVE-OPERATION,
;;and then can be called at will.
;;
;;Predicate context
;;-----------------
;;
;;For a primitive operation used in predicate context: the only thing that matters is
;;if the return value is true or false, as in:
;;
;;   (if (vector-length vec)
;;       (this)
;;     (that))
;;
;;in which case, if we know that the return value is always true, we can optimise to:
;;
;;   (begin
;;     (vector-length vec)
;;     (this))
;;
;;For side effects context
;;------------------------
;;
;;When  a primitive  operation is  used for  its side  effects: the  return value  is
;;discarded, so if we know that the primitive  has no side effects we can discard the
;;whole expression.  As example, we can optimise:
;;
;;   (begin
;;     (vector-length vec)
;;     (this))
;;
;;to:
;;
;;   (begin
;;     (this))
;;
;;because calling $VECTOR-LENGTH is useless; conversely:
;;
;;   (begin
;;     (read)
;;     (this))
;;
;;we cannot  discard the  call to READ,  because it consumes  bytes from  the current
;;input port.
;;
;;For return value context
;;------------------------
;;
;;When a primitive operation is used for its return value, as in:
;;
;;   (display (vector-length vec))
;;
;;we really have to perform the operation.
;;
(define-struct primitive-handler
  ;;Primitive  handler.   Collects  the  definitions  associated  to  core  primitive
  ;;operations.   An instance  of this  structure  is created  for every  use of  the
  ;;DEFINE-PRIMITIVE-OPERATION syntax.
  ;;
  (interruptable?
		;Boolean.   True if  the high-level  assembly code  implementing this
		;core primitive operation must be  wrapped into a SHORTCUT struct and
		;so it might contain INTERRUPT ASMCALL structs representing a jump to
		;the interrupt  handler.  False  if this  primitive operation  is not
		;interruptible and so it must not contain INTERRUPT ASMCALLs.
   p-handler
		;CASE-LAMBDA  function generating  assembly  code  for the  predicate
		;execution context.
   p-handled?
		;Boolean,  true  if  this  primitive  operation  is  implemented  for
		;predicate execution context.
   v-handler
		;CASE-LAMBDA function generating assembly  code for the "for returned
		;value" execution context.
   v-handled?
		;Boolean, true  if this  primitive operation  is implemented  for the
		;"for returned value" execution context.
   e-handler
		;CASE-LAMBDA  function generating  assembly  code for  the "for  side
		;effects" execution context.
   e-handled?
		;Boolean, true  if this  primitive operation  is implemented  for the
		;"for side effects" execution context.
   ))


(module (with-tmp)

  (define-syntax (with-tmp stx)
    ;;Do what is needed to generate recordized  code in the region of a local binding
    ;;definition.  It works like LET for recordized code generation
    ;;
    (syntax-case stx ()
      ((_ ((?lhs ?rhs) ...) ?body0 ?body ...)
       (with-syntax
	   (((LHS ...) (generate-temporaries #'(?lhs ...)))
	    ((RHS ...) (generate-temporaries #'(?lhs ...))))
	 ;;Evaluate the right-hand sides, which must return recordized code.  We want
	 ;;to evaluate the ?RHS expression outside the region of the ?LHS bindings.
	 #'(let ((RHS ?rhs) ...)
	     ;;Generate new struct instances of type VAR to be used as left-hand side
	     ;;in the BIND struct below.
	     (let ((LHS (make-unique-var '?lhs)) ...)
	       ;;Make the binding struct, which represents machine words allocated on
	       ;;the stack  and initialised with  the results of evaluating  the ?RHS
	       ;;expressions.
	       (make-bind (list LHS ...)
			  (list RHS ...)
			  ;;The ?BODY forms expect Scheme bindings to exist with name
			  ;;?LHS,  referencing  the  VAR structures.   Wrap  the  VAR
			  ;;structs into KNOWN structs whenever the corresponding RHS
			  ;;has a type description.
			  (let ((?lhs (%copy-core-type-descr LHS RHS)) ...)
			    ;;Evaluate  the body  forms,  each of  which must  return
			    ;;recordized code.
			    (multiple-forms-sequence ?body0 ?body ...)))))))
      ))

  ;;FIXME  Why in  hell does  this implementation  of WITH-TMP*  cause a  segfault?!?
  ;;(Marco Maggi; Sun Sep 14, 2014)
  ;;
  ;; (define-syntax (with-tmp* stx)
  ;;   ;;We use this when we want the ?RHS  expressions to be evaluated in the region of
  ;;   ;;the previous  ?LHS binding.  If WITH-TMP  works like LET, WITH-TMP*  works like
  ;;   ;;LET*.
  ;;   (syntax-case stx ()
  ;;     ((_ () ?body0 ?body ...)
  ;;      #'(let () ?body0 ?body ...))
  ;;     ((_ ((?lhs0 ?rhs0) (?lhs ?rhs) ...) ?body0 ?body ...)
  ;;      #'(with-tmp ((?lhs0 ?rhs0))
  ;; 	   (with-tmp* ((?lhs ?rhs) ...)
  ;; 	     ?body0 ?body ...)))
  ;;     ))

  (define (%copy-core-type-descr lhs.var rhs.struct)
    (struct-case rhs.struct
      ((known _ type)
       (make-known lhs.var type))
      (else lhs.var)))

  #| end of module: WITH-TMP |# )


(module CODE-GENERATION-FOR-CORE-PRIMITIVE-OPERATION-CALLS
  (cogen-primop cogen-debug-primop interrupt)
  ;;Some core primitives are implemented both as:
  ;;
  ;;*  Core primitive  functions.   There  exists a  loc  gensym  whose "value"  slot
  ;;   references  a  closure  object,  which   in  turn  references  a  code  object
  ;;  implementing  the core primitive as  machine code.  When the  core primitive is
  ;;  used as argument as in:
  ;;
  ;;     (map fx+ a* b*)
  ;;
  ;;  the closure object implementation is used.
  ;;
  ;;* Core  primitive operations.  There exist  functions that the compiler  calls to
  ;;  integrate assembly instructions implementing the core primitive.  When the core
  ;;  primitive is used as first subform of an application form as in:
  ;;
  ;;     (fx+ 1 2)
  ;;
  ;;  the primitive operation is used.
  ;;
  ;;The functions COGEN-PRIMOP and COGEN-DEBUG-PRIMOP  are used to process recordised
  ;;code:
  ;;
  ;;   (primopcall ?primitive-symbol-name ?rand ...)
  ;;
  ;;in which  it is known  that ?PRIMITIVE-SYMBOL-NAME  is a symbol  representing the
  ;;public name of a core primitive operation, so that:
  ;;
  ;;   (get-primop '?primitive-symbol-name)
  ;;
  ;;will retrieve a struct of type PRIMITIVE-HANDLER.
  ;;
  ;;
  ;;Disabled debugging mode
  ;;-----------------------
  ;;
  ;;If a core  primitive has both the implementations as  operation and function, the
  ;;general integration pattern is to use this code template:
  ;;
  ;;   (shortcut ?body ?interrupt-handler)
  ;;
  ;;where:  ?BODY is  recordised code  implementing a  fast and  sometimes simplified
  ;;implementation of the  primitive, working with the most  probable argument types;
  ;;?INTERRUPT-HANDLER  is  recordised code  implementing  a  call to  the  primitive
  ;;function.  See below for examples.
  ;;
  ;;If the fast implementation  works: it generates the result that  is handed to the
  ;;caller.   If the  fast implementation  fails:  it jumps  to  a call  to the  full
  ;;function; the  function validates the arguments  and retries to perform  the task
  ;;for all the supported argument types.
  ;;
  ;;For a few core primitives implementing simple computations, it is useless to call
  ;;the full function: if the fast implementation failed it means the operands are of
  ;;wrong type  or the operation is  impossible.  For these primitives  the interrupt
  ;;handler is  a special function  that knows the operands  are invalid, so  it just
  ;;validates them and raises the  appropriate exception.  The core primitives having
  ;;this implementation are:
  ;;
  ;;   fx+		fx-		fx*
  ;;   add1				sub1
  ;;   fxadd1				fxsub1
  ;;   fxarithmetic-shift-left		fxarithmetic-shift-right
  ;;
  ;;not many, but still important  cases.  Such exception-raising routines are called
  ;;ERROR@?PRIM, where ?PRIM is the name of the core primitive.
  ;;
  ;;
  ;;Partitioning simple and complex operands
  ;;----------------------------------------
  ;;
  ;;We implement a call to core primitive operation with the template:
  ;;
  ;;   (shortcut ?integrated-fast-implementation ?function-implementation-call)
  ;;
  ;;but  we have  to  be careful  not  to  include twice  the  code representing  the
  ;;operands; in general, the recordised code:
  ;;
  ;;   (primopcall ?prim-name ?rand ...)
  ;;
  ;;must be (conceptually) transformed into:
  ;;
  ;;   (bind ((?tmp ?rand) ...)
  ;;     (primopcall ?prim-name ?tmp ...))
  ;;
  ;;and then into:
  ;;
  ;;   (bind ((?tmp ?rand) ...)
  ;;     (shortcut
  ;;         (?integrated-fast-implementation ?tmp ...)
  ;;       (?function-implementation ?tmp ...))
  ;;
  ;;this way each ?RAND is included only once.   But, whenever a ?RAND has one of the
  ;;formats:
  ;;
  ;;   (constant ?const)
  ;;   (known (constant ?const) ?type)
  ;;   var
  ;;   (known var ?type)
  ;;
  ;;there is no need to introduce a  binding for it, because such operand structs can
  ;;be included multiple  times with no problems.   So, in this module,  we split the
  ;;operands between simple (which can be included multiple times) and complex (which
  ;;must  be included  through  a  local binding).   As  example,  the core  language
  ;;expression:
  ;;
  ;;   ((primitive fx+) '1 '2)
  ;;
  ;;is transformed into the pseudo-code:
  ;;
  ;;   (shortcut
  ;;       (cogen-value-fx+ (constant 1) (constant 2))
  ;;     (funcall (primref fx+) (constant 1) (constant 2)))
  ;;
  ;;while the core language expression:
  ;;
  ;;   ((primitive fx+) '1 ((primitive read)))
  ;;
  ;;is transformed into the pseudo-code:
  ;;
  ;;   (bind ((tmp ((primitive read))))
  ;;     (shortcut
  ;;         (cogen-value-fx+ (constant 1) tmp)
  ;;       (funcall (primref fx+) (constant 1) tmp)))
  ;;
  ;;The  result is  that the  primitive-operation implementation-handlers  receive as
  ;;operands only structs with the format:
  ;;
  ;;   (constant ?const)
  ;;   (known (constant ?const) ?type)
  ;;   var
  ;;   (known var ?type)
  ;;
  ;;which are  called "simple operands"; such  operands must be filtered  through the
  ;;function  "V-simple-operand", before  being  included in  recordised  code to  be
  ;;handed to the subsequent compiler pass.
  ;;
  ;;
  ;;Example: the VECTOR-LENGTH primitive function and primitive operation
  ;;---------------------------------------------------------------------
  ;;
  ;;Let's consider the core language expression:
  ;;
  ;;   ((primitive vector-length) ?rand)
  ;;
  ;;which is recordised as:
  ;;
  ;;   (funcall (primref vector-length) ?rand)
  ;;
  ;;when debugging is disabled, the recordised  representation we want to generate in
  ;;this module is (slightly edited):
  ;;
  ;;   (bind ((tmp_0 ?rand))
  ;;     (shortcut
  ;;         (seq
  ;;           ;;If the operand is a tagged pointer tagged as vector...
  ;;           (conditional (asmcall = (asmcall logand tmp_0 (constant 7))
  ;;                                   (constant 5))
  ;;               ;;... fine.
  ;;               (asmcall nop)
  ;;             ;;... otherwise call the full core primitive function.
  ;;             (asmcall interrupt))
  ;;           ;;Retrieve the first word.
  ;;           (bind ((vec.len_0 (asmcall mref tmp_0 (constant -5))))
  ;;             (seq
  ;;               ;;If the first word is a fixnum...
  ;;               (conditional (asmcall = (asmcall logand vec.len_0 (constant 7))
  ;;                                       (constant 0))
  ;;                   ;;... fine.
  ;;                   (asmcall nop)
  ;;                 ;;... otherwise call the full core primitive function.
  ;;                 (asmcall interrupt))
  ;;             ;;Return the first word, which is the length of the vector.
  ;;             vec.len_0)))
  ;;       ;;Interrupt handler: perform a full call to the primitive function and let
  ;;       ;;it raise an exception if there is the need.
  ;;       (funcall (asmcall mref (constant (object vector-length)) (constant 19))
  ;;                tmp_0)))
  ;;
  ;;
  ;;Example: the FX+ primitive function and primitive operation
  ;;-----------------------------------------------------------
  ;;
  ;;When the primitive function implementation  of FX+ detects overflow or underflow:
  ;;it  raises  an exception.   When  the  primitive  operation detects  overflow  or
  ;;underflow what should it do?  The answer is: every integrated primitive-operation
  ;;assembly-code will jump  to the same routine which will  raise an exception; such
  ;;exception-raising routines are called ERROR@?PRIM, where ?PRIM is the name of the
  ;;core primitive.
  ;;
  ;;Let's consider the core language expression:
  ;;
  ;;   ((primitive fx+) ?rand1 ?rand2)
  ;;
  ;;in which  the operands are  known at compile-time  to be fixnums;  when debugging
  ;;mode  is disabled,  the recordised  representation we  want to  generate in  this
  ;;module is:
  ;;
  ;;   (shortcut
  ;;       (asmcall int+/overflow ?rand1 ?rand2)
  ;;     (funcall (asmcall mref (constant (object error@fx+))
  ;;                             off-symbol-record-value)
  ;; 	    ?rand1 ?rand2))
  ;;
  ;;where  "(object error@fx+)"  represents  the  loc gensym  of  the core  primitive
  ;;function "error@fx+".
  ;;
  ;;The first form in SHORTCUT is the core primitive operation call's "body":
  ;;
  ;;   (asmcall int+/overflow ?rand1 ?rand2)
  ;;
  ;;the second  form in SHORTCUT  is the  core primitive operation  call's "interrupt
  ;;handler":
  ;;
  ;;   (funcall (asmcall mref (constant (object error@fx+))
  ;;                           off-symbol-record-value)
  ;;     ?rand1 ?rand2)
  ;;
  (define-syntax __module_who__
    (identifier-syntax 'code-generation-handler))

  (define (cogen-debug-primop primitive-symbol-name src/loc ctxt rand*)
    ;;Return  recordised  code  representing  the application  of  a  core  primitive
    ;;function, when debugging mode is ENabled.
    ;;
    ;;CTXT is one of  the symbols: V, E, P.  RAND* is a  list of structs representing
    ;;the operands as recordised code, not yet filtered through V.
    ;;
    (define (%cogen-core-primitive-debug-call primitive-symbol-name simple-rand*)
      (make-funcall (V (mk-primref 'debug-call))
		    (cons* (V src/loc)
			   (V (mk-primref primitive-symbol-name))
			   simple-rand*)))
    (%cogen-primop-call %cogen-core-primitive-debug-call
			%cogen-core-primitive-debug-call
			primitive-symbol-name ctxt rand*))

  (module (cogen-primop)

    (define (cogen-primop primitive-symbol-name ctxt rand*)
      ;;This is a function with signature:
      ;;
      ;;   (cogen-primop ?primitive-symbol-name ?ctxt ?rand*)
      ;;
      ;;where: ?CTXT  is one of  the symbols: V,  E, P; ?RAND*  is a list  of structs
      ;;representing the  operands as  recordised code, not  yet filtered  through V.
      ;;Return  recordised code  representing the  application of  a core  primitive,
      ;;either function or operation, when debugging mode is DISabled.
      ;;
      (%cogen-primop-call %cogen-core-primitive-interrupt-handler-function-call
			  %cogen-core-primitive-standalone-function-call
			  primitive-symbol-name ctxt rand*))

    (define (%cogen-core-primitive-standalone-function-call primitive-symbol-name simple-rand*)
      ;;Generate code representing a call to the core primitive function.  This is to
      ;;be  used when  no  core  primitive operation  integration  is performed  (for
      ;;example  because  the  primitive  has no  operation  implementation,  just  a
      ;;function implementation).
      ;;
      (make-funcall (V (mk-primref primitive-symbol-name)) simple-rand*))

    (module (%cogen-core-primitive-interrupt-handler-function-call)

      (define (%cogen-core-primitive-interrupt-handler-function-call primitive-symbol-name simple-rand*)
	;;Generate code representing a call to  the core primitive function.  This is
	;;to be used as implementation of the interrupt handler, after the integrated
	;;fast  implementation has  failed.  If  the core  primitive has  the special
	;;interrupt handler implementation: use such function.
	;;
	;;In the VECTOR-LENGTH example, this function generates the code:
	;;
	;;   (funcall (asmcall mref
	;;                     (constant (object vector-length))
	;;                     off-symbol-record-value)
	;;            tmp_0)
	;;
	;;where  "(object  vector-length)" represents  the  loc  gensym of  the  core
	;;primitive function VECTOR-LENGTH.
	;;
	;;In the FX+ example, this function generates the code:
	;;
	;;   (funcall (asmcall mref
	;;                     (constant (object error@fx+))
	;;                     off-symbol-record-value)
	;;            ?rand1 ?rand2)
	;;
	;;where "(object error@fx+)" represents the  loc gensym of the core primitive
	;;function ERROR@FX+"
	;;
	(make-funcall (V (mk-primref (%primop-interrupt-handler primitive-symbol-name)))
		      simple-rand*))

      (define (%primop-interrupt-handler primitive-symbol-name)
	;;FIXME  Should this  mapping  of names  be  included in  the  table of  core
	;;primitive declarations?  (Marco Maggi; Mon Sep 29, 2014)
	(case primitive-symbol-name
	  ((fx+)			'error@fx+)
	  ((fx-)			'error@fx-)
	  ((fx*)			'error@fx*)
	  ((add1)			'error@add1)
	  ((sub1)			'error@sub1)
	  ((fxadd1)			'error@fxadd1)
	  ((fxsub1)			'error@fxsub1)
	  ((fxarithmetic-shift-left)	'error@fxarithmetic-shift-left)
	  ((fxarithmetic-shift-right)	'error@fxarithmetic-shift-right)
	  (else				primitive-symbol-name)))

      #| end of module: %COGEN-CORE-PRIMITIVE-INTERRUPT-HANDLER-FUNCTION-CALL |# )

    #| end of module: COGEN-PRIMOP |# )

;;; --------------------------------------------------------------------

  (module (%cogen-primop-call)

    (define-syntax __module_who__
      (identifier-syntax '%cogen-primop-call))

    (define (%cogen-primop-call cogen-core-primitive-interrupt-handler-function-call
				cogen-core-primitive-standalone-function-call
				primitive-symbol-name ctxt rand*)
      ;;CTXT must be one of the symbols:  P, V, E representing the evaluation context
      ;;of a struct of recordised code.  RAND*  is a list of structs representing the
      ;;operands as recordised code, not yet filtered through V.
      ;;
      (define-syntax-rule (%cogen ?simple-rand*)
	(%generate-code cogen-core-primitive-interrupt-handler-function-call
			cogen-core-primitive-standalone-function-call
			primitive-symbol-name ctxt ?simple-rand*))
      ;;Here the complex  operand structs in RHS* have been  already filtered through
      ;;V; the  SIMPLE-RAND* structs have been  left alone, not yet  filtered through
      ;;"V-simple-operand".
      (receive (lhs* rhs* simple-rand*)
	  (%partition-simple/complex-operands rand*)
	(if (null? lhs*)
	    (%cogen simple-rand*)
	  (make-bind lhs* rhs* (%cogen simple-rand*)))))

    (define (%partition-simple/complex-operands rand*)
      ;;Non-tail  recursive  function.  Given  a  list  of structs  representing  the
      ;;operands  of a  primitive  operation  application: build  what  is needed  to
      ;;separate the operands requiring a single reference from the others.
      ;;
      ;;Filter the complex operands through V, leave the simple operands unfiltered.
      ;;
      (if (pair? rand*)
	  (receive (lhs* rhs* simple-rand*)
	      (%partition-simple/complex-operands (cdr rand*))
	    (let ((rand (car rand*)))
	      (struct-case rand
		((var)
		 ;;This operand is a variable reference: it is a simple operand.
		 (values lhs* rhs* (cons rand simple-rand*)))
		((known rand.expr rand.type)
		 (struct-case rand.expr
		   ((constant)
		    ;;This operand is:
		    ;;
		    ;;   (known (constant ?rand.expr.const) ?rand.type)
		    ;;
		    ;;it is a simple operand.
		    (values lhs* rhs* (cons rand simple-rand*)))
		   ((var)
		    ;;This operand is:
		    ;;
		    ;;   (known var ?rand.type)
		    ;;
		    ;;it is a simple operand.
		    (values lhs* rhs* (cons rand simple-rand*)))
		   (else
		    ;;This operand is:
		    ;;
		    ;;   (known ?rand.expr ?rand.type)
		    ;;
		    ;;the ?RAND.EXPR  must be  included only  once in  the recordised
		    ;;code: it is  a complex operand; we introduce a  VAR binding and
		    ;;move the  type description  from the expression  to the  VAR in
		    ;;reference position.
		    (let ((tmp (make-unique-var 'tmp)))
		      (values (cons tmp           lhs*)
			      (cons (V rand.expr) rhs*)
			      (cons (make-known tmp rand.type) simple-rand*))))))
		((constant)
		 ;;This operand is a constant: it is a simple operand.
		 (values lhs* rhs* (cons rand simple-rand*)))
		(else
		 ;;This operand is  an expression with unknown  type description; the
		 ;;RAND must  be included only once  in the recordised code:  it is a
		 ;;complex  operand; we  introduce a  new  VAR binding  and a  simple
		 ;;operand referencing it.
		 (let ((tmp (make-unique-var 'tmp)))
		   (values (cons tmp      lhs*)
			   (cons (V rand) rhs*)
			   (cons tmp simple-rand*)))))))
	(values '() '() '())))

    #| end of module: %COGEN-PRIMOP-CALL |# )

;;; --------------------------------------------------------------------

  (module (%generate-code interrupt)

    (define (%generate-code cogen-core-primitive-interrupt-handler-function-call
			    cogen-core-primitive-standalone-function-call
			    primitive-symbol-name ctxt simple-rand*)
      ;;Build and  return the  recordised code  representing the  primitive operation
      ;;application.  Return  either a  standalone integrated  application body  or a
      ;;SHORTCUT struct wrapping the integrated application body.
      ;;
      ;;First we compose the integration body, then:
      ;;
      ;;* If the body contains at least one "(interrupt)" call: we wrap the body into
      ;;  a SHORTCUT.
      ;;
      ;;*  If the  body contains  *no*  "(interrupt)" calls:  we return  the body  as
      ;;  standalone struct.
      ;;
      (define prim
	;;PRIM is a struct of type PRIMITIVE-HANDLER.
	(get-primop primitive-symbol-name))
      (define (interrupt-handler/uninterruptible-primitive-error)
	;;Function     to    be     used     as    value     for    the     parameter
	;;%RECORD-USE-OF-INTERRUPT-IN-BODY.  It raises an error.
	;;
	(compiler-internal-error '%record-use-of-interrupt-in-body
	  "attempt to introduce a jump to interrupt handler in the body of an uninterruptible core primitive operation"
	  primitive-symbol-name simple-rand* ctxt))
      (if (not (primitive-handler-interruptable? prim))
	  ;;Build  and return  the integrated  body as  standalone struct.   Raise an
	  ;;error if INTERRUPT is called by an uninterruptible primitive.
	  (parameterize ((%record-use-of-interrupt-in-body interrupt-handler/uninterruptible-primitive-error))
	    (%cogen-primop-body prim ctxt simple-rand*))
	(let* ((interrupted? #f)
	       (body         (parameterize ((%record-use-of-interrupt-in-body (lambda ()
										(set! interrupted? #t))))
			       (%cogen-primop-body prim ctxt simple-rand*))))
	  (if (not interrupted?)
	      ;;No jumps to the interrupt handler  is present in BODY: avoid creating
	      ;;a SHORTCUT and just return the BODY itself.
	      body
	    ;;At least one jump to the interrupt handler is present in BODY: wrap the
	    ;;body into a SHORTCUT; return the SHORTCUT struct.
	    (with-interrupt-handler prim ctxt body primitive-symbol-name simple-rand*
				    cogen-core-primitive-interrupt-handler-function-call
				    cogen-core-primitive-standalone-function-call)))))

    (define-constant %record-use-of-interrupt-in-body
      (make-parameter (lambda ()
			(compiler-internal-error '%record-use-of-interrupt-in-body
			  "uninitialized parameter"))))

    (define (interrupt)
      ;;Record that this body has requested the presence of an interrupt handler.
      ((%record-use-of-interrupt-in-body))
      ;;Return the "(asmcall interrupt)".
      (asm 'interrupt))

    #| end of module: %GENERATE-CODE |# )

;;; --------------------------------------------------------------------

  (module (%cogen-primop-body)

    (define (%cogen-primop-body prim ctxt simple-rand*)
      ;;Actually generate the BODY of a  primitive operation call; this body might be
      ;;wrapped  or not  into  a  SHORTCUT.  This  function  is  where the  primitive
      ;;operation handlers stored in the PRIMITIVE-HANDLER structs are applied to the
      ;;simple operands.
      ;;
      ;;* If CTXT is V:
      ;;
      ;;   if cogen-value, then V
      ;;   if cogen-pred, then (if P #f #t)
      ;;   if cogen-effect, then (seq E (void))
      ;;
      ;;* If CTXT is P:
      ;;
      ;;   if cogen-pred, then P
      ;;   if cogen-value, then (!= V #f)
      ;;   if cogen-effect, then (seq E #t)
      ;;
      ;;* If CTXT is E:
      ;;
      ;;   if cogen-effect, then E
      ;;   if cogen-value, then (let ((tmp V)) (nop))
      ;;   if cogen-pred, then (if P (nop) (nop))
      ;;
      ;;The  primitive  handler functions  extracted  from  PRIM  will take  care  of
      ;;filtering the SIMPLE-RAND* through the function T.
      ;;
      (case ctxt
	((P)
	 (case-primitive-operation-handler prim
	   ((P)
	    ;;There is a "for predicate" context implementation handler; just use it.
	    (apply P-handler simple-rand*))
	   ((V)
	    ;;There is no  "for predicate" implementation handler, but  a "for value"
	    ;;implementation handler  exists; we  generate a "for  predicate" handler
	    ;;as:
	    ;;
	    ;;   (asmcall != (for-value-asmcall) (KN bool-f))
	    ;;
	    ;;and we handle special cases.
	    (let ((e (apply V-handler simple-rand*)))
	      (define (%doit-with-adapter)
		(asm '!= e (KN bool-f)))
	      (struct-case e
		((asmcall op)
		 (if (eq? op 'interrupt)
		     e
		   (%doit-with-adapter)))
		((constant e.const)
		 ;;The "for  predicate" handler can  return a CONSTANT holding  #t or
		 ;;#f; we  convert the constant  returned by the "for  value" handler
		 ;;accordingly.
		 (if (eq? e.const bool-f)
		     (K #f)
		   (K #t)))
		(else
		 (%doit-with-adapter)))))
	   ((E)
	    ;;There is  neither a  "for predicate" nor  a "for  value" implementation
	    ;;handler, but  a "for  side effects"  implementation handler  exists; we
	    ;;generate a "for predicate" handler as:
	    ;;
	    ;;   (seq (for-effects-asmcall) (K t))
	    ;;
	    ;;and we handle special cases.
	    (let ((e (apply E-handler simple-rand*)))
	      (define (%doit-with-adapter)
		(make-seq e (K #t)))
	      (struct-case e
		((asmcall op)
		 (if (eq? op 'interrupt)
		     e
		   (%doit-with-adapter)))
		((constant)
		 ;;This should not happen... whatever.
		 (K #t))
		(else
		 (%doit-with-adapter)))))))
	((V)
	 (case-primitive-operation-handler prim
	   ((V)
	    ;;There is a "for value" context implementation handler; just use it.
	    (apply V-handler simple-rand*))
	   ((P)
	    ;;There is no  "for value" implementation handler, but  a "for predicate"
	    ;;implementation handler exists; we generate a "for value" handler as:
	    ;;
	    ;;   (condition (for-pred-asmcall)
	    ;;       (KN bool-t)
	    ;;     (KN bool-f))
	    ;;
	    ;;and we handle special cases.
	    (let ((e (apply P-handler simple-rand*)))
	      (define (%doit-with-adapter)
		(make-conditional e (KN bool-t) (KN bool-f)))
	      (struct-case e
		((asmcall op)
		 (if (eq? op 'interrupt)
		     e
		   (%doit-with-adapter)))
		((constant e.const)
		 ;;If the  "for predicate" handler has  returned a constant, it  is a
		 ;;boolean;  so   we  convert   it  into  the   corresponding  native
		 ;;representation of a boolean.
		 (if e.const
		     (KN bool-t)
		   (KN bool-f)))
		(else
		 (%doit-with-adapter)))))
	   ((E)
	    ;;There are  neither a "for  value" nor a "for  predicate" implementation
	    ;;handlers, but  a "for side  effects" implementation handler  exists; we
	    ;;generate a "for value" handler as:
	    ;;
	    ;;   (seq
	    ;;     (for-effects-asmcall)
	    ;;     (KN void-object))
	    ;;
	    ;;and we handle special cases.
	    (let ((e (apply E-handler simple-rand*)))
	      (define (%doit-with-adapter)
		(make-seq e (KN void-object)))
	      (struct-case e
		((asmcall op)
		 (if (eq? op 'interrupt)
		     e
		   (%doit-with-adapter)))
		((constant)
		 (nop))
		(else
		 (%doit-with-adapter)))))))
	((E)
	 (case-primitive-operation-handler prim
	   ((E)
	    ;;There is a "for side  effects" context implementation handler; just use
	    ;;it.
	    (apply E-handler simple-rand*))
	   ((P)
	    ;;There  is no  "for side  effects"  implementation handler,  but a  "for
	    ;;predicate" implementation  handler exists; we generate  a "for effects"
	    ;;handler as:
	    ;;
	    ;;   (condition (for-pred-asmcall)
	    ;;       (nop)
	    ;;     (nop))
	    ;;
	    ;;and we handle special cases.
	    (let ((e (apply P-handler simple-rand*)))
	      (define (%doit-with-adapter)
		(make-conditional e (nop) (nop)))
	      (struct-case e
		((asmcall op)
		 (if (eq? op 'interrupt)
		     e
		   (%doit-with-adapter)))
		((constant)
		 (nop))
		(else
		 (%doit-with-adapter)))))
	   ((V)
	    ;;There  are  neither  a  "for   side  effects"  nor  a  "for  predicate"
	    ;;implementation  handlers,  but  a "for  value"  implementation  handler
	    ;;exists; we generate a "for effects" handler as:
	    ;;
	    ;;   (bind ((tmp (for-value-asmcall)))
	    ;;     (nop))
	    ;;
	    ;;and  we handle  special cases.   Notice  that the  "for value"  handler
	    ;;represents code that generates and returns a value, so we must allocate
	    ;;a location for it, even if we do not use such return value.
	    (let ((e (apply V-handler simple-rand*)))
	      (define (%doit-with-adapter)
		(with-tmp ((t e))
		  (nop)))
	      (struct-case e
		((asmcall op)
		 (if (eq? op 'interrupt)
		     e
		   (%doit-with-adapter)))
		((constant)
		 (nop))
		(else
		 (%doit-with-adapter)))))))
	(else
	 (compiler-internal-error __module_who__ "invalid evaluation context" ctxt))))

    (define-syntax (case-primitive-operation-handler stx)
      (define (main stx)
	(syntax-case stx ()
	  ((?ctx ?prim
		 ((V) . ?V-body)
		 ((P) . ?P-body)
		 ((E) . ?E-body))
	   (%fender #'V #'P #'E)
	   (%generate-output-form #'?ctx #'?prim
				  (%generate-v-branch #'?ctx #'?V-body)
				  (%generate-p-branch #'?ctx #'?P-body)
				  (%generate-e-branch #'?ctx #'?E-body)))
	  ((?ctx ?prim
		 ((P) . ?P-body)
		 ((V) . ?V-body)
		 ((E) . ?E-body))
	   (%fender #'V #'P #'E)
	   (%generate-output-form #'?ctx #'?prim
				  (%generate-p-branch #'?ctx #'?P-body)
				  (%generate-v-branch #'?ctx #'?V-body)
				  (%generate-e-branch #'?ctx #'?E-body)))
	  ((?ctx ?prim
		 ((E) . ?E-body)
		 ((P) . ?P-body)
		 ((V) . ?V-body))
	   (%fender #'V #'P #'E)
	   (%generate-output-form #'?ctx #'?prim
				  (%generate-e-branch #'?ctx #'?E-body)
				  (%generate-p-branch #'?ctx #'?P-body)
				  (%generate-v-branch #'?ctx #'?V-body)))
	  ))

      (define (%generate-output-form ctx prim.stx branch-0 branch-1 branch-2)
	#`(let ((prim #,prim.stx))
	    (cond #,branch-0
		  #,branch-1
		  #,branch-2
		  (else
		   (%error-context-not-handled prim)))))

      (define (%fender V P E)
	(and (eq? 'V (syntax->datum V))
	     (eq? 'P (syntax->datum P))
	     (eq? 'E (syntax->datum E))))

      (define (%generate-v-branch ctx body)
	(with-syntax ((V-handler (datum->syntax ctx 'V-handler)))
	  #`((primitive-handler-v-handled? prim)
	     (let ((V-handler (primitive-handler-v-handler prim)))
	       . #,body))))

      (define (%generate-p-branch ctx body)
	(with-syntax ((P-handler (datum->syntax ctx 'P-handler)))
	  #`((primitive-handler-p-handled? prim)
	     (let ((P-handler (primitive-handler-p-handler prim)))
	       . #,body))))

      (define (%generate-e-branch ctx body)
	(with-syntax ((E-handler (datum->syntax ctx 'E-handler)))
	  #`((primitive-handler-e-handled? prim)
	     (let ((E-handler (primitive-handler-e-handler prim)))
	       . #,body))))

      (main stx))

    (define (%error-context-not-handled prim)
      (compile-time-error __module_who__
	"evaluation context not handled by core primitive operation" prim))

    #| end of module: %COGEN-PRIMOP-BODY |# )

;;; --------------------------------------------------------------------

  (module (with-interrupt-handler)
    ;;This module is used when there is at least one:
    ;;
    ;;   (asmcall interrupt)
    ;;
    ;;in  the  recordised  code   representing  the  integrated  primitive  operation
    ;;application; so we must generate an interrupt  handler and wrap the BODY into a
    ;;SHORTCUT.
    ;;
    ;;NOTE When  it is determined  at compile-time that  the operands of  a primitive
    ;;operation are invalid, the whole generated SHORTCUT's ?BODY can be a simple:
    ;;
    ;;   (asmcall interrupt)
    ;;
    ;;in this case, if we do nothing special, we end up generating:
    ;;
    ;;   (shortcut
    ;;       (asmcall interrupt)
    ;;     ?interrupt-handler)
    ;;
    ;;which would be stupid;  so we take care of recognising  this special ?BODY case
    ;;and instead of a  SHORTCUT return a plain call to  the core primitive function.
    ;;In this case, it  also makes sense to raise a  compile-time exception to signal
    ;;the error early;  we do not do it  here, we delegate this task  to the specific
    ;;primitive operation definition macro.
    ;;
    (define* (with-interrupt-handler prim ctxt body primitive-symbol-name simple-rand*
				     cogen-core-primitive-interrupt-handler-function-call
				     cogen-core-primitive-standalone-function-call)
      ;;PRIM is a struct of type PRIMITIVE-HANDLER.  CTXT must be one of the symbols:
      ;;V,  E,  P.  FILTERED-SIMPLE-RAND*  is  a  list  of structs  representing  the
      ;;operands as recordised code.
      ;;
      (define filtered-simple-rand*
	(map V-simple-operand simple-rand*))
      (case ctxt
	((V)
	 (if (%the-body-is-just-an-interrupt-asmcall? body)
	     (cogen-core-primitive-standalone-function-call primitive-symbol-name filtered-simple-rand*)
	   (make-shortcut
	       body
	     (cogen-core-primitive-interrupt-handler-function-call primitive-symbol-name filtered-simple-rand*))))

	((E)
	 (if (%the-body-is-just-an-interrupt-asmcall? body)
	     (cogen-core-primitive-standalone-function-call primitive-symbol-name filtered-simple-rand*)
	   (make-shortcut
	       body
	     (cogen-core-primitive-interrupt-handler-function-call primitive-symbol-name filtered-simple-rand*))))

	((P)
	 (if (%the-body-is-just-an-interrupt-asmcall? body)
	     (asm '!= (cogen-core-primitive-standalone-function-call primitive-symbol-name filtered-simple-rand*)
		    (K bool-f))
	   (make-shortcut
	       body
	     (asm '!= (cogen-core-primitive-interrupt-handler-function-call primitive-symbol-name filtered-simple-rand*)
		    (K bool-f)))))

	(else
	 (compiler-internal-error __module_who__ "invalid context" ctxt))))

    (define (%the-body-is-just-an-interrupt-asmcall? body)
      (struct-case body
	((asmcall op)
	 (eq? op 'interrupt))
	(else #f)))

    #| end of module: WITH-INTERRUPT-HANDLER |# )

  #| end of module: COGEN-PRIMOP, COGEN-DEBUG-PRIMOP |# )


(module COGEN-PRIMOP-DEBUG-CALL
  (cogen-primop-debug-call)
  (module (cogen-debug-primop)
    (import CODE-GENERATION-FOR-CORE-PRIMITIVE-OPERATION-CALLS))

  (define (cogen-primop-debug-call ctxt rand* kont)
    ;;This  function is  used to  process struct  instances of  type PRIMOPCALL  with
    ;;operand "debug-call"; such PRIMOPCALLs are inserted in the code when debug mode
    ;;is on: function calls are wrapped in calls to "debug-call".  So:
    ;;
    ;;   (funcall (primref list) '1 '2)
    ;;
    ;;becomes:
    ;;
    ;;   (primopcall debug-call '(#f . (list 1 2)) 'list '1 '2)
    ;;
    ;;where  the  #f  at the  beginning  of  the  quoted  list represents  a  missing
    ;;annotation  source.   See   the  function  RECORDIZE  for   details  about  how
    ;;"debug-call" PRIMREFs are generated.
    ;;
    ;;The argument CTXT is one of the symbols:  V, E, P; it represents the context in
    ;;which the PRIMOPCALL was found in recordized code.
    ;;
    ;;The argument RAND* is a list of structs representing recordized code that, when
    ;;evaluated, will return the arguments to  the "debug-call".  It is composed of 3
    ;;items:
    ;;
    ;;1.  A pair; the car is #f  or data representing the source location annotation;
    ;;   the cdr  is  a symbolic  expression  representing the  source  form of  this
    ;;  function call.
    ;;
    ;;2. A struct instance representing the function to call in debug mode; it can be
    ;;   a KNOWN wrapping a PRIMREF:
    ;;
    ;;      (known (primref ?prim-name) T:procedure)
    ;;
    ;;   or a reference to a used-defined function.
    ;;
    ;;3.  A  possibly empty list of  structs representing recordised code  that, when
    ;;   evaluated, will return the operands of the wrapped function call.
    ;;
    ;;The argument  KONT is a  continuation function.  For the  context V: it  is the
    ;;function V; for the  context P: it is the function P; for  the context E: it is
    ;;the function E.
    ;;
    ;;Return a FUNCALL struct instance.
    ;;
    ;;NOTE The core primitive DEBUG-CALL is actually a primitive function exported by
    ;;"ikarus.debugger.sls".
    ;;
    (assert (>= (length rand*) 2))
    (let ((src/expr	(car  rand*))  ;source expression
	  (func		(cadr rand*))  ;the wrapped function
	  (func-rand*	(cddr rand*))) ;args to the wrapped function
      (struct-case (%remove-known func)
	((primref name)
	 (if (core-primitive-operation? name)
	     (cogen-debug-primop name src/expr ctxt func-rand*)
	   (%fail kont rand*)))
	(else
	 (%fail kont rand*)))))

  (define (%fail kont rand*)
    (kont (make-funcall (mk-primref 'debug-call) rand*)))

  (define (%remove-known x)
    (struct-case x
      ((known expr)
       expr)
      (else x)))

  #| end of module: COGEN-PRIMOP-DEBUG-CALL |# )


(module (handle-fix)
  ;;This module transforms the structs fix.
  ;;
  ;;Upon entering this module: the argument LHS* is a proper list of VAR structs; the
  ;;argument RHS* is a proper list of  CLOSURE-MAKER structs; the argument BODY is as
  ;;struct representing recordised code *already* processed by the caller with the P,
  ;;V or E function.
  ;;
  ;;We know  that the  VAR in LHS*  will represent (in  further compiler  passes) CPU
  ;;registers  or Scheme  stack locations  holding a  tagged pointer  to the  closure
  ;;object resulting from the evaluation of the CLOSURE-MAKER structs in RHS*.
  ;;
  ;;
  ;;Handling all-combinators FIX structs
  ;;------------------------------------
  ;;
  ;;A closure is a  "combinator" if it has *no* free  variables: everything needed to
  ;;generate the closure  object is known at  run-time.  We know that,  in a previous
  ;;compiler  pass:  VAR structs  referencing  combinator  CLOSURE-MAKER structs  are
  ;;substituted by direct references to the  CLOSURE-MAKER struct itself, so that the
  ;;core language expression:
  ;;
  ;;   (let ((f (lambda () '1)))
  ;;     (f))
  ;;
  ;;is transformed into:
  ;;
  ;;   (codes
  ;;     ((lambda (label: asmlabel:f:clambda) (cp_0) (constant 1)))
  ;;     (jmpcall asmlabel:f:clambda:case-0
  ;;       (fix ((tmp_0 (closure-maker (code-loc asmlabel:f:clambda) no-freevars)))
  ;;         tmp_0)))
  ;;
  ;;so, in this  compiler pass, expect to find combinator  CLOSURE-MAKER structs only
  ;;in FIX structs defining a single binding.   In this module, we transform such FIX
  ;;structs as follows:
  ;;
  ;;   (bind ((tmp_0 (constant (closure-maker
  ;;                              (code-loc asmlabel:f:clambda)
  ;;                              no-freevars))))
  ;;     tmp_0)
  ;;
  ;;in which the CLOSURE-MAKER has been wrapped into a CONSTANT.  This will cause the
  ;;CLOSURE-MAKER struct to  generate a closure object at  compile-time; such closure
  ;;object will  be stored in  the relocation vector of  the code object  calling the
  ;;function.
  ;;
  ;;
  ;;Handling all-non-combinators FIX structs
  ;;----------------------------------------
  ;;
  ;;A closure is  a "non-combinator" if it  has free variables: we  must generate the
  ;;closure  object at  run-time to  capture the  values of  the free  variables.  In
  ;;previous  compiler  passes the  non-combinator  CLOSURE-MAKER  structs have  been
  ;;grouped (as much as possible) into single FIX structs; so, in this compiler pass,
  ;;we expect to find FIX structs defining multiple non-combinator bindings.
  ;;
  ;;Closure objects defined  by the same FIX  struct are "block allocated";  if a FIX
  ;;struct defines  three closures bound  to A_0, B_0, C_0  a single memory  block is
  ;;allocated to hold the thee closure objects.  Let's see how this is done.
  ;;
  ;;In the core language expression:
  ;;
  ;;   (let ((x (read)))
  ;;     (let ((a (lambda () x))
  ;;           (b (lambda () x))
  ;;           (c (lambda () x)))
  ;;       (list a b c)))
  ;;
  ;;the internal LET form is transformed into:
  ;;
  ;;         ;;allocate a single memory block
  ;;   (bind ((c_0 (asmcall alloc (constant 48) (constant 3))))
  ;;           ;;compute the tagged pointers referencing the other closure objects
  ;;     (bind ((b_0 (asmcall int+ c_0 (constant 16)))
  ;;            (a_0 (asmcall int+ c_0 (constant 32))))
  ;;       (seq
  ;;         ;;Initialise the closure object C_0: store in the 1st word
  ;;         ;;the address of the binary code entry point; store in the
  ;;         ;;2nd word the value of the free variable.
  ;;         (asmcall mset c_0 (constant -3) (constant (code-loc asmlabel:c:clambda)))
  ;;         (asmcall mset c_0 (constant  5) x_0)
  ;;
  ;;         ;;Initialise the closure object B_0: store in the 1st word
  ;;         ;;the address of the binary code entry point; store in the
  ;;         ;;2nd word the value of the free variable.
  ;;         (asmcall mset b_0 (constant -3) (constant (code-loc asmlabel:b:clambda)))
  ;;         (asmcall mset b_0 (constant  5) x_0)
  ;;
  ;;         ;;Initialise the closure object A_0: store in the 1st word
  ;;         ;;the address of the binary code entry point; store in the
  ;;         ;;2nd word the value of the free variable.
  ;;         (asmcall mset a_0 (constant -3) (constant (code-loc asmlabel:a:clambda)))
  ;;         (asmcall mset a_0 (constant  5) x_0)
  ;;
  ;;         ?body)))
  ;;
  ;;the layout of the single memory block is:
  ;;
  ;;    code entry  freevar   code entry  freevar   code entry  freevar
  ;;    point C_0   slot C_0  point B_0   slot B_0  point A_0   slot A_0
  ;;   |----------|----------|----------|----------|----------|----------|
  ;;
  ;;   |.....................|.....................|.....................|
  ;;     closure object C_0    closure object B_0    closure object C_0
  ;;
  (define (handle-fix lhs* rhs* body)
    (cond ((null? rhs*)
	   (compiler-internal-error __module_who__
	     "invalid FIX struct with empty bindings" lhs* rhs* body))
	  ((and (null? (cdr rhs*))
		(%combinator-closure-maker? (car rhs*)))
	   (make-bind lhs* (list (make-constant (car rhs*))) body))
	  (else
	   ;;NOTE For safety  I am leaving this assertion in.   (Marco Maggi; Sat Sep
	   ;;27, 2014)
	   (assert (for-all %non-combinator-closure-maker? rhs*))
	   (%make-bind-for-non-combinators lhs* rhs* (%closure-object-setters lhs* rhs* body)))))

  (define (%combinator-closure-maker? rhs)
    ;;Return true if the  struct instance of type CLOSURE-MAKER in  RHS has *no* free
    ;;variables.
    ;;
    (struct-case rhs
      ((closure-maker code freevar*)
       (null? freevar*))
      (else #f)))

  (define (%non-combinator-closure-maker? rhs)
    ;;Return  true if  the struct  instance  of type  CLOSURE-MAKER in  RHS has  free
    ;;variables.
    ;;
    (struct-case rhs
      ((closure-maker code freevar*)
       (pair? freevar*))
      (else #f)))

;;; --------------------------------------------------------------------

  (module (%make-bind-for-non-combinators)

    (define (%make-bind-for-non-combinators lhs* rhs* body)
      (let ((lhs  (car lhs*))
	    (rhs  (car rhs*))
	    (lhs* (cdr lhs*))
	    (rhs* (cdr rhs*)))
	;;LHS represents a  machine word holding the tagged poniter  to the allocated
	;;memory block; such pointer also references the first closure object.
	(let ((n  (%closure-object-area-size rhs))
	      (n* (map %closure-object-area-size rhs*)))
	  (make-bind (list lhs)
		     (list (asm 'alloc
				  (KN (apply + n n*))
				  (KN closure-tag)))
		     (make-bind lhs* (%adders lhs n n*)
				body)))))

    (define (%adders lhs n n*)
      ;;Return a  list of ASMCALL  structs representing expressions that  compute the
      ;;offset of an embedded closure object in the global memory block.
      ;;
      (if (pair? n*)
    	  (cons (asm 'int+ lhs (KN n))
    		(%adders lhs
    			 (+ n (car n*))
    			 (cdr n*)))
    	'()))

    (define (%closure-object-area-size x)
      ;;X must  be a  struct instance  of type  CLOSURE-MAKER.  Return  the *aligned*
      ;;number  of  bytes needed  to  hold:  the pointer  to  binary  code, the  free
      ;;variables' slots.
      ;;
      ;;          pointer to
      ;;          binary code   0   1   2   3   4   5
      ;;         |------------|---|---|---|---|---|---| closure object
      ;;
      ;;         |............|.......................|
      ;;     disp-closure-data       slots size
      ;;
      (struct-case x
	((closure-maker code freevar*)
	 #;(assert (not (null? freevar*)))
	 (align (fx+ disp-closure-data (fx* (length freevar*) wordsize))))))

    #| end of module: %MAKE-BIND-FOR-NON-COMBINATORS |# )

;;; --------------------------------------------------------------------

  (module (%closure-object-setters)
    ;;To build a closure object we must allocate a block of memory and then intialise
    ;;it.  Given a code object and a list of free variables, initialisation means:
    ;;
    ;;1. Store a pointer  to the binary code in the code object  in the first word of
    ;;   the closure object.
    ;;
    ;;2.  For each free variable: store the reference to it in the associated slot of
    ;;   the closure object.
    ;;
    ;;If ?VAR is  the address of a  closure object, ?BINARY-CODE is a  pointer to the
    ;;binary code, ?FREE-VAR is the reference  to a free variable, the initialisation
    ;;for a single closure object is:
    ;;
    ;;   (mset ?var off-closure-code ?binary-code)
    ;;   (mset ?var (+ 0 off-closure-data) ?free-var-0)
    ;;   (mset ?var (+ 1 off-closure-data) ?free-var-1)
    ;;   (mset ?var (+ 2 off-closure-data) ?free-var-2)
    ;;
    (define (%closure-object-setters lhs* rhs* body)
      ;;LHS*  must be  a list  of struct  instances of  type VAR  representing memory
      ;;locations containing references to the closure objects.
      ;;
      ;;RHS* must be a list of struct instances of type CLOSURE-MAKER.
      ;;
      ;;BODY must  be a  struct instance  representing recordized  code in  which the
      ;;closure bindings are visible.
      ;;
      (if (pair? lhs*)
	  (%single-closure-setters (car lhs*) (car rhs*)
				   (%closure-object-setters (cdr lhs*) (cdr rhs*) body))
	body))

    (define (%single-closure-setters lhs rhs body)
      (struct-case rhs
	((closure-maker code freevar*)
	 (make-seq (asm 'mset lhs (KN off-closure-code) (V code))
		   (%slot-setters lhs freevar* off-closure-data body)))))

    (define (%slot-setters lhs free* slot-offset body)
      ;;LHS must  be a struct  instance of type VAR  representing the address  of the
      ;;closure memory block.
      ;;
      ;;FREE* must be a list of  struct instances of type VAR representing references
      ;;to free variables.
      ;;
      ;;SLOT-OFFSET must be  a fixnum representing the offset (from  the beginning of
      ;;the closure memory block) of the next free variable slot, measured in bytes.
      ;;
      ;;BODY must  be a  struct instance  representing recordized  code in  which the
      ;;closure bindings are visible.
      ;;
      (if (pair? free*)
	  (make-seq (asm 'mset lhs (KN slot-offset) (V (car free*)))
		    (%slot-setters lhs (cdr free*) (+ slot-offset wordsize) body))
	body))

    #| end of module: %CLOSURE-OBJECT-SETTERS |# )

  #| end of module: HANDLE-FIX |# )


(module (V)
  ;;The function V erases known values;  its argument X must be a struct
  ;;instance  representing  recordized  code  to  be  executed  in  "for
  ;;returned  value" context;  its  return value  is  a struct  instance
  ;;representing recordized code (to be executed in "for returned value"
  ;;context) which is meant to replace X.
  ;;
  ;;Accept as input recordized code holding the following struct types:
  ;;
  ;;bind		code-loc
  ;;conditional		constant	fix
  ;;forcall		funcall		jmpcall
  ;;known		primopcall	primref
  ;;seq			var
  ;;
  ;;
  ;;Return recordized code in which:
  ;;
  ;;* Instances  of CONSTANT  contain the  binary representation  of the
  ;;  object.
  ;;
  ;;* Instances of PRIMREF are replaced by instances of ASMCALL.
  ;;
  ;;* Instances of CODE-LOC are wrapped into instances of CONSTANT.
  ;;
  ;;* Instances of PRIMOPCALL ...
  ;;
  ;;* Instances of FIX are handled.
  ;;
  (module (cogen-primop)
    (import CODE-GENERATION-FOR-CORE-PRIMITIVE-OPERATION-CALLS))
  (module (cogen-primop-debug-call)
    (import COGEN-PRIMOP-DEBUG-CALL))

  (define (V x)
    (struct-case x
      ((known expr)
       (unknown-V expr))
      (else
       (unknown-V x))))

  (define (unknown-V x)
    (struct-case x
      ((constant)
       (constant->native-constant-representation x))

      ((var)
       x)

      ((primref name)
       ;;Generate code  to retrieve  the "value"  field from  a location  gensym; the
       ;;value  of  such  slot  must  contain  a  reference  to  the  closure  object
       ;;implementing a global lexical procedure.
       ;;
       ;;NOTE Once we reference the loc gensym in the assembly code: we need a way to
       ;;associate such gensym to the generated binary code; the location gensym will
       ;;be stored  in the  relocation vector  associated to the  code object  we are
       ;;building.  This is what the OBJECT struct generated below is for.
       (asm 'mref
	      (K (make-object (primitive-public-function-name->location-gensym name)))
	      (K off-symbol-record-value)))

      ((code-loc)
       (make-constant x))

      ((bind lhs* rhs* body)
       (make-bind lhs* (map V rhs*) (V body)))

      ((fix lhs* rhs* body)
       (handle-fix lhs* rhs* (V body)))

      ((conditional test conseq altern)
       (make-conditional (P test) (V conseq) (V altern)))

      ((seq e0 e1)
       (make-seq (E e0) (V e1)))

      ((primopcall op rand*)
       (case op
	 ((debug-call)
	  (cogen-primop-debug-call    'V rand* V))
	 (else
	  (cogen-primop            op 'V rand*))))

      ((forcall op rand*)
       (make-forcall op (map V rand*)))

      ((funcall rator rand*)
       (make-funcall (Function rator) (map V rand*)))

      ((jmpcall label rator rand*)
       (make-jmpcall label (V rator) (map V rand*)))

      (else
       (error 'cogen-V "invalid value expr" (unparse-recordized-code x)))))

  #| end of module: V |# )


(define (P x)
  ;;X  must be  a struct  instance  representing recordized  code to  be
  ;;executed   in  predicate   context.    Return   a  struct   instance
  ;;representing recordized  code (to be executed  in predicate context)
  ;;which is meant to replace X.
  ;;
  ;;Accept as input recordized code holding the following struct types:
  ;;
  ;;bind		closure-maker	code-loc
  ;;conditional		constant	fix
  ;;forcall		funcall		jmpcall
  ;;known		primopcall	primref
  ;;seq			var
  ;;
  (module (cogen-primop)
    (import CODE-GENERATION-FOR-CORE-PRIMITIVE-OPERATION-CALLS))
  (module (cogen-primop-debug-call)
    (import COGEN-PRIMOP-DEBUG-CALL))
  (struct-case x
    ((constant c)
     (if c (K #t) (K #f)))

    ((primref)
     (K #t))

    ((code-loc)
     (K #t))

    ((closure-maker)
     (K #t))

    ((bind lhs* rhs* body)
     (make-bind lhs* (map V rhs*) (P body)))

    ((conditional test conseq altern)
     ;;FIXME Should  this be processed  further to  test the case  of (P
     ;;test)  always true  or always  false?   Or is  this already  done
     ;;later?  (Marco Maggi; Oct 16, 2012)
     (make-conditional (P test) (P conseq) (P altern)))

    ((seq e0 e1)
     (make-seq (E e0) (P e1)))

    ((fix lhs* rhs* body)
     (handle-fix lhs* rhs* (P body)))

    ((primopcall op rand*)
     (case op
       ((debug-call)
	(cogen-primop-debug-call    'P rand* P))
       (else
	(cogen-primop            op 'P rand*))))

    ((var)
     (asm '!= (V x) (KN bool-f)))

    ((funcall)
     (asm '!= (V x) (KN bool-f)))

    ((jmpcall)
     (asm '!= (V x) (KN bool-f)))

    ((forcall)
     (asm '!= (V x) (KN bool-f)))

    ((known expr)
     ;;FIXME.  Suboptimal.  (Abdulaziz Ghuloum)
     (P expr))

    (else
     (error 'cogen-P "invalid pred expr" (unparse-recordized-code x)))))


(define (E x)
  ;;X  must be  a struct  instance  representing recordized  code to  be
  ;;executed in  "for side  effect" context.   Return a  struct instance
  ;;representing recordized  code (to be  executed in "for  side effect"
  ;;context) which is meant to replace X.
  ;;
  ;;Accept as input recordized code holding the following struct types:
  ;;
  ;;bind		closure-maker	code-loc
  ;;conditional		constant	fix
  ;;forcall		funcall		jmpcall
  ;;known		primopcall	primref
  ;;seq			var
  ;;
  (module (cogen-primop)
    (import CODE-GENERATION-FOR-CORE-PRIMITIVE-OPERATION-CALLS))
  (module (cogen-primop-debug-call)
    (import COGEN-PRIMOP-DEBUG-CALL))
  (struct-case x

    ;;Useless for side effects: remove!
    ((constant)		(nop))
    ((var)		(nop))
    ((primref)		(nop))
    ((code-loc)		(nop))
    ((closure-maker)	(nop))

    ((bind lhs* rhs* body)
     (make-bind lhs* (map V rhs*) (E body)))

    ((conditional test conseq altern)
     (make-conditional (P test) (E conseq) (E altern)))

    ((seq e0 e1)
     (make-seq (E e0) (E e1)))

    ((fix lhs* rhs* body)
     (handle-fix lhs* rhs* (E body)))

    ((primopcall op rand*)
     (case op
       ((debug-call)
	(cogen-primop-debug-call    'E rand* E))
       (else
	(cogen-primop            op 'E rand*))))

    ((forcall op rand*)
     (make-forcall op (map V rand*)))

    ((funcall rator rand*)
     (make-funcall (Function rator) (map V rand*)))

    ((jmpcall label rator rand*)
     (make-jmpcall label (V rator) (map V rand*)))

    ((known expr)
     ;;FIXME Suboptimal.  (Abdulaziz Ghuloum)
     (E expr))

    (else
     (error 'cogen-E "invalid effect expr" (unparse-recordized-code x)))))


(define (V-simple-operand x)
  ;;Similar to V  but it must be  applied only to the  "simplified operands" prepared
  ;;for  a   core  primitive  operation   application.   Return  a   struct  instance
  ;;representing recordized  code (to  be executed in  "for returned  value" context)
  ;;which is meant to replace X.
  ;;
  ;;All    the     core    primitive     implementation    handlers     defined    by
  ;;DEFINE-PRIMITIVE-OPERATION must filter their arguments through "V-simple-operand"
  ;;before including them in their output recordised code.
  ;;
  ;;X must be a  struct instance representing recordized code to  be executed in "for
  ;;returned value" context, evaluating to a single value to be used as argument to a
  ;;primitive operation.
  ;;
  ;;Accept as input recordized code holding the following struct types:
  ;;
  ;;   constant		known		var
  ;;
  (struct-case x
    ((var)
     x)

    ((constant)
     (constant->native-constant-representation x))

    ((known expr type)
     (V-simple-operand expr))

    (else
     (compiler-internal-error 'cogen-specify-representation:T
       "invalid struct as simplified operand to core primitive operation application"
       (unparse-recordized-code x)))))

(define* (constant->native-constant-representation x)
  ;;X must  be a struct  instance of  type CONSTANT.  When  the constant value  has a
  ;;binary  representation:  return   a  new  CONSTANT  struct   holding  the  binary
  ;;representation itself.  Otherwise return:
  ;;
  ;;   (constant (object ?const))
  ;;
  ;;which meant that ?CONST will end in the code object's relocation vector.
  ;;
  ;;The binary  representation is an  exact integer that  fits into a  single machine
  ;;word.
  ;;
  (let ((c (constant-value x)))
    (cond ((target-platform-fixnum? c)
	   ;;Shifting as is done below is equivalent to:
	   ;;
	   ;;   (make-constant (* c fx-scale))
	   ;;
	   (make-constant (bitwise-arithmetic-shift-left c fx-shift)))

	  ((boolean? c)
	   (make-constant (if c bool-t bool-f)))

	  ((eq? c (void))
	   (make-constant void-object))

	  ((bwp-object? c)
	   (make-constant BWP-OBJECT))

	  ((char? c)
	   ;;Here  we are  interested  in Scheme  characters  as standalone  objects:
	   ;;machine words whose least significant bits  are set to the character tag
	   ;;and whose most significant bits are  set to the character's Unicode code
	   ;;point.
	   (make-constant (fxlogor char-tag
				   (fxsll (char->integer c)
					  char-shift))))

	  ((null? c)
	   (make-constant nil))

	  ((eof-object? c)
	   (make-constant eof))

	  ((object? c)
	   (compiler-internal-error __who__
	     "found recordised constant with double wrapping" (unparse-recordized-code x)))

	  (else
	   ;;Everything else will go in the relocation vector.
	   (make-constant (make-object c))))))


(define-syntax K
  ;;Wrap X with a struct instance of type CONSTANT.
  ;;
  (syntax-rules ()
    ((_ ?x)
     (make-constant ?x))))

(define (KN x)
  ;;Wrap  X with  a  struct instance  of  type CONSTANT;  X must  be  a native  value
  ;;representation.
  ;;
  (cond ((target-platform-fixnum? x)
	 (make-constant x))
	(else
	 (make-object (make-constant x)))))


(module (Function)
  ;;This module  is used  to process the  operator of every  struct instance  of type
  ;;FUNCALL by the functions V and E:
  ;;
  ;;   (make-funcall (Function rator) (map V rand*))
  ;;
  ;;the RATOR can be a reference to a top level binding, but also an expression which
  ;;should evaluate to a closure at runtime.
  ;;
  ;;This module takes care of:
  ;;
  ;;* Expanding  recordised references  to top  level bindings to  what is  needed to
  ;;  retrieve the reference to closure.
  ;;
  ;;* Inserting code to evaluate an arbitrary expression and check at runtime that it
  ;;  is actually a closure (if not: raise an exception).
  ;;
  (define-syntax-rule (Function rator)
    ;;X must be a struct instance representing recordized code to be executed in "for
    ;;returned value" context.  Return a struct instance representing recordized code
    ;;(to be executed in "for returned value" context) which is meant to replace X.
    ;;
    (F rator #t))

  (define (F rator check?)
    (struct-case rator
      ((primopcall op args)
       (cond ((and (eq? op 'top-level-value)
		   (null? (cdr args)) ;only one argument
		   (%recordized-symbol (car args)))
	      ;;The recordized code:
	      ;;
	      ;;   #[primopcall #[primref top-level-value] (?loc)]
	      ;;
	      ;;represents a  reference to a  top level value.  Whenever  binary code
	      ;;performs a call to a top level closure object, it does the following:
	      ;;
	      ;;* From the relocation vector of the current code object: retrieve the
	      ;;  loc gensym of the procedure to call.
	      ;;
	      ;;* From the loc gensym: extract the value of the "proc" slot, which is
	      ;;  meant to be a closure object.
	      ;;
	      ;;* Actually call the closure object.
	      ;;
	      ;;Here we generate  the code needed to retrieve the  value of the field
	      ;;"proc" from the symbol ?LOC.
	      ;;
	      => (lambda (loc)
		   ;;FIXME It is  clear that: at the time the  closure object call is
		   ;;performed, the loc gensym must  have been already initialised by
		   ;;storing the closure  object in the "proc" slot.   Good.  But why
		   ;;do we  call RESET-SYMBOL-PROC!   here, at  compile-time?  (Marco
		   ;;Maggi; Mon May 19, 2014)
		   (reset-symbol-proc! loc)
		   (asm 'mref
			  (constant->native-constant-representation (make-constant loc))
			  (K off-symbol-record-proc))))
	     (else
	      (F-nonproc rator check?))))

      ((primref op)
       ;;This is  a function application  in which the  function is a  core primitive
       ;;function, not a core primitive operation.  See the function V for what needs
       ;;to be done.
       (V rator))

      ((known rator.expr rator.type)
       (cond ((eq? (T:procedure? rator.type) 'yes)
	      (F rator.expr #f))
	     (else
	      (F rator.expr check?))))

      (else
       (F-nonproc rator check?))))

  (define (%recordized-symbol arg)
    ;;ARG  must be  a struct  instance representing  recordized code.   If ARG  is an
    ;;instance of CONSTANT  (possibly wrapped into a KNOWN) whose  value is a symbol:
    ;;return that symbol;  else return #f.  Such  symbol is meant to  be the location
    ;;gensym of a procedure.
    ;;
    (struct-case arg
      ((constant arg.val)
       (and (symbol? arg.val) arg.val))
      ((known arg.expr)
       ;;NOTE Here we really want a CONSTANT  holding a symbol; it does not matter if
       ;;the type in the KNOWN struct is "T:symbol".
       (%recordized-symbol arg.expr))
      (else #f)))

  (define (F-nonproc rator check?)
    ;;When  CHECK?   is  true: generate  the  code  needed  to  test at  run-time  if
    ;;evaluating RATOR  yields a  closure object;  if it does:  RATOR is  returned at
    ;;run-time, otherwise an error is raised at run-time.
    ;;
    (if check?
	(with-tmp ((x (V rator)))
	  (make-shortcut
	      (make-seq
	       (make-conditional (asm '=
					(asm 'logand x (K closure-mask))
					(K closure-tag))
		   (asm 'nop)
		 (asm 'interrupt))
	       x)
	    (V (make-funcall (mk-primref 'error)
			     (list (K 'apply) (K "not a procedure") x)))))
      (V rator)))

  #| end of module: Function |# )


;;;; utility functions for Assembly code generation

(module (target-platform-fixnum? NUMBER-OF-BITS-IN-FIXNUM-REPRESENTATION)

  ;;WORDSIZE is  the number of bytes  in a word: 4  on 32-bit platforms, 8  on 64-bit
  ;;platforms.

  (define-constant NUMBER-OF-BITS-IN-WORD
    (fx* wordsize 8))

  (define-constant NUMBER-OF-BITS-IN-FIXNUM-REPRESENTATION
    ;;This is 30 on 32-bit platforms and 61 on 64-bit platforms.
    (fx- NUMBER-OF-BITS-IN-WORD fx-shift))

  (define-constant NUMBER-OF-NEGATIVE-FIXNUMS
    (expt 2 (fx- NUMBER-OF-BITS-IN-FIXNUM-REPRESENTATION 1)))

  (define-constant TARGET-PLATFORM-LEAST-FIXNUM
    (- NUMBER-OF-NEGATIVE-FIXNUMS))

  (define-constant TARGET-PLATFORM-GREATEST-FIXNUM
    (- NUMBER-OF-NEGATIVE-FIXNUMS 1))

  (define (target-platform-fixnum? x)
    ;;Return true if X is a compile-time constant that can be represented by a fixnum
    ;;on the target platform.
    ;;
    (and (or (fixnum? x)
	     (bignum? x))
	 (<= TARGET-PLATFORM-LEAST-FIXNUM x TARGET-PLATFORM-GREATEST-FIXNUM)))

  ;; (fprintf (current-error-port)
  ;; 	   "target platform's word size = ~a\n\
  ;;           target platform's NUMBER-OF-BITS-IN-WORD = ~a\n\
  ;; 	    target platform's NUMBER-OF-BITS-IN-FIXNUM-REPRESENTATION = ~a\n\
  ;; 	    target platform's NUMBER-OF-NEGATIVE-FIXNUMS = ~a\n\
  ;; 	    TARGET-PLATFORM-LEAST-FIXNUM = ~a\n\
  ;; 	    TARGET-PLATFORM-GREATEST-FIXNUM = ~a\n\
  ;; 	    host's (least-fixnum)    = ~a\n\
  ;; 	    host's (greatest-fixnum) = ~a\n"
  ;; 	   wordsize
  ;; 	   NUMBER-OF-BITS-IN-WORD
  ;; 	   NUMBER-OF-BITS-IN-FIXNUM-REPRESENTATION
  ;; 	   NUMBER-OF-NEGATIVE-FIXNUMS
  ;; 	   TARGET-PLATFORM-LEAST-FIXNUM
  ;; 	   TARGET-PLATFORM-GREATEST-FIXNUM
  ;; 	   (least-fixnum) (greatest-fixnum)))

  #| end od module |# )


;;;; some external code

(include "ikarus.compiler.core-primitive-operations.scm" #t)


;;;; done

#| end of module SPECIFY-REPRESENTATION |# )

;;; end of file
;; Local Variables:
;; mode: vicare
;; eval: (put 'make-conditional		'scheme-indent-function 2)
;; eval: (put 'make-shortcut		'scheme-indent-function 1)
;; eval: (put 'case-primitive-operation-handler	'scheme-indent-function 1)
;; End:
