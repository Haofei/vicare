;;;Ikarus Scheme -- A compiler for R6RS Scheme.
;;;Copyright (C) 2006,2007,2008  Abdulaziz Ghuloum
;;;Modified by Marco Maggi <marco.maggi-ipsu@poste.it>
;;;
;;;This program is free software:  you can redistribute it and/or modify
;;;it under  the terms of  the GNU General  Public License version  3 as
;;;published by the Free Software Foundation.
;;;
;;;This program is  distributed in the hope that it  will be useful, but
;;;WITHOUT  ANY   WARRANTY;  without   even  the  implied   warranty  of
;;;MERCHANTABILITY  or FITNESS FOR  A PARTICULAR  PURPOSE.  See  the GNU
;;;General Public License for more details.
;;;
;;;You should  have received  a copy of  the GNU General  Public License
;;;along with this program.  If not, see <http://www.gnu.org/licenses/>.


;;;; introduction
;;
;;


(module (alt-cogen.specify-representation)
  (import CORE-PRIMITIVE-OPERATION-NAMES SCHEME-OBJECTS-ONTOLOGY)

  (define (alt-cogen.specify-representation x)
    (V-codes x))

  ;;The one below is for debugging purposes.  (Marco Maggi, Thu Sep 18, 2014)
  ;;
  ;; (define (alt-cogen.specify-representation x)
  ;;   (debug-print* 'input (unparse-recordized-code/sexp x))
  ;;   (receive-and-return (code)
  ;; 	(V-codes x)
  ;;     (void)
  ;;     (debug-print* 'output (unparse-recordized-code/sexp code))))

  (module (V-codes)
    (define-fluid-override __who__
      (identifier-syntax 'alt-cogen.specify-representation))

    (define (V-codes x)
      (struct-case x
	((codes code* body)
	 (let ((code* (map V-clambda code*))
	       (body  (V body)))
	   (make-codes code* body)))
	(else
	 (compiler-internal-error __who__ "invalid program" x))))

    (define (V-clambda x)
      (struct-case x
	((clambda label clause* cp free* name)
	 (make-clambda label (map V-clambda-clause clause*) cp free* name))
	(else
	 (compiler-internal-error __who__ "invalid clambda" x))))

    (define (V-clambda-clause x)
      (struct-case x
	((clambda-case info body)
	 (make-clambda-case info (V body)))
	(else
	 (compiler-internal-error __who__ "invalid clambda-case" x))))

    #| end of module: V-codes |# )


;;;; internal representation of primitive operations
;;
;;The internal  representation of a  primitive operation  is a symbol  whose property
;;list contains an instance of  struct PRIMITIVE-HANDLER.  For example $VECTOR-LENGTH
;;is represented by:
;;
;;   (set-primop! '$vector-length
;;                (make-primitive-handler #f
;;                  cogen-pred-$vector-length    #t
;;                  cogen-value-$vector-length   #t
;;                  cogen-effect-$vector-length  #t))
;;
;;where the  bindings COGEN-*-$VECTOR-LENGTH are CASE-LAMBDA  functions that generate
;;high-level  assembly  code for  the  specified  execution context.   The  execution
;;context functions  are usually generated by  the syntax DEFINE-PRIMITIVE-OPERATION,
;;and then can be called at will.
;;
;;Predicate context
;;-----------------
;;
;;For a primitive operation used in predicate context: the only thing that matters is
;;if the return value is true or false, as in:
;;
;;   (if ($vector-length vec)
;;       (this)
;;     (that))
;;
;;in which case, if we know that the return value is always true, we can optimise to:
;;
;;   (begin
;;     ($vector-length vec)
;;     (this))
;;
;;For side effects context
;;------------------------
;;
;;When  a primitive  operation is  used for  its side  effects: the  return value  is
;;discarded, so if we know that the primitive  has no side effects we can discard the
;;whole expression.  As example, we can optimise:
;;
;;   (begin
;;     ($vector-length vec)
;;     (this))
;;
;;to:
;;
;;   (begin
;;     (this))
;;
;;because calling $VECTOR-LENGTH is useless; conversely:
;;
;;   (begin
;;     (read)
;;     (this))
;;
;;we cannot  discard the  call to READ,  because it consumes  bytes from  the current
;;input port.
;;
;;For return value context
;;------------------------
;;
;;When a primitive operation is used for its return value, as in:
;;
;;   (display ($vector-length vec))
;;
;;we really have to perform the operation.
;;
(define-struct primitive-handler
  ;;Primitive  handler.   Collects  the  definitions  associated  to  core  primitive
  ;;operations.   An instance  of this  structure  is created  for every  use of  the
  ;;DEFINE-PRIMITIVE-OPERATION syntax.
  ;;
  (interruptable?
		;Boolean.   True if  the high-level  assembly code  implementing this
		;core primitive operation must be  wrapped into a SHORTCUT struct and
		;so it might  contain INTERRUPT PRIMCALL structs  representing a jump
		;to the interrupt handler.  False  if this primitive operation is not
		;interruptible and so it must not contain INTERRUPT PRIMCALLs.
   p-handler
		;CASE-LAMBDA  function generating  assembly  code  for the  predicate
		;execution context.
   p-handled?
		;Boolean,  true  if  this  primitive  operation  is  implemented  for
		;predicate execution context.
   v-handler
		;CASE-LAMBDA function generating assembly  code for the "for returned
		;value" execution context.
   v-handled?
		;Boolean, true  if this  primitive operation  is implemented  for the
		;"for returned value" execution context.
   e-handler
		;CASE-LAMBDA  function generating  assembly  code for  the "for  side
		;effects" execution context.
   e-handled?
		;Boolean, true  if this  primitive operation  is implemented  for the
		;"for side effects" execution context.
   ))


;;;; high-level assembly primitives

(define (prm op . args)
  ;;Build  and return  recordised  call  which performs  the  primitive operation  OP
  ;;applying it to the arguments ARGS.
  ;;
  (make-primcall op args))

(define (nop)
  ;;Build  and  return  recordised  call   representing  the  dummy  instruction  "no
  ;;operation".
  ;;
  (make-primcall 'nop '()))


(module (with-tmp)

  (define-syntax (with-tmp stx)
    ;;Do what is needed to generate recordized  code in the region of a local binding
    ;;definition.  It works like LET for recordized code generation
    ;;
    (syntax-case stx ()
      ((_ ((?lhs ?rhs) ...) ?body0 ?body ...)
       (with-syntax
	   (((LHS ...) (generate-temporaries #'(?lhs ...)))
	    ((RHS ...) (generate-temporaries #'(?lhs ...))))
	 ;;Evaluate the right-hand sides, which must return recordized code.  We want
	 ;;to evaluate the ?RHS expression outside the region of the ?LHS bindings.
	 #'(let ((RHS ?rhs) ...)
	     ;;Generate new struct instances of type VAR to be used as left-hand side
	     ;;in the BIND struct below.
	     (let ((LHS (make-unique-var '?lhs)) ...)
	       ;;Make the binding struct, which represents machine words allocated on
	       ;;the stack  and initialised with  the results of evaluating  the ?RHS
	       ;;expressions.
	       (make-bind (list LHS ...)
			  (list RHS ...)
			  ;;The ?BODY forms expect Scheme bindings to exist with name
			  ;;?LHS,  referencing  the  VAR structures.   Wrap  the  VAR
			  ;;structs into KNOWN structs whenever the corresponding RHS
			  ;;has a type description.
			  (let ((?lhs (%copy-core-type-descr LHS RHS)) ...)
			    ;;Evaluate  the body  forms,  each of  which must  return
			    ;;recordized code.
			    (multiple-forms-sequence ?body0 ?body ...)))))))
      ))

  ;;FIXME  Why in  hell does  this implementation  of WITH-TMP*  cause a  segfault?!?
  ;;(Marco Maggi; Sun Sep 14, 2014)
  ;;
  ;; (define-syntax (with-tmp* stx)
  ;;   ;;We use this when we want the ?RHS  expressions to be evaluated in the region of
  ;;   ;;the previous  ?LHS binding.  If WITH-TMP  works like LET, WITH-TMP*  works like
  ;;   ;;LET*.
  ;;   (syntax-case stx ()
  ;;     ((_ () ?body0 ?body ...)
  ;;      #'(let () ?body0 ?body ...))
  ;;     ((_ ((?lhs0 ?rhs0) (?lhs ?rhs) ...) ?body0 ?body ...)
  ;;      #'(with-tmp ((?lhs0 ?rhs0))
  ;; 	   (with-tmp* ((?lhs ?rhs) ...)
  ;; 	     ?body0 ?body ...)))
  ;;     ))

  (define (%copy-core-type-descr lhs.var rhs.struct)
    (struct-case rhs.struct
      ((known _ type)
       (make-known lhs.var type))
      (else lhs.var)))

  #| end of module: WITH-TMP |# )


(module CODE-GENERATION-FOR-CORE-PRIMITIVE-OPERATION-CALLS
  (cogen-primop cogen-debug-primop interrupt)
  ;;Some core primitives are implemented both as:
  ;;
  ;;*  Core primitive  functions.   There  exists a  loc  gensym  whose "value"  slot
  ;;   references  a  closure  object,  which   in  turn  references  a  code  object
  ;;  implementing  the core primitive as  machine code.  When the  core primitive is
  ;;  used as argument as in:
  ;;
  ;;     (map fx+ a* b*)
  ;;
  ;;  the closure object implementation is used.
  ;;
  ;;* Core  primitive operations.  There exist  functions that the compiler  calls to
  ;;  integrate assembly instructions implementing the core primitive.  When the core
  ;;  primitive is used as first subform of an application form as in:
  ;;
  ;;     (fx+ 1 2)
  ;;
  ;;  the primitive operation is used.
  ;;
  ;;The functions COGEN-PRIMOP and COGEN-DEBUG-PRIMOP  are used to process recordised
  ;;code:
  ;;
  ;;   (primcall ?primitive-symbol-name ?rand ...)
  ;;
  ;;in which  it is known  that ?PRIMITIVE-SYMBOL-NAME  is a symbol  representing the
  ;;public name of a core primitive operation, so that:
  ;;
  ;;   (get-primop '?primitive-symbol-name)
  ;;
  ;;will retrieve a struct of type PRIMITIVE-HANDLER.
  ;;
  ;;
  ;;Disabled debugging mode
  ;;-----------------------
  ;;
  ;;If a core  primitive has both the implementations as  operation and function, the
  ;;general integration pattern is to use this code template:
  ;;
  ;;   (shortcut ?body ?interrupt-handler)
  ;;
  ;;where:  ?BODY is  recordised code  implementing a  fast and  sometimes simplified
  ;;implementation of the  primitive, working with the most  probable argument types;
  ;;?INTERRUPT-HANDLER  is  recordised code  implementing  a  call to  the  primitive
  ;;function.
  ;;
  ;;If the fast implementation  works: it generates the result that  is handed to the
  ;;caller.   If the  fast implementation  fails:  it jumps  to  a call  to the  full
  ;;function; the  function validates the arguments  and retries to perform  the task
  ;;for all the supported argument types.
  ;;
  ;;For a few core  primitives with simple arguments, it is useless  to call the full
  ;;function: if  the fast implementation failed  it means the operands  are of wrong
  ;;type or the operation is impossible.   For these primitives the interrupt handler
  ;;is a special function  that knows the operands are invalid,  so it just validates
  ;;them  and raises  the appropriate  exception.   The core  primitives having  this
  ;;implementation are:
  ;;
  ;;   fx+		fx-		fx*
  ;;   add1				sub1
  ;;   fxadd1				fxsub1
  ;;   fxarithmetic-shift-left		fxarithmetic-shift-right
  ;;
  ;;not many, but still important  cases.  Such exception-raising routines are called
  ;;ERROR@?PRIM, where ?PRIM is the name of the core primitive.
  ;;
  ;;Partitioning simple and comples bindings
  ;;----------------------------------------
  ;;
  ;;We implement a call to core primitive operation with the template:
  ;;
  ;;   (shortcut ?integrated-fast-implementation ?function-implementation-call)
  ;;
  ;;but  we have  to  be careful  not  to  include twice  the  code representing  the
  ;;operands; in general, the recordised code:
  ;;
  ;;   (primcall ?prim-name ?rand ...)
  ;;
  ;;must be (conceptually) transformed into:
  ;;
  ;;   (bind ((?tmp ?rand) ...)
  ;;     (primcall ?prim-name ?tmp ...))
  ;;
  ;;and then into:
  ;;
  ;;   (bind ((?tmp ?rand) ...)
  ;;     (shortcut
  ;;         (?integrated-fast-implementation ?tmp ...)
  ;;       (?function-implementation ?tmp ...))
  ;;
  ;;this way the ?RAND code is included only  once.  But, whenever a ?RAND is has one
  ;;of the formats:
  ;;
  ;;   (constant ?const)
  ;;   (known (constant ?const) ?type)
  ;;   var
  ;;   (known var ?type)
  ;;
  ;;there is no need to introduce a  binding for it, because such operand structs can
  ;;be included multiple  times with no problems.   So, in this module,  we split the
  ;;operands between simple (which can be included multiple times) and complex (which
  ;;must be included through a local binding).
  ;;
  ;;
  ;;Example: the VECTOR-LENGTH primitive function and primitive operation
  ;;---------------------------------------------------------------------
  ;;
  ;;Let's consider:
  ;;
  ;;   (vector-length ?rand)
  ;;
  ;;which is recordised as:
  ;;
  ;;   (funcall (primref vector-length) ?rand)
  ;;
  ;;when debugging is disabled, the recordised  representation we want to generate in
  ;;this module is (slightly edited):
  ;;
  ;;   (bind ((tmp_0 ?rand))
  ;;     (shortcut
  ;;         (seq
  ;;           ;;If the operand is a tagged pointer tagged as vector...
  ;;           (conditional (primcall = (primcall logand tmp_0 (constant 7))
  ;;                                    (constant 5))
  ;;               ;;... fine.
  ;;               (primcall nop)
  ;;             ;;... otherwise call the full core primitive function.
  ;;             (primcall interrupt))
  ;;           ;;Retrieve the first word.
  ;;           (bind ((vec.len_0 (primcall mref tmp_0 (constant -5))))
  ;;             (seq
  ;;               ;;If the first word is a fixnum...
  ;;               (conditional (primcall = (primcall logand vec.len_0 (constant 7))
  ;;                                        (constant 0))
  ;;                   ;;... fine.
  ;;                   (primcall nop)
  ;;                 ;;... otherwise call the full core primitive function.
  ;;                 (primcall interrupt))
  ;;             ;;Return the first word.
  ;;             vec.len_0)))
  ;;       ;;Interrupt handler: perform a full call to the primitive function and let
  ;;       ;;it raise an exception if there is the need.
  ;;       (funcall (primcall mref (constant (object vector-length)) (constant 19))
  ;;                tmp_0)))
  ;;
  ;;
  ;;Example: the FX+ primitive function and primitive operation
  ;;-----------------------------------------------------------
  ;;
  ;;Let's consider FX+.  When the  primitive function implementation detects overflow
  ;;or  underflow: it  raises an  exception.   When the  primitive operation  detects
  ;;overflow  or underflow  what  should  it do?   The  answer  is: every  integrated
  ;;primitive-operation assembly-code will jump to  the same routine which will raise
  ;;an exception; such exception-raising routines are called ERROR@?PRIM, where ?PRIM
  ;;is the name of the core primitive.
  ;;
  ;;Let's consider:
  ;;
  ;;   (fx+ ?rand1 ?rand2)
  ;;
  ;;in which  the operands are  known at compile-time  to be fixnums;  when debugging
  ;;mode  is disabled,  the recordised  representation we  want to  generate in  this
  ;;module is:
  ;;
  ;;   (shortcut
  ;;       (seq
  ;;         (primcall nop)
  ;;         (primcall int+/overflow ?rand1 ?rand2))
  ;;     (funcall (primcall mref (constant (object error@fx+))
  ;;                             ?offset-of-slot-value-in-loc-gensym)
  ;; 	    ?rand1 ?rand2))
  ;;
  ;;where  "(object error@fx+)"  represents  the  loc gensym  of  the core  primitive
  ;;function "error@fx+".
  ;;
  ;;The first form in SHORTCUT is the core primitive operation call's "body":
  ;;
  ;;   (seq
  ;;     (primcall nop)
  ;;     (primcall int+/overflow ?rand1 ?rand2))
  ;;
  ;;the second  form in SHORTCUT  is the  core primitive operation  call's "interrupt
  ;;handler":
  ;;
  ;;   (funcall (primcall mref (constant (object error@fx+))
  ;;                           ?offset-of-slot-value-in-loc-gensym)
  ;;     ?rand1 ?rand2)
  ;;

  (define (cogen-debug-primop primitive-symbol-name src/loc ctxt rand*)
    ;;Return  recordised  code  representing  the application  of  a  core  primitive
    ;;function, when debugging mode is ENabled.
    ;;
    ;;CTXT is one of  the symbols: V, E, P.  RAND* is a  list of structs representing
    ;;the operands as recordised code, not yet filtered through V.
    ;;
    (define (%cogen-core-primitive-debug-call primitive-symbol-name simplified-rand*)
      (make-funcall (V (mk-primref 'debug-call))
		    (cons* (V src/loc)
			   (V (mk-primref primitive-symbol-name))
			   simplified-rand*)))
    (%cogen-primop-call %cogen-core-primitive-debug-call
			%cogen-core-primitive-debug-call
			primitive-symbol-name ctxt rand*))

  (module (cogen-primop)

    (define (cogen-primop primitive-symbol-name ctxt rand*)
      ;;This is a function with signature:
      ;;
      ;;   (cogen-primop ?primitive-symbol-name ?ctxt ?rand*)
      ;;
      ;;where: ?CTXT  is one of  the symbols: V,  E, P; ?RAND*  is a list  of structs
      ;;representing the  operands as  recordised code, not  yet filtered  through V.
      ;;Return  recordised code  representing the  application of  a core  primitive,
      ;;either function or operation, when debugging mode is DISabled.
      ;;
      (%cogen-primop-call %cogen-core-primitive-interrupt-handler-function-call
			  %cogen-core-primitive-standalone-function-call
			  primitive-symbol-name ctxt rand*))

    (define (%cogen-core-primitive-standalone-function-call primitive-symbol-name simplified-rand*)
      ;;Generate code representing a call to the core primitive function.  This is to
      ;;be  used when  no  core  primitive operation  integration  is performed  (for
      ;;example  because  the  primitive  has no  operation  implementation,  just  a
      ;;function implementation).
      ;;
      (make-funcall (V (mk-primref primitive-symbol-name)) simplified-rand*))

    (module (%cogen-core-primitive-interrupt-handler-function-call)

      (define (%cogen-core-primitive-interrupt-handler-function-call primitive-symbol-name simplified-rand*)
	;;Generate code representing a call to  the core primitive function.  This is
	;;to be used as implementation of the interrupt handler, after the integrated
	;;fast  implementation has  failed.  If  the core  primitive has  the special
	;;interrupt handler implementation: use such function.
	;;
	;;In the VECTOR-LENGTH example, this function generates the code:
	;;
	;;   (funcall (primcall mref (constant (object vector-length))
	;;                           ?offset-of-slot-value-in-loc-gensym)
	;;            tmp_0)
	;;
	;;where  "(object  vector-length)" represents  the  loc  gensym of  the  core
	;;primitive function "error@fx+".
	;;
	;;In the FX+ example, this function generates the code:
	;;
	;;   (funcall (primcall mref (constant (object error@fx+))
	;;                           ?offset-of-slot-value-in-loc-gensym)
	;;            ?rand1 ?rand2)
	;;
	;;where "(object error@fx+)" represents the  loc gensym of the core primitive
	;;function "error@fx+".
	;;
	(make-funcall (V (mk-primref (%primop-interrupt-handler primitive-symbol-name)))
		      simplified-rand*))

      (define (%primop-interrupt-handler primitive-symbol-name)
	(case primitive-symbol-name
	  ((fx+)			'error@fx+)
	  ((fx-)			'error@fx-)
	  ((fx*)			'error@fx*)
	  ((add1)			'error@add1)
	  ((sub1)			'error@sub1)
	  ((fxadd1)			'error@fxadd1)
	  ((fxsub1)			'error@fxsub1)
	  ((fxarithmetic-shift-left)	'error@fxarithmetic-shift-left)
	  ((fxarithmetic-shift-right)	'error@fxarithmetic-shift-right)
	  (else				primitive-symbol-name)))

      #| end of module: %COGEN-CORE-PRIMITIVE-INTERRUPT-HANDLER-FUNCTION-CALL |# )

    #| end of module: COGEN-PRIMOP |# )

;;; --------------------------------------------------------------------

  (module (%cogen-primop-call)

    (define-fluid-override __who__
      (identifier-syntax '%cogen-primop-call))

    (define (%cogen-primop-call cogen-core-primitive-interrupt-handler-function-call
				cogen-core-primitive-standalone-function-call
				primitive-symbol-name ctxt rand*)
      ;;CTXT must be one of the symbols:  P, V, E representing the evaluation context
      ;;of a struct of recordised code.
      ;;
      ;;RAND* is a list of structs  representing the operands as recordised code, not
      ;;yet filtered through V.
      ;;
      (define-syntax-rule (%cogen ?simplified-rand*)
	(%generate-code cogen-core-primitive-interrupt-handler-function-call
			cogen-core-primitive-standalone-function-call
			primitive-symbol-name ctxt ?simplified-rand*))
      ;;Here the RHS*  have been already filtered through V  and the SIMPLIFIED-RAND*
      ;;have been left alone.
      (receive (lhs* rhs* simplified-rand*)
	  (%partition-simple-operands rand*)
	(if (null? lhs*)
	    (%cogen simplified-rand*)
	  (make-bind lhs* rhs* (%cogen simplified-rand*)))))

    (define (%partition-simple-operands rand*)
      ;;Given a  list of structs representing  the operands of a  primitive operation
      ;;call:  build what  is  needed to  separate the  operands  requiring a  single
      ;;reference from the others.
      ;;
      ;;Filter the complex operands through V, leave the simple operands unfiltered.
      ;;
      (if (null? rand*)
	  (values '() '() '())
	(receive (lhs* rhs* simplified-rand*)
	    (%partition-simple-operands (cdr rand*))
	  (let ((rand (car rand*)))
	    (struct-case rand
	      ((var)
	       ;;This  operand is  a variable  reference: it  is fine  to include  it
	       ;;multiple times; it is a simple operand.
	       (values lhs* rhs* (cons rand simplified-rand*)))
	      ((known rand.expr rand.type)
	       (struct-case rand.expr
		 ((constant)
		  ;;This operand is:
		  ;;
		  ;;   (known (constant ?rand.expr.const) ?type)
		  ;;
		  ;;it is fine to include it  multiple times: it is a simple operand.
		  ;;
		  ;;FIXME Here I  would like to keep the type  description and so add
		  ;;RAND itself as simplified operand, rather than add RAND.EXPR; but
		  ;;if I  do it: there  are expressions  that fail to  compile.  This
		  ;;must  be further  investigated and  solved because  handing KNOWN
		  ;;structs to the primitive-operation implementation-handlers is the
		  ;;whole point of  having KNOWN structs.  (Marco Maggi;  Mon Sep 15,
		  ;;2014)
		  (values lhs* rhs* (cons rand.expr simplified-rand*)))
		 ((var)
		  ;;This operand is:
		  ;;
		  ;;   (known var ?type)
		  ;;
		  ;;it is fine to include it multiple times; it is a simple operand.
		  ;;
		  ;;FIXME Here I  would like to keep the type  description and so add
		  ;;RAND itself as simplified operand, rather than add RAND.EXPR; but
		  ;;if I  do it: there  are expressions  that fail to  compile.  This
		  ;;must  be further  investigated and  solved because  handing KNOWN
		  ;;structs to the primitive-operation implementation-handlers is the
		  ;;whole point of  having KNOWN structs.  (Marco Maggi;  Mon Sep 15,
		  ;;2014)
		  (values lhs* rhs* (cons rand.expr simplified-rand*)))
		 (else
		  ;;This operand is:
		  ;;
		  ;;   (known ?expr ?type)
		  ;;
		  ;;the ?EXPR must  be included only once in the  recordised code: it
		  ;;is a  complex operand; we  introduce a  VAR binding and  move the
		  ;;type  description from  the expression  to the  VAR in  reference
		  ;;position.
		  (let ((tmp (make-unique-var 'tmp)))
		    (values (cons tmp           lhs*)
			    (cons (V rand.expr) rhs*)
			    (cons (make-known tmp rand.type) simplified-rand*))))))
	      ((constant)
	       ;;This operand is a constant: it is fine to include it multiple times;
	       ;;it is a simple operand.
	       (values lhs* rhs* (cons rand simplified-rand*)))
	      (else
	       ;;This operand  is an  expression with  unknown type  description; the
	       ;;RAND must  be included  only once  in the recordised  code: it  is a
	       ;;complex operand; we introduce a new VAR binding and a simple operand
	       ;;referencing it.
	       (let ((tmp (make-unique-var 'tmp)))
		 (values (cons tmp      lhs*)
			 (cons (V rand) rhs*)
			 (cons tmp simplified-rand*)))))))))

    (define (%generate-code cogen-core-primitive-interrupt-handler-function-call
			    cogen-core-primitive-standalone-function-call
			    primitive-symbol-name ctxt simplified-rand*)
      (define-fluid-override __who__
	(identifier-syntax 'code-generation-handler))
      (define prim
	;;PRIM is a struct of type PRIMITIVE-HANDLER.
	(get-primop primitive-symbol-name))
      (with-interrupt-handler
       prim primitive-symbol-name ctxt (map T simplified-rand*)
       cogen-core-primitive-interrupt-handler-function-call
       cogen-core-primitive-standalone-function-call
       (lambda ()
	 ;;This thunk actually generates the BODY of a primitive operation call.
	 ;;
	 ;;* If CTXT is V:
	 ;;
	 ;;   if cogen-value, then V
	 ;;   if cogen-pred, then (if P #f #t)
	 ;;   if cogen-effect, then (seq E (void))
	 ;;
	 ;;* If CTXT is P:
	 ;;
	 ;;   if cogen-pred, then P
	 ;;   if cogen-value, then (!= V #f)
	 ;;   if cogen-effect, then (seq E #t)
	 ;;
	 ;;* If CTXT is E:
	 ;;
	 ;;   if cogen-effect, then E
	 ;;   if cogen-value, then (let ((tmp V)) (nop))
	 ;;   if cogen-pred, then (if P (nop) (nop))
	 ;;
         ;;The  primitive handler  functions extracted  from PRIM  will take  care of
         ;;filtering the SIMPLIFIED-RAND* through the function T.
         ;;
	 (case ctxt
	   ((P)
	    (case-primitive-operation-handler prim
	      ((P)
	       ;;There is a "for predicate"  context implementation handler; just use
	       ;;it.
	       (apply P-handler simplified-rand*))
	      ((V)
	       ;;There  is no  "for  predicate" implementation  handler,  but a  "for
	       ;;value" implementation handler exists;  we generate a "for predicate"
	       ;;handler as:
	       ;;
	       ;;   (primcall != (for-value-primcall) (KN bool-f))
	       ;;
	       ;;and we handle special cases.
	       (let ((e (apply V-handler simplified-rand*)))
		 (define (%doit-as-pred)
		   (prm '!= e (KN bool-f)))
		 (struct-case e
		   ((primcall op)
		    (if (eq? op 'interrupt)
			e
		      (%doit-as-pred)))
		   ((constant e.const)
		    ;;The "for predicate" handler can return a CONSTANT holding #t or
		    ;;#f; we convert the constant returned by the "for value" handler
		    ;;accordingly.
		    (if (eq? e.const bool-f)
			(K #f)
		      (K #t)))
		   (else
		    (%doit-as-pred)))))
	      ((E)
	       ;;There is neither a "for  predicate" nor a "for value" implementation
	       ;;handler, but a "for side  effects" implementation handler exists; we
	       ;;generate a "for predicate" handler as:
	       ;;
	       ;;   (seq (for-effects-primcall) (K t))
	       ;;
	       ;;and we handle special cases.
	       (let ((e (apply E-handler simplified-rand*)))
		 (if (%interrupt-primcall? e)
		     e
		   (make-seq e (K #t)))))))
	   ((V)
	    (case-primitive-operation-handler prim
	      ((V)
	       ;;There is a "for value" context implementation handler; just use it.
	       (apply V-handler simplified-rand*))
	      ((P)
	       ;;There  is  no  "for  value"   implementation  handler,  but  a  "for
	       ;;predicate" implementation handler exists;  we generate a "for value"
	       ;;handler as:
	       ;;
	       ;;   (condition (for-pred-primcall)
	       ;;       (KN bool-t)
	       ;;     (KN bool-f))
	       ;;
	       ;;and we handle special cases.
	       (let ((e (apply P-handler simplified-rand*)))
		 (define (%doit-as-conditional)
		   (make-conditional e (KN bool-t) (KN bool-f)))
		 (struct-case e
		   ((primcall op)
		    (if (eq? op 'interrupt)
			e
		      (%doit-as-conditional)))
		   ((constant e.const)
		    ;;If the "for predicate" handler has returned a constant, it is a
		    ;;boolean;  so  we  convert  it  into  the  corresponding  native
		    ;;representation of a boolean.
		    (if e.const
			(KN bool-t)
		      (KN bool-f)))
		   (else
		    (%doit-as-conditional)))))
	      ((E)
	       ;;There are neither a "for value" nor a "for predicate" implementation
	       ;;handlers, but a "for side effects" implementation handler exists; we
	       ;;generate a "for value" handler as:
	       ;;
	       ;;   (seq
	       ;;     (for-effects-primcall)
	       ;;     (KN void-object))
	       ;;
	       ;;and we handle special cases.
	       (let ((e (apply E-handler simplified-rand*)))
		 (define (%doit-as-sequence)
		   (make-seq e (KN void-object)))
		 (struct-case e
		   ((primcall op)
		    (if (eq? op 'interrupt)
			e
		      (%doit-as-sequence)))
		   ((constant)
		    (nop))
		   (else
		    (%doit-as-sequence)))))))
	   ((E)
	    (case-primitive-operation-handler prim
	      ((E)
	       ;;There is a  "for side effects" context  implementation handler; just
	       ;;use it.
	       (apply E-handler simplified-rand*))
	      ((P)
	       ;;There is  no "for side  effects" implementation handler, but  a "for
	       ;;predicate"  implementation  handler  exists;   we  generate  a  "for
	       ;;effects" handler as:
	       ;;
	       ;;   (condition (for-pred-primcall)
	       ;;       (nop)
	       ;;     (nop))
	       ;;
	       ;;and we handle special cases.
	       (let ((e (apply P-handler simplified-rand*)))
		 (define (%doit-as-conditional)
		   (make-conditional e (nop) (nop)))
		 (struct-case e
		   ((primcall op)
		    (if (eq? op 'interrupt)
			e
		      (%doit-as-conditional)))
		   ((constant)
		    (nop))
		   (else
		    (%doit-as-conditional)))))
	      ((V)
	       (let ((e (apply V-handler simplified-rand*)))
		 (if (%interrupt-primcall? e)
		     e
		   (with-tmp ((t e))
		     (nop)))))))
	   (else
	    (compiler-internal-error __who__ "invalid evaluation context" ctxt))))))

    (define (%interrupt-primcall? x)
      ;;Return true if  X is a PRIMCALL  struct representing a jump  to the interrupt
      ;;handler.
      ;;
      (struct-case x
	((primcall op)
	 (eq? op 'interrupt))
	(else #f)))

    (define-syntax (case-primitive-operation-handler stx)
      (define (main stx)
	(syntax-case stx ()
	  ((?ctx ?prim
		 ((V) . ?V-body)
		 ((P) . ?P-body)
		 ((E) . ?E-body))
	   (%fender #'V #'P #'E)
	   (%generate-output-form #'?ctx #'?prim
				  (%generate-v-branch #'?ctx #'?V-body)
				  (%generate-p-branch #'?ctx #'?P-body)
				  (%generate-e-branch #'?ctx #'?E-body)))
	  ((?ctx ?prim
		 ((P) . ?P-body)
		 ((V) . ?V-body)
		 ((E) . ?E-body))
	   (%fender #'V #'P #'E)
	   (%generate-output-form #'?ctx #'?prim
				  (%generate-p-branch #'?ctx #'?P-body)
				  (%generate-v-branch #'?ctx #'?V-body)
				  (%generate-e-branch #'?ctx #'?E-body)))
	  ((?ctx ?prim
		 ((E) . ?E-body)
		 ((P) . ?P-body)
		 ((V) . ?V-body))
	   (%fender #'V #'P #'E)
	   (%generate-output-form #'?ctx #'?prim
				  (%generate-e-branch #'?ctx #'?E-body)
				  (%generate-p-branch #'?ctx #'?P-body)
				  (%generate-v-branch #'?ctx #'?V-body)))
	  ))

      (define (%generate-output-form ctx prim.stx branch-0 branch-1 branch-2)
	#`(let ((prim #,prim.stx))
	    (cond #,branch-0
		  #,branch-1
		  #,branch-2
		  (else
		   (%error-context-not-handled prim)))))

      (define (%fender V P E)
	(and (eq? 'V (syntax->datum V))
	     (eq? 'P (syntax->datum P))
	     (eq? 'E (syntax->datum E))))

      (define (%generate-v-branch ctx body)
	(with-syntax ((V-handler (datum->syntax ctx 'V-handler)))
	  #`((primitive-handler-v-handled? prim)
	     (let ((V-handler (primitive-handler-v-handler prim)))
	       . #,body))))

      (define (%generate-p-branch ctx body)
	(with-syntax ((P-handler (datum->syntax ctx 'P-handler)))
	  #`((primitive-handler-p-handled? prim)
	     (let ((P-handler (primitive-handler-p-handler prim)))
	       . #,body))))

      (define (%generate-e-branch ctx body)
	(with-syntax ((E-handler (datum->syntax ctx 'E-handler)))
	  #`((primitive-handler-e-handled? prim)
	     (let ((E-handler (primitive-handler-e-handler prim)))
	       . #,body))))

      (main stx))

    (define (%error-context-not-handled prim)
      (compile-time-error __who__
	"evaluation context not handled by core primitive operation" prim))

    #| end of module: %COGEN-PRIMOP-CALL |# )

;;; --------------------------------------------------------------------

  (module (with-interrupt-handler interrupt)
    ;;
    ;;NOTE  When it  is determined  at compile-time  that the  operands of  a primitive
    ;;operation are invalid, the generated SHORTCUT's ?BODY can be a simple:
    ;;
    ;;   (primcall interrupt)
    ;;
    ;;in this case, if we do nothing special, we end up generating:
    ;;
    ;;   (shortcut
    ;;       (primcall interrupt)
    ;;     ?interrupt-handler)
    ;;
    ;;which would be stupid;  so we take care of recognising  this special ?BODY case
    ;;and instead of a  SHORTCUT return a plain call to  the core primitive function.
    ;;In this case, it  also makes sense to raise a  compile-time exception to signal
    ;;the error early;  we do not do it  here, we delegate this task  to the specific
    ;;primitive operation definition macro.
    ;;

    (define (interrupt)
      ;;Record that this body has requested the presence of an interrupt handler.
      ((%record-use-of-interrupt-in-body))
      ;;Return the "(primcall interrupt)".
      (prm 'interrupt))

    (define* (with-interrupt-handler prim primitive-symbol-name ctxt filtered-simplified-rand*
				     cogen-core-primitive-interrupt-handler-function-call
				     cogen-core-primitive-standalone-function-call
				     cogen-body)
      ;;Compose the primitive operation call, generating the SHORTCUT if needed.
      ;;
      ;;PRIM is a struct of type PRIMITIVE-HANDLER.  CTXT must be one of the symbols:
      ;;V, E,  P.  FILTERED-SIMPLIFIED-RAND*  is a list  of structs  representing the
      ;;operands as recordised code.
      ;;
      ;;COGEN-BODY must be a continuation thunk:  when we do not generate a SHORTCUT,
      ;;COGEN-BODY  is called  to  generate  the primitive  operation  call; when  we
      ;;generate a  SHORTCUT, COGEN-BODY  is called to  generate the  recordised code
      ;;body.
      ;;
      (define (interrupt-handler/uninterruptible-primitive-error)
	;;Function     to    be     used     as    value     for    the     parameter
	;;%RECORD-USE-OF-INTERRUPT-IN-BODY.  It raises an error.
	;;
	(compiler-internal-error '%record-use-of-interrupt-in-body
	  "attempt to introduce a jump to interrupt handler in the body of an uninterruptible core primitive operation"
	  primitive-symbol-name filtered-simplified-rand* ctxt))
      (if (not (primitive-handler-interruptable? prim))
	  ;;Raise an error if INTERRUPT is called by an uninterruptible primitive.
	  (parameterize ((%record-use-of-interrupt-in-body interrupt-handler/uninterruptible-primitive-error))
	    (cogen-body))
	(let* ((interrupted? #f)
	       (body         (parameterize ((%record-use-of-interrupt-in-body (lambda ()
										(set! interrupted? #t))))
			       (cogen-body))))
	  (if (not interrupted?)
	      ;;No jumps to the interrupt handler  in BODY: avoid creating a SHORTCUT
	      ;;and just return the BODY itself.
	      body
	    ;;There is at least one:
	    ;;
	    ;;   (primcall interrupt)
	    ;;
	    ;;in the  generated BODY; so  we must  generate an interrupt  handler and
	    ;;wrap the BODY into a SHORTCUT.
	    (case ctxt
	      ((V)
	       (if (%the-body-is-just-an-interrupt-primcall? body)
		   (cogen-core-primitive-standalone-function-call primitive-symbol-name filtered-simplified-rand*)
		 (make-shortcut
		     body
		   (cogen-core-primitive-interrupt-handler-function-call primitive-symbol-name filtered-simplified-rand*))))

	      ((E)
	       (if (%the-body-is-just-an-interrupt-primcall? body)
		   (cogen-core-primitive-standalone-function-call primitive-symbol-name filtered-simplified-rand*)
		 (make-shortcut
		     body
		   (cogen-core-primitive-interrupt-handler-function-call primitive-symbol-name filtered-simplified-rand*))))

	      ((P)
	       (if (%the-body-is-just-an-interrupt-primcall? body)
		   (prm '!= (cogen-core-primitive-standalone-function-call primitive-symbol-name filtered-simplified-rand*)
			(K bool-f))
		 (make-shortcut
		     body
		   (prm '!= (cogen-core-primitive-interrupt-handler-function-call primitive-symbol-name filtered-simplified-rand*)
			(K bool-f)))))

	      (else
	       (error __who__ "invalid context" ctxt)))))))

    (define-constant %record-use-of-interrupt-in-body
      (make-parameter (lambda ()
			(error '%record-use-of-interrupt-in-body "uninitialized"))))

    (define (%the-body-is-just-an-interrupt-primcall? body)
      (struct-case body
	((primcall op)
	 (eq? op 'interrupt))
	(else #f)))

    #| end of module: WITH-INTERRUPT-HANDLER, INTERRUPT |# )

  #| end of module: COGEN-PRIMOP, COGEN-DEBUG-PRIMOP |# )


(module (handle-fix)
  ;;This module transforms and expands the values in struct instances of
  ;;type FIX.  Knowing that a closure is a:
  ;;
  ;;* "combinator" if it has *no* free variables;
  ;;
  ;;* "non-combinator" if it has free variables;
  ;;
  ;;the values from a FIX struct are processed as follows:
  ;;
  ;;* If the FIX struct contains only bindings for combinators: a single
  ;;  BIND structure is returned, representing the following operations:
  ;;
  ;;     (let ((?combinator-name ?combinator-code))
  ;;           ...))
  ;;       ?body)
  ;;
  ;;* If  the FIX struct  contains only bindings for  non-combinators: a
  ;;  single BIND  structure is returned, containing  recordized code to
  ;;  allocate and initialise the closures:
  ;;
  ;;     (let ((?non-combin-name
  ;;                  (alloc-and-init-closure ?non-combin-code))
  ;;           ...)
  ;;       ?body)
  ;;
  ;;* If the  FIX struct contains both  combinators and non-combinators,
  ;;  the  return value  is recordized  code representing  the following
  ;;  operations:
  ;;
  ;;     (let ((?combinator-name ?combinator-code))
  ;;           ...))
  ;;       (let ((?non-combin-name
  ;;                   (alloc-and-init-closure ?non-combin-code))
  ;;             ...)
  ;;         ?body))
  ;;
  (module (handle-fix)

    (define (handle-fix lhs* rhs* body)
      (let-values (((lhs-combin* rhs-combin* lhs-non-combin* rhs-non-combin*)
		    (%partition lhs* rhs*)))
	(cond ((null? lhs-non-combin*)
	       (make-bind lhs-combin* (map V rhs-combin*) body))
	      ((null? lhs-combin*)
	       (build-closures lhs-non-combin* rhs-non-combin*
			       (closure-object-setters lhs-non-combin*
						       rhs-non-combin*
						       body)))
	      (else
	       (make-bind lhs-combin* (map V rhs-combin*)
			  (build-closures lhs-non-combin* rhs-non-combin*
					  (closure-object-setters lhs-non-combin*
								  rhs-non-combin*
								  body)))))))

    (define (%partition lhs* rhs*)
      (if (null? lhs*)
	  (values '() '() '() '())
	(let-values (((lhs-combin* rhs-combin lhs-non-combin rhs-non-combin)
		      (%partition ($cdr lhs*) ($cdr rhs*))))
	  (let ((lhs ($car lhs*))
		(rhs ($car rhs*)))
	    (if (%combinator? lhs rhs)
		(values (cons lhs lhs-combin*)
			(cons rhs rhs-combin)
			lhs-non-combin
			rhs-non-combin)
	      (values lhs-combin*
		      rhs-combin
		      (cons lhs lhs-non-combin)
		      (cons rhs rhs-non-combin)))))))

    (define (%combinator? lhs.unused rhs)
      ;;Return true if the struct  instance of type CLOSURE-MAKER in RHS
      ;;has *no* free variables.
      ;;
      (struct-case rhs
	((closure-maker code freevar*)
	 (null? freevar*))
	(else #f)))

    #| end of module |# )

  (module (build-closures)

    (define (build-closures lhs* rhs* body)
      (let ((lhs  ($car lhs*))
	    (rhs  ($car rhs*))
	    (lhs* ($cdr lhs*))
	    (rhs* ($cdr rhs*)))
	(let ((n  (%closure-size rhs))
	      (n* (map %closure-size rhs*)))
	  (make-bind (list lhs)
		     (list (prm 'alloc
				(K (%sum n n*))
				(K closure-tag)))
		     (make-bind lhs* (%adders lhs n n*)
				body)))))

    (define (%adders lhs n n*)
      ;;Return   a   list  of   struct   instances   of  type   PRIMCALL
      ;;representing...
      ;;
      (if (null? n*)
	  '()
	(cons (prm 'int+ lhs (K n))
	      (%adders lhs
		       (+ n ($car n*))
		       ($cdr n*)))))

    (define (%sum n n*)
      ;;Return the sum between the numbers in the list N* and the number
      ;;N.
      ;;
      (if (null? n*)
	  n
	(%sum (+ n ($car n*))
	      ($cdr n*))))

    (define (%closure-size x)
      ;;X must be  a struct instance of type  CLOSURE-MAKER.  Return the
      ;;*aligned*  number of  bytes needed  to hold  the free  variables
      ;;slots in the closure built in object.
      ;;
      ;;                  0   1   2   3   4   5
      ;;   |------------|---|---|---|---|---|---| closure object
      ;;         ^
      ;;         |      |.......................|
      ;;    pointer to         slots size
      ;;    binary code
      ;;
      (struct-case x
	((closure-maker code freevar*)
	 (if (null? freevar*)
	     0
	   (align (+ disp-closure-data (* (length freevar*) wordsize)))))))

    #| end of module |# )

  (module (closure-object-setters)
    ;;To build  a closure built  in object we  must allocate a  block of
    ;;memory and then intialise it.  Given  a built in code object and a
    ;;list of free variables, initialisation means:
    ;;
    ;;1. Store a  pointer to the binary  code in the code  object in the
    ;;   first word of the closure object.
    ;;
    ;;2.   For each  free variable:  store the  reference to  it in  the
    ;;   associated slot of the closure object.
    ;;
    ;;If ?VAR is the address of  a closure built in object, ?BINARY-CODE
    ;;is a pointer  to the binary code, ?FREE-VAR is  the reference to a
    ;;free variable, the initialisation for a single closure object is:
    ;;
    ;;   (mset ?var off-closure-code ?binary-code)
    ;;   (mset ?var (+ 0 off-closure-data) ?free-var-0)
    ;;   (mset ?var (+ 1 off-closure-data) ?free-var-1)
    ;;   (mset ?var (+ 2 off-closure-data) ?free-var-2)
    ;;
    (define (closure-object-setters lhs* rhs* body)
      ;;LHS* must be a list of struct instances of type VAR representing
      ;;memory locations containing references to the closure objects.
      ;;
      ;;RHS* must be a list of struct instances of type CLOSURE-MAKER.
      ;;
      ;;BODY must be  a struct instance representing  recordized code in
      ;;which the closure bindings are visible.
      ;;
      (if (null? lhs*)
	  body
	(%single-closure-setters ($car lhs*) ($car rhs*)
				 (closure-object-setters ($cdr lhs*) ($cdr rhs*) body))))

    (define (%single-closure-setters lhs rhs body)
      (struct-case rhs
	((closure-maker code freevar*)
	 (make-seq (prm 'mset lhs (K off-closure-code) (V code))
		   (%slot-setters lhs freevar* off-closure-data body)))))

    (define (%slot-setters lhs free* slot-offset body)
      ;;LHS  must be  a struct  instance  of type  VAR representing  the
      ;;address of the closure memory block.
      ;;
      ;;FREE*  must  be   a  list  of  struct  instances   of  type  VAR
      ;;representing references to free variables.
      ;;
      ;;SLOT-OFFSET must be  a fixnum representing the  offset (from the
      ;;beginning of the closure memory block) of the next free variable
      ;;slot, measured in bytes.
      ;;
      ;;BODY must be  a struct instance representing  recordized code in
      ;;which the closure bindings are visible.
      ;;
      (if (null? free*)
	  body
	(make-seq (prm 'mset lhs (K slot-offset) (V ($car free*)))
		  (%slot-setters lhs ($cdr free*) (+ slot-offset wordsize) body))))

    #| end of module: closure-object-setters |# )

  #| end of module: handle-fix |# )


(module cogen-debug-call-stuff
  (cogen-debug-call)
  (import CODE-GENERATION-FOR-CORE-PRIMITIVE-OPERATION-CALLS)

  (define (cogen-debug-call op ctxt arg* kont)
    ;;This function is used to process struct instances of type PRIMCALL
    ;;with operand "debug-call"; such PRIMCALLs are inserted in the code
    ;;when debug  mode is  on, function  calls are  wrapped in  calls to
    ;;"debug-call".  So:
    ;;
    ;;   (list 1 2)
    ;;
    ;;becomes:
    ;;
    ;;   (debug-call '(#f list 1 2) 'list '1 '2)
    ;;
    ;;where the  #f at  the beginning  of the  quoted list  represents a
    ;;missing annotation source.  See the function RECORDIZE for details
    ;;about how "debug-call" PRIMREFs are generated.
    ;;
    ;;This function returns a FUNCALL struct instance.
    ;;
    ;;OP is  always the symbol "debug-call";  it is the value  of the OP
    ;;field of the PRIMCALL structure.
    ;;
    ;;CTXT is one of the symbols: V, E, P.  It represents the context in
    ;;which the PRIMCALL was found in recordized code.
    ;;
    ;;ARG* is  a list  of struct  instance representing  recordized code
    ;;that,   when  evaluated,   will  return   the  arguments   to  the
    ;;"debug-call".  It is composed of 3 items:
    ;;
    ;;1.  A  symbolic expression  representing the  source form  of this
    ;;   function call.
    ;;
    ;;2. A  struct instance representing  the function to call  in debug
    ;;   mode.
    ;;
    ;;3.   A  list of  struct  instances  representing code  that,  when
    ;;   evaluated,  will return the  arguments of the  wrapped function
    ;;   call.
    ;;
    ;;KONT is  a continuation function.   For the  context V: it  is the
    ;;function  V; for  the context  P: it  is the  function P;  for the
    ;;context E: it is the function E.
    ;;
    ;;Notice that  DEBUG-CALL is actually a  primitive function exported
    ;;by "ikarus.debugger.sls".
    ;;
    (assert (eq? op 'debug-call))
    (assert (>= (length arg*) 2))
    (let ((src/expr	(car  arg*))  ;source expression
	  (func		(cadr arg*))  ;the wrapped function
	  (args		(cddr arg*))) ;args to the wrapped function
      (struct-case (%remove-tag func)
	((primref name)
	 (if (core-primitive-operation? name)
	     (cogen-debug-primop name src/expr ctxt args)
	   (%fail kont arg*)))
	(else
	 (%fail kont arg*)))))

  (define (%fail kont arg*)
    (kont (make-funcall (mk-primref 'debug-call) arg*)))

  (define (%remove-tag x)
    (struct-case x
      ((known expr)
       expr)
      (else
       x)))

  #| end of module: cogen-debug-call |# )


(module (V)
  ;;The function V erases known values;  its argument X must be a struct
  ;;instance  representing  recordized  code  to  be  executed  in  "for
  ;;returned  value" context;  its  return value  is  a struct  instance
  ;;representing recordized code (to be executed in "for returned value"
  ;;context) which is meant to replace X.
  ;;
  ;;Accept as input recordized code holding the following struct types:
  ;;
  ;;bind		closure-maker	code-loc
  ;;conditional		constant	fix
  ;;forcall		funcall		jmpcall
  ;;known		primcall	primref
  ;;seq			var
  ;;
  ;;
  ;;Return recordized code in which:
  ;;
  ;;* Instances  of CONSTANT  contain the  binary representation  of the
  ;;  object.
  ;;
  ;;* Instances of PRIMREF are replaced by instances of PRIMCALL.
  ;;
  ;;* Instances of CODE-LOC and CLOSURE-MAKER are wrapped into instances
  ;;  of CONSTANT.
  ;;
  ;;* Instances of PRIMCALL ...
  ;;
  ;;* Instances of FIX are handled.
  ;;
  (import cogen-debug-call-stuff)
  (import CODE-GENERATION-FOR-CORE-PRIMITIVE-OPERATION-CALLS)
  (define (V x)
    (struct-case x
      ((known expr)
       (unknown-V expr))
      (else
       (unknown-V x))))

  (define (unknown-V x)
    (struct-case x
      ((constant)
       (constant->native-constant-representation x))

      ((var)
       x)

      ((primref name)
       ;;Generate code  to retrieve  the "value"  field from  a location  gensym; the
       ;;value  of  such  slot  must  contain  a  reference  to  the  closure  object
       ;;implementing a global lexical procedure.
       ;;
       ;;NOTE Once we reference the loc gensym in the assembly code: we need a way to
       ;;associate such gensym to the generated binary code; the location gensym will
       ;;be stored  in the  relocation vector  associated to the  code object  we are
       ;;building.  This is what the OBJECT struct generated below is for.
       (prm 'mref
	    (K (make-object (primitive-public-function-name->location-gensym name)))
	    (K off-symbol-record-value)))

      ((code-loc)
       (make-constant x))

      ((closure-maker)
       (make-constant x))

      ((bind lhs* rhs* body)
       (make-bind lhs* (map V rhs*) (V body)))

      ((fix lhs* rhs* body)
       (handle-fix lhs* rhs* (V body)))

      ((conditional test conseq altern)
       (make-conditional (P test) (V conseq) (V altern)))

      ((seq e0 e1)
       (make-seq (E e0) (V e1)))

      ((primcall op arg*)
       (case op
	 ((debug-call)
	  (cogen-debug-call op 'V arg* V))
	 (else
	  (cogen-primop     op 'V arg*))))

      ((forcall op arg*)
       (make-forcall op (map V arg*)))

      ((funcall rator arg*)
       (make-funcall (Function rator) (map V arg*)))

      ((jmpcall label rator arg*)
       (make-jmpcall label (V rator) (map V arg*)))

      (else
       (error 'cogen-V "invalid value expr" (unparse-recordized-code x)))))

  #| end of module: V |# )


(define (P x)
  ;;X  must be  a struct  instance  representing recordized  code to  be
  ;;executed   in  predicate   context.    Return   a  struct   instance
  ;;representing recordized  code (to be executed  in predicate context)
  ;;which is meant to replace X.
  ;;
  ;;Accept as input recordized code holding the following struct types:
  ;;
  ;;bind		closure-maker	code-loc
  ;;conditional		constant	fix
  ;;forcall		funcall		jmpcall
  ;;known		primcall	primref
  ;;seq			var
  ;;
  (import cogen-debug-call-stuff)
  (import CODE-GENERATION-FOR-CORE-PRIMITIVE-OPERATION-CALLS)
  (struct-case x
    ((constant c)
     (if c (K #t) (K #f)))

    ((primref)
     (K #t))

    ((code-loc)
     (K #t))

    ((closure-maker)
     (K #t))

    ((bind lhs* rhs* body)
     (make-bind lhs* (map V rhs*) (P body)))

    ((conditional test conseq altern)
     ;;FIXME Should  this be processed  further to  test the case  of (P
     ;;test)  always true  or always  false?   Or is  this already  done
     ;;later?  (Marco Maggi; Oct 16, 2012)
     (make-conditional (P test) (P conseq) (P altern)))

    ((seq e0 e1)
     (make-seq (E e0) (P e1)))

    ((fix lhs* rhs* body)
     (handle-fix lhs* rhs* (P body)))

    ((primcall op arg*)
     (case op
       ((debug-call)
	(cogen-debug-call op 'P arg* P))
       (else
	(cogen-primop     op 'P arg*))))

    ((var)
     (prm '!= (V x) (V (K #f))))

    ((funcall)
     (prm '!= (V x) (V (K #f))))

    ((jmpcall)
     (prm '!= (V x) (V (K #f))))

    ((forcall)
     (prm '!= (V x) (V (K #f))))

    ((known expr)
     ;;FIXME.  Suboptimal.  (Abdulaziz Ghuloum)
     (P expr))

    (else
     (error 'cogen-P "invalid pred expr" (unparse-recordized-code x)))))


(define (E x)
  ;;X  must be  a struct  instance  representing recordized  code to  be
  ;;executed in  "for side  effect" context.   Return a  struct instance
  ;;representing recordized  code (to be  executed in "for  side effect"
  ;;context) which is meant to replace X.
  ;;
  ;;Accept as input recordized code holding the following struct types:
  ;;
  ;;bind		closure-maker	code-loc
  ;;conditional		constant	fix
  ;;forcall		funcall		jmpcall
  ;;known		primcall	primref
  ;;seq			var
  ;;
  (import cogen-debug-call-stuff)
  (import CODE-GENERATION-FOR-CORE-PRIMITIVE-OPERATION-CALLS)
  (struct-case x

    ;;Useless for side effects: remove!
    ((constant)		(nop))
    ((var)		(nop))
    ((primref)		(nop))
    ((code-loc)		(nop))
    ((closure-maker)	(nop))

    ((bind lhs* rhs* body)
     (make-bind lhs* (map V rhs*) (E body)))

    ((conditional test conseq altern)
     (make-conditional (P test) (E conseq) (E altern)))

    ((seq e0 e1)
     (make-seq (E e0) (E e1)))

    ((fix lhs* rhs* body)
     (handle-fix lhs* rhs* (E body)))

    ((primcall op arg*)
     (case op
       ((debug-call)
	(cogen-debug-call op 'E arg* E))
       (else
	(cogen-primop     op 'E arg*))))

    ((forcall op arg*)
     (make-forcall op (map V arg*)))

    ((funcall rator arg*)
     (make-funcall (Function rator) (map V arg*)))

    ((jmpcall label rator arg*)
     (make-jmpcall label (V rator) (map V arg*)))

    ((known expr)
     ;;FIXME Suboptimal.  (Abdulaziz Ghuloum)
     (E expr))

    (else
     (error 'cogen-E "invalid effect expr" (unparse-recordized-code x)))))


(define (T x)
  ;;Similar to V  but it must be  applied only to the  "simplified operands" prepared
  ;;for  a   core  primitive  operation   application.   Return  a   struct  instance
  ;;representing recordized  code (to  be executed in  "for returned  value" context)
  ;;which is meant to replace X.
  ;;
  ;;All    the     core    primitive     implementation    handlers     defined    by
  ;;DEFINE-PRIMITIVE-OPERATION must filter their arguments through T before including
  ;;them in their output recordised code.
  ;;
  ;;X must be a  struct instance representing recordized code to  be executed in "for
  ;;returned value" context, evaluating to a single value to be used as argument to a
  ;;primitive operation.
  ;;
  ;;Accept as input recordized code holding the following struct types:
  ;;
  ;;   constant		known		var
  ;;
  (struct-case x
    ((var)
     x)

    ((constant)
     (constant->native-constant-representation x))

    ((known expr type)
     (T expr))

    (else
     (compiler-internal-error 'cogen-specify-representation:T
       "invalid struct as simplified operand to core primitive operation application"
       (unparse-recordized-code x)))))

(define* (constant->native-constant-representation x)
  ;;X must  be a struct  instance of  type CONSTANT.  When  the constant value  has a
  ;;binary  representation:  return   a  new  CONSTANT  struct   holding  the  binary
  ;;representation itself.  Otherwise return:
  ;;
  ;;   (constant (object ?const))
  ;;
  ;;which meant that ?CONST will end in the code object's relocation vector.
  ;;
  ;;The binary  representation is an  exact integer that  fits into a  single machine
  ;;word.
  ;;
  (let ((c (constant-value x)))
    (cond ((fx? c)
	   ;;Shifting as is done below is equivalent to:
	   ;;
	   ;;   (make-constant (* c fx-scale))
	   ;;
	   (make-constant (bitwise-arithmetic-shift-left c fx-shift)))

	  ((boolean? c)
	   (make-constant (if c bool-t bool-f)))

	  ((eq? c (void))
	   (make-constant void-object))

	  ((bwp-object? c)
	   (make-constant BWP-OBJECT))

	  ((char? c)
	   ;;Here  we are  interested  in Scheme  characters  as standalone  objects:
	   ;;machine words whose least significant bits  are set to the character tag
	   ;;and whose most significant bits are  set to the character's Unicode code
	   ;;point.
	   (make-constant ($fxlogor char-tag
				    ($fxsll (char->integer c)
					    char-shift))))

	  ((null? c)
	   (make-constant nil))

	  ((eof-object? c)
	   (make-constant eof))

	  ((object? c)
	   (compiler-internal-error __who__
	     "found recordised constant with double wrapping" (unparse-recordized-code x)))

	  (else
	   ;;Everything else will go in the relocation vector.
	   (make-constant (make-object c))))))


(define-syntax K
  ;;Wrap X with a struct instance of type CONSTANT.
  ;;
  (syntax-rules ()
    ((_ ?x)
     (make-constant ?x))))

(define (KN x)
  ;;Wrap  X with  a  struct instance  of  type CONSTANT;  X must  be  a native  value
  ;;representation.
  ;;
  (cond ((fx? x)
	 (make-constant x))
	(else
	 (make-object (make-constant x)))))


(module (Function)
  ;;This module is used to process the operator of every struct instance
  ;;of type FUNCALL by the V and  E.  The operator can be a reference to
  ;;a top level binding, but also  an expression which should evaluate a
  ;;closure at runtime.
  ;;
  ;;This module takes care of:
  ;;
  ;;* Expanding recordized  references to top level bindings  to what is
  ;;  needed to retrieve the reference to closure.
  ;;
  ;;* Inserting  code to evaluate  an arbitrary expression and  check at
  ;;   runtime  that  it  is  actually  a  closure  (if  not:  raise  an
  ;;  exception).
  ;;
  (define-inline (Function x)
    ;;X must  be a  struct instance representing  recordized code  to be
    ;;executed  in  "for  returned  value"  context.   Return  a  struct
    ;;instance  representing recordized  code  (to be  executed in  "for
    ;;returned value" context) which is meant to replace X.
    ;;
    (F x #t))

  (define (F x check?)
    (struct-case x
      ((primcall op args)
       (cond ((and (eq? op 'top-level-value)
		   (null? ($cdr args)) ;only one argument
		   (%recordized-symbol ($car args)))
	      ;;The recordized code:
	      ;;
	      ;;   #[primcall #[primref top-level-value] (?loc)]
	      ;;
	      ;;represents a  reference to a top  level value.  Whenever
	      ;;binary code performs a call  to a global closure object,
	      ;;it does the following:
	      ;;
	      ;;* From the relocation vector of the current code object:
	      ;;  retrieve the loc gensym of the procedure to call.
	      ;;
	      ;;* From the  loc gensym: extract the value  of the "proc"
	      ;;  slot, which is meant to be a closure object.
	      ;;
	      ;;* Actually call the closure object.
	      ;;
	      ;;Here we generate  the code needed to  retrieve the value
	      ;;of the field "proc" from the symbol ?LOC.
	      ;;
	      ;;FIXME It is  clear that: at the time  the closure object
	      ;;call is performed, the loc gensym must have been already
	      ;;initialised by storing the  closure object in the "proc"
	      ;;slot.   Good.  But  why  do  we call  RESET-SYMBOL-PROC!
	      ;;here, at compile-time?  (Marco Maggi; Mon May 19, 2014)
	      => (lambda (loc)
		   (reset-symbol-proc! loc)
		   (prm 'mref
			(constant->native-constant-representation (make-constant loc))
			(K off-symbol-record-proc))))
	     (else
	      (nonproc x check?))))

      ((primref op)
       (V x))

      ((known x.expr x.type)
       (cond ((eq? (T:procedure? x.type) 'yes)
	      (F x.expr #f))
	     (else
	      (F x.expr check?))))

      (else
       (nonproc x check?))))

  (define (%recordized-symbol arg)
    ;;ARG must be a struct instance representing recordized code.
    ;;
    ;;If ARG is  an intance of CONSTANT (possibly wrapped  into a KNOWN)
    ;;whose value is a symbol: return that symbol; else return #f.  Such
    ;;symbol is meant to be the location gensym of a procedure.
    ;;
    (struct-case arg
      ((constant arg.val)
       (and (symbol? arg.val) arg.val))
      ((known arg.expr)
       (%recordized-symbol arg.expr))
      (else
       #f)))

  (module (nonproc)

    (define (nonproc x check?)
      ;;When  CHECK?  is true:  generate  the  code needed  to  test  at run-time  if
      ;;evaluating X yields a closure object; if  it does: X is returned at run-time,
      ;;otherwise an error is raised at run-time.
      ;;
      (if check?
	  (with-tmp ((x (V x)))
	    (make-shortcut
		(make-seq
		 (make-conditional (%tag-test x closure-mask closure-tag)
		     (prm 'nop)
		   (prm 'interrupt))
		 x)
	      (V (make-funcall (mk-primref 'error)
			       (list (K 'apply) (K "not a procedure") x)))))
	(V x)))

    (define (%tag-test x mask tag)
      ;;Primary tag test.  X must be recordised code representing an immediate Scheme
      ;;object or a tagged pointer referencing a  Scheme object.  Test if X is a word
      ;;of type  TAG: use MASK to  extract bits from X,  then verify if the  bits are
      ;;equal to TAG.
      ;;
      (if mask
	  (prm '= (prm 'logand x (K mask)) (K tag))
	(prm '= x (K tag))))

    #| end of module: NONPROC |# )

  #| end of module: Function |# )


;;;; some external code

(include "ikarus.compiler.primitive-operations.scm" #t)


;;;; done

#| end of module ALT-COGEN.SPECIFY-REPRESENTATION |# )

;;; end of file
;; Local Variables:
;; mode: vicare
;; eval: (put 'make-conditional		'scheme-indent-function 2)
;; eval: (put 'make-shortcut		'scheme-indent-function 1)
;; eval: (put 'case-primitive-operation-handler	'scheme-indent-function 1)
;; End:
