;;;Ikarus Scheme -- A compiler for R6RS Scheme.
;;;Copyright (C) 2006,2007,2008  Abdulaziz Ghuloum
;;;Modified by Marco Maggi.
;;;
;;;This program is free software:  you can redistribute it and/or modify
;;;it under  the terms of  the GNU General  Public License version  3 as
;;;published by the Free Software Foundation.
;;;
;;;This program is  distributed in the hope that it  will be useful, but
;;;WITHOUT  ANY   WARRANTY;  without   even  the  implied   warranty  of
;;;MERCHANTABILITY or  FITNESS FOR  A PARTICULAR  PURPOSE.  See  the GNU
;;;General Public License for more details.
;;;
;;;You should  have received a  copy of  the GNU General  Public License
;;;along with this program.  If not, see <http://www.gnu.org/licenses/>.


#!vicare
(library (ikarus.intel-assembler)
  (export
    assemble-sources
    assembler-property-key)
  (import (except (vicare)
		  fixnum-width
		  greatest-fixnum
		  least-fixnum)
    ;;NOTE  This library  is needed  to build  a  new boot  image.  Let's  try to  do
    ;;everything here without loading external  libraries.  (Marco Maggi; Thu Sep 25,
    ;;2014)
    (ikarus.compiler.condition-types)
    (except (ikarus.code-objects)
	    procedure-annotation)
    (except (vicare system $codes)
	    assembler-property-key))

  (module (wordsize boot.case-word-size)
    (include "ikarus.wordsize.scm" #t))


;;;; introduction
;;
;;As reference for Intel Architecture instructions  we can look at (URL last verified
;;on Fri Oct 24, 2014):
;;
;;   Intel® 64 and IA-32 Architectures Software Developer Manuals
;;   <http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html>
;;
;;and search especially for:
;;
;;   Intel 64  and IA-32 Architectures  Software Developer's Manual  Combined Volumes
;;   2A, 2B, and 2C: Instruction Set Reference, A-Z.
;;
;;which  has a  nice, clickable,  index of  supported instruction  mnemonics.  For  a
;;quickly searchable list of x86 Assembly  instructions (both Intel notation and AT&T
;;notation) see also:
;;
;;   Wikipedia  contributors.   "X86  instruction  listings."   Wikipedia,  The  Free
;;   Encyclopedia.   Wikipedia,  The Free  Encyclopedia,  30  Aug.  2014.   Web.   24
;;   Oct. 2014.  <https://en.wikipedia.org/wiki/X86_instruction_listings>
;;
;;
;;General notes
;;-------------
;;
;;Almost  all the  Assembly language  instructions used  by Vicare  act upon  machine
;;words;  which means  32-bit integers  on 32-bit  platforms and  64-bit integers  on
;;64-bit platforms.
;;
;;The only high-level  Assembly instructions acting upon bytes are:  BSET, BREF; they
;;are used to access bytes and octets in the data area of bytevector, flonum and code
;;Scheme  objects.  Both  BSET  and  BREF are  implemented  with  the Intel  Assembly
;;instruction MOVB.
;;
;;The only high-level Assembly instructions  acting upon 32-bit integers are: MSET32,
;;MREF32; they are used to access  Unicode code points representing characters in the
;;data area  of string Scheme objects.   Both MSET32 and MREF32  are implemented with
;;the Intel Assembly instruction MOV32.
;;
;;The code is generated by previous compiler passes using 32-bit register names (EAX,
;;EBX, ...)   and this compiler  pass takes care  of replacing them  with appropriate
;;64-bit opcodes when assembling for a 64-bit platform.
;;
;;NOTE  The high-level  Assembly instruction  BSWAP!  is  implemented with  the Intel
;;Assembly  instruction BSWAP,  which does  *not* act  on byte  operands: as  used by
;;Vicare, it reverses the byte order of a machine word operand.
;;
;;NOTE Some  Assembly instructions accept  an immediate integer constant  as operand,
;;embedded in the instruction opcode.  The Intel architecture only supports immediate
;;constants of size: 8-bit, 16-bit, 32-bit;  there is no support for 64-bit immediate
;;constants.  The code  refers to integers that can be  embedded as "small operands",
;;while 64-bit constants are "big operands".  Whenever we have to assemble code using
;;a 64-bit  constant: we have  to load it  into a 64-bit  CPU register, then  use the
;;register as operand.
;;
;;
;;About this compiler pass
;;------------------------
;;
;;The purpose of this compiler pass  is to convert symbolic expressions, representing
;;Assembly language  code, into code objects  that can be executed  and serialised in
;;FASL files.  To  understand this compiler pass we need  to understand:
;;
;;* The  internals of code  objects and associated  relocation vectors.  For  this we
;;should read the documentation in Texinfo format.
;;
;;* The structure of opcodes of machine code for the Intel Architecture.  For this we
;;need to study the Intel Architecture manuals.
;;


;;;; syntax helpers

(define-syntax __module_who__
  (identifier-syntax 'assemble-sources))

(define-syntax ($for-each/stx stx)
  ;;Like FOR-HEACH, but expand the loop inline.   The "function" to be mapped must be
  ;;specified by an identifier or lambda form because it is evaluated multiple times.
  ;;
  ;;This implementation:  is tail recursive,  assumes proper list arguments  of equal
  ;;length.
  ;;
  (syntax-case stx ()
    ((_ ?func ?ell0 ?ell ...)
     (with-syntax (((T ...) (generate-temporaries #'(?ell ...))))
       #'(let loop ((t ?ell0) (T ?ell) ...)
	   (when (pair? t)
	     (?func (car t) (car T) ...)
	     (loop  (cdr t) (cdr T) ...)))))
    ))

;;; --------------------------------------------------------------------

(define-syntax-rule (fxadd2 ?op)
  (fx+ ?op 2))

(define-syntax-rule (fxadd3 ?op)
  (fx+ ?op 3))

(define-syntax-rule (fxadd4 ?op)
  (fx+ ?op 4))

(define-syntax fxincr!
  (syntax-rules ()
    ((_ ?op)
     (fxincr! ?op 1))
    ((_ ?op 0)
     ?op)
    ((_ ?op 1)
     (set! ?op (fxadd1 ?op)))
    ((_ ?op 2)
     (set! ?op (fxadd2 ?op)))
    ((_ ?op 3)
     (set! ?op (fxadd3 ?op)))
    ((_ ?op 4)
     (set! ?op (fxadd4 ?op)))
    ((_ ?op ?N)
     (set! ?op (fx+ ?op ?N)))
    ))

;; ------------------------------------------------------------

(define-syntax with-args
  ;;Expect ?X to be an expression evaluating to a list of 2 values; bind these values
  ;;to ?A0 and ?A1 then evaluate the ?BODY forms in the region of the bindings.
  ;;
  (syntax-rules (lambda)
    ((_ ?x (lambda (?a0 ?a1) ?body0 . ?body))
     (let ((t ?x))
       (if (pair? t)
           (let ((t (cdr t)))
             (if (pair? t)
                 (let ((?a0 (car t))
		       (t   (cdr t)))
                   (if (pair? t)
		       (let ((?a1 (car t)))
			 (if (null? (cdr t))
			     (let ()
			       ?body0 . ?body)
			   (compiler-internal-error __module_who__  'with-args "too many args")))
		     (compiler-internal-error __module_who__  'with-args "too few args")))
	       (compiler-internal-error __module_who__  'with-args "too few args")))
	 (compiler-internal-error __module_who__  'with-args "too few args"))))))

(define-syntax-rule (byte ?x)
  ;;Expect ?X to be an expression evaluating  to an exact integer; extract and return
  ;;the 8 least significant bits from the integer.
  ;;
  (let ((t ?x))
    (if (or (fixnum? t)
	    (bignum? t))
	(bitwise-and t #xFF)
      (compiler-internal-error __module_who__ 'byte
	"invalid" t '(byte ?x)))))

(define-syntax-rule (define-entry-predicate ?who ?symbol)
  (define (?who x)
    (and (pair? x)
	 (eq? (car x) '?symbol))))


;;;; helpers

(define-constant LEAST-S32-INTEGER
  -2147483648)	#;(- (expt 2 31))

(define-constant GREATEST-S32-INTEGER
  +2147483647)	#;(- (expt 2 31) 1)

;;; --------------------------------------------------------------------

(define-syntax-rule (%compiler-internal-error ?message . ?irritants)
  (compiler-internal-error __module_who__ __who__ ?message . ?irritants))

;;; --------------------------------------------------------------------

(define* (%compute-code-size octets-and-labels)
  ;;Non-tail recursive  function.  Given a  list holding octets-as-fixnums  and label
  ;;sexps: compute  and return the number  of bytes needed to  hold the corresponding
  ;;binary code.  Such number of bytes will be the minimum size of the data area in a
  ;;code object.
  ;;
  (fold-right (lambda (x size)
		(if (fixnum? x)
		    (fxadd1 size)
		  (case (car x)
		    ((byte)
		     (fxadd1 size))
		    ((relative local-relative)
		     (fxadd4 size))
		    ((label)
		     size)
		    ((word reloc-word reloc-word+ label-addr code-object-self-machine-word-index foreign-label)
		     (fx+ size wordsize))
		    ((bottom-code)
		     (fx+ size (%compute-code-size (cdr x))))
		    (else
		     (%compiler-internal-error
		       "unknown instruction" x)))))
    0
    octets-and-labels))

;;; --------------------------------------------------------------------
;;; symbols properties

(module (assembler-property-key)

  (define (assembler-property-key)
    ASSEMBLER-PROPERTY-KEY)

  (define-syntax (compile-time-gensym stx)
    ;;Generate a gensym at expand time and expand to the quoted symbol.
    ;;
    (syntax-case stx ()
      ((_ ?template)
       (let* ((tmp (syntax->datum #'?template))
	      (fxs (vector->list (foreign-call "ikrt_current_time_fixnums_2")))
	      (str (apply string-append tmp (map (lambda (N)
						   (string-append "." (number->string N)))
					      fxs)))
	      (sym (gensym str)))
	 (with-syntax
	     ((SYM (datum->syntax #'here sym)))
	   (fprintf (current-error-port) "expand-time gensym ~a\n" sym)
	   #'(quote SYM))))))

  (define-constant ASSEMBLER-PROPERTY-KEY
    (compile-time-gensym "assembler-property-key"))

  #| end of module |# )


(module (assemble-sources)

  (define (assemble-sources thunk?-label code-object-sexp*)
    ;;This is the entry point in the assembler.
    ;;
    ;;The argument CODE-OBJECT-SEXP* is a list of symbolic expressions:
    ;;
    ;;   (?code-object-sexp ...)
    ;;
    ;;each of which has the format:
    ;;
    ;;   (code-object-sexp
    ;;     (number-of-free-vars:	?num)
    ;;     (annotation:			?annotation)
    ;;     (label			?label)
    ;;     ?asm-instr-sexp ...)
    ;;
    ;;Return a list of code objects.
    ;;
    (let ((code.num-of-freevars*  (map %sexp.number-of-free-vars code-object-sexp*))
	  (code.annotation*       (map %sexp.annotation          code-object-sexp*))
	  (code.asm-instr-sexp**  (map %sexp.asm-instr-sexp*     code-object-sexp*)))
      (let* ((octets-and-labels* (map convert-instructions  code.asm-instr-sexp**))
	     (octets-and-labels* (map %optimize-local-jumps octets-and-labels*)))
	(let ((code-size*  (map %compute-code-size         octets-and-labels*))
	      (reloc-size* (map %compute-reloc-vector-size octets-and-labels*)))
	  (let ((code-objects* (map make-code   code-size* code.num-of-freevars*))
		(reloc-vector* (map make-vector reloc-size*)))
	    (let ((reloc** (map %store-binary-code-in-code-objects
			     code-objects* octets-and-labels*)))
	      (for-each
		  (lambda (code-object reloc-vector reloc*)
		    (for-each
			(make-reloc-vector-record-filler thunk?-label code-object reloc-vector)
		      reloc*))
		code-objects* reloc-vector* reloc**)
	      ;;Store the reloc vectors in the associated code objects.  Process each
	      ;;code object with the C function "ik_relocate_code()".
	      (for-each set-code-reloc-vector! code-objects* reloc-vector*)
	      ;;Store the annotations in the associated code objects.
	      (for-each (lambda (code annotation)
			  (when annotation
			    (set-code-annotation! code annotation)))
		code-objects* code.annotation*)
	      code-objects*))))))

;;; --------------------------------------------------------------------

  (define (%sexp.number-of-free-vars sexp)
    ;;Given as  argument a CODE-OBJECT-SEXP  symbolic expression: extract  and return
    ;;the value of the NUMBER-OF-FREE-VARS: field.
    ;;
    (let ((field-sexp (cadr sexp)))
      (assert (eq? (car field-sexp) 'number-of-free-vars:))
      (cadr field-sexp)))

  (define (%sexp.annotation sexp)
    ;;Given as  argument a CODE-OBJECT-SEXP  symbolic expression: extract  and return
    ;;the value of the ANNOTATION: field.
    ;;
    (let ((field-sexp (caddr sexp)))
      (assert (eq? (car field-sexp) 'annotation:))
      (cadr field-sexp)))

  (define (%sexp.asm-instr-sexp* sexp)
    ;;Given as  argument a CODE-OBJECT-SEXP  symbolic expression: extract  and return
    ;;the  list  of  Assembly instructions.   We  know  that  the  first is  a  label
    ;;definition.
    ;;
    (receive-and-return (asm-instr-sexp*)
	(cdddr sexp)
      (assert (eq? 'label (caar asm-instr-sexp*)))))

;;; --------------------------------------------------------------------

  (define (%optimize-local-jumps octets-and-labels)
    ;;Scan OCTETS-AND-LABELS and  collect the LABEL entries, which  are "local"; then
    ;;scan again OCTETS-AND-LABELS and mutate  the RELATIVE entries referencing local
    ;;labels to be LOCAL-RELATIVE entries.
    ;;
    ;;Notice that this function does NOT modify the spine of OCTETS-AND-LABELS in any
    ;;way; it just mutates some of the entry's CARs.
    ;;
    (let ((locals '())
	  (G      (gensym)))

      (define (%mark-labels-with-property x)
	;;Non-tail recursive function.
	;;
	(when (pair? x)
	  (case (car x)
	    ((label)
	     (putprop (cdr x) G 'local)
	     (set! locals (cons (cdr x) locals)))
	    ((bottom-code)
	     (for-each %mark-labels-with-property (cdr x))))))

      (define (%relative->local-relative x)
	;;Non-tail recursive function.
	;;
	(when (pair? x)
	  (case (car x)
	    ((relative)
	     (when (eq? (getprop (cdr x) G) 'local)
	       (set-car! x 'local-relative)))
	    ((bottom-code)
	     (for-each %relative->local-relative (cdr x))))))

      (for-each %mark-labels-with-property octets-and-labels)
      (for-each %relative->local-relative  octets-and-labels)
      ;;Clean up the property lists of label symbols.
      ($for-each/stx (lambda (x)
		       (remprop x G))
	locals)
      octets-and-labels))

;;; --------------------------------------------------------------------

  (define* (%compute-reloc-vector-size octets-and-labels)
    ;;Compute the  length of the relocation  vector needed to relocate  a code object
    ;;holding the binary code in OCTETS-AND-LABELS.
    ;;
    (fold-right (lambda (x ac)
		  (if (fixnum? x)
		      ac
		    (case (car x)
		      ((word byte label code-object-self-machine-word-index local-relative)
		       ac)
		      ((reloc-word foreign-label)
		       (fx+ ac 2))
		      ((relative reloc-word+ label-addr)
		       (fx+ ac 3))
		      ((bottom-code)
		       (fx+ ac (%compute-reloc-vector-size (cdr x))))
		      (else
		       (%compiler-internal-error
			 "unknown instr" x)))))
      0
      octets-and-labels))

;;; --------------------------------------------------------------------

  (module (%store-binary-code-in-code-objects)

    (define* (%store-binary-code-in-code-objects x ls)
      ;;Loop over the list of entries LS,  filling the data area of X accordingly.  X
      ;;is a  code object.   LS is  a list of  fixnums and  lists; the  fixnums being
      ;;binary code octects  to be stored in  the code object's data  area, the lists
      ;;representing entries for the relocation vector.
      ;;
      ;;Return a list representing data to build a relocation vector.
      ;;
      (define (loop ls idx reloc bot*)
	;;IDX is the  index of the next byte  to be filled in the  code object's data
	;;area.
	;;
	;;BOT* is initially  empty and is filled with subentries  from the entries in
	;;LS having  key BOTTOM-CODE; such  entries are  processed after LS  has been
	;;consumed.
	;;
	(cond ((null? ls)
	       (if (null? bot*)
		   reloc
		 (loop (car bot*) idx reloc (cdr bot*))))
	      (else
	       (let ((a (car ls)))
		 (if (fixnum? a)
		     (begin
		       ;;Store a byte of binary code in the data area.
		       ($code-set! x idx a)
		       (loop (cdr ls) (fxadd1 idx) reloc bot*))
		   (case (car a)
		     ((byte)
		      ;;Store a byte of binary code in the data area.
		      ($code-set! x idx (cdr a))
		      (loop (cdr ls) (fxadd1 idx) reloc bot*))
		     ((relative local-relative)
		      ;;Add an entry to the relocation list; leave 4 bytes of room in
		      ;;the data area.
		      (loop (cdr ls) (fx+ idx 4) (cons (cons idx a) reloc) bot*))
		     ((reloc-word reloc-word+ label-addr foreign-label)
		      ;;Add an entry to the relocation  list; leave a word of room in
		      ;;the data area.
		      (loop (cdr ls) (fx+ idx wordsize) (cons (cons idx a) reloc) bot*))
		     ((word)
		      ;;Store a machine word in the data area.
		      (%set-code-word-as-fixnum! x idx (cdr a))
		      (loop (cdr ls) (fx+ idx wordsize) reloc bot*))
		     ((code-object-self-machine-word-index)
		      ;;Store a machine word in the data area of the code object; the
		      ;;machine  word  represents  the index  (zero-based  number  of
		      ;;machine  words)  of the  current  machine  word in  the  code
		      ;;object's data area; the index is IDX itself.
		      ;;
		      ;;NOTE This machine word can be used by machine code to compute
		      ;;the address  of the meta data  in the code object,  and so to
		      ;;access, for example, the relocation vector.
		      ;;
		      (%set-code-word-as-fixnum! x idx idx)
		      (loop (cdr ls) (fx+ idx wordsize) reloc bot*))
		     ((label)
		      ;;Store  informations about  the current  location in  the code
		      ;;object in the symbol (cdr a).
		      (%set-label-loc! (cdr a) (list x idx))
		      (loop (cdr ls) idx reloc bot*))
		     ((bottom-code)
		      ;;Push this entry in BOT* to be processed at the end.
		      (loop (cdr ls) idx reloc (cons (cdr a) bot*)))
		     (else
		      (%compiler-internal-error
			"unknown instr" a))))))))
      (loop ls 0 '() '()))

    (define* (%set-code-word-as-fixnum! code idx {x fixnum?})
      ;;Store a machine word,  whose value is X, in the data area  of the code object
      ;;CODE at index IDX.  The machine word is stored encoded as fixnum.
      ;;
      (boot.case-word-size
       ((32)
	;;On 32-bit platforms,  we know that X has a  payload of 32 - 2 =  30 bits in
	;;the bit range [0, 29].  We split such bits as follows:
	;;
	;;            2         1         0
	;;   987654321098765432109876543210
	;;   |----------------------------| 30 bits
	;;                           |----| 6 bits, bit range [0, 5]
	;;                   |------|       8 bits, bit range [6, 13]
	;;           |------|               8 bits, bit range [14, 21]
	;;   |------|                       8 bits, bit range [22, 29]
	;;
	;;*  Bit  range  [0, 5]  is  stored  in  the  first least  significant  byte,
	;;left-shifted by 2 bits to represent the fixnum tag #b00.
	;;
	;;* Bit range [6, 13] is stored in the second byte.
	;;
	;;* Bit range [14, 21] is stored in the third byte.
	;;
	;;* Bit range [22, 29] is stored in the fourth byte.
	;;
	($code-set! code (fx+ idx 0) (fxsll (fxlogand x #x3F) 2))
	($code-set! code (fx+ idx 1) (fxlogand (fxsra x  6) #xFF))
	($code-set! code (fx+ idx 2) (fxlogand (fxsra x 14) #xFF))
	($code-set! code (fx+ idx 3) (fxlogand (fxsra x 22) #xFF)))
       ((64)
	;;On 64-bit platforms,  we know that X has a  payload of 64 - 3 =  61 bits in
	;;the bit range 0-60.  We split such bits as follows:
	;;
	;;   6         5         4         3         2         1         0
	;;   0987654321098765432109876543210987654321098765432109876543210
	;;   |-----------------------------------------------------------| 61 bits
	;;                                                           |---| 5 bits, bit range [0, 4]
	;;                                                   |------|      8 bits, bit range [5, 12]
	;;                                           |------|              8 bits, bit range [13, 20]
	;;                                   |------|                      8 bits, bit range [21, 28]
	;;                           |------|                              8 bits, bit range [29, 36]
	;;                   |------|                                      8 bits, bit range [37, 44]
	;;           |------|                                              8 bits, bit range [45, 52]
	;;   |------|                                                      8 bits, bit range [53, 60]
	;;
	;;* Bit range 0-4 is stored in the 1st (least significant) byte, left-shifted
	;;by 3 bits to represent the fixnum tag #b000.
	;;
	;;* Bit range [5, 12] is stored in the 2nd byte.
	;;
	;;* Bit range [13, 20] is stored in the 3rd byte.
	;;
	;;* Bit range [21, 28] is stored in the 4th byte.
	;;
	;;* Bit range [29, 36] is stored in the 5th byte.
	;;
	;;* Bit range [37, 44] is stored in the 6th byte.
	;;
	;;* Bit range [45, 52] is stored in the 7th byte.
	;;
	;;* Bit range [53, 60] is stored in the 8th byte.
	;;
	($code-set! code (fx+ idx 0) (fxsll (fxlogand x #x1F) 3))
	($code-set! code (fx+ idx 1) (fxlogand (fxsra x  5) #xFF))
	($code-set! code (fx+ idx 2) (fxlogand (fxsra x 13) #xFF))
	($code-set! code (fx+ idx 3) (fxlogand (fxsra x 21) #xFF))
	($code-set! code (fx+ idx 4) (fxlogand (fxsra x 29) #xFF))
	($code-set! code (fx+ idx 5) (fxlogand (fxsra x 37) #xFF))
	($code-set! code (fx+ idx 6) (fxlogand (fxsra x 45) #xFF))
	($code-set! code (fx+ idx 7) (fxlogand (fxsra x 53) #xFF)))))

    (define* (%set-label-loc! x loc)
      (if (getprop x '*label-loc*)
	  (%compiler-internal-error "label is already defined" x)
	(putprop x '*label-loc* loc)))

    #| end of module: %STORE-BINARY-CODE-IN-CODE-OBJECTS |# )

  #| end of module: ASSEMBLE-SOURCES |# )


(module ASSEMBLY-INSTRUCTION-OPERANDS-HELPERS
  ( ;;
   byte?		disp?		small-disp?

   ;; enqueuing bytes in the acccumulator
   CODE			CODE+r
   CODErri		CODErr
   ModRM

   ;; register operands
   register-index
   reg?			reg32?		reg8?		xmmreg?
   reg-requires-REX?	RegReg

   ;; immediate operands
   IMM			IMM32		IMM8		IMM*2
   imm?			imm32?		imm8?
   immediate-int?

   obj?
   word			reloc-word	reloc-word+

   ;; label operands
   label?		label-address?
   label-name

   ;;These are commented out because unused.
   #;SIB
   #;obj+?
   )

  (define* (register-index x)
    (cond ((assq x REGISTER-MAPPING)
	   ;;Extract the IDX field from the table entry.
	   => caddr)
	  (else
	   (%compiler-internal-error "expected symbol representing register name" x))))

  (let-syntax ((define-register-mapping-predicate
		 (syntax-rules ()
		   ((_ ?who ?val)
		    (define (?who x)
		      (cond ((assq x REGISTER-MAPPING)
			     => (lambda (x)
				  (eqv? (cadr x) ?val)))
			    (else #f)))))))
    (define-register-mapping-predicate reg8?   8)
    (define-register-mapping-predicate reg32?  32)
    (define-register-mapping-predicate xmmreg? 'xmm))

  (define-inline (reg? x)
    (assq x REGISTER-MAPPING))

  (define* (reg-requires-REX? x)
    ;;Return the REX.R field in the table entry.
    ;;
    (cond ((assq x REGISTER-MAPPING)
	   => cadddr)
	  (else
	   (%compiler-internal-error "expected symbol representing CPU register name" x))))

  (define-constant REGISTER-MAPPING
;;;     reg  cls  idx  REX.R
    '((%eax   32    0  #f)
      (%ecx   32    1  #f)
      (%edx   32    2  #f)
      (%ebx   32    3  #f)
      (%esp   32    4  #f)
      (%ebp   32    5  #f)
      (%esi   32    6  #f)
      (%edi   32    7  #f)
      (%r8    32    0  #t)
      (%r9    32    1  #t)
      (%r10   32    2  #t)
      (%r11   32    3  #t)
      (%r12   32    4  #t)
      (%r13   32    5  #t)
      (%r14   32    6  #t)
      (%r15   32    7  #t)
      (%al     8    0  #f)
      (%cl     8    1  #f)
      (%dl     8    2  #f)
      (%bl     8    3  #f)
      (%ah     8    4  #f)
      (%ch     8    5  #f)
      (%dh     8    6  #f)
      (%bh     8    7  #f)
      (/0      0    0  #f)
      (/1      0    1  #f)
      (/2      0    2  #f)
      (/3      0    3  #f)
      (/4      0    4  #f)
      (/5      0    5  #f)
      (/6      0    6  #f)
      (/7      0    7  #f)
      (xmm0  xmm    0  #f)
      (xmm1  xmm    1  #f)
      (xmm2  xmm    2  #f)
      (xmm3  xmm    3  #f)
      (xmm4  xmm    4  #f)
      (xmm5  xmm    5  #f)
      (xmm6  xmm    6  #f)
      (xmm7  xmm    7  #f)
      (%r8l    8    0  #t)
      (%r9l    8    1  #t)
      (%r10l   8    2  #t)
      (%r11l   8    3  #t)
      (%r12l   8    4  #t)
      (%r13l   8    5  #t)
      (%r14l   8    6  #t)
      (%r15l   8    7  #t)
      ))

;;; --------------------------------------------------------------------

  (define-inline (word x)
    (cons 'word x))

  (define-inline (reloc-word x)
    (cons 'reloc-word x))

  (define-inline (reloc-word+ x d)
    (cons* 'reloc-word+ x d))

  (define (byte? x)
    (and (fixnum? x)
	 (fx>= x -128)
	 (fx<= x +127)))

  (define-entry-predicate disp? disp)

  (define (small-disp? x)
    (and (disp? x)
	 (byte? (cadr x))))

  (define (CODE n ac)
    ;;N must be a fixnum or bignum.
    ;;
    (cons (byte n) ac))

  (define (CODE+r n reg ac)
    ;;N must be a fixnum or bignum.  REG must be a symbol representing a CPU register
    ;;name.
    ;;
    (cons (byte (fxlogor n (register-index reg)))
	  ac))

  (define (ModRM mod reg r/m ac)
    ;;REG must be a symbol representing a CPU register name.
    ;;
    (cons (byte (fxlogor (register-index r/m)
			 (fxlogor (fxsll (register-index reg) 3)
				  (fxsll mod 6))))
	  (if (and (not (fx= mod 3))
		   (eq? r/m '%esp))
	      (cons (byte #x24) ac)
	    ac)))

  (define* (IMM32 n ac)
    (boot.case-word-size
     ((32)
      (IMM n ac))
     ((64)
      (cond ((imm32? n)
	     ;;Prepend  to  the  accumulator  AC  a  32-bit  immediate  value,  least
	     ;;significant byte first.
	     ;;
	     ;;  #xDDCCBBAA -> `(#xAA #xBB #xCC #xDD . ,ac)
	     ;;
	     ;;SRA = shift right arithmetic.
	     (cons* (byte n)
		    (byte (sra n 8))
		    (byte (sra n 16))
		    (byte (sra n 24))
		    ac))
	    ((label? n)
	     (let ((LN (label-name n)))
	       `((,(if (local-label? LN) 'local-relative 'relative) . ,LN)
		 . ,ac)))
	    (else
	     (%compiler-internal-error "invalid" n))))))

  (define* (IMM n ac)
    (cond ((immediate-int? n)
	   ;;Prepend  to the  accumulator  AC an  immediate integer  value
	   ;;least significant bytes first.
	   ;;
	   ;;  #xDDCCBBAA -> `(#xAA #xBB #xCC #xDD . ,ac)
	   ;;
	   (boot.case-word-size
	    ((32)
	     (cons* (byte n)
		    (byte (sra n 8))
		    (byte (sra n 16))
		    (byte (sra n 24))
		    ac))
	    ((64)
	     (cons* (byte n)
		    (byte (sra n 8))
		    (byte (sra n 16))
		    (byte (sra n 24))
		    (byte (sra n 32))
		    (byte (sra n 40))
		    (byte (sra n 48))
		    (byte (sra n 56))
		    ac))))
	  ((obj? n)
	   (let ((v (cadr n)))
	     (cons (if (immediate? v)
		       (word v)
		     (reloc-word v))
		   ac)))

	  ;;Commented out because unused.  (Marco Maggi; Tue Nov 4, 2014)
	  ;;
	  ;; ((obj+? n)
	  ;;  (let ((v (cadr  n))
	  ;; 	 (d (caddr n)))
	  ;;    (cons (reloc-word+ v d) ac)))

	  ((label-address? n)
	   (cons `(label-addr	. ,(label-name n))
		 ac))

	  ((foreign-label? n)
	   (cons `(foreign-label	. ,(label-name n))
		 ac))

	  ((label? n)
	   (let ((LN (label-name n)))
	     `((,(if (local-label? LN) 'local-relative 'relative) . ,LN)
	       . ,ac)))

	  (else
	   (%compiler-internal-error "invalid" n))))

  (define* (IMM8 {n immediate-int?} ac)
    ;;Prepend to  the accumulator AC  a fixnum representing the  byte N, which  is an
    ;;immediate 8-bit value.
    ;;
    (cons (byte n) ac))

  (define (imm? x)
    (or (immediate-int?	x)
	(obj?		x)
	;;(obj+?	x)
	(label-address?	x)
	(foreign-label?	x)
	(label?		x)))

  (define-entry-predicate foreign-label? foreign-label)

  (define-syntax-rule (imm8? ?x)
    (byte? ?x))

  (define-entry-predicate label? label)
  (define-entry-predicate label-address? label-address)

  (define-syntax-rule (label-name ?x)
    (cadr ?x))

  (define-inline (immediate-int? x)
    (or (fixnum? x)
	(bignum? x)))

  (define-entry-predicate obj?	obj)

  ;;Commented out because unused.  (Marco Maggi; Tue Nov 4, 2014)
  ;;
  ;;(define-entry-predicate obj+? obj+)

  (define* (CODErri c d s i ac)
    ;;Generate code for register+register+immediate operations?
    ;;
    (cond ((imm8? i)
	   (CODE c (ModRM 1 d s (IMM8 i ac))))
	  ((imm? i)
	   (CODE c (ModRM 2 d s (IMM i ac))))
	  (else
	   (%compiler-internal-error "invalid i" i))))

  (define (CODErr c r1 r2 ac)
    ;;Generate code for register+register operations?
    ;;
    (CODE c (ModRM 3 r1 r2 ac)))

  (define* (RegReg r1 r2 r3 ac)
    (cond ((eq? r3 '%esp)
	   (%compiler-internal-error "invalid src %esp"))
	  ((eq? r1 '%ebp)
	   (%compiler-internal-error "invalid src %ebp"))
	  (else
	   (cons* (byte (fxlogor 4                   (fxsll (register-index r1) 3)))
		  (byte (fxlogor (register-index r2) (fxsll (register-index r3) 3)))
		  ac))))

  (module (IMM*2)

    (define* (IMM*2 i1 i2 ac)
      (cond ((and (immediate-int? i1)
		  (obj? i2))
	     (let ((d i1)
		   (v (cadr i2)))
	       (cons (reloc-word+ v d) ac)))
	    ((and (immediate-int? i2)
		  (obj? i1))
	     (IMM*2 i2 i1 ac))
	    ((and (immediate-int? i1)
		  (immediate-int? i2))
	     (IMM (bitwise-and (+ i1 i2) WORDSIZE-BITMASK)
		  ac))
	    (else
	     (%compiler-internal-error "invalid IMM*2" i1 i2))))

    (define-constant WORDSIZE-BITMASK
      ;;On 32-bit platforms: this is an exact integer of 32 bits set to 1.
      ;;
      ;;On 64-bit platforms: this is an exact integer of 64 bits set to 1.
      ;;
      (- (expt 2 (* wordsize 8)) 1))

    #| end of module: IMM*2 |# )

  ;;Commented out because unused.  (Marco Maggi; Wed Nov  5, 2014)
  ;;
  ;;(define (SIB s offset-register base-register ac)
  ;;  (cons (byte (fxlogor (register-index base-register)
  ;;                       (fxlogor (fxsll (register-index offset-register) 3)
  ;;                                (fxsll s 6))))
  ;;        ac))

  (define (imm32? x)
    (boot.case-word-size
     ((32)
      (imm? x))
     ((64)
      (and (immediate-int? x)
	   (<= LEAST-S32-INTEGER x GREATEST-S32-INTEGER)))))

  #| end of module |# )


(module (convert-instructions local-label?)
  (module (label-name)
    (import ASSEMBLY-INSTRUCTION-OPERANDS-HELPERS))

  (define-fluid-override __who__
    (identifier-syntax 'convert-instructions))

  ;;List  of symbols  representing  local labels.
  (define local-labels
    (make-parameter '()))

  (define (local-label? x)
    ;;Return true if X is a local label previously registered.
    ;;
    ;;FIXME Would  this be  significantly faster  with an EQ?  hashtable?  Or  is the
    ;;number of local labels usually small?  (Marco Maggi; Oct 9, 2012)
    ;;
    (and (memq x (local-labels)) #t))

  (define (convert-instructions ls)
    (parametrise ((local-labels (%uncover-local-labels '() ls)))
      (fold-right %convert-single-sexp '() ls)))

  (define (%convert-single-sexp assembly-sexp accum)
    ;;Non-tail  recursive function.   Convert ASSEMBLY-SEXP  into a  list of  fixnums
    ;;(representing  machine  code  octets)  and  sexps;  prepend  the  list  to  the
    ;;accumulator  list   ACCUM;  return  the   new  accumulator  list.    We  expect
    ;;ASSEMBLY-SEXP to have one of the formats:
    ;;
    ;;   (?assembly-instruction-mnemonic ?operand ...)
    ;;   (seq ?assembly-sexp0 ?assembly-sexp ...)
    ;;   (pad ?bytes-count ?assembly-sexp0 ?assembly-sexp ...)
    ;;
    ;;The items prepended to ACCUM can be fixnums or entries like the following:
    ;;
    ;;	(label . ?symbol)
    ;;  (label-addr . ?symbol)
    ;;  (code-object-self-machine-word-index)
    ;;
    ;;NOTE The actual job of sexp instruction conversion is performed by the function
    ;;stored in the property list of the instruction name's symbol.
    ;;
    (define key
      (car assembly-sexp))
    (cond ((getprop key (assembler-property-key))
	   ;;Convert an assembly instruction specification.
	   ;;
	   => (lambda (prop)
		;;We expect PROP to have the format:
		;;
		;;   (?num-of-rand* . ?conversion-function)
		;;
		(let ((num-of-rand*         (car prop))
		      (conversion-function  (cdr prop))
		      (rand*                (cdr assembly-sexp)))
		  (define-syntax-rule (%with-checked-args ?num-of-rand* ?body-form)
		    (if (fx=? (length rand*) ?num-of-rand*)
			?body-form
		      (%error-incorrect-args assembly-sexp num-of-rand*)))
		  (case num-of-rand*
		    ((2)
		     (%with-checked-args 2
		       (conversion-function assembly-sexp accum (car rand*) (cadr rand*))))
		    ((1)
		     (%with-checked-args 1
		       (conversion-function assembly-sexp accum (car rand*))))
		    ((0)
		     (%with-checked-args 0
		       (conversion-function assembly-sexp accum)))
		    (else
		     (%with-checked-args num-of-rand*
		       (apply conversion-function assembly-sexp accum rand*)))))))

	  ((eq? key 'seq)
	   ;;Process a SEQ sexp.  A SEQ sexp has the format:
	   ;;
	   ;;   (seq . ?asm-sexps)
	   ;;
	   ;;where ?ASM-SEXPS is a list of assembly symbolic expressions.
	   ;;
	   (fold-right %convert-single-sexp accum (cdr assembly-sexp)))

	  ((eq? key 'pad)
	   ;;Process  a  PAD sexp.   Convert  the  assembly  code  and return  a  new
	   ;;accumulator list padded with a prefix of zeros.
	   ;;
	   ;;Here is an example PAD sexp, part of a non-tail function call:
	   ;;
	   ;;   (pad 10
	   ;;        (label call_label)
	   ;;        (call (disp -3 %edi)))
	   ;;
	   (let* ((N              (cadr assembly-sexp))
		  (asm-sexps      (cddr assembly-sexp))
		  (new-accum.tail (fold-right %convert-single-sexp accum asm-sexps))
		  (prefix.len     (%compute-code-size (%extract-prefix accum new-accum.tail))))
	     (append (make-list (- N prefix.len) 0)
		     new-accum.tail)))

	  (else
	   (%compiler-internal-error
	     "unknown instruction" assembly-sexp))))

  (define (%extract-prefix old-accum new-accum)
    ;;Non-tail recursive function.  Expect NEW-ACCUM to be a list having OLD-ACCUM as
    ;;tail:
    ;;
    ;;   new-accum = (item0 item ... . old-accum)
    ;;
    ;;visit the  prefix of NEW-ACCUM  building a new list  holding the new  ITEMs and
    ;;filtering out the ITEMs being BOTTOM-CODE entries; return the resulting list.
    ;;
    (if (eq? old-accum new-accum)
	'()
      (let ((asm-sexp (car new-accum)))
	(define-syntax-rule (recur)
	  (%extract-prefix old-accum (cdr new-accum)))
	(if (bottom-code? asm-sexp)
	    ;;Skip BOTTOM-CODE sexp.
	    (recur)
	  (cons asm-sexp (recur))))))

  (define-entry-predicate bottom-code? bottom-code)

  (define (%error-incorrect-args assembly-sexp expected-num-of-rand*)
    (%compiler-internal-error
      (string-append "wrong number of operands in Assembly symbolic expression, expected "
		     (number->string expected-num-of-rand*))
      assembly-sexp))

  (define (%uncover-local-labels names accum)
    ;;Tail recursive  function.  Expect ACCUM to  be a list of  assembly sexps; visit
    ;;ACCUM, visiting  PAD and SEQ entries  recursively, and build a  list of symbols
    ;;being the names of the LABEL entries.  Return the list of LABEL names.
    ;;
    (define-syntax-rule (recur ?names)
      (%uncover-local-labels ?names (cdr accum)))
    (if (null? accum)
	names
      (let ((entry (car accum)))
	(if (pair? entry)
	    (case (car entry)
	      ((label)
	       (recur (cons (label-name entry) names)))
	      ((seq pad)
	       (recur (%uncover-local-labels names (cdr entry))))
	      (else
	       (recur names)))
	  (recur names)))))

  #| end of module |# )


(module ()
  ;;Notice that this  module exports nothing; this  is because its purpose  is to put
  ;;properties in the  property lists of the  symbols (ret, cltd, movl,  ...)  of the
  ;;assembly operations:
  ;;
  ;;   ret
  ;;   cltd
  ;;   movl src dst
  ;;   mov32 src dst
  ;;   movb src dst
  ;;   addl src dst
  ;;   subl src dst
  ;;   sall src dst
  ;;   shrl src dst
  ;;   sarl src dst
  ;;   andl src dst
  ;;   orl src dst
  ;;   xorl src dst
  ;;   leal src dst
  ;;   cmpl src dst
  ;;   imull src dst
  ;;   idivl dst
  ;;   pushl dst
  ;;   popl dst
  ;;   notl dst
  ;;   bswap dst
  ;;   negl dst
  ;;   jmp dst
  ;;   call dst
  ;;   movsd src dst
  ;;   cvtsi2sd src dst
  ;;   cvtsd2ss src dst
  ;;   cvtss2sd src dst
  ;;   movss src dst
  ;;   addsd src dst
  ;;   subsd src dst
  ;;   mulsd src dst
  ;;   divsd src dst
  ;;   ucomisd src dst
  ;;   ja dst
  ;;   jae dst
  ;;   jb dst
  ;;   jbe dst
  ;;   jg dst
  ;;   jge dst
  ;;   jl dst
  ;;   jle dst
  ;;   je dst
  ;;   jna dst
  ;;   jnae dst
  ;;   jnb dst
  ;;   jnbe dst
  ;;   jng dst
  ;;   jnge dst
  ;;   jnl dst
  ;;   jnle dst
  ;;   jne dst
  ;;   jo dst
  ;;   jp dst
  ;;   jnp dst
  ;;
  ;;and additionally to  the symbols (byte, byte-vector, int,  ...)  representing the
  ;;following datums:
  ;;
  ;;   byte x
  ;;   byte-vector x
  ;;   int a
  ;;   label L
  ;;   label-address L
  ;;   code-object-self-machine-word-index
  ;;   nop ac
  ;;
  (import ASSEMBLY-INSTRUCTION-OPERANDS-HELPERS)

;;; --------------------------------------------------------------------

  (define* (REX.R bits ac)
    (boot.case-word-size
     ((32)
      (%compiler-internal-error
	"invalid in 32-bit mode"))
     ((64)
      (cons (fxlogor #b01001000 bits) ac))))

  (define (REX+r r ac)
    (boot.case-word-size
     ((32)
      ac)
     ((64)
      (cond ((reg-requires-REX? r)
	     (REX.R #b001 ac))
	    (else
	     (REX.R #b000 ac))))))

  (define* (REX+RM r rm ac)
    (define (C n ac)
      ac)
    ;;(printf "CASE ~s\n" n)
    ;;(let f ((ac ac) (i 30))
    ;;  (unless (or (null? ac) (= i 0))
    ;;    (if (number? (car ac))
    ;;        (printf " #x~x" (car ac))
    ;;        (printf " ~s" (car ac)))
    ;;    (f (cdr ac) (- i 1))))
    ;;(newline)
    ;;ac)
    (boot.case-word-size
     ((32)
      ac)
     ((64)
      (cond ((disp? rm)
	     (if (reg-requires-REX? r)
		 (with-args rm
		   (lambda (a0 a1)
		     (cond ((and (imm?   a0)
				 (reg32? a1))
			    (if (reg-requires-REX? a1)
				(REX.R #b101 ac)
			      (REX.R #b100 ac)))

			   ((and (imm?   a1)
				 (reg32? a0))
			    (if (reg-requires-REX? a0)
				(REX.R #b101 ac)
			      (REX.R #b100 ac)))

			   ((and (reg32? a0)
				 (reg32? a1))
			    (cond ((reg-requires-REX? a0)
				   (if (reg-requires-REX? a1)
				       (REX.R #b111 ac)
				     (REX.R #b110 ac)))
				  ((reg-requires-REX? a1)
				   (REX.R #b101 ac))
				  (else
				   (REX.R #b100 ac))))

			   ((and (imm? a0)
				 (imm? a1))
			    (%compiler-internal-error
			      "not here 4"))

			   (else
			    (%compiler-internal-error
			      "unhandled" a0 a1)))))
	       (with-args rm
		 (lambda (a0 a1)
		   (cond ((and (imm?   a0)
			       (reg32? a1))
			  (if (reg-requires-REX? a1)
			      (REX.R #b001 ac)
			    (REX.R 0 ac)))

			 ((and (imm?   a1)
			       (reg32? a0))
			  (if (reg-requires-REX? a0)
			      (REX.R #b001 ac)
			    (REX.R 0 ac)))

			 ((and (reg32? a0)
			       (reg32? a1))
			  (cond ((reg-requires-REX? a0)
				 (if (reg-requires-REX? a1)
				     (%compiler-internal-error
				       "unhandled x1" a0 a1)
				   (REX.R #b010 ac)))
				((reg-requires-REX? a1)
				 (%compiler-internal-error
				   "unhandled x3" a0 a1))
				(else
				 (REX.R 0 ac))))

			 ((and (imm? a0)
			       (imm? a1))
			  (REX.R 0 ac))

			 (else
			  (%compiler-internal-error "unhandled" a0 a1)))))))
	    ((reg? rm)
	     (let* ((bits 0)
		    (bits (if (reg-requires-REX? r)
			      (fxlogor bits #b100)
			    bits))
		    (bits (if (reg-requires-REX? rm)
			      (fxlogor bits #b001)
			    bits)))
	       (REX.R bits ac)))
	    (else
	     (%compiler-internal-error
	       "unhandled" rm))))))

  (define (C c ac)
    (boot.case-word-size
     ((32)
      (CODE c ac))
     ((64)
      (REX.R 0 (CODE c ac)))))

  ;;Commented out because it is not used (Marco Maggi; Oct 25, 2011).
  ;;
  ;; (define trace-ac
  ;;   (let ((cache '()))
  ;;     (lambda (ac1 what ac2)
  ;;       (when (assembler-output)
  ;;         (let ((diff (let f ((ls ac2))
  ;; 		      (cond ((eq? ls ac1)
  ;; 			     '())
  ;; 			    (else
  ;; 			     (cons (car ls) (f (cdr ls))))))))
  ;;           (unless (member diff cache)
  ;;             (set! cache (cons diff cache))
  ;;             (printf "~s => ~s\n" what diff))))
  ;;       ac2)))

  (define (CR c r ac)
    (REX+r r (CODE+r c r ac)))

  (define (CR* c r rm ac)
    (REX+RM r rm (CODE c (RM r rm ac))))

  (define (CR*-no-rex c r rm ac)
    (CODE c (RM r rm ac)))

  (define (CCR* c0 c1 r rm ac)
    ;;(CODE c0 (CODE c1 (RM r rm ac))))
    (REX+RM r rm (CODE c0 (CODE c1 (RM r rm ac)))))

  (define (CCR c0 c1 r ac)
    ;;(CODE c0 (CODE+r c1 r ac)))
    (REX+r r (CODE c0 (CODE+r c1 r ac))))

  (define (CCCR* c0 c1 c2 r rm ac)
    ;;(CODE c0 (CODE c1 (CODE c2 (RM r rm ac)))))
    (REX+RM r rm (CODE c0 (CODE c1 (CODE c2 (RM r rm ac))))))

  (define (CCI32 c0 c1 i32 ac)
    (CODE c0 (CODE c1 (IMM32 i32 ac))))

  (define* (RM /d dst ac)
    (cond ((disp? dst)
	   (with-args dst
	     (lambda (a0 a1)
	       (cond ((and (imm8?  a0)
			   (reg32? a1))
		      (ModRM 1 /d a1 (IMM8 a0 ac)))
		     ((and (imm?   a0)
			   (reg32? a1))
		      (ModRM 2 /d a1 (IMM32 a0 ac)))
		     ((and (imm8?  a1)
			   (reg32? a0))
		      (ModRM 1 /d a0 (IMM8 a1 ac)))
		     ((and (imm?   a1)
			   (reg32? a0))
		      (ModRM 2 /d a0 (IMM32 a1 ac)))
		     ((and (reg32? a0)
			   (reg32? a1))
		      (RegReg /d a0 a1 ac))
		     ((and (imm? a0)
			   (imm? a1))
		      (ModRM 0 /d '/5 (IMM*2 a0 a1 ac)))
		     (else
		      (%compiler-internal-error
			"unhandled" a0 a1))))))
	  ((reg? dst)
	   (ModRM 3 /d dst ac))
	  (else
	   (%compiler-internal-error
	     "unhandled" dst))))

  (define* (jmp-pc-relative code0 code1 dst ac)
    (boot.case-word-size
     ((32)
      (%compiler-internal-error
	"no pc-relative jumps in 32-bit mode"))
     ((64)
      (let ((G (gensym "L_jump")))
	(CODE code0
	      (CODE code1 (cons* `(local-relative . ,G)
				 `(bottom-code (label . ,G)
					       (label-addr . ,(label-name dst)))
				 ac)))))))

;;; --------------------------------------------------------------------

  (let-syntax
      ((add-single-instruction
	(syntax-rules ()
	  ;;?NAME is a  symbol representing the Assembly  instruction name (examples:
	  ;;ret, cltd, movl, ...).
	  ;;
	  ;;?INSTR  is   an  identifier  used   as  first  formal  argument   in  the
	  ;;instruction's  conversion   function.   It  is  bound   to  the  symbolic
	  ;;expression representing the full Assembly instruction:
	  ;;
	  ;;   (?assembly-instruction-mnemonic ?operand ...)
	  ;;
	  ;;?AC is an identifier user as  second formal argument in the instruction's
	  ;;conversion function.  It is bound to the accumulator list.
	  ;;
	  ;;The ?ARG formals are additional arguments to the instruction's conversion
	  ;;function.
	  ;;
	  ((add-single-instruction (?name ?instr ?ac ?arg ...)
				   ?body0 ?body ...)
	   (putprop '?name (assembler-property-key)
		    (cons (length '(?arg ...))
			  ;;This LAMBDA builds the instruction's conversion function.
			  (lambda (?instr ?ac ?arg ...)
			    (fluid-let-syntax
				((__who__ (identifier-syntax (quote ?name))))
			      ?body0 ?body ...))))))))
    (define-syntax add-instructions
      (syntax-rules ()
	((add-instructions ?instr ?accumulator
	   ((?name ?arg ...) ?body0 ?body ...)
	   ...)
	 (begin
	   (add-single-instruction (?name ?instr ?accumulator ?arg ...)
	     ?body0 ?body ...)
	   ...)))))

;;; --------------------------------------------------------------------
;;; end of module definitions

  ;;Store a function  in the properties list of symbols  being the names
  ;;of assembly instructions.
  ;;
  (add-instructions instr ac
    ((ret)
     (CODE #xC3 ac))
    ((cltd)
     (C #x99 ac))
    ((movl src dst)
     (cond ((and (imm? src)
		 (reg? dst))
	    (CR #xB8 dst (IMM src ac)))
	   ((and (imm?  src)
		 (disp? dst))
	    (CR* #xC7 '/0 dst (IMM32 src ac)))
	   ((and (reg? src)
		 (reg? dst))
	    (CR* #x89 src dst ac))
	   ((and (reg?  src)
		 (disp? dst))
	    (CR* #x89 src dst ac))
	   ((and (disp? src)
		 (reg?  dst))
	    (CR* #x8B dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((mov32 src dst)
     ;;FIXME (Abdulaziz Ghuloum)
     (cond ((and (imm? src)
		 (reg? dst))
	    (%compiler-internal-error
	      "here1")
	    (CR #xB8 dst (IMM32 src ac)))
	   ((and (imm?  src)
		 (disp? dst))
	    (CR*-no-rex #xC7 '/0 dst (IMM32 src ac)))
	   ((and (reg? src)
		 (reg? dst))
	    (%compiler-internal-error
	      "here3")
	    (CR* #x89 src dst ac))
	   ((and (reg?  src)
		 (disp? dst))
	    (CR*-no-rex #x89 src dst ac))
	   ((and (disp? src)
		 (reg?  dst))
	    (boot.case-word-size
	     ((32)
	      (CR* #x8B dst src ac))
	     ((64)
	      (CR*-no-rex #x8B dst src ac))))
	   (else
	    (%compiler-internal-error "invalid" instr))))
    ((movb src dst)
     (cond ((and (imm8? src)
		 (disp? dst))
	    (CR* #xC6 '/0 dst (IMM8 src ac)))
	   ((and (reg8? src)
		 (disp? dst))
	    (CR* #x88 src dst ac))
	   ((and (disp? src)
		 (reg8? dst))
	    (CR* #x8A dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((addl src dst)
     (cond ((and (imm8? src)
		 (reg?  dst))
	    (CR*  #x83 '/0 dst (IMM8 src ac)))
	   ((and (imm32? src)
		 (eq? dst '%eax))
	    (C #x05 (IMM32 src ac)))
	   ((and (imm32? src)
		 (reg?   dst))
	    (CR*  #x81 '/0 dst (IMM32 src ac)))
	   ((and (reg? src)
		 (reg? dst))
	    (CR*  #x01 src dst ac))
	   ((and (disp? src)
		 (reg?  dst))
	    (CR*  #x03 dst src ac))
	   ((and (imm32? src)
		 (disp?  dst))
	    (CR*  #x81 '/0 dst (IMM32 src ac)))
	   ((and (reg?  src)
		 (disp? dst))
	    (CR*  #x01 src dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((subl src dst)
     (cond ((and (imm8? src)
		 (reg?  dst))
	    (CR*  #x83 '/5 dst (IMM8 src ac)))
	   ((and (imm32? src)
		 (eq? dst '%eax))
	    (C #x2D (IMM32 src ac)))
	   ((and (imm32? src)
		 (reg?   dst))
	    (CR*  #x81 '/5 dst (IMM32 src ac)))
	   ((and (reg? src)
		 (reg? dst))
	    (CR*  #x29 src dst ac))
	   ((and (disp? src)
		 (reg?  dst))
	    (CR*  #x2B dst src ac))
	   ((and (imm32? src)
		 (disp?  dst))
	    (CR*  #x81 '/5 dst (IMM32 src ac)))
	   ((and (reg?  src)
		 (disp? dst))
	    (CR*  #x29 src dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((sall src dst)
     (cond ((and (eqv? 1 src)
		 (reg? dst))
	    (CR* #xD1 '/4 dst ac))
	   ((and (imm8? src)
		 (reg? dst))
	    (CR* #xC1 '/4 dst (IMM8 src ac)))
	   ((and (imm8? src)
		 (disp? dst))
	    (CR* #xC1 '/4 dst (IMM8 src ac)))
	   ((and (eq? src '%cl)
		 (reg? dst))
	    (CR* #xD3 '/4 dst ac))
	   ((and (eq? src '%cl)
		 (disp? dst))
	    (CR* #xD3 '/4 dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((shrl src dst)
     (cond ((and (eqv? 1 src)
		 (reg? dst))
	    (CR* #xD1 '/5 dst ac))
	   ((and (imm8? src)
		 (reg? dst))
	    (CR* #xC1 '/5 dst (IMM8 src ac)))
	   ((and (eq? src '%cl)
		 (reg? dst))
	    (CR* #xD3 '/5 dst ac))
	   ((and (imm8? src)
		 (disp? dst))
	    (CR* #xC1 '/5 dst (IMM8 src ac)))
	   ((and (eq? src '%cl)
		 (disp? dst))
	    (CR* #xD3 '/5 dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((sarl src dst)
     (cond ((and (eqv? 1 src)
		 (reg? dst))
	    (CR* #xD1 '/7 dst ac))
	   ((and (imm8? src)
		 (reg?  dst))
	    (CR* #xC1 '/7 dst (IMM8 src ac)))
	   ((and (imm8? src)
		 (disp? dst))
	    (CR* #xC1 '/7 dst (IMM8 src ac)))
	   ((and (eq? src '%cl)
		 (reg? dst))
	    (CR* #xD3 '/7 dst ac))
	   ((and (eq? src '%cl)
		 (disp? dst))
	    (CR* #xD3 '/7 dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((andl src dst)
     (cond ((and (imm32? src)
		 (disp?  dst))
	    (CR*  #x81 '/4 dst (IMM32 src ac)))
	   ((and (imm8? src)
		 (reg?  dst))
	    (CR*  #x83 '/4 dst (IMM8 src ac)))
	   ((and (imm32? src)
		 (eq? dst '%eax))
	    (C #x25 (IMM32 src ac)))
	   ((and (imm32? src)
		 (reg?   dst))
	    (CR*  #x81 '/4 dst (IMM32 src ac)))
	   ((and (reg? src)
		 (reg? dst))
	    (CR*  #x21 src dst ac))
	   ((and (reg?  src)
		 (disp? dst))
	    (CR*  #x21 src dst ac))
	   ((and (disp? src)
		 (reg?  dst))
	    (CR*  #x23 dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((orl src dst)
     (cond ((and (imm32? src)
		 (disp?  dst))
	    (CR*  #x81 '/1 dst (IMM32 src ac)))
	   ((and (reg?  src)
		 (disp? dst))
	    (CR*  #x09 src dst ac))
	   ((and (imm8? src)
		 (reg?  dst))
	    (CR*  #x83 '/1 dst (IMM8 src ac)))
	   ((and (imm32? src)
		 (eq? dst '%eax))
	    (C #x0D (IMM32 src ac)))
	   ((and (imm32? src)
		 (reg?   dst))
	    (CR*  #x81 '/1 dst (IMM32 src ac)))
	   ((and (reg? src)
		 (reg? dst))
	    (CR*  #x09 src dst ac))
	   ((and (disp? src)
		 (reg?  dst))
	    (CR*  #x0B dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((xorl src dst)
     (cond ((and (imm8? src)
		 (reg?  dst))
	    (CR*  #x83 '/6 dst (IMM8 src ac)))
	   ((and (imm8? src)
		 (disp? dst))
	    (CR*  #x83 '/6 dst (IMM8 src ac)))
	   ((and (imm32? src)
		 (eq? dst '%eax))
	    (C #x35 (IMM32 src ac)))
	   ((and (reg? src)
		 (reg? dst))
	    (CR*  #x31 src dst ac))
	   ((and (disp? src)
		 (reg?  dst))
	    (CR*  #x33 dst src ac))
	   ((and (reg?  src)
		 (disp? dst))
	    (CR*  #x31 src dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((leal src dst)
     (cond ((and (disp? src)
		 (reg?  dst))
	    (CR* #x8D dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((cmpl src dst)
     (cond ((and (imm8? src)
		 (reg?  dst))
	    (CR*  #x83 '/7 dst (IMM8 src ac)))
	   ((and (imm32? src)
		 (eq? dst '%eax))
	    (C #x3D (IMM32 src ac)))
	   ((and (imm32? src)
		 (reg?   dst))
	    (CR*  #x81 '/7 dst (IMM32 src ac)))
	   ((and (reg? src)
		 (reg? dst))
	    (CR*  #x39 src dst ac))
	   ((and (disp? src)
		 (reg?  dst))
	    (CR*  #x3B dst src ac))
	   ((and (imm8? src)
		 (disp? dst))
	    (CR*  #x83 '/7 dst (IMM8 src ac)))
	   ((and (imm32? src)
		 (disp?  dst))
	    (CR*  #x81 '/7 dst (IMM32 src ac)))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((imull src dst)
     (cond ((and (imm8? src)
		 (reg?  dst))
	    (CR*  #x6B dst dst (IMM8 src ac)))
	   ((and (imm32? src)
		 (reg?   dst))
	    (CR*  #x69 dst dst (IMM32 src ac)))
	   ((and (reg? src)
		 (reg? dst))
	    (CCR* #x0F #xAF dst src ac))
	   ((and (disp? src)
		 (reg?  dst))
	    (CCR* #x0F #xAF dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((idivl dst)
     (cond ((reg? dst)
	    (CR* #xF7 '/7 dst ac))
	   ((disp? dst)
	    (CR* #xF7 '/7 dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((pushl dst)
     (cond ((imm8? dst)
	    (CODE #x6A (IMM8 dst ac)))
	   ((imm32? dst)
	    (CODE #x68 (IMM32 dst ac)))
	   ((reg? dst)
	    (CR   #x50 dst ac))
	   ((disp? dst)
	    (CR*  #xFF '/6 dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((popl dst)
     (cond ((reg? dst)
	    (CR  #x58 dst ac))
	   ((disp? dst)
	    (CR* #x8F '/0 dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((notl dst)
     (cond((reg? dst)
	   (CR* #xF7 '/2 dst ac))
	  ((disp? dst)
	   (CR* #xF7 '/7 dst ac))
	  (else
	   (%compiler-internal-error
	     "invalid" instr))))
    ((bswap dst)
     (cond ((reg? dst)
	    (CCR #x0F #xC8 dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((negl dst)
     (cond ((reg? dst)
	    (CR* #xF7 '/3 dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((jmp dst)
     (cond ((and (label? dst)
		 (local-label? (label-name dst)))
	    (CODE #xE9 (cons `(local-relative . ,(label-name dst))
			     ac)))
	   ((imm? dst)
	    (boot.case-word-size
	     ((32)
	      (CODE #xE9 (IMM32 dst ac)))
	     ((64)
	      (jmp-pc-relative #xFF #x25 dst ac))))
	   ((disp? dst)
	    (CR*  #xFF '/4 dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid jmp target" dst))))
    ((call dst)
     (cond ((and (label? dst)
		 (local-label? (label-name dst)))
	    (CODE #xE8 (cons `(local-relative . ,(label-name dst))
			     ac)))
	   ((imm? dst)
	    (boot.case-word-size
	     ((32)
	      (CODE #xE8 (IMM32 dst ac)))
	     ((64)
	      (jmp-pc-relative #xFF #x15 dst ac))))
	   ((disp? dst)
	    (CR* #xFF '/2 dst ac))
	   ((reg? dst)
	    (CR* #xFF '/2 dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid jmp target" dst))))
    ((movsd src dst)
     (cond ((and (xmmreg? dst)
		 (disp?   src))
	    (CCCR* #xF2 #x0F #x10 dst src ac))
	   ((and (xmmreg? src)
		 (disp?   dst))
	    (CCCR* #xF2 #x0F #x11 src dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((cvtsi2sd src dst)
     (cond ((and (xmmreg? dst)
		 (reg? src))
	    (CCCR* #xF2 #x0F #x2A src dst ac))
	   ((and (xmmreg? dst)
		 (disp?   src))
	    (CCCR* #xF2 #x0F #x2A dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((cvtsd2ss src dst)
     (cond ((and (xmmreg? dst)
		 (xmmreg? src))
	    (CCCR* #xF2 #x0F #x5A src dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((cvtss2sd src dst)
     (cond ((and (xmmreg? dst)
		 (xmmreg? src))
	    (CCCR* #xF3 #x0F #x5A src dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((movss src dst)
     (cond ((and (xmmreg? dst)
		 (disp?   src))
	    (CCCR* #xF3 #x0F #x10 dst src ac))
	   ((and (xmmreg? src)
		 (disp?   dst))
	    (CCCR* #xF3 #x0F #x11 src dst ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((addsd src dst)
     (cond ((and (xmmreg? dst)
		 (disp?   src))
	    (CCCR* #xF2 #x0F #x58 dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((subsd src dst)
     (cond ((and (xmmreg? dst)
		 (disp?   src))
	    (CCCR* #xF2 #x0F #x5C dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((mulsd src dst)
     (cond ((and (xmmreg? dst)
		 (disp?   src))
	    (CCCR* #xF2 #x0F #x59 dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((divsd src dst)
     (cond ((and (xmmreg? dst)
		 (disp?   src))
	    (CCCR* #xF2 #x0F #x5E dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((ucomisd src dst)
     (cond ((and (xmmreg? dst)
		 (disp?   src))
	    (CCCR* #x66 #x0F #x2E dst src ac))
	   (else
	    (%compiler-internal-error
	      "invalid" instr))))
    ((ja dst)     (CCI32 #x0F #x87 dst ac))
    ((jae dst)    (CCI32 #x0F #x83 dst ac))
    ((jb dst)     (CCI32 #x0F #x82 dst ac))
    ((jbe dst)    (CCI32 #x0F #x86 dst ac))
    ((jg dst)     (CCI32 #x0F #x8F dst ac))
    ((jge dst)    (CCI32 #x0F #x8D dst ac))
    ((jl dst)     (CCI32 #x0F #x8C dst ac))
    ((jle dst)    (CCI32 #x0F #x8E dst ac))
    ((je dst)     (CCI32 #x0F #x84 dst ac))
    ((jna dst)    (CCI32 #x0F #x86 dst ac))
    ((jnae dst)   (CCI32 #x0F #x82 dst ac))
    ((jnb dst)    (CCI32 #x0F #x83 dst ac))
    ((jnbe dst)   (CCI32 #x0F #x87 dst ac))
    ((jng dst)    (CCI32 #x0F #x8E dst ac))
    ((jnge dst)   (CCI32 #x0F #x8C dst ac))
    ((jnl dst)    (CCI32 #x0F #x8D dst ac))
    ((jnle dst)   (CCI32 #x0F #x8F dst ac))
    ((jne dst)    (CCI32 #x0F #x85 dst ac))
    ((jo dst)     (CCI32 #x0F #x80 dst ac))
    ((jp dst)     (CCI32 #x0F #x8A dst ac))
    ((jnp dst)    (CCI32 #x0F #x8B dst ac))
    ((byte x)
     (if (byte? x)
	 (cons (byte x) ac)
       (%compiler-internal-error
	 "not a byte" x)))
    ((byte-vector x)
     (append (map (lambda (x)
		    (byte x))
	       (vector->list x))
	     ac))
    ((int a)
     (IMM a ac))
    ((label L)
     (if (symbol? L)
	 (cons (cons 'label L) ac)
       (%compiler-internal-error
	 "label is not a symbol" L)))
    ((label-address L)
     (if (symbol? L)
	 (cons (cons 'label-addr L) ac)
       (%compiler-internal-error
	 "label-address is not a symbol" L)))
    ((code-object-self-machine-word-index)
     (cons '(code-object-self-machine-word-index) ac))
    ((nop)
     ac))

  #| end of module |# )


(module (make-reloc-vector-record-filler)
  (module (off-code-data)
    (include "ikarus.compiler.scheme-objects-layout.scm" #t))

  (define-syntax __who__
    (identifier-syntax 'make-reloc-vector-record-filler))

  (define (make-reloc-vector-record-filler thunk?-label code vec)
    ;;Return  a closure  to be  used  to add  records  to the  relocation vector  VEC
    ;;associated to the code object CODE.
    ;;
    (define reloc-idx 0)
    (lambda (r)
      (define val
	(let ((v (cddr r)))
	  (cond ((thunk?-label v)
		 => (lambda (label)
		      (let ((p (%label-loc label)))
			(cond ((fx= (length p) 2)
			       (let ((code (car  p))
				     (idx  (cadr p)))
				 (unless (fxzero? idx)
				   (%error "cannot create a thunk pointing" idx))
				 (let ((thunk (code->thunk code)))
				   (set-cdr! (cdr p) (list thunk))
				   thunk)))
			      (else
			       (caddr p))))))
		(else v))))
      (define-syntax key
	(identifier-syntax (cadr r)))
      (case key
	((reloc-word)
	 ;;Add a record of type "vanilla object".
	 (let ((off (car r))) ;Offset into the data area of the code object.
	   (%store-first-word! vec reloc-idx IK_RELOC_RECORD_VANILLA_OBJECT_TAG off)
	   (vector-set! vec (fxadd1 reloc-idx) val)
	   (fxincr! reloc-idx 2)))

	((foreign-label)
	 ;;Add a record of type "foreign address".
	 (let ((off  (car r)) ;Offset into the data area of the code object.
	       (name (string->utf8 val)))
	   (%store-first-word! vec reloc-idx IK_RELOC_RECORD_FOREIGN_ADDRESS_TAG off)
	   (vector-set! vec (fxadd1 reloc-idx) name)
	   (fxincr! reloc-idx 2)))

	((reloc-word+)
	 ;;Add a record of type "displaced object".
	 (let ((off  (car r)) ;Offset into the data area of the code object.
	       (obj  (car val))
	       (disp (cdr val)))
	   (%store-first-word! vec reloc-idx IK_RELOC_RECORD_DISPLACED_OBJECT_TAG off)
	   (vector-set! vec (fxadd1 reloc-idx) disp)
	   (vector-set! vec (fxadd2 reloc-idx) obj)
	   (fxincr! reloc-idx 3)))

	((label-addr)
	 ;;Add a record of type "displaced object".
	 (let* ((off  (car r))	;Offset into the data area of the code object.
		(loc  (%label-loc val))
		(obj  (car  loc))
		(disp (cadr loc)))
	   (%store-first-word! vec reloc-idx IK_RELOC_RECORD_DISPLACED_OBJECT_TAG off)
	   (vector-set! vec (fxadd1 reloc-idx) (fx+ disp off-code-data))
	   (vector-set! vec (fxadd2 reloc-idx) obj))
	 (fxincr! reloc-idx 3))

	((local-relative)
	 ;;This entry requires the address of a label in the binary code
	 ;;of this very  code object.  There is no need  to add a record
	 ;;to the relocation vector, we  just store in the code object's
	 ;;data area  the relative offset  of the label with  respect to
	 ;;the current position in data area itself.
	 ;;
	 ;;  meta data     L  data area
	 ;; |---------|----+-------------|---|---|--------| code object
	 ;;                ^               ^ |
	 ;;                |               | |
	 ;;                |         ------  |
	 ;;                |        |        |
	 ;;                |.................| relative offset of L
	 ;;
	 ;;           |....| disp        |...| 4
	 ;;           |..................| off
	 ;;
	 ;;Notice that local  labels are specified with  a 32-bit offset
	 ;;on all the platforms.
	 ;;
	 (let* ((off  (car r))	;Offset into the data area of the code object.
		(loc  (%label-loc val))
		(obj  (car  loc))
		(disp (cadr loc)))
	   (unless (eq? obj code)
	     (%error "source code object and target code object of \
                      a local relative jump are not the same"))
	   (let ((rel (fx- disp (fxadd4 off))))
	     ($code-set! code          off  (fxlogand         rel     #xFF))
	     ($code-set! code (fxadd1 off) (fxlogand (fxsra rel 8)  #xFF))
	     ($code-set! code (fxadd2 off) (fxlogand (fxsra rel 16) #xFF))
	     ($code-set! code (fxadd3 off) (fxlogand (fxsra rel 24) #xFF)))))

	((relative)
	 ;;Add a record of type "jump label".
	 (let* ((off  (car r))	;Offset into the data area of the code object.
		(loc  (%label-loc val))
		(obj  (car  loc))
		(disp (cadr loc)))
	   (unless (and (code? obj) (fixnum? disp))
	     (%error "invalid relative jump obj/disp" obj disp))
	   (%store-first-word! vec reloc-idx IK_RELOC_RECORD_JUMP_LABEL_TAG off)
	   (vector-set! vec (fxadd1 reloc-idx) (fx+ disp off-code-data))
	   (vector-set! vec (fxadd2 reloc-idx) obj))
	 (fxincr! reloc-idx 3))

	(else
	 (%error "invalid entry key while filling relocation vector" key)))))

  (define-syntax-rule (%error ?message . ?irritants)
    (%compiler-internal-error ?message . ?irritants))

  (define-syntax %store-first-word!
    ;;
    ;;Here   we   left-shift  the   offset   so   that   we  can   Inclusive-OR   the
    ;;IK_RELOC_RECORD_*_TAG, which is 2 bits wide.
    ;;
    (syntax-rules (IK_RELOC_RECORD_VANILLA_OBJECT_TAG)
      ((_ ?vec ?reloc-idx IK_RELOC_RECORD_VANILLA_OBJECT_TAG ?binary-code.offset)
       (vector-set! ?vec ?reloc-idx               (fxsll ?binary-code.offset 2)))
      ((_ ?vec ?reloc-idx ?tag ?binary-code.offset)
       (vector-set! ?vec ?reloc-idx (fxlogor ?tag (fxsll ?binary-code.offset 2))))
      ))

  (define (%label-loc x)
    (or (getprop x '*label-loc*)
	(%compiler-internal-error
	  "undefined label" x)))

  ;;Commented out because unused.  (Marco Maggi; Oct 9, 2012)
  ;;
  ;; (define-inline (unset-label-loc! x)
  ;;   (remprop x '*label-loc*))

  ;;The following constants  must be kept in sync with  the equivalent definitions in
  ;;the C language headers.
  (define-inline-constant IK_RELOC_RECORD_VANILLA_OBJECT_TAG	#b00)
  (define-inline-constant IK_RELOC_RECORD_FOREIGN_ADDRESS_TAG	#b01)
  (define-inline-constant IK_RELOC_RECORD_DISPLACED_OBJECT_TAG	#b10)
  (define-inline-constant IK_RELOC_RECORD_JUMP_LABEL_TAG	#b11)
  #;(define-inline-constant IK_RELOC_RECORD_MASK_TAG		#b11)

  #| end of module |# )


;;;; done

#| end of library |# )

;;; end of file
;; Local Variables:
;; eval: (put 'add-instructions 'scheme-indent-function 2)
;; eval: (put 'add-instruction 'scheme-indent-function 1)
;; eval: (put 'with-args 'scheme-indent-function 1)
;; eval: (put '%with-checked-args 'scheme-indent-function 1)
;; End:
