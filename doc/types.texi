@node types
@chapter Typed language


@value{PRJNAME}'s expander implements an extension to the language
defined by @rnrs{6} that allows the definition of typed syntactic
bindings.  Type annotations are optional: we are free to specify them or
leave the type of variables unspecified.

@menu
* types intro::                 Introduction to the typed language.
* types syntaxes::              Type-exploiting syntaxes.
* types built-in::              Built-in object types.
@end menu

@c page
@node types intro
@section Introduction to the typed language


@value{PRJNAME}'s typed language adds some expand--time syntactic
binding type--checking and extended @oop{} syntax to the language
specified by @rnrs{6}.

@menu
* types intro philosophy::      Typed language philosophy.
* types intro enabling::        Enabling typed language extensions.
* types intro annotations::     Adding type annotations.
* types intro type ids::        Type identifiers.
* types intro typed vars::      Typed lexical variables.
@end menu

@c page
@node types intro philosophy
@subsection Typed language philosophy


In this document we refer to the standard Scheme language defined by the
@rnrs{6} specifications as the @dfn{standard language}; we refer to the
typed Scheme language defined by @value{PRJNAME} as the @dfn{typed
language}.

To understand how @value{PRJNAME} represents the types of values, we
must remember that every Scheme expression might return multiple values;
so we can think of an expression evaluation as follows:

@lisp
(call-with-values
     (lambda () @meta{epxr})
  (lambda @meta{formals} @meta{body}))
@end lisp

@noindent
the return values of @meta{expr} are bound to the @meta{formals} and
used in the @meta{body}.  For example, in the code:

@lisp
(call-with-values
     (lambda () (values 1 2 3))
  (lambda (a b c) @meta{body}))
@end lisp

@noindent
while the expansion of @meta{body} takes place: a typed language would
annotate the syntactic bindings @code{a}, @code{b} and @code{c} with the
information that the values are fixnums.

The tuple of type annotations associated to the @meta{formals} is called
@dfn{type signature}; a type signature represents informations about
both the number of values and their type.  We need a type signature to
represent the types of values returned by an expression; more generally,
we need a type signature to represent the types of values returned by a
function application.  We need a type signature to represent the types
of the arguments accepted in a function application.

Given the @syntax{call-with-values} model of thinking to expressions
evaluations: the whole purpose of a typed language is to verify, at
expand--time, that the type signature of an expression matches the type
signature of the arguments of a function.

The standard language already mandates that the operands in a function
application must be validated at run--time; this means the type
signature of the operands is matched, at run--time, with the type
signature of the arguments.  The typed language extends this feature to
make it possible at expand--time.

Type annotations are not mandatory in the typed language, so some
operands are validated and others are not.

To understand the role of @value{PRJNAME}'s typed language extensions,
we have to consider that:

@itemize
@item
Standard Scheme is dynamically typed: language implementations might
perform application signatures validation at run--time every time a
function is called, considering that the return values of a function
application are discarded or become the arguments of another function
application.  For example the function @func{flsin} can be implemented
as:

@example
#!r6rs
(import (except (rnrs (6))
                flsin)
  (vicare system $flonums))

(define (flsin x)
  (assert (flonum? x))
  ($flsin x))
@end example

@item
It is possible to build a standard Scheme language implementation that
performs compile--time type inference; with such implementation:
occasionally the compiler can determine the type of operands and return
values and collapse multiple validations into a single one.  For
example:

@example
#!r6rs
(import (rnrs (6)))

(define (flsomething x)
  (values (flsin x) (flcos x) (fltan x)))
@end example

@noindent
can be transformed into (pseudo--code):

@example
#!r6rs
(import (rnrs (6))
  (vicare system $flonums))

(define (flsomething x)
  (assert (flonum? x))
  (values ($flsin x) ($flcos x) ($fltan x)))
@end example

@noindent
or automatically defined safe and unsafe variants of the same function:

@example
#!r6rs
(import (rnrs (6))
  (vicare system $flonums))

(define (flsomething x)
  (assert (flonum? x))
  ($flsomething x))

(define ($flsomething x)
  (values ($flsin x) ($flcos x) ($fltan x)))
@end example

@noindent
so that the unsafe @func{$flsomething} can be used later in place of the
safe @func{flsomething} if we know that the argument is a flonum.

@item
The evaluation of a Scheme language program or library is defined to
have two steps: expansion; compilation--and--evaluation or
interpretation.  Standard Scheme is a ``high--level language'' which is
transformed into a ``core language'' by the process of expansion; the
expander allows macros to implement customised high--level
transformations.  The core language expressions are handed to the
compiler or the interpreter.

@item
Type inference does not blend well with standard Scheme macro expansion;
it is, in general, impossible to infer the types of a macro use before
fully expanding it, or, in special cases, at least partially expanding
it.  True type inference can be performed on the core language that is
the result of fully expanding the standard language.  This means we
cannot integrate the powerful features of the expander in the code
resulting from transformations made possible by type inference.

@item
@value{PRJNAME} is a language dialect whose purpose is to be a standard
Scheme language with extensions; it allows mixed use of standard
language syntax and extended language syntax.  The language extensions
are mostly implemented in the expander, to allow user code to customise
the generation of core language.

@item
By explicitly specifying the types of lexical bindings:
@value{PRJNAME}'s dialect allows some of the expand--time validations
and transformations that would be possible in a language with full type
inference.
@end itemize

Since there is no type inference: the code writer is invited to
explicitly add type annotations to the syntaxes that establish syntactic
bindings.

@c page
@node types intro enabling
@subsection Enabling typed language extensions


Typed language extensions are @strong{off} by default.  To enable the
extensions we have to use the @code{typed-language} option as follows:

@itemize
@item
For libraries:

@lisp
(library (demo)
  (options typed-language)
  (export)
  (import (vicare))
  ---)
@end lisp

@noindent
@ref{iklib libraries options, typed-language}.

@item
For programs:

@lisp
(program (demo)
  (options typed-language)
  (import (vicare))
  ---)
@end lisp

@noindent
@ref{iklib programs options, typed-language}.
@end itemize

@noindent
we usually want to import the library @library{vicare} to use the
extended syntaxes that recognise type definitions and declarations.


@defun enable-typed-language
@defunx disable-typed-language
Enable or disable typed language support.  These functions are meant to
be used at the @repl{}; they do @strong{not} modify support for typed
language for programs and libraries.
@end defun

@c page
@node types intro annotations
@subsection Adding type annotations


Type annotations are special syntaxes that make use of the @func{brace}
syntax (@pxref{iklib syntaxes misc, brace}) as follows:

@lisp
(define (brace O <fixnum>)
  123)
@end lisp

@noindent
to use the extensions in a friendly manner we need to put the reader in
@samp{#!vicare} mode, this way @func{brace} can be inserted using actual
brace characters:

@lisp
#!vicare
(define @{O <fixnum>@}
  123)
@end lisp

@menu
* types intro annotations inserting:: Inserting type annotations.
* types intro annotations putting::   What to put in a type annotation.
@end menu

@c page
@node types intro annotations inserting
@subsubsection Inserting type annotations


Everywhere the name of a syntactic binding appears in binding position:
we can add a type annotation by wrapping the syntactic identifier in
braces and appending a type syntax.  With @syntax{let}--like syntaxes we
can do:

@lisp
(let ((@{a <fixnum>@} 1)
      (@{b <string>@} "ciao")
      (@{c <symbol>@} 'hello))
  (list a b c))
@end lisp

@noindent
with @syntax{lambda} and @syntax{case-lambda} syntaxes we can do:

@lisp
(lambda (@{a <fixnum>@} @{b <string>@})
  (list a b))

(case-lambda
  ((@{a <fixnum>@} @{b <string>@})
   (list a b))
  ((@{a <fixnum>@} @{b <string>@} @{c <symbol>@})
   (list a b c)))
@end lisp

@noindent
with @syntax{define} and @syntax{case-define} syntaxes we can do:

@lisp
(define (fun1 @{a <fixnum>@} @{b <string>@})
  (list a b))

(case-define fun2
  ((@{a <fixnum>@} @{b <string>@})
   (list a b))
  ((@{a <fixnum>@} @{b <string>@} @{c <symbol>@})
   (list a b c)))
@end lisp

When using the syntaxes @syntax{lambda}, @syntax{case-lambda},
@syntax{define}, @syntax{case-define}, @syntax{receive},
@syntax{let-values} and @syntax{let*-values} we can specify a ``rest''
argument that is bound to a list of the rest of the operands; this
syntactic binding can be annotated only with the type identifier
@class{list} or the type annotation @samp{(list-of @meta{type})}.  For
example:

@lisp
((lambda (@{a <fixnum>@} @{b <string>@} . @{rest (list-of <symbol>)@})
   (vector a b rest))
 1 "ciao" 'x 'y 'z)
@result{} #(1 "ciao" (x y z))

((lambda @{args <list>@} args)
 1 2 3)
@result{} (1 2 3)

(receive (@{a <fixnum>@} @{b <string>@} . @{rest <list>@})
    (values 1 "ciao" 'x 'y 'z)
  rest)
@result{} (x y z)
@end lisp

@c page
@node types intro annotations putting
@subsubsection What to put in a type annotation


Type annotations are either standalone type identifiers like
@class{fixnum}, @class{string}, @condition{message} or compound type
syntaxes like the following:

@lisp
(pair      <fixnum> <string>)
(list      <fixnum> <string> <symbol>)
(vector    <fixnum> <string> <symbol>)
(pair-of   <fixnum>)
(list-of   <fixnum>)
(vector-of <fixnum>)
(hashtable <symbol> <string>)
(alist     <symbol> <string>)
(condition &who &message &irritants)
(or    <false> <symbol> <string>)
(and   <exact> <positive>)
(not   <exact>)
(lambda (<fixnum>) => (<string>))
(case-lambda
  ((<fixnum>) => (<string>))
  ((<flonum>) => (<string>)))
@end lisp

@noindent
compound type annotations can be nested at will:

@lisp
(or (list-of   <fixnum>)
    (vector-of <fixnum>))
@end lisp

The following syntactic bindings are exported by @library{vicare}.


@deftp {Compound Type Annotation} pair @meta{car-type} @meta{car-type}
Describe a pair having car of type @meta{car-type} and cdr of type
@meta{car-type}.  Both @meta{car-type} and @meta{car-type} are nested
type annotations.

@lisp
(is-a? '(1 . 2.3) (pair <fixnum> <flonum>))
@result{} #t
@end lisp
@end deftp


@deftp {Compound Type Annotation} list @metao{item-type} @meta{item-type} @dots{}
Describe a proper list holding a fixed number of items of the specified
types (in the given order).  Every @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '(1 2.3) (list <fixnum> <flonum>))
@result{} #t
@end lisp
@end deftp


@deftp {Compound Type Annotation} vector @metao{item-type} @meta{item-type} @dots{}
Describe a vector holding a fixed number of items of the specified types
(in the given order).  Every @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '#(1 2.3) (vector <fixnum> <flonum>))
@result{} #t
@end lisp
@end deftp


@deftp {Compound Type Annotation} pair-of @meta{item-type}
Describe a pair having both the car and cdr of type @meta{item-type}.
The syntax @meta{item-type} is a nested type annotation.

@lisp
(is-a? '(1 . 2) (pair-of <fixnum>))
@result{} #t
@end lisp
@end deftp


@deftp {Compound Type Annotation} list-of @meta{item-type}
Describe a proper list holding any number of items (including zero) all
of the specified type.  The syntax @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '(1 2) (list-of <fixnum>))       @result{} #t
(is-a? '()    (list-of <fixnum>))       @result{} #t
@end lisp
@end deftp


@deftp {Compound Type Annotation} vector-of @meta{item-type}
Describe a vector holding any number of items (including zero) all of
the specified type.  The syntax @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '#(1 2) (vector-of <fixnum>))    @result{} #t
(is-a? '#()    (vector-of <fixnum>))    @result{} #t
@end lisp
@end deftp


@deftp {Compound Type Annotation} hashtable @meta{key-type} @meta{value-type}
Describe a hashtable having keys of type @meta{key-type} and values of
type @meta{value-type}.  Both @meta{key-type} and @meta{value-type} are
nested type annotations.
@end deftp


@deftp {Compound Type Annotation} alist @meta{key-type} @meta{value-type}
Describe an association list having keys of type @meta{key-type} and
values of type @meta{value-type}.  Both @meta{key-type} and
@meta{value-type} are nested type annotations.
@end deftp


@deftp {Compound Type Annotation} condition @metao{item-type} @meta{item-type} @dots{}
Describe a compound condition object holding at least one instance of
the specified types (the order does not matter).  Every @meta{item-type}
is a nested type annotation that must be one among: @class{condition},
@class{compound-condition}, a sub--type of @condition{condition}.

@lisp
(is-a? (condition (make-who-condition 'I)
                  (make-message-condition "hello"))
       (condition &who &message))
@result{} #t

(is-a? (condition (make-who-condition 'I)
                  (make-message-condition "hello"))
       (condition &message &who))
@result{} #t
@end lisp
@end deftp


@deftp {Compound Type Annotation} lambda @meta{args-signature} => @meta{rv-signature}
Describe a sub--type of @class{procedure} having a single clause, like
procedures defined by @syntax{lambda}.  @syntax{=>} is the syntactic
binding exported by @rsixlibrary{base}.

The argument @meta{args-signature} must be a syntax object representing
the type signature of the procedure's arguments.  The argument
@meta{rv-signature} must be a syntax object representing the type
signature of the procedure's return values.
@end deftp


@deftp {Compound Type Annotation} case-lambda @metao{clause} @meta{clause} @dots{}
Describe a sub--type of @class{procedure} having multiple clauses, like
procedures defined by @syntax{case-lambda}.  @syntax{=>} is the
syntactic binding exported by @rsixlibrary{base}.

Each @meta{clause} argument must have the format:

@example
(@meta{args-signature} => @meta{rv-signature})
@end example

@noindent
where: @meta{args-signature} must be a syntax object representing the
type signature of the clause's arguments; @meta{rv-signature} must be a
syntax object representing the type signature of the clause's return
values.
@end deftp


@deftp {Compound Type Annotation} or @metao{item-type} @meta{item-type} @dots{}
Describe the union between the specified types.  Every @meta{item-type}
is a nested type annotation.  A value matches a union of types if its
type matches at least one of the union's types.

@lisp
(is-a? 1      (or <fixnum> <string>))   @result{} #t
(is-a? "ciao" (or <fixnum> <string>))   @result{} #t
(is-a? 1.23   (or <fixnum> <string>))   @result{} #f
@end lisp
@end deftp


@deftp {Compound Type Annotation} and @metao{item-type} @meta{item-type} @dots{}
Describe the intersection between the specified types.  Every
@meta{item-type} is a nested type annotation.  A value matches an
intersection of types if its type matches all the intersection's types.

@lisp
(is-a? 1   (and <fixnum> <positive>))   @result{} #t
(is-a? 1.0 (and <exact>  <positive>))   @result{} #f
@end lisp
@end deftp


@deftp {Compound Type Annotation} not @metao{item-type}
Describe the complement of the type.  The argument @meta{item-type} is a
nested type annotation.  A value matches the complement of a type if its
type does @strong{not} match the complement's type.

@lisp
(is-a? 1   (not <string>))      @result{} #t
(is-a? 1.0 (not <fixnum>))      @result{} #f

;;If something is not a "<number>", for sure it is
;;not a "<fixnum>".
(type-annotation-super-and-sub? (not <fixnum>) (not <number>))
@result{} #t
@end lisp
@end deftp

@c page
@node types intro type ids
@subsection Type identifiers


A @dfn{type identifier} is a bound syntactic identifier whose syntactic
binding's descriptor contains informations about the type's properties.
Examples of type identifiers are:

@itemize
@item
Struct--type name identifiers defined by @func{define-struct}; they are
automatically made type identifiers by @value{PRJNAME}.

@item
Record--type name identifiers defined by @func{define-record-type}; they
are automatically made type identifiers by @value{PRJNAME}.  Condition
object types (like @condition{i/o}) are special cases of these.

@item
The library @library{vicare} exports a set type identifiers (whose
implementation is integrated in @value{PRJNAME}'s expander) representing
the types of built--in objects.  Some of them are: @class{fixnum},
@class{string}, @class{vector}, @class{textual-input-port}.
@end itemize

Type identifiers are organised in a tree hierarchy, with subtypes
inheriting properties of supertypes; by convention, @class{top} is the
parent of all the type annotations, the root of the tree; @class{top}
has no parent.

Many predefined type identifiers have names enclosed in ``angular
parentheses'' @samp{< >}, but this is just a convention.  Any valid
Scheme symbol can be used as name for a type identifier.

@c page
@node types intro typed vars
@subsection Typed lexical variables


A @dfn{typed lexical variable}, shortly @dfn{typed variable}, is a bound
syntactic identifier whose syntactic binding's descriptor contains both
informations about a lexical variable and its type annotation.  Typed
variables are created by the built--in binding syntaxes @func{lambda},
@func{define}, @func{let}, @func{letrec}, @func{let-values}, et cetera.

An example of typed binding creation follows:

@example
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare)
  (define @{O <fixnum>@}
    123))
@end example

@noindent
the syntactic identifier @code{O} represents a typed variable with type
annotation @class{fixnum}.

At the time the typed variable's syntactic binding is established: the
type annotation must hold only already bound type identifiers.  So the
following program (where @samp{---} represents an unspecified form) is
correct because @objtype{duo} is bound before @var{O}:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))
  (define-record-type duo
    (fields one two))
  (define @{O duo@}
    ---))
@end lisp

@noindent
the follow program is @strong{not} correct:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))
  (define @{O duo@}
    ---)
  (define-record-type duo
    (fields one two)))
@end lisp

@noindent
and will cause an expand--time syntax violation.

@c page
@node types syntaxes
@section Type--exploiting syntaxes


@value{PRJNAME} allows us to perform some operations on objects through
generic syntaxes, provided that we use the type annotation.

Unless otherwise specified, the syntactic bindings documented in this
section are exported by the library @library{vicare}.  When showing code
examples, we always assume: to have imported the library
@library{vicare}; to have enabled the typed language; to have put the
Scheme source code reader in @code{#!vicare} mode.

@menu
* types syntaxes type-of::      Determining the type of expressions.
* types syntaxes descriptors::  Retrieving type descriptors.
* types syntaxes new-and-del::  Constructors and destructors.
* types syntaxes predicates::   Predicate syntaxes.
* types syntaxes slots::        Slot getter and setter syntaxes.
* types syntaxes methods::      Calling object-type methods.
* types syntaxes equality::     Equality between type annotations.
* types syntaxes super-sub::    Super and sub types.
* types syntaxes ancestor::     Common ancestor of types and signatures.
* types syntaxes assert::       Validating signatures.
* types syntaxes unsafe-cast::  Casting the type of expressions.
* types syntaxes case-type::    Branching on type of expression.
@end menu

@c page
@node types syntaxes type-of
@subsection Determining the type of expressions


@deffn Syntax type-of @meta{expr}
Fully expand the given expression in the current lexical environment and
return a structure of type @class{type-signature} representing the types
of the tuple of returned values.  The expression is @strong{not}
evaluated, only expanded; this means that the expansion side effects are
performed.

Examples:

@example
(type-of (values))
@result{} #[signature ()]

(type-of (values 1 2))
@result{} #[signature (<positive-fixnum> <positive-fixnum>)]

(type-of 123)
@result{} #[signature (<positive-fixnum>)]

(type-of ((lambda (@{_ symbol@}) 'ciao)))
@result{} #[signature (<symbol>)]

(type-of (+ 1 2))
@result{} #[signature (<exact-integer>)]

(type-of (+ 1.2 2.3))
@result{} #[signature (<flonum>)]

(type-of (list 1 2.3))
@result{} #[signature ((list <positive-fixnum> <positive-flonum>))]

(type-of (condition (make-who-condition 'io)
                    (make-message-condition "ciao")))
@result{} #[signature ((condition &who &message))]
@end example
@end deffn

@c page
@node types syntaxes descriptors
@subsection Retrieving type descriptors


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-descriptor @meta{type}
Expand to an expression which, when evaluated, results in:

@itemize
@item
A struct--type descriptor if the given identifier argument @meta{type}
is a struct--type name.

@item
A record--type descriptor if the given identifier argument @meta{type}
is a record--type name.

@item
A Scheme built--in object--type descriptor if the given identifier
argument @meta{type} is a built--in object--type name.  This descriptor
is a record of type @class{scheme-type-descriptor}.
@end itemize
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Scheme built--in object--type descriptors


@deftp {Recort-Type} @aclass{scheme-type-descriptor}
Type name identifier for records describing Scheme built--in
object--types.  It has the following immutable fields:

@table @code
@item name
A symbol representing the name of this type.  For example:
@samp{<string>}.

@item parent
If this type has a parent: an instance of @class{scheme-type-descriptor}
representing the parent of this type; otherwise @false{}.

@item uids-list
A list of symbols representing the hierarchy of unique identifiers
(@uid{}s) for this type.  The first item in the list is the @uid{} of
this type, then the parent's @uid{}, then the grandparent's @uid{}, et
cetera.

@item method-retriever
If this type has methods: a procedure to be applied to the method name
(a symbol) to retrieve the method implementation function; otherwise
@false{}.
@end table
@end deftp


@defun scheme-type-descriptor? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{scheme-type-descriptor}; otherwise return @false{}.
@end defun


@defun scheme-type-descriptor.name @var{btd}
@defunx scheme-type-descriptor.parent @var{btd}
@defunx scheme-type-descriptor.uids-list @var{btd}
@defunx scheme-type-descriptor.method-retriever @var{btd}
Accessors for the fields of @class{scheme-type-descriptor}.
@end defun


Some usage examples:

@lisp
(define @{string-btd <scheme-type-descriptor>@}
  (type-descriptor <string>))

(.name string-btd)
@result{} <string>

(.name (.parent string-btd))
@result{} <top>

(.uids-list string-btd)
@result{} (vicare:scheme-type:<string> vicare:scheme-type:<top>)

(((.method-retriever string-btd) 'length) "ciao")
@result{} 4
@end lisp

@c page
@node types syntaxes new-and-del
@subsection Constructors and destructors


The syntaxes @syntax{new} and @syntax{delete} allow us to retrieve the
constructor and destructor function of Scheme objects of some types.
For example, with records:

@lisp
(define-record-type duo
  (fields one two)
  (destructor-protocol
    (lambda ()
      (lambda (self)
        (fprintf (current-error-port) "destroying ~s\n" self)))))

(define O
  (new duo 1 2))

(delete O)
@print{} destroying #[record duo one=1 two=2]
@end lisp

@noindent
such syntaxes make it easier to code, for example, compensated
allocation of objects:

@lisp
(define (make-compensated-duo one two)
  (compensate
      (new duo one two)
    (with
      (delete <>))))
@end lisp

@noindent
where @syntax{<>} is the fluid syntax exported by @library{vicare} and
@syntax{compensate} binds it to the value returned by the allocation
form (@pxref{iklib compensations api, compensate}).

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax new @meta{type} @meta{arg} @dots{}
Retrieve the default constructor function of the type @var{type-name}
and apply it to the given arguments; return the result of the
application.
@end deffn


@deffn Syntax delete @meta{expr}
Retrieve the destructor function, if any, of the object returned by the
evaluation of the expression @meta{expr} and apply it to the object;
return the return value of the application.  The evaluation of
@meta{expr} must return a single return value.
@end deffn

@c page
@node types syntaxes predicates
@subsection Predicate syntaxes


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax is-a? @meta{expr} @meta{type}
@deffnx Syntax is-a? _ @meta{type}
@deffnx {Auxiliary Syntax} _
Expand to an expression which, when evaluated, returns @true{} if
@meta{expr} evaluates to a value of type @meta{type}.  @meta{expr} can
be any expression returning a single value.

When @syntax{_} is used as first argument: the syntax evaluates to a
predicate function.

@example
(define-record-type duo
  (fields one two))

(is-a? (new duo 1 2) two)       @result{} #t

((is-a? _ duo) (new duo 1 2))   @result{} #t

(is-a? 123 duo)                 @result{} #f

(is-a? '(1 2 3) (list <fixnum> <exact-integer> <number>))
@result{} #t
@end example
@end deffn

@c page
@node types syntaxes slots
@subsection Slot getter and setter syntaxes


The syntaxes @func{slot-ref} and @func{slot-set!} allow access and
mutation of struct and record fields:

@example
(define-record-type color
  (fields (mutable red)
          (mutable green)
          (mutable blue)))

(define @{R color@}
  (new color 1 2 3))

(slot-set! R red   color 19)
(slot-set! R green color 29)
(slot-set! R blue  color 39)

(slot-ref R red   color)        @result{} 19
(slot-ref R green color)        @result{} 29
(slot-ref R blue  color)        @result{} 39
@end example

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax slot-ref @meta{expr} @meta{field-name} @meta{type}
@deffnx Syntax slot-ref @meta{expr} @meta{field-name}
@deffnx Syntax slot-ref _ @meta{field-name} @meta{type}
@deffnx {Auxiliary Syntax} _
Expand to the slot accessor of @meta{field-name} applied to @meta{expr}.
@meta{expr} can be any expression evaluating to an instance of
@meta{type}.  @meta{type} must be the type identifier of a struct--type
or record--type.  @meta{field-name} must be an identifier representing
the name of a field.  When @syntax{_} is used in place of @meta{expr}:
the syntax evaluates to a slot accessor function.

When @meta{type} is absent: the type is inferred from @meta{expr}.  If
it is impossible to infer the type of @meta{expr}: an exception is
raised at expand--time.
@end deffn


@deffn Syntax slot-set! @meta{expr} @meta{field-name} @meta{type} @meta{new-val}
@deffnx Syntax slot-set! @meta{expr} @meta{field-name} @meta{new-val}
@deffnx Syntax slot-set! _ @meta{field-name} @meta{type} _
@deffnx {Auxiliary Syntax} _
Expand to the slot mutator of @meta{field-name} applied to @meta{expr}
and @meta{new-val}.  @meta{expr} can be any expression evaluating to an
instance of @meta{type}.  @meta{type} must be the type identifier of a
struct--type or record--type.  @meta{field-name} must be an identifier
representing the name of a field.  When @syntax{_} is used in place of
both @meta{expr} and @meta{new-val}: the syntax evaluates to a slot
mutator function.

When @meta{type} is absent: the type is inferred from @meta{expr}.  If
it is impossible to infer the type of @meta{expr}: an exception is
raised at expand--time.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Dot notation

As special case it is possible to mutate a record's mutable field using
the @syntax{set!} syntax and the dot notation.  Here is an example:

@lisp
(define-record-type alpha
  (fields (mutable a)
          (mutable b)))

(define @{O alpha@}
  (new alpha 1 2))

(set! (.a O) 10)
(set! (.b O) 20)

(.a O)  @result{} 10
(.b O)  @result{} 20
@end lisp

For details on the dot notation @ref{types syntaxes methods, Dot
notation}.

@c page
@node types syntaxes equality
@subsection Equality between type annotations


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-annotation=? @metai{type} @metaii{type}
Expand to a boolean constant: @true{} if @metai{type} is equal to
@metaii{type}; otherwise @false{}.

@lisp
(type-annotation=? <top>    <top>)              @result{} #t
(type-annotation=? <fixnum> <fixnum>)           @result{} #t
(type-annotation=? <fixnum> <positive-fixnum>)  @result{} #f

(internal-body
  (define-type <my-fixnum> <fixnum>)
  (type-annotation=? <fixnum> <my-fixnum>))     @result{} #t

(type-annotation=? (lambda (<fixnum>) => (<fixnum>))
                   (lambda (<fixnum>) => (<fixnum>)))
@result{} #t
@end lisp
@end deffn

@c page
@node types syntaxes methods
@subsection Calling object--type methods


The following keyword syntactic bindings are involved in the definition
and use of methods: @clause{method}, @clause{case-method},
@syntax{method-call}.  In addition the function
@func{method-call-late-binding} performs a method call with ``late
binding'' (run--time dispatching).

The keywords @clause{method} and @clause{case-method} are used in
@syntax{define-record-type} to define methods for a record type
(@pxref{iklib records defs methods, Record--type methods}).  For
example:

@lisp
(define-record-type duo
  (fields one two)
  (method (sum-them self)
    (+ (duo-one self)
       (duo-two self)))
  (method (mul-them self)
    (* (duo-one self)
       (duo-two self))))
@end lisp

@noindent
the syntax @syntax{method-call} is then used to call a record's methods:

@lisp
(define @{O duo@}
  (new duo 3 5))

(method-call sum-them O)        @result{} 8
(method-call mul-them O)        @result{} 15
@end lisp

When defining a record or struct: @value{PRJNAME} automatically adds a
method to the methods table, for each field, with the same name of the
field.  When the field is mutable: if the method is called with one
argument, it behaves as a field accessor; if the method is called with
two arguments, it behaves as a field mutator.  When the field is
immutable: the method can be called with one argument only.  Example:

@lisp
(define-record-type duo
  (fields (immutable one)
          (mutable   two)))

(define @{O duo@}
  (new duo 1 2))

(method-call one O)     @result{} 1
(method-call one O 123) @error{} &syntax
(method-call two O)     @result{} 2
(method-call two O 9)
(method-call two O)     @result{} 9
@end lisp

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax method-call @meta{name} @meta{subject-expr} @meta{arg} @dots{}
Apply an object--type's method to the return value of
@meta{subject-expr} and the optional arguments @meta{arg}.

@meta{name} must be a symbol representing a method or field name.
@meta{subject-expr} must be a Scheme expression which, expanded and
evaluated at run--time, returns a single value.  Each @meta{arg} must be
a Scheme expression which, expanded and evaluated at run--time, returns
a single value.

When possible, @syntax{method-call} determines at expand--time the type
of the expression @meta{subject-expr} and searches for a method with
equal name, according to @func{eq?}.  If the method is found, the
syntactic identifier to which the implementation procedure is bound is
inserted in the macro expansion:

@lisp
(@meta{procedure} @meta{subject-expr} @meta{arg} ...)
@end lisp

@noindent
If the object--type of @meta{subject-expr} has no matching method: its
super--type is inspected, then the super--type of the super--type and so
on.  If no method is found in the types hierarchy: an exception is
raised.

@syntax{method-call} is able to retrieve the type of its second argument
at expand--time only when the typed language is enabled.  If
@syntax{method-call} cannot determine the type of @meta{subject-expr} at
expand--time, the macro use is expanded to:

@lisp
(method-call-late-binding (quote @meta{name})
                          @meta{subject-expr} @meta{arg} ...)
@end lisp

@noindent
and the function @func{method-call-late-binding} attempts to determine a
suitable method at run--time.
@end deffn


@defun method-call-late-binding @var{name} @var{subject} @var{arg} @dots{}
Apply an object--type's method to @var{subject} and the optional
arguments @meta{arg}.  Return the application results.

@var{name} must be a symbol representing a method or field name.
@var{subject} must be a Scheme object implementing a set of methods.
The optional @meta{arg} arguments can be any value.

This function attempts to determine the type of @var{subject} at
run--time and searches the object--type's table of methods, if any, for
a method whose name equals @var{name} according to @func{eq?}.  If a
method is found, its implementation procedure is retrieved and applied
to @var{subject} and the @var{arg} values.

If the object--type of @var{subject} has no matching method: its
super--type is inspected, then the super--type of the super--type and so
on.  If no method is found in the type's hierarchy: an exception is
raised.

Usually we do not need to call this function explicitly; however, it is
useful for debugging purposes.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Dot notation

When the Scheme reader's textual input port is configured in
@samp{#!vicare} mode: if a list starts with a symbol; the name of the
symbol is a string of length at least @math{2}; the first character of
the string is a dot; the second character of the string is @strong{not}
a dot, then a @syntax{method-call} symbol is inserted and the symbol
stripped of the dot.

We can try it at the @repl{}:

@example
vicare> '(.ciao)
$1 = (method-call ciao)
@end example

Notice that @rnrs{6} forbids symbols starting with a dot, with the
exception of the ellipsis; so this transformation does not influence the
other reader operations.

We can use this notation to call an object--type's methods as in the
following program:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))

  (define-record-type duo
    (fields one two)

    (method (sum-them @{O duo@})
      (+ (.one O) (.two O)))

    (method (mul-them @{O duo@})
      (* (.one O) (.two O)))

    (method (display O port)
      (display O port)))

  (define @{O duo@}
    (new duo 3 4))

  (pretty-print (.sum-them O)
                (current-error-port))

  (pretty-print (.mul-them O)
                (current-error-port))

  (.display O (current-error-port))
  (newline (current-error-port))

  #| end of program |# )
@end lisp

@c page
@node types syntaxes super-sub
@subsection Super and sub types


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-annotation-super-and-sub? @metai{type} @metaii{type}
Expand to a boolean constant: @true{} if @metai{type} is a super--type
of @metaii{type}; otherwise @false{}.  The type @class{top} is
conventionally the super--type of all the types.

@lisp
(type-annotation-super-and-sub? <number> <fixnum>)  @result{} #t
(type-annotation-super-and-sub? <number> <string>)  @result{} #f
(type-annotation-super-and-sub? <top> <number>)     @result{} #t
(type-annotation-super-and-sub? <number> <top>)     @result{} #f

(expansion-of
  (type-annotation-super-and-sub? <number> <fixnum>))
@result{} (quote #t)

(expansion-of
  (type-annotation-super-and-sub? <number> <string>))
@result{} (quote #f)

(define-record-type alpha)

(define-record-type beta
  (parent alpha))

(define-record-type gamma
  (parent beta))

(type-annotation-super-and-sub? alpha beta)        @result{} #t
(type-annotation-super-and-sub? beta alpha)        @result{} #f

(type-annotation-super-and-sub? alpha gamma)       @result{} #t
(type-annotation-super-and-sub? gamma alpha)       @result{} #f

(type-annotation-super-and-sub? beta gamma)        @result{} #t
(type-annotation-super-and-sub? gamma beta)        @result{} #f
@end lisp
@end deffn


@deffn Syntax type-signature-super-and-sub? @metai{signature} @metaii{signature}
Expand to a boolean constant: @true{} if @metai{signature} is a
super--signature of @metaii{signature}; otherwise @false{}.  The
arguments @meta{signature} must be proper or improper lists of type
annotations, with @class{list} or @samp{(list-of @meta{type})} in tail
position when the list is improper.

@lisp
(type-signature-super-and-sub? (<number>) (<fixnum>))        @result{} #t
(type-signature-super-and-sub? (<number>) (<string>))        @result{} #f

(expansion-of
  (type-signature-super-and-sub? (<number>) (<fixnum>))
@result{} (quote #t)

(expansion-of
  (type-signature-super-and-sub? (<number>) (<string>))
@result{} (quote #f)

(type-signature-super-and-sub? (<top>) (<number>))   @result{} #t
(type-signature-super-and-sub? (<number>) (<top>))   @result{} #f

(type-signature-super-and-sub? (<number> <number>) (<fixnum> <fixnum>))
@result{} #t
(type-signature-super-and-sub? (<fixnum> <fixnum>) (<number> <number>))
@result{} #f

(type-signature-super-and-sub? (<number> <number> . <list>)
                               (<fixnum> <real>   . <list>))
@result{} #t
@end lisp
@end deffn

@c page
@node types syntaxes ancestor
@subsection Common ancestor of types and signatures


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-annotation-common-ancestor @metai{type} @metaii{type}
Expand to a syntax object representing the type annotation that is the
common ancestor of @metai{type} and @metaii{type}.

@lisp
(type-annotation-common-ancestor <top> <top>)
@result{} #'<top>

(type-annotation-common-ancestor <top> <fixnum>)
@result{} #'<top>

(type-annotation-common-ancestor <fixnum> <top>)
@result{} #'<top>

(type-annotation-common-ancestor <fixnum> <flonum>)
@result{} #'<real>
@end lisp
@end deffn


@deffn Syntax type-signature-common-ancestor @metai{signature} @metaii{signature}
Expand to a syntax object representing the type signature that is the
common ancestor of @metai{signature} and @metaii{signature}.

@lisp
(type-signature-common-ancestor (<fixnum> <fixnum>)
                                (<flonum> <bignum>))
@result{} #'(<real> <exact-integer>)

(type-signature-common-ancestor (<fixnum> <fixnum> <string>)
                                (<flonum> <bignum>)
@result{} #'(<real> <exact-integer> . <list>)

(type-signature-common-ancestor (<fixnum> <fixnum>)
                                (<flonum> <bignum> <string>)
@result{} #'(<real> <exact-integer> . <list>)
@end lisp
@end deffn

@c page
@node types syntaxes assert
@subsection Validating signatures


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax assert-signature @meta{signature} @meta{expr}
@deffnx Syntax assert-signature-and-return @meta{signature} @meta{expr}
@deffnx Syntax cast-signature @meta{signature} @meta{expr}
Validate the type signature of the values returned by @meta{expr},
either at expand--time or run--time.  @meta{expr} can be any Scheme
expression.  @meta{signature} must be a proper or improper list of type
annotations representing the type signature.

The syntax @syntax{assert-signature} returns a single unspecified value.
The syntax @syntax{assert-signature-and-return} returns the return
values of @meta{expr}.  The syntax @syntax{cast-signature} is an alias
of @syntax{assert-signature-and-return}.

If it is possible to validate the signature at expand--time: when
successful, the syntax use just expands to the evaluation of
@meta{expr}; when a type mismatch is detected, an expand--time exception
is raised.  Otherwise the syntax use expands to an expression that
validates the values at run--time.

As special cases, when @meta{signature} is @samp{()},
@samp{(<no-return>)} a proper or improper list of @class{top} and
@class{list} types like:

@lisp
<list>
(<top>)
(<top> <top> <top>)
(<top> <top> . <list>)
@end lisp

@noindent
no validation is performed at run--time, only at expand--time.
@end deffn


Here are some validation examples:

@lisp
(assert-signature () (values))
(assert-signature-and-return (<fixnum>) 123)    @result{} 123
(assert-signature-and-return (<string>) "ciao") @result{} "ciao"

(assert-signature-and-return (<fixnum> <flonum>) (values 1 2.0))
@result{} 1 2.0

(expansion-of
  (assert-signature (<fixnum>) 123))
@result{} (begin (quote 123) (quote #!void))

(expansion-of
  (assert-signature-and-return (<fixnum>) 123))
@result{} (quote 123)

(expansion-of
  (assert-signature-and-return (<fixnum>)
    (unsafe-cast-signature <fixnum> (read))))
@result{} ((primitive read))
@end lisp

There are some interesting special cases:

@itemize
@item
If we want to assert (at expand--time) that an expression returns zero
values, we can do:

@lisp
(assert-signature () @meta{expr})
@end lisp

@item
If we want to assert nothing, we can do:

@lisp
(assert-signature <list> @meta{expr})
@end lisp

@noindent
which will just expand to the evaluation of @meta{expr}; this might be
useful when the syntax is used in the output form of another macro use.

@item
If we want to assert (at expand--time) that an expression returns a
single value, of any type, we can do:

@lisp
(assert-signature (<top>) @meta{expr})
@end lisp

@item
If we want to assert (at expand--time) that an expression returns two
values, of any type, we can do:

@lisp
(assert-signature (<top> <top>) @meta{expr})
@end lisp

@item
If we want to assert (at expand--time) that an expression returns two or
more values, of any type, we can do:

@lisp
(assert-signature (<top> <top> . <list>) @meta{expr})
@end lisp
@end itemize

@c ------------------------------------------------------------------------

@subheading Expansion examples for run--time validation

Let's say we have a function @samp{fun} such that:

@lisp
(type-of (fun))
@result{} #[signature <list>]
@end lisp

@noindent
there is nothing the expander can do to infer the type signature of the
function application.

@c ------------------------------------------------------------------------

@subsubheading Example 1: multiple values and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (<fixnum> <flonum> <string>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(call-with-values
    (lambda () (fun))
  (lambda (arg1 arg2 arg3)
    (values ((lambda (obj value-index caller-who)
               (if (fixnum? obj)
                   obj
                 (expression-return-value-violation
                     caller-who
                   '"return value of invalid type"
                   value-index '(is-a? _ <fixnum>) obj)))
             arg1 '1 'assert-signature-and-return)
            ((lambda (obj value-index caller-who)
               (if (flonum? obj)
                   obj
                 (expression-return-value-violation
                     caller-who
                   '"return value of invalid type"
                   value-index '(is-a? _ <flonum>) obj)))
             arg2 '2 'assert-signature-and-return)
            ((lambda (obj value-index caller-who)
               (if (string? obj)
                   obj
                 (expression-return-value-violation
                     caller-who
                   '"return value of invalid type"
                   value-index '(is-a? _ <string>) obj)))
             arg3 '3 'assert-signature-and-return))))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 2: multiple values and no return values

The following syntax use:

@lisp
(assert-signature
    (<fixnum> <flonum> <string>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(call-with-values
    (lambda () (fun))
  (lambda (arg1 arg2 arg3)
    ((lambda (obj value-index caller-who)
       (if (not (fixnum? obj))
           (expression-return-value-violation
               caller-who '"return value of invalid type"
               value-index '(is-a? _ <fixnum>) obj)
         '#!void))
     arg1 '1 'assert-signature)
    ((lambda (obj value-index caller-who)
       (if (not (flonum? obj))
           (expression-return-value-violation
               caller-who '"return value of invalid type"
               value-index '(is-a? _ <flonum>) obj)
         '#!void))
     arg2 '2 'assert-signature)
    ((lambda (obj value-index caller-who)
       (if (not (string? obj))
           (expression-return-value-violation
               caller-who '"return value of invalid type"
               value-index '(is-a? _ <string>) obj)
         '#!void))
     arg3 '3 'assert-signature)
    (void)))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 3: list of values and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (list-of <fixnum>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
((lambda arg1
   (lambda (list-value first-value-index caller-who)
     (fold-left
         (lambda (item-index item-value)
           ((lambda (obj value-index caller-who)
              (if (not ((letrec
                            ((pred (lambda (obj)
                                     (if (pair? obj)
                                         (if (fixnum? (car obj))
                                             (pred (cdr obj))
                                           '#f)
                                       (null? obj)))))
                          pred)
                        obj))
                  (expression-return-value-violation caller-who
                    '"return value of invalid type"
                    value-index '(is-a? _ (list-of <fixnum>))
                    obj)
                '#!void))
            item-value item-index caller-who)
           (fxadd1 item-index))
       first-value-index list-value)
     list-value))
 (fun))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 5: multiple values and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (<fixnum> <flonum> . (list-of <fixnum>))
  (fun))
@end lisp

@noindent
is expanded to:

@smalllisp
(call-with-values
    (lambda () (fun))
  (lambda (arg1 arg2 . arg3)
    (apply values
           ((lambda (obj value-index caller-who)
              (if (fixnum? obj)
                  obj
                (expression-return-value-violation
                    caller-who
                  '"return value of invalid type"
                  value-index '(is-a? _ <fixnum>) obj)))
            arg1 '1 'assert-signature-and-return)
           ((lambda (obj value-index caller-who)
              (if (flonum? obj)
                  obj
                (expression-return-value-violation
                    caller-who
                  '"return value of invalid type"
                  value-index '(is-a? _ <flonum>) obj)))
            arg2 '2 'assert-signature-and-return)
           (lambda (list-value first-value-index caller-who)
             (fold-left
                 (lambda (item-index item-value)
                   ((lambda (obj value-index caller-who)
                      (if (not ((letrec
                                    ((pred (lambda (obj)
                                             (if (pair? obj)
                                                 (if (fixnum? (car obj))
                                                     (pred (cdr obj))
                                                   '#f)
                                               (null? obj)))))
                                  pred) obj))
                          (expression-return-value-violation
                              caller-who
                            '"return value of invalid type"
                            value-index
                            '(is-a? _ (list-of <fixnum>)) obj)
                        '#!void))
                    item-value item-index caller-who)
                   (fxadd1 item-index))
               first-value-index list-value)
             list-value)
           arg3 '3 'assert-signature-and-return)))
@end smalllisp

@c ------------------------------------------------------------------------

@subsubheading Example 5: single value and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (<fixnum>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
((lambda (arg1)
   ((lambda (obj value-index caller-who)
      (if (fixnum? obj)
          obj
        (expression-return-value-violation caller-who
          '"return value of invalid type"
          value-index '(is-a? _ <fixnum>) obj)))
    arg1 '1 'assert-signature-and-return))
 (fun))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 6: no validation and single return value

The following syntax use:

@lisp
(assert-signature-and-return
    (<top>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(fun)
@end lisp

@noindent
there is no need to insert a validation form because a single value of
any type matches the type signature.

@c ------------------------------------------------------------------------

@subsubheading Example 7: no validation and return values

The following syntax use:

@lisp
(assert-signature-and-return
    <list>
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(fun)
@end lisp

@noindent
there is no need to insert a validation form because any number of
return values of any type matches the type signature.

@c page
@node types syntaxes unsafe-cast
@subsection Casting the type of expressions


It is sometimes useful to explicitly declare the type signature of an
expression, so that the expander can perform more type checks and,
maybe, optimisations.  We might want to do it as an unsafe operation,
without introducing run--time validation of values.  For example, if we
know that the result of an expression is a vector of @math{3} fixnums,
we might write:

@lisp
($vector-ref @meta{expr} 1)
@end lisp

@noindent
and everything is all right, but we are not specifying that the return
value is a fixnum.

In these corner cases, we can use the syntax
@syntax{unsafe-cast-signature}: at expand--time, it tags an expression
as returning values of a specified type signature.  So, in the above
example, we could write:

@lisp
(unsafe-cast-signature (<fixnum>)
  ($vector-ref @meta{expr} 1))
@end lisp

We can easily check how @syntax{unsafe-cast-signature} works at the @repl{}:

@example
vicare> (unsafe-cast-signature (<fixnum>) 123)
$1 = 123
vicare> (expansion-of (unsafe-cast-signature (<fixnum>) 123))
$1 = '123
vicare> (type-of (unsafe-cast-signature (<fixnum>) 123))
$1 = #[signature (<fixnum>)]
@end example

@noindent
for a truly untyped expression:

@example
vicare> (expansion-of (unsafe-cast-signature (<fixnum>) (read)))
$1 = ((primitive read))
vicare> (type-of (unsafe-cast-signature (<fixnum>) (read)))
$1 = #[signature (<fixnum>)]
@end example

@noindent
if the type is incompatible, and we know it at expand--time:

@smallexample
vicare> (unsafe-cast-signature (<fixnum>) "ciao")
Unhandled exception
 Condition components:
   1. &who: unsafe-cast-signature
   2. &message: "expression type is incompatible with the requested tag"
   3. &syntax:
       form: #<syntax expr=(unsafe-cast-signature (<fixnum>) "ciao")>
       subform: #<syntax expr="ciao" mark*=(src)>
   4. &irritants: (#[signature (<string>)])
@end smallexample

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax unsafe-cast-signature @meta{signature} @meta{expr}
Expand to the @meta{expr} expression itself, but, in the expander, tag
the expression as returning a tuple of values with type signature
@meta{signature}.
@end deffn

@c page
@node types syntaxes case-type
@subsection Branching on type of expression


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax case-type @meta{expr} @metao{clause} @meta{clause} @dots{}
@deffnx {Auxiliary Syntax} =>
@deffnx {Auxiliary Syntax} else
Similar to @syntax{case} but branches based on the type of the single
value returned by @meta{expr}.  Each @meta{clause} must have one of the
formats:

@lisp
((@meta{type-id}) . @meta{body})
((@meta{type-id}) => @meta{receiver-expr})
(else . @meta{body})
@end lisp

@noindent
where: @meta{type-id} must be a type identifier; the @syntax{else}
clause is valid only as last clause; @meta{receiver-expr} must be an
expression evaluating to a closure object accepting a single argument.

Examples:

@lisp
(case-type 123
  ((<vector>)   'vector)
  ((<fixnum>)   'fixnum)
  ((<string>)   'string))
@result{} fixnum

(case-type 123
  ((<vector>)   'vector)
  ((<fixnum>)   => (lambda (arg) (list arg 'fixnum)))
  ((<string>)   'string)
  (else   'else))
@result{} (123 fixnum)

(case-type #t
  ((<vector>)   'vector)
  ((<fixnum>)   'fixnum)
  ((<string>)   'string)
  (else         'else))
@result{} else
@end lisp
@end deffn

@c page
@node types built-in
@section Built--in object types


The library @library{vicare} exports keyword syntactic bindings
representing the types of built--in objects: fixnum, strings, vectors,
et cetera.

@menu
* types built-in top::          The conventional parent of all the types.
* types built-in void::         Type of the void object.
* types built-in booleans::     Type of boolean objects.
* types built-in chars::        Type of character objects.
* types built-in symbols::      Type of symbol objects.
* types built-in gensyms::      Type of gensym values.
* types built-in keywords::     Type of keyword objects.
* types built-in pointers::     Type of pointer objects.
* types built-in transcoders::  Type of transcoder objects.
* types built-in procedures::   Type of procedures objects.
* types built-in numerics::     Type of numeric objects.
* types built-in strings::      Type of string objects.
* types built-in vectors::      Type of vector objects.
* types built-in lists::        Type of list objects.
* types built-in null::         Type of empty lists.
* types built-in pairs::        Type of pair objects.
* types built-in ipairs::       Type of immutable pair objects.
* types built-in bytevectors::  Type of bytevector objects.
* types built-in hashtables::   Type of hashtable objects.
* types built-in structs::      Type of struct objects.
* types built-in records::      Type of record objects.
* types built-in conditions::   Type of condition objects.
* types built-in ports::        Types of input/output ports.
* types built-in misc::         Miscellaneous built-in types.
@end menu

@c page
@node types built-in top
@subsection The conventional parent of all the types


@deftp {Built--in Type} @aclass{top}
The conventional parent of all the types.
@end deftp


@defop Constructor @class{top} new @aclass{top} @var{obj}
Return @var{obj} itself.
@end defop


@defop {Type predicate} @class{top} is-a? @var{obj} @aclass{top}
Always return @true{}.
@end defop


@deftypemethod @class{top} @aclass{non-negative-fixnum} hash @var{self}
Compute and return a hash value for @var{self}.  When the object--type
does not define a specialised hash function: @func{object-hash} is
applied to @var{self}.
@end deftypemethod

@c page
@node types built-in void
@subsection The type of the void value


@deftp {Built--in Type} @aclass{void}
@deftpx {Parent Type} @aclass{top}
The type of the void object.
@end deftp


@defop Constructor @class{void} new @aclass{void}
Return the void object.
@end defop


@defop {Type predicate} @class{void} is-a? @var{obj} @aclass{void}
The type predicate is @func{void-object?}.  Return @true{} if @var{obj}
is void; otherwise return @false{}.
@end defop

@c page
@node types built-in booleans
@subsection Type of boolean values


@deftp {Built--in Type} @aclass{boolean}
@deftpx {Parent Type} @aclass{top}
Type of the boolean values @true{} and @false{}.
@end deftp


@defop Constructor @class{boolean} new @aclass{boolean} @var{obj}
Return @true{} if @var{obj} is true; otherwise return @false{}.
@end defop


@defop {Type predicate} @class{boolean} is-a? @var{obj} @aclass{boolean}
The type predicate is @func{boolean?}.  Return @true{} if @var{obj} is
@true{} or @false{}; otherwise return @false{}.
@end defop

@c ------------------------------------------------------------------------

@deftp {Built--in Type} @aclass{true}
@deftpx {Parent Type} @aclass{boolean}
Type of the boolean value @true{}.  There is no constructor.  There is
no predicate.
@end deftp


@deftp {Built--in Type} @aclass{false}
@deftpx {Parent Type} @aclass{boolean}
Type of the boolean value @false{}.  There is no constructor.  There is
no predicate.
@end deftp

@c page
@node types built-in chars
@subsection Type of character values


@deftp {Built--in Type} @aclass{char}
@deftpx {Parent Type} @aclass{top}
Type of character values.
@end deftp


@defop Constructor @class{char} new @aclass{char} @var{obj}
The constructor is @func{integer->char}.
@end defop


@defop {Type predicate} @class{char} is-a? @var{obj} @aclass{char}
The type predicate is @func{char?}.  Return @true{} if @var{obj} is a
character object; otherwise return @false{}.
@end defop


@deftypemethod @class{char} @aclass{string} string @var{self}
Apply @func{string} to the instance.
@end deftypemethod


@deftypemethod @class{char} @aclass{fixnum} hash @var{self}
Apply @func{char-hash} to the instance.
@end deftypemethod


@deftypemethod @class{char} @aclass{fixnum} integer @var{self}
Apply @func{char->integer} to the instance.
@end deftypemethod


@deftypemethod @class{char} @aclass{fixnum} fixnum @var{self}
Apply @func{char->fixnum} to the instance.
@end deftypemethod

@c page
@node types built-in symbols
@subsection Type of symbol values


@deftp {Built--in Type} @aclass{symbol}
@deftpx {Parent Type} @aclass{top}
Type of symbol values (including gensyms).
@end deftp


@defop Constructor @class{symbol} new @aclass{symbol} @var{string}
The constructor is @func{string->symbol}.
@end defop


@defop {Type predicate} @class{symbol} is-a? @var{obj} @aclass{symbol}
The type predicate is @func{symbol?}.  Return @true{} if @var{obj} is a
symbol object; otherwise return @false{}.
@end defop


@deftypemethod @class{symbol} @aclass{string} string @var{self}
Apply @func{symbol->string} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{fixnum} hash @var{self}
Apply @func{symbol-hash} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{boolean} bound? @var{self}
Apply @func{symbol-bound?} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{top} value @var{self}
@deftypemethodx @class{symbol} @aclass{void} value @var{self} @var{new-value}
When called with no arguments: apply @func{symbol-value} to the instance
to retrieve the current value in the @code{value} slot.  When called
with one argument: apply @func{set-symbol-value!} to the instance to
store a new value @code{value} slot.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{void} putprop @var{self} (@var{key} @aclass{symbol}) @var{value}
Apply @func{putprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{top} getprop @var{self} (@var{key} @aclass{symbol})
Apply @func{getprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{void} remprop @var{self} (@var{key} @aclass{symbol})
Apply @func{remprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{list} property-list @var{self}
Apply @func{property-list} to the instance.
@end deftypemethod

@c page
@node types built-in gensyms
@subsection Type of gensym values


@deftp {Built--in Type} @aclass{gensym}
@deftpx {Parent Type} @aclass{symbol}
Type of gensym values.
@end deftp


@defop Constructor @class{gensym} new @aclass{gensym}
@defopx Constructor @class{gensym} new @aclass{gensym} @var{string}
@defopx Constructor @class{gensym} new @aclass{gensym} @var{symbol}
The constructor is @func{gensym}.
@end defop


@defop {Type predicate} @class{gensym} is-a? @var{obj} @aclass{gensym}
The type predicate is @func{gensym?}.  Return @true{} if @var{obj} is a
gensym object; otherwise return @false{}.
@end defop

@c page
@node types built-in keywords
@subsection Type of keyword values


@deftp {Built--in Type} @aclass{keyword}
@deftpx {Parent Type} @aclass{top}
Type of keyword values.
@end deftp


@defop Constructor @class{keyword} new @aclass{keyword} @var{symbol}
The constructor is @func{symbol->keyword}.
@end defop


@defop {Type predicate} @class{keyword} is-a? @var{obj} @aclass{keyword}
The type predicate is @func{keyword?}.  Return @true{} if @var{obj} is a
keyword object; otherwise return @false{}.
@end defop


@deftypemethod @class{keyword} @aclass{symbol} symbol @var{self}
Apply @func{keyword->symbol} to the instance.
@end deftypemethod


@deftypemethod @class{keyword} @aclass{string} string @var{self}
Apply @func{keyword->string} to the instance.
@end deftypemethod


@deftypemethod @class{keyword} @aclass{fixnum} hash @var{self}
Apply @func{keyword-hash} to the instance.
@end deftypemethod

@c page
@node types built-in pointers
@subsection Type of pointer values


@deftp {Built--in Type} @aclass{pointer}
@deftpx {Parent Type} @class{top}
Type of pointer values.
@end deftp


@defop Constructor @class{pointer} new @aclass{pointer} @var{int}
The constructor is @func{integer->pointer}.
@end defop


@defop {Type predicate} @class{pointer} is-a? @var{obj} @aclass{pointer}
The type predicate is @func{pointer?}.  Return @true{} if @var{obj} is a
pointer object; otherwise return @false{}.
@end defop


@deftypemethod @class{pointer} @aclass{boolean} null? @var{self}
Apply @func{pointer-null?} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{exact-integer} integer @var{self}
Apply @func{pointer->integer} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} = @var{self} @var{ptr} @dots{}
Apply @func{pointer=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} != @var{self} @var{ptr} @dots{}
Apply @func{pointer!=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} < @var{self} @var{ptr} @dots{}
Apply @func{pointer<?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} > @var{self} @var{ptr} @dots{}
Apply @func{pointer>?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} <= @var{self} @var{ptr} @dots{}
Apply @func{pointer<=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} >= @var{self} @var{ptr} @dots{}
Apply @func{pointer>=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} add @var{diff}
Apply @func{pointer-add} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} diff @var{self} @var{pointer}
Apply @func{pointer-diff} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} clone @var{self}
Apply @func{pointer-clone} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{void} set-null! @var{self}
Apply @func{set-pointer-null!)} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{fixnum} hash @var{self}
Apply @func{pointer-hash} to the instance.
@end deftypemethod

@c page
@node types built-in transcoders
@subsection Type of transcoder values


@deftp {Built--in Type} @aclass{transcoder}
@deftpx {Parent Type} @aclass{top}
Type of transcoder values.
@end deftp


@defop Constructor @class{transcoder} new @aclass{transcoder} @var{codec}
@defopx Constructor @class{transcoder} new @aclass{transcoder} @var{codec} @var{eol-style}
@defopx Constructor @class{transcoder} new @aclass{transcoder} @var{codec} @var{eol-style} @var{handling-mode}
The constructor is @func{make-transcoder}.
@end defop


@defop {Type predicate} @class{transcoder} is-a? @var{obj} @aclass{transcoder}
The type predicate is @func{transcoder?}.  Return @true{} if @var{obj}
is a transcoder object; otherwise return @false{}.
@end defop


@deftypemethod @class{transcoder} @aclass{symbol} codec @var{self}
Apply @func{transcoder-codec} to the instance.
@end deftypemethod


@deftypemethod @class{transcoder} @aclass{symbol} eol-style @var{self}
Apply @func{transcoder-eol-style} to the instance.
@end deftypemethod


@deftypemethod @class{transcoder} @aclass{symbol} handling-mode @var{self}
Apply @func{transcoder-error-handling-mode} to the instance.
@end deftypemethod

@c page
@node types built-in procedures
@subsection Type of procedures values


@deftp {Built--in Type} @aclass{procedure}
@deftpx {Parent Type} @aclass{top}
Type of closure object values.  There is no constructor.
@end deftp


@defop {Type predicate} @aclass{procedure} is-a? @var{obj} @aclass{procedure}
The type predicate is @func{procedure?}.  Return @true{} if @var{obj} is
a closure object; otherwise return @false{}.
@end defop


@defop {Type Annotation} @aclass{thunk}
Type of procedures accepting no arguments.  The definition of this type
is equivalent to:

@lisp
(define-type <thunk>
  (lambda () => <list>))
@end lisp
@end defop

@c ------------------------------------------------------------------------

@subsubheading Type procedures

@deftp {Type Annotation} @aclass{type-predicate}
Type of procedures acting as type predicates.  The definition of this
type is equivalent to:

@lisp
(define-type <type-predicate>
  (lambda (<top>) => (<boolean>)))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{type-destructor}
Type of procedures acting as destructors for object of a specified type.
The definition of this type is equivalent to:

@lisp
(define-type <type-destructor>
  (lambda (<top>) => <list>))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{type-printer}
Type of procedures acting as custom printers for object of a specified
type.  The definition of this type is equivalent to:

@lisp
(define-type-annotation <type-printer>
  (lambda (<top> <textual-output-port> <procedure>) => <list>))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{equality-predicate}
Type of procedures acting as equality predicates.  The definition of
this type is equivalent to:

@lisp
(define-type <equality-predicate>
  (lambda (<top> <top>) => (<boolean>)))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{comparison-procedure}
Type of procedures acting as equality predicates.  The definition of
this type is equivalent to:

@lisp
(define-type <comparison-procedure>
  (lambda (<top> <top>) => (<fixnum>)))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{hash-function}
Type of procedures acting as equality predicates.  The definition of
this type is equivalent to:

@lisp
(define-type <hash-function>
  (lambda (<top>) => (<non-negative-fixnum>)))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{type-method-retriever}
Type of procedures acting as run--time method retriever for object of a
specified type.  The definition of this type is equivalent to:

@lisp
(define-type <type-method-retriever>
  (lambda (<symbol>) => ((or <false> <procedure>))))
@end lisp
@end deftp

@c page
@node types built-in numerics
@subsection Type of numeric values


@menu
* types built-in numerics number::           Type of number values.
* types built-in numerics complex::          Type of complex values.
* types built-in numerics real-valued::      Type of real-valued values.
* types built-in numerics real::             Type of real values.
* types built-in numerics rational-valued::  Type of rational-valued values.
* types built-in numerics rational::         Type of rational values.
* types built-in numerics integer-valued::   Type of integer-valued values.
* types built-in numerics integer::          Type of integer values.
* types built-in numerics exact-integer::    Type of exact-integer values.
* types built-in numerics fixnums::          Type of fixnum values.
* types built-in numerics bignums::          Type of bignum values.
* types built-in numerics flonums::          Type of flonum values.
* types built-in numerics ratnums::          Type of ratnum values.
* types built-in numerics compnums::         Type of compnum values.
* types built-in numerics cflonums::         Type of cflonum values.
* types built-in numerics bytes::            Type of byte values.
* types built-in numerics octets::           Type of octet values.
* types built-in numerics exactness::        Exactness of numeric values.
* types built-in numerics sign::             Sign of numeric values.
@end menu

@c page
@node types built-in numerics number
@subsubsection Type of number values


@deftp {Built--in Type} @aclass{number}
@deftpx {Parent Type} @aclass{top}
Type of numeric values.  There is no constructor.  The type predicate is
@func{number?}.
@end deftp

@c page
@node types built-in numerics complex
@subsubsection Type of complex values


@deftp {Built--in Type} @aclass{complex}
@deftpx {Parent Type} @aclass{number}
Type of complex numbers.  The constructor is @func{make-rectangular}.
The type predicate is @func{complex?}.
@end deftp

@c page
@node types built-in numerics real-valued
@subsubsection Type of real--valued values


@deftp {Built--in Type} @aclass{real-valued}
@deftpx {Parent Type} @aclass{complex}
Type of real--valued values.  There is no constructor.  The type
predicate is @func{real-valued?}.
@end deftp

@c page
@node types built-in numerics real
@subsubsection Type of real values


@deftp {Built--in Type} @aclass{real}
@deftpx {Parent Type} @aclass{real-valued}
Type of real values.  There is no constructor.  The type predicate is
@func{real?}.
@end deftp

@c page
@node types built-in numerics rational-valued
@subsubsection Type of rational--valued values


@deftp {Built--in Type} @aclass{rational-valued}
@deftpx {Parent Type} @aclass{real}
Type of rational--valued values.  There is no constructor.  The type
predicate is @func{rational-valued?}.
@end deftp

@c page
@node types built-in numerics rational
@subsubsection Type of rational values


@deftp {Built--in Type} @aclass{rational}
@deftpx {Parent Type} @aclass{rational-valued}
Type of rational values.  There is no constructor.  The type predicate
is @func{rational?}.
@end deftp


@deftp {Built--in Type} @aclass{exact-rational}
Type of exact rational values.  Its definition is equivalent to:

@lisp
(define-type <exact-rational>
  (or <exact-integer> <ratnum>))
@end lisp
@end deftp

@c page
@node types built-in numerics integer-valued
@subsubsection Type of integer--valued values


@deftp {Built--in Type} @aclass{integer-valued}
@deftpx {Parent Type} @aclass{rational-valued}
Type of integer--valued values.  There is no constructor.  The type
predicate is @func{integer-valued?}.
@end deftp

@c page
@node types built-in numerics integer
@subsubsection Type of integer values


Notice that @class{integer} is a @class{rational}, not a
@class{integer-valued}.


@deftp {Built--in Type} @aclass{integer}
@deftpx {Parent Type} @aclass{rational}
Type of integer values.  There is no constructor.  The type predicate is
@func{integer?}.
@end deftp

@c page
@node types built-in numerics exact-integer
@subsubsection Type of exact--integer values


@deftp {Built--in Type} @aclass{exact-integer}
@deftpx {Parent Type} @aclass{integer}
Type of exact integers.  There is no constructor.  The type predicate is
@func{exact-integer?}.
@end deftp


@deftp {Built--in Type} @aclass{non-negative-exact-integer}
Type of non--negative exact integers.  Its definition is equivalent to:

@lisp
(define-type <non-negative-exact-integer>
  (or <non-negative-fixnum> <positive-bignum>))
@end lisp
@end deftp


@deftp {Built--in Type} @aclass{positive-exact-integer}
Type of positive exact integers.  Its definition is equivalent to:

@lisp
(define-type <positive-exact-integer>
  (or <positive-fixnum> <positive-bignum>))
@end lisp
@end deftp


@deftp {Built--in Type} @aclass{negative-exact-integer}
Type of negative exact integers.  Its definition is equivalent to:

@lisp
(define-type <negative-exact-integer>
  (or <negative-fixnum> <negative-bignum>))
@end lisp
@end deftp

@c page
@node types built-in numerics fixnums
@subsubsection Type of fixnum values


@deftp {Built--in Type} @aclass{fixnum}
@deftpx {Parent Type} @aclass{exact-integer}
Type of fixnum values.  There is no constructor.  The type predicate is
@func{fixnum?}.
@end deftp


@deftp {Built--in Type} @aclass{positive-fixnum}
@deftpx {Parent Type} @aclass{fixnum}
Type of positive fixnum values.  There is no constructor.  The type
predicate is @func{positive-fixnum?}.
@end deftp


@deftp {Built--in Type} @aclass{negative-fixnum}
@deftpx {Parent Type} @aclass{fixnum}
Type of negative fixnum values.  There is no constructor.  The type
predicate is @func{negative-fixnum?}.
@end deftp


@deftp {Built--in Type} @aclass{zero-fixnum}
@deftpx {Parent Type} @aclass{fixnum}
Type of the zero fixnum value.  There is no constructor.  The type
predicate is @func{zero-fixnum?}.
@end deftp


@deftp {Built--in Type} @aclass{non-negative-fixnum}
Type of non--negative fixnum values.  Its definition is equivalent to:

@lisp
(define-type <non-negative-fixnum>
  (or <zero-fixnum> <positive-fixnum>))
@end lisp
@end deftp


@deftp {Built--in Type} @aclass{non-positive-fixnum}
Type of non--positive fixnum values.  Its definition is equivalent to:

@lisp
(define-type <non-positive-fixnum>
  (or <zero-fixnum> <negative-fixnum>))
@end lisp
@end deftp

@c page
@node types built-in numerics bignums
@subsubsection Type of bignum values


@deftp {Built--in Type} @aclass{bignum}
@deftpx {Parent Type} @aclass{exact-integer}
Type of bignum values.  There is no constructor.  The type predicate is
@func{bignum?}.
@end deftp


@deftp {Built--in Type} @aclass{positive-bignum}
@deftpx {Parent Type} @aclass{bignum}
Type of positive bignum values.  There is no constructor.  The type
predicate is @func{positive-bignum?}.
@end deftp


@deftp {Built--in Type} @aclass{negative-bignum}
@deftpx {Parent Type} @aclass{bignum}
Type of negative bignum values.  There is no constructor.  The type
predicate is @func{negative-bignum?}.
@end deftp

@c page
@node types built-in numerics flonums
@subsubsection Type of flonum values


@deftp {Built--in Type} @aclass{flonum}
@deftpx {Parent Type} @aclass{real-valued}
Type of flonum values.  There is no constructor.  The type predicate is
@func{flonum?}.
@end deftp


@deftp {Built--in Type} @aclass{positive-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of positive flonum values.  There is no constructor.  The type
predicate is @func{positive-flonum?}.
@end deftp


@deftp {Built--in Type} @aclass{negative-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of negative flonum values.  There is no constructor.  The type
predicate is @func{negative-flonum?}.
@end deftp


@deftp {Built--in Type} @aclass{positive-zero-flonum}
@deftpx {Parent Type} @aclass{positive-flonum}
Type of zero flonum values.  There is no constructor.  The type
predicate is @func{positive-zero-flonum?}.
@end deftp


@deftp {Built--in Type} @aclass{negative-zero-flonum}
@deftpx {Parent Type} @aclass{negative-flonum}
Type of zero flonum values.  There is no constructor.  The type
predicate is @func{negative-zero-flonum?}.
@end deftp


@deftp {Built--in Type} @aclass{zero-flonum}
Type of zero flonum values.  Its definition is equivalent to:

@lisp
(define-type <zero-flonum>
  (or <positive-zero-flonum> <negative-zero-flonum>))
@end lisp
@end deftp

@c page
@node types built-in numerics ratnums
@subsubsection Type of ratnum values


@deftp {Built--in Type} @aclass{ratnum}
@deftpx {Parent Type} @aclass{rational}
Type of ratnum values.  There is no constructor.  The type predicate is
@func{ratnum?}.
@end deftp


@deftp {Built--in Type} @aclass{positive-ratnum}
@deftpx {Parent Type} @aclass{ratnum}
Type of positive ratnum values.  There is no constructor.  The type
predicate is @func{positive-ratnum?}.
@end deftp


@deftp {Built--in Type} @aclass{negative-ratnum}
@deftpx {Parent Type} @aclass{ratnum}
Type of negative ratnum values.  There is no constructor.  The type
predicate is @func{negative-ratnum?}.
@end deftp

@c page
@node types built-in numerics compnums
@subsubsection Type of compnum values


@deftp {Built--in Type} @aclass{compnum}
@deftpx {Parent Type} @aclass{complex}
Type of compnum values.  There is no constructor.  The type predicate is
@func{compnum?}.
@end deftp


@deftp {Built--in Type} @aclass{exact-compnum}
@deftpx {Parent Type} @aclass{compnum}
Type of compnum values having exact real and imaginary parts.  There is
no constructor.  The type predicate is @func{exact-compnum?}.
@end deftp


@deftp {Built--in Type} @aclass{inexact-compnum}
@deftpx {Parent Type} @aclass{compnum}
Type of compnum values having inexact real and imaginary parts.  There
is no constructor.  The type predicate is @func{inexact-compnum?}.
@end deftp

@c page
@node types built-in numerics cflonums
@subsubsection Type of cflonum values


@deftp {Built--in Type} @aclass{cflonum}
@deftpx {Parent Type} @aclass{complex}
Type of cflonum values.  There is no constructor.  The type predicate is
@func{cflonum?}.
@end deftp

@c page
@node types built-in numerics bytes
@subsubsection Type of byte values


@deftp {Built--in Type} @class{byte}
@deftpx {Parent Type} @aclass{fixnum}
Type of byte values.  A ``byte'' is a fixnum in the range @math{[-128,
127]}.
@end deftp


@defop Constructor @class{byte} new @aclass{byte} @var{obj}
There is no constructor.  Validate @var{obj} as byte value and return
it.
@end defop


@defop {Type predicate} @class{byte} is-a? @var{obj} @aclass{byte}
The type predicate is @func{byte-fixnum?}.  Return @true{} if @var{obj}
is a byte value; otherwise return @false{}.
@end defop

@c page
@node types built-in numerics octets
@subsubsection Type of octet values


@deftp {Built--in Type} @class{octet}
@deftpx {Parent Type} @aclass{non-negative-fixnum}
Type of octet values.  An ``octet'' is a fixnum in the range @math{[0,
255]}.  There is no constructor.
@end deftp


@defop Constructor @class{byte} new @aclass{octet} @var{obj}
There is no constructor.  Validate @var{obj} as octet value and return
it.
@end defop


@defop {Type predicate} @class{octet} is-a? @var{obj} @aclass{octet}
The type predicate is @func{octet-fixnum?}.  Return @true{} if @var{obj}
is a octet value; otherwise return @false{}.
@end defop

@c page
@node types built-in numerics exactness
@subsubsection Exactness of values


@deftp {Built--in Type} @class{exact}
Type of exact numeric values.  Its definition is equivalent to:

@lisp
(define-type <exact>
  (or <exact-rational> <exact-compnum>))
@end lisp
@end deftp


@deftp {Built--in Type} @class{inexact}
Type of inexact numeric values.  Its definition is equivalent to:

@lisp
(define-type <inexact>
  (or <flonum> <cflonum> <inexact-compnum>))
@end lisp
@end deftp

@c page
@node types built-in numerics sign
@subsubsection Sign of numeric values


@deftp {Built--in Type} @class{positive}
Type of positive numeric values.  Its definition is equivalent to:

@lisp
(define-type <positive>
  (or <positive-fixnum> <positive-bignum> <positive-ratnum>
      <positive-flonum> <positive-zero-flonum>))
@end lisp
@end deftp


@deftp {Built--in Type} @class{negative}
Type of negative numeric values.  Its definition is equivalent to:

@lisp
(define-type <negative>
  (or <negative-fixnum> <negative-bignum> <negative-ratnum>
      <negative-flonum> <negative-zero-flonum>))
@end lisp
@end deftp


@deftp {Built--in Type} @class{non-negative}
Type of non--negative numeric values.  Its definition is equivalent to:

@lisp
(define-type <non-negative>
  (or <non-negative-fixnum> <positive-bignum> <positive-ratnum>
      <positive-flonum> <positive-zero-flonum>))
@end lisp
@end deftp


@deftp {Built--in Type} @class{zero}
Type of zero numeric values.  Its definition is equivalent to:

@lisp
(define-type <zero>
  (or <zero-fixnum> <zero-flonum>))
@end lisp
@end deftp

@c page
@node types built-in strings
@subsection Type of string values


@deftp {Built--in Type} @class{string}
@deftpx {Parent Type} @aclass{top}
Type of string values.
@end deftp


@defop Constructor @class{string} new @aclass{string} @var{char} @dots{}
The constructor is @func{string}.
@end defop


@defop {Type predicate} @class{string} is-a? @var{obj} @aclass{string}
The type predicate is @func{string?}.  Return @true{} if @var{obj} is a
string object; otherwise return @false{}.
@end defop

@c ------------------------------------------------------------------------

@subsubheading Inspection


@deftypemethod @class{string} @aclass{boolean} empty? @var{self}
Apply @func{string-empty?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} length @var{self}
Apply @func{string-length} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} for-each @var{self} @var{func} @var{str} @dots{}
Apply @func{string-for-each} to the function @var{func}, the instance
and the arguments.  Example:

@lisp
(.for-each "ciao" display)
@end lisp
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Constructors


@deftypemethod @aclass{string} copy @var{self}
Apply @func{string-copy} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} append @var{self}
Apply @func{string-append} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators


@deftypemethod @aclass{string} ref @var{self} @var{idx}
Apply @func{string-ref} to the instance and the index @var{idx}.
@end deftypemethod


@deftypemethod @aclass{string} set! @var{self} @var{idx} @var{char}
Apply @func{string-set!} to the instance, the index @var{idx} and the
character @var{char}.
@end deftypemethod


@deftypemethod @aclass{string} fill! @var{self} @var{char}
Apply @func{string-fill!} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Encoding inspection


@deftypemethod @aclass{string} ascii-encoded? @var{self}
Apply @func{ascii-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} latin1-encoded? @var{self}
Apply @func{latin1-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} octets-encoded? @var{self}
Apply @func{octets-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} uri-encoded @var{self}
Apply @func{uri-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} pencent-encoded? @var{self}
Apply @func{percent-encoded-string?} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Comparison


@deftypemethod @aclass{string} = @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} < @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} > @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} <= @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} >= @var{self} @var{str} @dots{}
Apply @func{string=?}, @func{string<?}, @func{string>?},
@func{string<=?}, @func{string>=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @aclass{string} ci= @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci< @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci> @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci<= @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci>= @var{self} @var{str} @dots{}
Apply @func{string-ci=?}, @func{string-ci<?}, @func{string-ci>?},
@func{string-ci<=?}, @func{string-ci>=?}, to the instance and the
arguments.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Case handling


@deftypemethod @aclass{string} titlecase @var{self}
Apply @func{string-titlecase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} upcase @var{self}
Apply @func{string-upcase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} downcase @var{self}
Apply @func{string-downcase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} foldcase @var{self}
Apply @func{string-foldcase} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Normalisation


@deftypemethod @aclass{string} normalize-nfc @var{self}
Apply @func{string-normalize-nfc} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfd @var{self}
Apply @func{string-normalize-nfd} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfkc @var{self}
Apply @func{string-normalize-nfkc} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfkd @var{self}
Apply @func{string-normalize-nfkd} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Conversion


@deftypemethod @aclass{string} flonum @var{self}
Apply @func{string->flonum} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} number @var{self}
@deftypemethodx @aclass{string} number @var{self} @var{radix}
Apply @func{string->number} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} utf8 @var{self}
Apply @func{string->utf8} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16 @var{self}
@deftypemethodx @aclass{string} utf16 @var{self} @var{endianness}
Apply @func{string->utf16} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} utf16be @var{self}
Apply @func{string->utf16be} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16le @var{self}
Apply @func{string->utf16le} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16n @var{self}
Apply @func{string->utf16n} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf32 @var{self}
@deftypemethodx @aclass{string} utf32 @var{self} @var{endianness}
Apply @func{string->utf32} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} bytevector @var{self}
@deftypemethodx @aclass{string} bytevector @var{self} @var{transcoder}
Apply @func{string->bytevector} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} ascii @var{self}
Apply @func{string->ascii} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} latin1 @var{self}
Apply @func{string->latin1} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} octets @var{self}
Apply @func{string->octets} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} percent-encoding @var{self}
Apply @func{string->percent-encoding} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} uri-encoding @var{self}
Apply @func{string->uri-encoding} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} base64->bytevector @var{self}
Apply @func{string-base64->bytevector} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} hex->bytevector @var{self}
Apply @func{string-hex->bytevector} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} symbol @var{self}
Apply @func{string->symbol} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} keyword @var{self}
Apply @func{string->keyword} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} list @var{self}
Apply @func{string->list} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Miscellaneous


@deftypemethod @aclass{string} hash @var{self}
Apply @func{string-hash} to the instance.
@end deftypemethod

@c page
@node types built-in vectors
@subsection Type of vector values


@deftp {Built--in Type} @aclass{vector}
@deftpx {Parent Type} @aclass{top}
Type of vector values.
@end deftp


@defop Constructor @class{vector} new @aclass{vector} @var{obj} @dots{}
The constructor is @func{vector}.
@end defop


@defop {Type predicate} @class{vector} is-a? @var{obj} @aclass{vector}
The type predicate is @func{vector?}.  Return @true{} if @var{obj} is a
vector object; otherwise return @false{}.
@end defop

@c ------------------------------------------------------------------------

@subsubheading Inspection


@deftypemethod @class{vector} @aclass{non-negative-fixnum} length @var{self}
Apply @func{vector-length} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators


@deftypemethod @class{vector} @aclass{top} ref @var{self} @var{idx}
Apply @func{vector-ref} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{vector} @aclass{void} set! @var{self} @var{idx} @var{obj}
Apply @func{vector-set!} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{void} fill! @var{self} @var{obj}
Apply @func{vector-fill!} to the instance and the argument.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Other constructors


@deftypemethod @class{vector} @aclass{vector} subvector @var{self} @var{begin} @var{end}
Apply @func{subvector} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{vector} append @var{self} @var{vec} @dots{}
Apply @func{vector-append} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{vector} resize @var{self} @var{new-length}
@deftypemethodx @class{vector} @aclass{vector} resize @var{self} @var{new-length} @var{fill}
Apply @func{vector-resize} to the instance and the arguments.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Iteration and searching


@deftypemethod @class{vector} @aclass{vector} map @var{self} @var{proc} @var{vec} @dots{}
Apply @func{vector-map} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{void} for-each @var{self} @var{proc} @var{vec} @dots{}
Apply @func{vector-for-each} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} for-all @var{self} @var{proc} @var{vec} @dots{}
Apply @func{vector-for-all} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} exists @var{self} @var{proc} @var{vec} @dots{}
Apply @func{vector-exists} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} find @var{self} @var{proc}
Apply @func{vector-find} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} fold-left @var{self} @var{proc} @var{knil} @var{vec} @dots{}
Apply @func{vector-fold-left} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} fold-right @var{self} @var{proc} @var{knil} @var{vec} @dots{}
Apply @func{vector-fold-right} to the instance and the arguments.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Sorting


@deftypemethod @class{vector} @aclass{vector} sort @var{self} @var{proc}
@deftypemethodx @class{vector} @aclass{vector} sort! @var{self} @var{proc}
Apply @func{vector-sort} or @func{vector-sort!} to the instance and the
argument.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Conversion


@deftypemethod @class{vector} @aclass{list} list @var{self}
Apply @func{vector->list} to the instance.
@end deftypemethod

@c page
@node types built-in lists
@subsection Type of list objects


@deftp {Built--in Type} @aclass{list}
@deftpx {Parent Type} @aclass{top}
Type of lists, whatever their structure.  The fact that a list structure
is non--empty, non--circular, proper or improper must be checked at
run--time.
@end deftp


@defop Constructor @class{list} new @aclass{list} @var{obj} @dots{}
The constructor is @func{list}.  Return a new list having the given
@var{obj} arguments as items.
@end defop


@defop {Type predicate} @class{list} is-a? @var{obj} @aclass{list}
The type predicate is @func{list?}.  Return @true{} if @var{obj} is null
or a proper list object; otherwise return @false{}.
@end defop


@defmethod @class{list} car
Apply @func{car} to the type instance.  Raise an exception if the
instance is null.
@end defmethod


@defmethod @class{list} cdr
Apply @func{cdr} to the type instance.  Raise an exception if the
instance is null.
@end defmethod

@c page
@node types built-in null
@subsection Type of empty lists


@deftp {Built--in Type} @aclass{null}
@deftpx {Parent Type} @aclass{list}
Type of the null object.

The type @class{null} is special in that it is considered sub--type of
both the type @class{list} and the types defined with the annotations
@code{(list-of @meta{type})}.  Notice that types defined with the
annotations @code{(list @metao{type} @meta{type} ...)} are @strong{not}
super--types of @class{null}, because, by definition, they contain at
list one item.
@end deftp


@defop {Type predicate} @class{null} is-a? @var{obj} @aclass{null}
The type predicate is @func{null?}.  Return @true{} if @var{obj} is
null; otherwise return @false{}.
@end defop

@c page
@node types built-in pairs
@subsection Type of pair objects


@deftp {Built--in Type} @aclass{pair}
@deftpx {Parent Type} @aclass{list}
Type of pair objects.
@end deftp


@defop Constructor @class{pair} new @aclass{pair} @var{A} @var{D}
The constructor is @func{cons}.  Return a new pair having @var{A} and
@var{D} as car and cdr.
@end defop


@defop {Type predicate} @class{pair} is-a? @var{obj} @aclass{pair}
The type predicate is @func{pair?}.  Return @true{} if @var{obj} is a
pair object; otherwise return @false{}.
@end defop


@defmethod @class{pair} car
Apply @func{car} to the type instance.
@end defmethod


@defmethod @class{pair} cdr
Apply @func{cdr} to the type instance.
@end defmethod

@c page
@node types built-in ipairs
@subsection Type of immutable pair objects


@deftp {Built--in Type} @aclass{ipair}
@deftpx {Parent Type} @aclass{record}
Type of immutable pair objects.
@end deftp


@defop Constructor @class{ipair} new @aclass{ipair} @var{A} @var{D}
The constructor is @func{ipair}.  Return a new immutable pair having
@var{A} and @var{D} as car and cdr.
@end defop


@defop {Type predicate} @class{ipair} is-a? @var{obj} @aclass{ipair}
The type predicate is @func{ipair?}.  Return @true{} if @var{obj} is an
immutable pair object; otherwise return @false{}.
@end defop


@defmethod @class{ipair} car
Apply @func{icar} to the type instance.
@end defmethod


@defmethod @class{ipair} cdr
Apply @func{icdr} to the type instance.
@end defmethod

@c page
@node types built-in bytevectors
@subsection Type of bytevector objects


@deftp {Built--in Type} @aclass{bytevector}
@deftpx {Parent Type} @aclass{top}
Type of bytevector objects.  The constructor is @func{make-bytevector}.
The type predicate is @func{bytevector?}.
@end deftp

@c page
@node types built-in hashtables
@subsection Type of hashtable objects


@deftp {Built--in Type} @aclass{hashtable}
@deftpx {Parent Type} @aclass{top}
Base type for hashtable objects.  There is no constructor.  The type
predicate is @func{hashtable?}.
@end deftp


@deftp {Built--in Type} @aclass{hashtable-eq}
@deftpx {Parent Type} @aclass{hashtable}
Type of @func{eq?} hashtables.  The constructor is
@func{make-eq-hashtable}.  There type predicate is @func{hashtable-eq?}.
@end deftp


@deftp {Built--in Type} @aclass{hashtable-eqv}
@deftpx {Parent Type} @aclass{hashtable}
Type of @func{eqv?} hashtables.  The constructor is
@func{make-eqv-hashtable}.  There type predicate is @func{hashtable-eqv?}.
@end deftp


@deftp {Built--in Type} @aclass{hashtable-equal}
@deftpx {Parent Type} @aclass{hashtable}
Type of @func{equal?} hashtables.  The constructor is
@func{make-hashtable}.  There type predicate is @func{hashtable-equiv?}.
@end deftp

@c page
@node types built-in structs
@subsection Type of struct objects


@deftp {Built--in Type} @aclass{struct}
@deftpx {Parent Type} @aclass{top}
Type of struct objects.  There is no constructor.  The type predicate is
@func{struct?}.
@end deftp


@deftp {Built--in Type} @aclass{struct-type-descriptor}
@deftpx {Parent Type} @aclass{struct}
Type of struct--type descriptor objects.  The constructor is
@func{make-struct-type}.  The type descriptor is
@func{struct-type-descriptor?}.
@end deftp

@c page
@node types built-in records
@subsection Type of record objects


@deftp {Built--in Type} @aclass{record}
@deftpx {Parent Type} @aclass{struct}
Type of record objects.  There is no constructor.  The type predicate is
@func{record?}.
@end deftp


@deftp {Built--in Type} @aclass{record-type-descriptor}
@deftpx {Parent Type} @aclass{struct}
Type of record--type descriptor objects.  The constructor is
@func{make-record-type-descriptor}.  The type predicate is
@func{record-type-descriptor?}.
@end deftp


@deftp {Built--in Type} @aclass{record-constructor-descriptor}
@deftpx {Parent Type} @aclass{struct}
Type of record--constructor descriptor objects.  The constructor is
@func{make-record-constructor-descriptor}.  The type predicate is
@func{record-constructor-descriptor?}.
@end deftp

@c page
@node types built-in conditions
@subsection Type of condition objects


@deftp {Built--in Type} @aclass{condition}
@deftpx {Parent Type} @aclass{record}
Type of condition objects.  There is no constructor.  The type predicate
is @func{condition?}.
@end deftp


@deftp {Built--in Type} @aclass{compound-condition}
@deftpx {Parent Type} @aclass{condition}
Type of compound condition objects.  The constructor is
@func{condition}.  The type predicate is @func{compound-condition?}.
@end deftp


@defmethod @class{condition} print
@defmethodx @class{compound-condition} print
Apply @func{print-condition} to the instance.
@end defmethod

@c page
@node types built-in ports
@subsection Types of input/output ports


@menu
* types built-in ports base::            Base port types.
* types built-in ports textual::         Textual port types.
* types built-in ports binary::          Binary port types.
* types built-in ports textual in::      Textual input port types.
* types built-in ports textual out::     Textual output port types.
* types built-in ports textual in/out::  Textual input/output port types.
* types built-in ports binary in::       Binary input port types.
* types built-in ports binary out::      Binary output port types.
* types built-in ports binary in/out::   Binary input/output port types.
@end menu

@c page
@node types built-in ports base
@subsubsection Base port types


@deftp {Built--in Type} @aclass{port}
@deftpx {Parent Type} @aclass{top}
Base type for input, output and input/output ports.  There is no
constructor.  The type predicate is @func{port?}.
@end deftp


@deftp {Built--in Type} @aclass{input-port}
@deftpx {Parent Type} @aclass{port}
Base type for input ports.  There is no constructor.  The type predicate
is @func{input-port?}.
@end deftp


@deftp {Built--in Type} @aclass{output-port}
@deftpx {Parent Type} @aclass{port}
Base type for output ports.  There is no constructor.  The type
predicate is @func{output-port?}.
@end deftp


@deftp {Built--in Type} @aclass{input/output-port}
@deftpx {Parent Type} @aclass{port}
Base type for input/output ports.  There is no constructor.  The type
predicate is @func{input/output-port?}.
@end deftp

@c page
@node types built-in ports textual
@subsubsection Textual port types


@deftp {Built--in Type} @aclass{textual-port}
@deftpx {Parent Type} @aclass{port}
Type of textual ports.  There is no constructor.  The type predicate is
@func{textual-port?}.
@end deftp

@c page
@node types built-in ports binary
@subsubsection Binary port types


@deftp {Built--in Type} @aclass{binary-port}
@deftpx {Parent Type} @aclass{port}
Type of binary ports.  There is no constructor.  The type predicate is
@func{binary-port?}.
@end deftp

@c page
@node types built-in ports textual in
@subsubsection Textual input port types


@deftp {Built--in Type} @aclass{textual-input-port}
@deftpx {Parent Type} @aclass{input-port}
Type of textual input ports.  There is no constructor.  The type
predicate is @func{textual-input-port?}.
@end deftp

@c page
@node types built-in ports textual out
@subsubsection Textual output port types


@deftp {Built--in Type} @aclass{textual-output-port}
@deftpx {Parent Type} @aclass{output-port}
Type of textual output port.  There is no constructor.  The type
predicate is @func{textual-output-port?}.
@end deftp

@c page
@node types built-in ports textual in/out
@subsubsection Textual input/output port types


@deftp {Built--in Type} @aclass{textual-input/output-port}
@deftpx {Parent Type} @aclass{input/output-port}
Type of textual input/output ports.  There is no constructor.  The type
predicate is @func{textual-input/output-port?}.
@end deftp

@c page
@node types built-in ports binary in
@subsubsection Binary input port types


@deftp {Built--in Type} @aclass{binary-input-port}
@deftpx {Parent Type} @aclass{input-port}
Type of binary input ports.  There is no constructor.  The type
predicate is @func{binary-input-port?}.
@end deftp

@c page
@node types built-in ports binary out
@subsubsection Binary output port types


@deftp {Built--in Type} @aclass{binary-output-port}
@deftpx {Parent Type} @aclass{output-port}
Type of binary output ports.  There is no constructor.  The type
predicate is @func{binary-output-port?}.
@end deftp

@c page
@node types built-in ports binary in/out
@subsubsection Binary input/output port types


@deftp {Built--in Type} @aclass{binary-input/output-port}
@deftpx {Parent Type} @aclass{input/output-port}
Type of binary input/output ports.  There is no constructor.  The type
predicate is @func{binary-input/output-port?}.
@end deftp

@c page
@node types built-in misc
@subsection Miscellaneous built-in types


@deftp {Built--In Type} @class{&who-value}
The type of the field in the built--in condition object type
@condition{who}.  Its definition is equivalent to:

@lisp
(define-type <&who-value>
  (or <false> <symbol> <string>))
@end lisp
@end deftp


@deftp {Built--In Type} @class{file-descriptor}
The type of file descriptor values.  Its definition is equivalent to:

@lisp
(define-type <file-descriptor>
  <non-negative-fixnum>)
@end lisp
@end deftp

@c end of file
