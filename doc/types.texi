@node types
@chapter Typed language


@value{PRJNAME}'s expander implements an extension to the language
defined by @rnrs{6} that allows the definition of typed syntactic
bindings.  Type annotations are optional: we are free to specify them or
leave the type of variables unspecified.

@menu
* types intro::                 Introduction to the typed language.
* types ann::                   Type annotations.
* types descr::                 Type descriptors.
* types syntaxes::              Type-exploiting syntaxes.
* types built-in::              Built-in object types.
* types void::                  Handling of void values.
* types methods::               Methods and virtual methods.
* types protlev::               Protection levels.
* types mixins::                Sharing object-type definition clauses.
* types interfaces::            Interface types.
* types labels::                Sub-typing with labels.
@end menu

@c page
@node types intro
@section Introduction to the typed language


@value{PRJNAME}'s typed language adds some expand--time syntactic
binding type--checking and extended @oop{} syntax to the language
specified by @rnrs{6}.

@menu
* types intro philosophy::      Typed language philosophy.
* types intro enabling::        Enabling typed language extensions.
* types intro type ids::        Type identifiers.
* types intro typed vars::      Typed lexical variables.
@end menu

@c page
@node types intro philosophy
@subsection Typed language philosophy


In this document we refer to the standard Scheme language defined by the
@rnrs{6} specifications as the @dfn{standard language}; we refer to the
typed Scheme language defined by @value{PRJNAME} as the @dfn{typed
language}.

To understand how @value{PRJNAME} represents the types of values, we
must remember that every Scheme expression might return multiple values;
so we can think of an expression evaluation as follows:

@lisp
(call-with-values
     (lambda () @meta{epxr})
  (lambda @meta{formals} @meta{body}))
@end lisp

@noindent
the return values of @meta{expr} are bound to the @meta{formals} and
used in the @meta{body}.  For example, in the code:

@lisp
(call-with-values
     (lambda () (values 1 2 3))
  (lambda (a b c) @meta{body}))
@end lisp

@noindent
while the expansion of @meta{body} takes place: a typed language would
annotate the syntactic bindings @code{a}, @code{b} and @code{c} with the
information that the values are fixnums.

The tuple of type annotations associated to the @meta{formals} is called
@dfn{type signature}; a type signature represents informations about
both the number of values and their type.  We need a type signature to
represent the types of values returned by an expression; more generally,
we need a type signature to represent the types of values returned by a
function application.  We need a type signature to represent the types
of the arguments accepted in a function application.

Given the @syntax{call-with-values} model of thinking to expressions
evaluations: the whole purpose of a typed language is to verify, at
expand--time, that the type signature of an expression matches the type
signature of the arguments of a function.

The standard language already mandates that the operands in a function
application must be validated at run--time; this means the type
signature of the operands is matched, at run--time, with the type
signature of the arguments.  The typed language extends this feature to
make it possible at expand--time.

Type annotations are not mandatory in the typed language, so some
operands are validated and others are not.

To understand the role of @value{PRJNAME}'s typed language extensions,
we have to consider that:

@itemize
@item
Standard Scheme is dynamically typed: language implementations might
perform application signatures validation at run--time every time a
function is called, considering that the return values of a function
application are discarded or become the arguments of another function
application.  For example the function @func{flsin} can be implemented
as:

@example
#!r6rs
(import (except (rnrs (6))
                flsin)
  (vicare system $flonums))

(define (flsin x)
  (assert (flonum? x))
  ($flsin x))
@end example

@item
It is possible to build a standard Scheme language implementation that
performs compile--time type inference; with such implementation:
occasionally the compiler can determine the type of operands and return
values and collapse multiple validations into a single one.  For
example:

@example
#!r6rs
(import (rnrs (6)))

(define (flsomething x)
  (values (flsin x) (flcos x) (fltan x)))
@end example

@noindent
can be transformed into (pseudo--code):

@example
#!r6rs
(import (rnrs (6))
  (vicare system $flonums))

(define (flsomething x)
  (assert (flonum? x))
  (values ($flsin x) ($flcos x) ($fltan x)))
@end example

@noindent
or automatically defined safe and unsafe variants of the same function:

@example
#!r6rs
(import (rnrs (6))
  (vicare system $flonums))

(define (flsomething x)
  (assert (flonum? x))
  ($flsomething x))

(define ($flsomething x)
  (values ($flsin x) ($flcos x) ($fltan x)))
@end example

@noindent
so that the unsafe @func{$flsomething} can be used later in place of the
safe @func{flsomething} if we know that the argument is a flonum.

@item
The evaluation of a Scheme language program or library is defined to
have two steps: expansion; compilation--and--evaluation or
interpretation.  Standard Scheme is a ``high--level language'' which is
transformed into a ``core language'' by the process of expansion; the
expander allows macros to implement customised high--level
transformations.  The core language expressions are handed to the
compiler or the interpreter.

@item
Type inference does not blend well with standard Scheme macro expansion;
it is, in general, impossible to infer the types of a macro use before
fully expanding it, or, in special cases, at least partially expanding
it.  True type inference can be performed on the core language that is
the result of fully expanding the standard language.  This means we
cannot integrate the powerful features of the expander in the code
resulting from transformations made possible by type inference.

@item
@value{PRJNAME} is a language dialect whose purpose is to be a standard
Scheme language with extensions; it allows mixed use of standard
language syntax and extended language syntax.  The language extensions
are mostly implemented in the expander, to allow user code to customise
the generation of core language.

@item
By explicitly specifying the types of lexical bindings:
@value{PRJNAME}'s dialect allows some of the expand--time validations
and transformations that would be possible in a language with full type
inference.
@end itemize

Since there is no type inference: the code writer is invited to
explicitly add type annotations to the syntaxes that establish syntactic
bindings.

@c page
@node types intro enabling
@subsection Enabling typed language extensions


Typed language extensions are @strong{off} by default.  To enable the
extensions we have to use the @code{typed-language} option as follows:

@itemize
@item
For libraries:

@lisp
(library (demo)
  (options typed-language)
  (export)
  (import (vicare))
  ---)
@end lisp

@noindent
@ref{iklib libraries options, typed-language}.

@item
For programs:

@lisp
(program (demo)
  (options typed-language)
  (import (vicare))
  ---)
@end lisp

@noindent
@ref{iklib programs options, typed-language}.
@end itemize

@noindent
we usually want to import the library @library{vicare} to use the
extended syntaxes that recognise type definitions and declarations.

We can use the function @func{typed-language-enabled?} to enable the
typed language at the @repl{}.

@c page
@node types intro type ids
@subsection Type identifiers


A @dfn{type identifier} is a bound syntactic identifier whose syntactic
binding's descriptor contains informations about the type's properties.
Examples of type identifiers are:

@itemize
@item
Struct--type name identifiers defined by @func{define-struct}; they are
automatically made type identifiers by @value{PRJNAME}.

@item
Record--type name identifiers defined by @func{define-record-type}; they
are automatically made type identifiers by @value{PRJNAME}.  Condition
object types (like @condition{i/o}) are special cases of these.

@item
The library @library{vicare} exports a set type identifiers (whose
implementation is integrated in @value{PRJNAME}'s expander) representing
the types of built--in objects.  Some of them are: @class{fixnum},
@class{string}, @class{vector}, @class{textual-input-port}.
@end itemize

Type identifiers are organised in a tree hierarchy, with subtypes
inheriting properties of supertypes; by convention, @class{top} is the
parent of all the type annotations, the root of the tree; @class{top}
has no parent.

Many predefined type identifiers have names enclosed in ``angular
parentheses'' @samp{< >}, but this is just a convention.  Any valid
Scheme symbol can be used as name for a type identifier.

@c page
@node types intro typed vars
@subsection Typed lexical variables


A @dfn{typed lexical variable}, shortly @dfn{typed variable}, is a bound
syntactic identifier whose syntactic binding's descriptor contains both
informations about a lexical variable and its type annotation.  Typed
variables are created by the built--in binding syntaxes @func{lambda},
@func{define}, @func{let}, @func{letrec}, @func{let-values}, et cetera.

An example of typed binding creation follows:

@example
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare)
  (define @{O <fixnum>@}
    123))
@end example

@noindent
the syntactic identifier @code{O} represents a typed variable with type
annotation @class{fixnum}.

At the time the typed variable's syntactic binding is established: the
type annotation must hold only already bound type identifiers.  So the
following program (where @samp{---} represents an unspecified form) is
correct because @objtype{duo} is bound before @var{O}:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))
  (define-record-type duo
    (fields one two))
  (define @{O duo@}
    ---))
@end lisp

@noindent
the follow program is @strong{not} correct:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))
  (define @{O duo@}
    ---)
  (define-record-type duo
    (fields one two)))
@end lisp

@noindent
and will cause an expand--time syntax violation.

@c page
@node types ann
@section Type annotations

Type annotations are special syntaxes that make use of the @func{brace}
syntax to associate a type specification to a lexical syntax
(@pxref{iklib syntaxes misc, brace}).  It works as follows:

@lisp
(define (brace O @aclass{fixnum})
  123)
@end lisp

@noindent
in which the variable @samp{O} is defined as having type @class{fixnum}.

@quotation
@strong{NOTE} To use the extensions in a friendly manner we need to put
the reader in @samp{#!vicare} mode, this way @func{brace} can be
inserted using actual brace characters:

@lisp
#!vicare
(define @braces{O @aclass{fixnum}}
  123)
@end lisp
@end quotation

@menu
* types ann inserting::         Inserting type annotations.
* types ann syntaxes::          The syntax of type annotations.
@end menu

@c page
@node types ann inserting
@subsection Inserting type annotations


Everywhere the name of a syntactic binding appears in binding position:
we can add a type annotation by wrapping the syntactic identifier in
braces and appending a type syntax.  With @syntax{let}--like syntaxes we
can do:

@lisp
(let ((@{a @aclass{fixnum}@} 1)
      (@{b @aclass{string}@} "ciao")
      (@{c @aclass{symbol}@} 'hello))
  (list a b c))
@end lisp

@noindent
with @syntax{lambda} and @syntax{case-lambda} syntaxes we can do:

@lisp
(lambda (@{a @aclass{fixnum}@} @{b @aclass{string}@})
  (list a b))

(case-lambda
  ((@{a @aclass{fixnum}@} @{b @aclass{string}@})
   (list a b))
  ((@{a @aclass{fixnum}@} @{b @aclass{string}@} @{c @aclass{symbol}@})
   (list a b c)))
@end lisp

@noindent
with @syntax{define} and @syntax{case-define} syntaxes we can do:

@lisp
(define (fun1 @{a @aclass{fixnum}@} @{b @aclass{string}@})
  (list a b))

(case-define fun2
  ((@{a @aclass{fixnum}@} @{b @aclass{string}@})
   (list a b))
  ((@{a @aclass{fixnum}@} @{b @aclass{string}@} @{c @aclass{symbol}@})
   (list a b c)))
@end lisp

When using the syntaxes @syntax{lambda}, @syntax{case-lambda},
@syntax{define}, @syntax{case-define}, @syntax{receive},
@syntax{let-values} and @syntax{let*-values} we can specify a ``rest''
argument that is bound to a list of the rest of the operands; this
syntactic binding can be annotated only with the type identifier
@class{list} or the type annotation @samp{(list-of @meta{type})}.  For
example:

@lisp
((lambda (@{a @aclass{fixnum}@} @{b @aclass{string}@} . @{rest (list-of @aclass{symbol})@})
   (vector a b rest))
 1 "ciao" 'x 'y 'z)
@result{} #(1 "ciao" (x y z))

((lambda @{args @aclass{list}@} args)
 1 2 3)
@result{} (1 2 3)

(receive (@{a @aclass{fixnum}@} @{b @aclass{string}@} . @{rest @aclass{list}@})
    (values 1 "ciao" 'x 'y 'z)
  rest)
@result{} (x y z)
@end lisp

@c page
@node types ann syntaxes
@subsection The syntax of type annotations


Type annotations are either standalone type identifiers like
@class{fixnum}, @class{string}, @condition{message} or compound type
syntaxes like the following:

@lisp
(pair      <fixnum> <string>)
(list      <fixnum> <string> <symbol>)
(vector    <fixnum> <string> <symbol>)
(pair-of   <fixnum>)
(list-of   <fixnum>)
(nelist-of <fixnum>)
(vector-of <fixnum>)
(hashtable <symbol> <string>)
(alist     <symbol> <string>)
(enumeration @metao{symbol} @meta{symbol} ...)
(condition &who &message &irritants)
(or    <false> <symbol> <string>)
(and   <exact> <positive>)
(not   <exact>)
(lambda (<fixnum>) => (<string>))
(case-lambda
  ((<fixnum>) => (<string>))
  ((<flonum>) => (<string>)))
(type-of @meta{expr})
@end lisp

@noindent
and others; compound type annotations can be nested at will:

@lisp
(or (list-of   <fixnum>)
    (vector-of <fixnum>))
@end lisp

For every type annotation: a parent type is documented, but the
super--type/sub--type relation is ``flexible''.  For example,
@syntax{list-of} and @syntax{list} annotations are both sub--types of
@class{list}; but it also stands that:

@lisp
(type-annotation-super-and-sub? (list-of <fixnum>)
                                (list <fixnum> <fixnum>))
@result{} #t

(type-annotation-super-and-sub? (list-of <fixnum>)
                                (list <fixnum> <string>))
@result{} #f
@end lisp


The following syntactic bindings are exported by @library{vicare}.


@deftp {Type Annotation} pair @meta{car-type} @meta{car-type}
@deftpx {Parent Type} @aclass{pair}
Describe a pair having car of type @meta{car-type} and cdr of type
@meta{car-type}.  Both @meta{car-type} and @meta{car-type} are nested
type annotations.

@lisp
(is-a? '(1 . 2.3) (pair <fixnum> <flonum>))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} list @metao{item-type} @meta{item-type} @dots{}
@deftpx {Parent Type} @aclass{list}
Describe a proper list holding a fixed number of items of the specified
types (in the given order).  Every @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '(1 2.3) (list <fixnum> <flonum>))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} vector @metao{item-type} @meta{item-type} @dots{}
@deftpx {Parent Type} @aclass{vector}
Describe a vector holding a fixed number of items of the specified types
(in the given order).  Every @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '#(1 2.3) (vector <fixnum> <flonum>))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} pair-of @meta{item-type}
@deftpx {Parent Type} @aclass{pair}
Describe a pair having both the car and cdr of type @meta{item-type}.
The syntax @meta{item-type} is a nested type annotation.

@lisp
(is-a? '(1 . 2) (pair-of <fixnum>))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} list-of @meta{item-type}
@deftpx {Parent Type} @aclass{list}
Describe a proper list holding any number of items (including zero) all
of the specified type.  The syntax @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '(1 2) (list-of <fixnum>))       @result{} #t
(is-a? '()    (list-of <fixnum>))       @result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} nelist-of @meta{item-type}
@deftpx {Parent Type} @aclass{pair}
Describe a proper non--empty list holding any number of items all of the
specified type.  The syntax @meta{item-type} is a nested type
annotation.  This type annotation is expanded to:

@lisp
(pair @meta{item-type} (list-of @meta{item-type}))
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} vector-of @meta{item-type}
@deftpx {Parent Type} @aclass{vector}
Describe a vector holding any number of items (including zero) all of
the specified type.  The syntax @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '#(1 2) (vector-of <fixnum>))    @result{} #t
(is-a? '#()    (vector-of <fixnum>))    @result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} hashtable @meta{key-type} @meta{value-type}
@deftpx {Parent Type} @aclass{hashtable}
Describe a hashtable having keys of type @meta{key-type} and values of
type @meta{value-type}.  Both @meta{key-type} and @meta{value-type} are
nested type annotations.
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} enumeration @metao{symbol} @meta{symbol} @dots{}
@deftpx {Parent Type} @aclass{symbol}
Describe an enumeration of symbols; it is used to match a symbol in a
specified enumeration set.

@lisp
(is-a? 'ciao (enumeration hello ciao salut ohayo))
@result{} #t

(is-a? 'blue (enumeration hello ciao salut ohayo))
@result{} #f
@end lisp

As special case, if we define an alias for an @syntax{enumeration} type
annotation: we can use such identifier to validate symbols.  Example:

@lisp
(define-type greetings
  (enumeration hello ciao salut ohayo))

(is-a? 'ciao greetings) @result{} #t
(greetings ciao)        @result{} ciao
(greetings blue)        @error{} symbol not in enumeration
@end lisp

The enumeration identifier is indeed used in the implementation of the
@syntax{define-enumeration} built--in syntax; @ref{stdlib enum,
define-enumeration}.

@lisp
(define-enumeration greetings
  (hello ciao salut ohayo)
  make-greetings)

(is-a? 'ciao greetings) @result{} #t
(greetings ciao)        @result{} ciao
(greetings blue)        @error{} symbol not in enumeration
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} alist @meta{key-type} @meta{value-type}
@deftpx {Parent Type} @aclass{list}
Describe an association list having keys of type @meta{key-type} and
values of type @meta{value-type}.  Both @meta{key-type} and
@meta{value-type} are nested type annotations.
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} condition @metao{cond-type} @meta{cond-type} @dots{}
@deftpx {Parent Type} @aclass{compound-condition}
Describe a compound condition object holding at least one instance of
the specified types (the order does not matter).  Every @meta{cond-type}
is a nested type annotation that must be one among: @class{condition},
@class{compound-condition}, a sub--type of @condition{condition}.

@lisp
(is-a? (condition (make-who-condition 'I)
                  (make-message-condition "hello"))
       (condition &who &message))
@result{} #t

(is-a? (condition (make-who-condition 'I)
                  (make-message-condition "hello"))
       (condition &message &who))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} lambda @meta{args-signature} => @meta{rv-signature}
@deftpx {Parent Type} @aclass{procedure}
Describe a sub--type of @class{procedure} having a single clause, like
procedures defined by @syntax{lambda}.  @syntax{=>} is the syntactic
binding exported by @rsixlibrary{base}.

The argument @meta{args-signature} must be a syntax object representing
the type signature of the procedure's arguments.  The argument
@meta{rv-signature} must be a syntax object representing the type
signature of the procedure's return values.
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} case-lambda @metao{clause} @meta{clause} @dots{}
@deftpx {Parent Type} @aclass{procedure}
Describe a sub--type of @class{procedure} having multiple clauses, like
procedures defined by @syntax{case-lambda}.  @syntax{=>} is the
syntactic binding exported by @rsixlibrary{base}.

Each @meta{clause} argument must have the format:

@example
(@meta{args-signature} => @meta{rv-signature})
@end example

@noindent
where: @meta{args-signature} must be a syntax object representing the
type signature of the clause's arguments; @meta{rv-signature} must be a
syntax object representing the type signature of the clause's return
values.
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} or @metao{type} @meta{type} @dots{}
@deftpx {Parent Type} @aclass{top}
Describe the union between the specified types.  Every @meta{type} is a
nested type annotation.  A value matches a union of types if its type
matches at least one of the union's types.

@lisp
(is-a? 1      (or <fixnum> <string>))   @result{} #t
(is-a? "ciao" (or <fixnum> <string>))   @result{} #t
(is-a? 1.23   (or <fixnum> <string>))   @result{} #f
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} and @metao{type} @meta{type} @dots{}
@deftpx {Parent Type} @aclass{top}
Describe the intersection between the specified types.  Every
@meta{type} is a nested type annotation.  A value matches an
intersection of types if its type matches all the intersection's types.

@lisp
(is-a? 1   (and <fixnum> <positive>))   @result{} #t
(is-a? 1.0 (and <exact>  <positive>))   @result{} #f
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} not @meta{type}
@deftpx {Parent Type} @aclass{top}
Describe the complement of the type.  The argument @meta{type} is a
nested type annotation.  A value of type @meta{val-type} matches the
complement of @meta{type} if @meta{val-type} is neither @meta{type} nor
a sub--type of @meta{type}.

@lisp
(is-a? 1   (not <string>))      @result{} #t
(is-a? 1.0 (not <fixnum>))      @result{} #f

;;If something is not a "<number>", for sure it is
;;not a "<fixnum>".
(type-annotation-super-and-sub? (not <fixnum>) (not <number>))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} parent-of @meta{type}
@deftpx {Parent Type} @aclass{top}
Describe the parent of the type; an exception is raised if the type has
no parent.  The argument @meta{type} is a nested type annotation.

@lisp
(type-annotation=? <struct> (parent-of <record>))
@result{} #t

(type-annotation=? <fixnum> (parent-of <positive-fixnum>))
@result{} #t

(type-annotation=? <positive-fixnum> (parent-of <fixnum>))
@result{} #f
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} ancestor-of @meta{type}
@deftpx {Parent Type} @aclass{top}
Describe the ancestors of the type; if the type has no parent: the list
of ancestors is empty.  The argument @meta{type} is a nested type
annotation and it is not included in its list of ancestors.

This type annotation can be used to match @strong{exactly} a type
annotation with one of the ancestors of @meta{type}:

@lisp
(type-annotation-matching (ancestor-of &condition)
                          &condition)
@result{} no-match

(type-annotation-matching (ancestor-of &condition)
                          <condition>)
@result{} exact-match

(type-annotation-matching (ancestor-of &condition)
                          <record>)
@result{} exact-match

(type-annotation-matching (ancestor-of &condition)
                          <struct>)
@result{} exact-match

(type-annotation-matching (ancestor-of &condition)
                          <top>)
@result{} exact-match

(type-annotation-matching <condition>
                          (ancestor-of &condition))
@result{} exact-match
@end lisp

When used along with @syntax{not}, it can is used to avoid matching
exactly a type annotation with one of the ancestors of @meta{type}:

@lisp
(type-annotation-matching (not (ancestor-of &condition))
                          <condition>)
@result{} no-match
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} type-predicate @meta{type}
A short--cut to specify:

@lisp
(lambda (@meta{type}) => (<true>))
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} equality-predicate @meta{type}
A short--cut to specify:

@lisp
(lambda (@meta{type} @meta{type}) => (<boolean>))
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} comparison-procedure @meta{type}
A short--cut to specify:

@lisp
(lambda (@meta{type} @meta{type}) => (<fixnum>))
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} hash-function @meta{type}
A short--cut to specify:

@lisp
(lambda (@meta{type}) => (<non-negative-fixnum>))
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} type-of @meta{expr}
Describe the type of @meta{expr}, which must be a Scheme expression.
The type signature of @meta{expr} must hold a single value.  The
expression is expanded and not evaluated; the side effects of the
expansion are performed, so this type annotation must be used with care.

@lisp
(type-annotation-syntax (type-of 123))
@result{} <positive-fixnum>

(type-annotation-syntax (type-of (void)))
@result{} <void>

(let ((fun (lambda () 123)))
  (type-annotation-syntax (type-of (fun))))
@result{} <positive-fixnum>

(type-annotation-syntax (or (type-of 1)
                            (type-of "ciao")
                            (type-of 'hey)))
@result{} (or <positive-fixnum> <string> (enumeration hey))
@end lisp

The expression is not allowed not to return:

@lisp
(type-annotation-syntax (type-of (error #f "error")))
@error{} &assertion
@end lisp

The expression is not allowed not return zero, two or more values:

@lisp
(type-annotation-syntax (type-of (values)))
@error{} &assertion

(type-annotation-syntax (type-of (values 1 2)))
@error{} &assertion

(type-annotation-syntax (type-of (values 1 2 3)))
@error{} &assertion
@end lisp

The expression is not allowed to return unspecified values:

@lisp
(letrec ((fun (lambda (@{_ . <list>@}) (fun))))
  (type-annotation-syntax (type-of (fun))))
@error{} &assertion
@end lisp

The expression is expanded in the current lexical environment for phase
zero, but with empty lexical environment for the other phases:

@lisp
(let-syntax ((outer (lambda (stx) 123)))
  (type-annotation-syntax (outer)))
@error{} identifier OUTER out of context

(let-syntax  ((outer (lambda (stx) 123)))
  (type-annotation-syntax
     (type-of (let-syntax ((inner (lambda (stx) (outer))))
                (inner)))))
@error{} identifier OUTER out of context
@end lisp
@end deftp

@c page
@node types descr
@section Type descriptors


@cindex @library{vicare system type-descriptors}, library
@cindex Library @library{vicare system type-descriptors}


Type descriptors are run--time objects that ``describe'' the
characteristics of object--types.  For example @rnrs{6} record--type
descriptors, @rnrs{6} record--constructor descriptors, @value{PRJNAME}'s
struct descriptors are all special cases of type descriptors.

Every expand-time type annotation has a corresponding run--time type
descriptor.  Usually we do not have to deal with type descriptors; so
most of the syntactic bindings are exported by the library
@library{vicare system type-descriptors}, while the public @api{} is
exported by @library{vicare}.

Whenever we need a type descriptor, we must use the syntax
@syntax{type-descriptor} or the function @func{type-descriptor-of}; we
should never call directly the constructors of the type descriptor
types.

@menu
* types descr retrieving::      Retrieving type descriptors.
* types descr core::            Core object-type descriptors.
* types descr compound::        Compound object-type descriptors.
* types descr other::           Other object-type descriptors.
* types descr signatures::      Type descriptor signatures.
* types descr relations::       Relations between type descriptors.
@end menu

@c page
@node types descr retrieving
@subsection Retrieving type descriptors


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-descriptor @meta{type-annotation}
Expand to an expression which, compiled and evaluated, results in the
type descriptor of the specified type annotation.

@lisp
(type-descriptor @aclass{fixnum})
@expansion{} @actdname{fixnum}

(type-descriptor (list @aclass{fixnum} @aclass{flonum}))
@expansion{} (make-list-type-descr (list @actdname{fixnum} @actdname{flonum}))
@end lisp

Internally, first an expand--time type specification is built; then the
type descriptor is built from the specification.
@end deffn


@defun type-descriptor-of @var{obj}
Return the type descriptor of @var{obj}.

@lisp
(type-descriptor-of +1)         @result{} @actdname{positive-fixnum}
(type-descriptor-of "ciao")     @result{} @actdname{nestring}
@end lisp
@end defun

@c page
@node types descr core
@subsection Core object--type descriptors


Core object--type descriptors gather the run--time characteristics of
object--types like fixnums and strings; for every core object--type
there is an already defined type descriptor, bound to a syntactic
binding exported by the library @library{vicare system
type-descriptors}.

Such syntactic binding have name derived from the type name by appending
@samp{-ctd} (where @samp{ctd} stands for Core Type Descriptor).  So the
type name @class{fixnum} has the associated type descriptor
@ctdname{fixnum}, the type name @class{string} has the associated type
descriptor @ctdname{string}, et cetera.

Some usage examples:

@lisp
(import (only (vicare system type-descriptors)
              @actdname{string}))

(type-descriptor @aclass{string})         @result{} @actdname{string}
(.name @actdname{string})               @result{} @aclass{string}
(.parent @actdname{string})             @result{} @actdname{top}

(.uids-list @actdname{string})
@result{} (vicare:core-type:@aclass{string} vicare:core-type:@aclass{top})

(let* ((retriever (.method-retriever <string>-ctd))
       (strlen    (retriever 'length)))
  (strlen "ciao"))
@result{} 4
@end lisp

The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{core-type-descriptor}
Type name for objects describing core object--types.  It has the
following immutable fields:

@table @code
@item name
A symbol representing the name of this type.  For example:
@samp{@aclass{string}}.

@item parent
If this type has a parent: an instance of @class{core-type-descriptor}
representing the parent of this type; otherwise @false{}.

@item type-predicate
@false{} or a function implementing the type predicate.

@item equality-predicate
@false{} or a function implementing the equality predicate.

@item comparison-procedure
@false{} or a function implementing the comparison procedure.

@item hash-function
@false{} or a function implementing the hash function.

@item uids-list
A list of symbols representing the hierarchy of unique identifiers
(@uid{}s) for this type.  The first item in the list is the @uid{} of
this type, then the parent's @uid{}, then the grandparent's @uid{}, et
cetera.

@item method-retriever
If this type has methods: a procedure to be applied to the method name
(a symbol) to retrieve the method implementation function; otherwise
@false{}.
@end table
@end deftp


@defun core-type-descriptor? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{core-type-descriptor}; otherwise return @false{}.
@end defun


@defun core-type-descriptor.name @var{ctd}
@defunx core-type-descriptor.parent @var{ctd}
@defunx core-type-descriptor.uids-list @var{ctd}
@defunx core-type-descriptor.type-predicate @var{ctd}
@defunx core-type-descriptor.equality-predicate @var{ctd}
@defunx core-type-descriptor.comparison-procedure @var{ctd}
@defunx core-type-descriptor.hash-function @var{ctd}
@defunx core-type-descriptor.method-retriever @var{ctd}
Accessors for the fields of @class{core-type-descriptor}.
@end defun

@defun core-type-descriptor.uid @var{ctd}
Return the @uid{} of the core--type descriptor @var{ctd}.
@end defun

@c page
@node types descr compound
@subsection Compound object-type descriptors


@menu
* types descr compound pair::      Pair type descriptors.
* types descr compound pair-of::   Pair-of type descriptors.
* types descr compound list::      List type descriptors.
* types descr compound list-of::   List-of type descriptors.
* types descr compound vector::    Vector type descriptors.
* types descr compound vector-of:: Vector-of type descriptors.
* types descr compound condobj::   Condition-object type descriptors.
* types descr compound enum::      Enumeration type descriptors.
* types descr compound hashtable:: Hashtable type descriptors.
* types descr compound alist::     Association list type descriptors.
* types descr compound closure::   Closure object type descriptors.
* types descr compound union::     Union type descriptors.
* types descr compound intersect:: Intersection type descriptors.
* types descr compound complem::   Complement type descriptors.
* types descr compound ancestor::  Ancestor-of type descriptors.
@end menu

@c page
@node types descr compound pair
@subsubsection Pair type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{pair-type-descr}
Name of type descriptors for pairs of heterogeneous values.  It has the
following fields:

@table @code
@item car-des
A type descriptor describing the type of the car.

@item cdr-des
A type descriptor describing the type of the cdr.
@end table
@end deftp


@defun make-pair-type-descr @var{car-des} @var{cdr-des}
Build and return a new instance of @class{pair-type-descr}.
@end defun


@defun pair-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of @class{pair-type-descr};
otherwise return @false{}.
@end defun


@defun pair-type-descr.car-des @var{des}
@defunx pair-type-descr.cdr-des @var{des}
Accessors for the fields of @class{pair-type-descr} instances.
@end defun

@c page
@node types descr compound pair-of
@subsubsection Pair-of type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{pair-of-type-descr}
Name of type descriptors for pairs of homogeneous values.  It has the
following fields:

@table @code
@item item-des
A type descriptor describing the type of the car and cdr.
@end table
@end deftp


@defun make-pair-of-type-descr @var{item-des}
Build and return a new instance of @class{pair-of-type-descr}.
@end defun


@defun pair-of-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{pair-of-type-descr}; otherwise return @false{}.
@end defun


@defun pair-of-type-descr.item-des @var{des}
Accessor for the field of @class{pair-of-type-descr} instances.
@end defun

@c page
@node types descr compound list
@subsubsection List type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{list-type-descr}
Name of type descriptors for lists of heterogeneous values.  It has the
following fields:

@table @code
@item item-des*
A list of type descriptors describing the types of the items.
@end table
@end deftp


@defun make-list-type-descr @var{des-list}
Build and return a new instance of @class{list-type-descr}.
@end defun


@defun list-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{list-type-descr}; otherwise return @false{}.
@end defun


@defun list-type-descr.item-des* @var{des}
Accessor for the field of @class{list-type-descr} instances.
@end defun


@defun list-type-descr.length @var{des}
Return the length of the list, a non--negative exact integer.
@end defun

@c page
@node types descr compound list-of
@subsubsection List-of type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{list-of-type-descr}
Name of type descriptors for lists of homogeneous values.  It has the
following fields:

@table @code
@item item-des
A type descriptor describing the type of the items.
@end table
@end deftp


@defun make-list-of-type-descr @var{item-des}
Build and return a new instance of @class{list-of-type-descr}.
@end defun


@defun list-of-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{list-of-type-descr}; otherwise return @false{}.
@end defun


@defun list-of-type-descr.item-des @var{des}
Accessor for the field of @class{list-of-type-descr} instances.
@end defun

@c page
@node types descr compound vector
@subsubsection Vector type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{vector-type-descr}
Name of type descriptors for vectors of heterogeneous values.  It has
the following fields:

@table @code
@item item-des*
A list of type descriptors describing the types of the items.
@end table
@end deftp


@defun make-vector-type-descr @var{des-list}
Build and return a new instance of @class{vector-type-descr}.
@end defun


@defun vector-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{vector-type-descr}; otherwise return @false{}.
@end defun


@defun vector-type-descr.item-des* @var{des}
Accessor for the field of @class{vector-type-descr} instances.
@end defun


@defun vector-type-descr.length @var{des}
Return the length of the vector, a non--negative exact integer.
@end defun

@c page
@node types descr compound vector-of
@subsubsection Vector-of type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{vector-of-type-descr}
Name of type descriptors for vectors of homogeneous values.  It has the
following fields:

@table @code
@item item-des
A type descriptor describing the type of the items.
@end table
@end deftp


@defun make-vector-of-type-descr @var{item-des}
Build and return a new instance of @class{vector-of-type-descr}.
@end defun


@defun vector-of-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{vector-of-type-descr}; otherwise return @false{}.
@end defun


@defun vector-of-type-descr.item-des @var{des}
Accessor for the field of @class{vector-of-type-descr} instances.
@end defun

@c page
@node types descr compound condobj
@subsubsection Condition-object type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{compound-condition-type-descr}
Name of type descriptors for compound condition objects.  It has the
following fields:

@table @code
@item component-des*
A list of type descriptors describing the types of the component
condition objects.
@end table
@end deftp


@defun make-compound-condition-type-descr @var{des-list}
Build and return a new instance of
@class{compound-condition-type-descr}.
@end defun


@defun compound-condition-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{compound-condition-type-descr}; otherwise return @false{}.
@end defun


@defun compound-condition-type-descr.component-des* @var{des}
Accessor for the field of @class{compound-condition-type-descr}
instances.
@end defun

@c page
@node types descr compound enum
@subsubsection Enumeration type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{enumeration-type-descr}
Name of type descriptors for symbols enumerations.  It has the following
fields:

@table @code
@item symbol*
A list of symbols representing the enumerated items.
@end table
@end deftp


@defun make-enumeration-type-descr @var{symbols}
Build and return a new instance of @class{enumeration-type-descr}.
@end defun


@defun enumeration-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{enumeration-type-descr}; otherwise return @false{}.
@end defun


@defun enumeration-type-descr.symbols* @var{des}
Accessor for the field of @class{enumeration-type-descr} instances.
@end defun

@c page
@node types descr compound hashtable
@subsubsection Hashtable type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{hashtable-type-descr}
Name of type descriptors for hashtables.  It has the following fields:

@table @code
@item key-des
A type descriptor describing the type of the keys.

@item val-des
A type descriptor describing the type of the values.
@end table
@end deftp


@defun make-hashtable-type-descr @var{key-des} @var{val-des}
Build and return a new instance of @class{hashtable-type-descr}.
@end defun


@defun hashtable-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{hashtable-type-descr}; otherwise return @false{}.
@end defun


@defun hashtable-type-descr.key-des @var{des}
@defunx hashtable-type-descr.val-des @var{des}
Accessors for the fields of @class{hashtable-type-descr} instances.
@end defun

@c page
@node types descr compound alist
@subsubsection Association list type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{alist-type-descr}
Name of type descriptors for association lists.  It has the following
fields:

@table @code
@item key-des
A type descriptor describing the type of the keys.

@item val-des
A type descriptor describing the type of the values.
@end table
@end deftp


@defun make-alist-type-descr @var{key-des} @var{val-des}
Build and return a new instance of @class{alist-type-descr}.
@end defun


@defun alist-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{alist-type-descr}; otherwise return @false{}.
@end defun


@defun alist-type-descr.key-des @var{des}
@defunx alist-type-descr.val-des @var{des}
Accessors for the fields of @class{alist-type-descr} instances.
@end defun

@c page
@node types descr compound closure
@subsubsection Closure object type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{closure-type-descr}
Name of type descriptors for closure objects.  It has the following
fields:

@table @code
@item signature
An instance of @class{case-lambda-descriptors} representing the type
signatures of the closure's clauses.
@end table
@end deftp


@defun make-closure-type-descr @var{signature}
Build and return a new instance of @class{closure-type-descr}.
@end defun


@defun closure-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{closure-type-descr}; otherwise return @false{}.
@end defun


@defun closure-type-descr.signature @var{des}
Accessor for the field of @class{closure-type-descr} instances.
@end defun

@c page
@node types descr compound union
@subsubsection Union type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{union-type-descr}
Name of type descriptors for unions of type descriptors.  It has the
following fields:

@table @code
@item item-des*
A list of type descriptors describing the types of the components.
@end table
@end deftp


@defun make-union-type-descr @var{des-list}
Build and return a new instance of @class{union-type-descr}.
@end defun


@defun union-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{union-type-descr}; otherwise return @false{}.
@end defun


@defun union-type-descr.item-des* @var{des}
Accessor for the field of @class{union-type-descr} instances.
@end defun

@c page
@node types descr compound intersect
@subsubsection Intersection type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{intersection-type-descr}
Name of type descriptors for intersections of type descriptors.  It has
the following fields:

@table @code
@item item-des*
A list of type descriptors describing the types of the components.
@end table
@end deftp


@defun make-intersection-type-descr @var{des-list}
Build and return a new instance of @class{intersection-type-descr}.
@end defun


@defun intersection-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{intersection-type-descr}; otherwise return @false{}.
@end defun


@defun intersection-type-descr.item-des* @var{des}
Accessor for the field of @class{intersection-type-descr} instances.
@end defun

@c page
@node types descr compound complem
@subsubsection Complement type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{complement-type-descr}
Name of type descriptors for the complement of a type descriptor.  It
has the following fields:

@table @code
@item item-des
The type descriptor to be complemented.
@end table
@end deftp


@defun make-complement-type-descr @var{des}
Build and return a new instance of @class{complement-type-descr}.
@end defun


@defun complement-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{complement-type-descr}; otherwise return @false{}.
@end defun


@defun complement-type-descr.item-des @var{des}
Accessor for the field of @class{complement-type-descr} instances.
@end defun

@c page
@node types descr compound ancestor
@subsubsection Ancestor-of type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{ancestor-of-type-descr}
Name of type descriptors representing the ancestors of a type
descriptor.  It has the following fields:

@table @code
@item item-des
The type descriptor of which we describe the ancestors.

@item ancestor-des*
List of type descriptors representing the ancestors.  The head of the
list is the parent type descriptor.
@end table
@end deftp


@defun make-ancestor-of-type-descr @var{des}
Build and return a new instance of @class{ancestor-of-type-descr}.
@end defun


@defun ancestor-of-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{ancestor-of-type-descr}; otherwise return @false{}.
@end defun


@defun ancestor-of-type-descr.item-des @var{des}
@defunx ancestor-of-type-descr.ancestor-des* @var{des}
Accessors for the fields of @class{ancestor-of-type-descr} instances.
@end defun

@c page
@node types descr other
@subsection Other object-type descriptors


@menu
* types descr other interface::         Interface type descriptors.
@end menu

@c page
@node types descr other interface
@subsubsection Interface type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{interface-type-descr}
Name of type descriptors representing interfaces.  It has the following
fields:

@table @code
@item type-name
A symbol representing the name of this interface type.

@item uid
A symbol acting as unique identifier associated to this type descriptor.

@item method-prototype-names
A list of symbols representing the names of the methods that must be
provided by object--types implementing this interface.

@item implemented-method-names
A list of symbols representing the names of te methods implemented by
this interface type (excluding the prototype names).

@item implemented-interface-uids
A list of symbols representing the @uid{}s of the interfaces implemented
by this interface--type.

@item method-retriever
A function that retrieves method implementation functions given the name
of a method as symbol.
@end table
@end deftp


@defun make-interface-type-descr @var{type-name} @var{method-retriever}
Build and return a new instance of @class{interface-type-descr}.
@end defun


@defun interface-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{interface-type-descr}; otherwise return @false{}.
@end defun


@defun interface-type-descr.type-name @var{des}
@defunx interface-type-descr.uid @var{des}
@defunx interface-type-descr.method-prototype-names @var{des}
@defunx interface-type-descr.implemented-method-names @var{des}
@defunx interface-type-descr.implemented-interface-uids @var{des}
@defunx interface-type-descr.method-retriever @var{des}
Accessors for the fields of @class{interface-type-descr} instances.
@end defun

@c page
@node types descr signatures
@subsection Type descriptor signatures


@menu
* types descr signatures descriptors::  Descriptors signatures.
* types descr signatures lambda::       Lambda signature descriptors.
* types descr signatures case-lambda::  Case-lambda signature descriptors.
@end menu

@c page
@node types descr signatures descriptors
@subsubsection Descriptors signatures


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{descriptors-signature}
Name of descriptors representing tuples of values signatures.  It has
the following fields:

@table @code
@item object-type-descrs
A proper or improper list of type descriptors representing the
signatures of lambda formals.
@end table
@end deftp


@defun make-descriptors-signature @var{descriptors}
Build and return a new instance of @class{descriptors-signature}.
@end defun


@defun descriptors-signature? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{descriptors-signature}; otherwise return @false{}.
@end defun


@defun descriptors-signature.object-type-descrs @var{des}
Accessor for the field of @class{descriptors-signature} instances.
@end defun

@c page
@node types descr signatures lambda
@subsubsection Lambda signature descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{lambda-descriptors}
Name of descriptors the type signature of single lambda clauses.  It has
the following fields:

@table @code
@item retvals
An instance of @class{descriptors-signature} representing the types of
values returned by this lambda clause.

@item argvals
An instance of @class{descriptors-signature} representing the types of
arguments expected by this lambda clause.
@end table
@end deftp


@defun make-lambda-descriptors @var{descriptors}
Build and return a new instance of @class{lambda-descriptors}.
@end defun


@defun lambda-descriptors? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{lambda-descriptors}; otherwise return @false{}.
@end defun


@defun lambda-descriptors.retvals @var{des}
@defunx lambda-descriptors.argvals @var{des}
Accessors for the fields of @class{lambda-descriptors} instances.
@end defun

@c page
@node types descr signatures case-lambda
@subsubsection Case-lambda signature descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{case-lambda-descriptors}
Name of descriptors representing the type signature of a tuple of lambda
clauses.  It has the following fields:

@table @code
@item clause-signature*
A list of @class{lambda-descriptors} representing the type signatures of
the clauses.
@end table
@end deftp


@defun make-case-lambda-descriptors @var{descriptors}
Build and return a new instance of @class{case-lambda-descriptors}.
@end defun


@defun case-lambda-descriptors? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{case-lambda-descriptors}; otherwise return @false{}.
@end defun


@defun case-lambda-descriptors.clause-signature* @var{des}
Accessor for the field of @class{case-lambda-descriptors} instances.
@end defun

@c page
@node types descr relations
@subsection Relations between type descriptors


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-descriptor-parent @meta{type-annotation}
Expand to an expression which, compiled and evaluated, returns the type
descriptor of the parent of the specified type annotation.

@lisp
(type-descriptor-parent @aclass{fixnum})
@result{} @actdname{fixnum}

(type-descriptor-parent (pair @aclass{fixnum} @aclass{flonum}))
@result{} @actdname{pair}

(define-record-type alpha)

(type-descriptor-parent alpha)  @result{} @actdname{record}

(define-record-type beta
  (parent alpha))

(type-descriptor-parent beta)
@expansion{} (record-type-descriptor alpha)
@end lisp
@end deffn


@deffn Syntax type-descriptor-ancestors @meta{type-annotation}
Expand to an expression which, compiled and evaluated, returns the list
of type descriptors representing the ancestors of the specified type
annotation.  The descriptor of the annotation itself is @strong{not}
included.

@lisp
(type-descriptor-ancestors @aclass{top})
@result{} ()

(type-descriptor-ancestors @aclass{string})
@result{} (@actdname{top})

(type-descriptor-ancestors @aclass{record})
@result{} (@actdname{struct} @actdname{top})

(type-descriptor-ancestors @aclass{nelist})
@result{} (@actdname{list} @actdname{top})
@end lisp
@end deffn


@deffn Syntax type-descriptor=? @metai{type-annotation} @metaii{type-annotation}
Expand to an expression which, compiled and evaluated, returns @true{}
if the type descriptors associated to the specified type annotations are
equal; otherwise it returns @false{}.

@lisp
(type-descriptor=? @aclass{top} @aclass{top})
@result{} #t

(type-descriptor=? @aclass{top} @aclass{number})
@result{} #f

(type-descriptor=? (pair @aclass{fixnum} @aclass{string})
                   (pair @aclass{fixnum} @aclass{string}))
@result{} #t
@end lisp
@end deffn


@deffn Syntax type-descriptor-super-and-sub? @metai{type-annotation} @metaii{type-annotation}
Expand to an expression which, compiled and evaluated, returns @true{}
if the type descriptor associated to @metai{type-annotation} is a
matching super--type of the type descriptor associated to
@metaii{type-annotation}; otherwise it returns @false{}.

@lisp
(type-descriptor-super-and-sub?
   @aclass{top} @aclass{top})
@result{} #t

(type-descriptor-super-and-sub?
   @aclass{top} @aclass{number})
@result{} #t

(type-descriptor-super-and-sub?
   @aclass{number} @aclass{top})
@result{} #t

;;this pair is a matching super-type of this list
(type-descriptor-super-and-sub?
   (pair @aclass{fixnum} @aclass{null}) (list @aclass{fixnum}))
@result{} #t
@end lisp
@end deffn


@deffn Syntax type-descriptor-matching @metai{type-annotation} @metaii{type-annotation}
Expand to an expression which, compiled and evaluated, matches the
arguments as if: the descriptor associated to @metai{type-annotation} is
the type of a formal argument requested by a closure object; the type
descriptor associated to @metaii{type-annotation} is the type of the
operand given to a closure object application.

Expand to a quoted symbol:

@table @code
@item exact-match
If there is an exact match between the argument's and operand's
annotations.

@item possible-match
If there is a possible match between the argument's and operand's
annotations; the operand must be further validated at run--time.

@item no-match
If there is no match between the argument's and operand's annotations.
@end table
@end deffn

@c page
@node types syntaxes
@section Type--exploiting syntaxes


@value{PRJNAME} allows us to perform some operations on objects through
generic syntaxes, provided that we use the type annotation.

Unless otherwise specified, the syntactic bindings documented in this
section are exported by the library @library{vicare}.  When showing code
examples, we always assume: to have imported the library
@library{vicare}; to have enabled the typed language; to have put the
Scheme source code reader in @code{#!vicare} mode.

@menu
* types syntaxes type-of::      Determining the type of expressions.
* types syntaxes types::        Defining type annotations.
* types syntaxes new-and-del::  Constructors and destructors.
* types syntaxes predicates::   Predicate syntaxes.
* types syntaxes annotations::  Operating on type annotations.
* types syntaxes signatures::   Operating on type signatures.
* types syntaxes assert::       Validating signatures.
* types syntaxes unsafe-cast::  Casting the type of expressions.
* types syntaxes case-type::    Branching on type of expression.
* types syntaxes variables::    Defining typed variables.
* types syntaxes overloads::    Overloaded functions.
* types syntaxes operations::   Miscellaneous operations.
@end menu

@c page
@node types syntaxes type-of
@subsection Determining the type of expressions


@deffn Syntax type-of @meta{expr}
Fully expand the given expression in the current lexical environment and
return a structure of type @class{type-signature} representing the types
of the tuple of returned values.  The expression is @strong{not}
evaluated, only expanded; this means that the expansion side effects are
performed.

Examples:

@example
(type-of (values))
@result{} #[signature ()]

(type-of (values 1 2))
@result{} #[signature (<positive-fixnum> <positive-fixnum>)]

(type-of 123)
@result{} #[signature (<positive-fixnum>)]

(type-of ((lambda (@{_ symbol@}) 'ciao)))
@result{} #[signature (<symbol>)]

(type-of (+ 1 2))
@result{} #[signature (<exact-integer>)]

(type-of (+ 1.2 2.3))
@result{} #[signature (<flonum>)]

(type-of (list 1 2.3))
@result{} #[signature ((list <positive-fixnum> <positive-flonum>))]

(type-of (condition (make-who-condition 'io)
                    (make-message-condition "ciao")))
@result{} #[signature ((condition &who &message))]
@end example
@end deffn


@deffn Syntax type-unique-identifiers @meta{type-name}
Expand into a list of symbols representing the type hierarchy of
@meta{type-name}, which must be a syntactic identifier bound to an
object type specification.

@lisp
(type-unique-identifiers <top>)
@result{} (vicare:scheme-type:<top>)

(type-unique-identifiers <string>)
@result{} (vicare:scheme-type:<string>
    vicare:scheme-type:<top>)

(type-unique-identifiers <condition>)
@result{} (vicare:scheme-type:<condition>
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(type-unique-identifiers <compound-condition>)
@result{} (vicare:scheme-type:<compound-condition>
    vicare:scheme-type:<condition>
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(type-unique-identifiers &condition)
@result{} (vicare:scheme-type:&condition
    vicare:scheme-type:<condition>
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(type-unique-identifiers &message)
@result{} (vicare:scheme-type:&message
    vicare:scheme-type:&condition
    vicare:scheme-type:<condition>
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(internal-body
  (define-struct duo
    (one two)
    (nongenerative yeah))
  (type-unique-identifiers duo))
@result{} (yeah
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(internal-body
  (define-record-type duo
    (nongenerative duo)
    (fields one two))
  (type-unique-identifiers duo))
@result{} (duo
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(internal-body
   (define-record-type alpha
     (nongenerative alpha))
   (define-record-type beta
     (parent alpha)
     (nongenerative beta))
   (type-unique-identifiers beta))
@result{} (beta
    alpha
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)
@end lisp
@end deffn

@c page
@node types syntaxes types
@subsection Defining type annotations


@defun make-type-annotation @var{annotation}
Build and return a new type annotation description object; expand to the
quoted type annotation object.  @var{annotation} must be a syntax object
representing the type annotation.

This function is exported by @library{vicare expander} and it allows us
to define type annotations as follows:

@lisp
(import (only (psyntax expander)
              make-type-annotation))

(let*-syntax ((<string1> (make-type-annotation #'<string>))
              (<string2> (make-type-annotation #'<string1>)))
  (is-a? "string" <string2>)    @result{} #t
  (is-a? 123      <string2>))   @result{} #f
@end lisp
@end defun


@deffn Syntax type-annotation @meta{annotation}
Build a new type annotation description object; expand to the quoted
type annotation object.  This syntax allows us to define type
annotations as follows:

@lisp
(let*-syntax ((<string1> (type-annotation <string>))
              (<string2> (type-annotation <string1>)))
  (is-a? "string" <string2>)    @result{} #t
  (is-a? 123      <string2>))   @result{} #f
@end lisp
@end deffn


@deffn Syntax define-type @meta{name} @meta{annotation}
Define a new type annotation bound to @meta{name}.  The argument
@meta{name} must be a syntactic identifier.  The argument
@meta{annotation} must be a type annotation syntax.

It is equivalent to:

@lisp
(define-syntax @meta{name}
  (type-annotation @meta{annotation}))
@end lisp
@end deffn

@c page
@node types syntaxes new-and-del
@subsection Constructors and destructors


The syntaxes @syntax{new} and @syntax{delete} allow us to retrieve the
constructor and destructor function of Scheme objects of some types.
For example, with records:

@lisp
(define-record-type duo
  (fields one two)
  (destructor-protocol
    (lambda ()
      (lambda (self)
        (fprintf (current-error-port) "destroying ~s\n" self)))))

(define O
  (new duo 1 2))

(delete O)
@print{} destroying #[record duo one=1 two=2]
@end lisp

@noindent
such syntaxes make it easier to code, for example, compensated
allocation of objects:

@lisp
(define (make-compensated-duo one two)
  (compensate
      (new duo one two)
    (with
      (delete <>))))
@end lisp

@noindent
where @syntax{<>} is the fluid syntax exported by @library{vicare} and
@syntax{compensate} binds it to the value returned by the allocation
form (@pxref{iklib compensations api, compensate}).

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax new @meta{type} @meta{arg} @dots{}
Retrieve the default constructor function of the type @var{type-name}
and apply it to the given arguments; return the result of the
application.
@end deffn


@deffn Syntax delete @meta{expr}
Retrieve the destructor function, if any, of the object returned by the
evaluation of the expression @meta{expr} and apply it to the object;
return the return value of the application.  The evaluation of
@meta{expr} must return a single return value.
@end deffn

@c page
@node types syntaxes predicates
@subsection Predicate syntaxes


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax is-a? @meta{expr} @meta{type}
@deffnx Syntax is-a? _ @meta{type}
@deffnx {Auxiliary Syntax} _
Expand to an expression which, when evaluated, returns @true{} if
@meta{expr} evaluates to a value of type @meta{type}.  @meta{expr} can
be any expression returning a single value.

When @syntax{_} is used as first argument: the syntax evaluates to a
predicate function.

@example
(define-record-type duo
  (fields one two))

(is-a? (new duo 1 2) two)       @result{} #t

((is-a? _ duo) (new duo 1 2))   @result{} #t

(is-a? 123 duo)                 @result{} #f

(is-a? '(1 2 3) (list <fixnum> <exact-integer> <number>))
@result{} #t
@end example
@end deffn

@c page
@node types syntaxes annotations
@subsection Operating on type annotations


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-annotation-syntax @meta{type}
Expand to a syntax object representing the type annotation of
@meta{type}.  If @meta{type} is a compound annotation (@syntax{or},
@syntax{and}, @syntax{condition}, @dots{}) some simplification may have
been applied to the input to produce the output.

@lisp
(type-annotation-syntax (or <fixnum> <bignum>))
@result{} (or <fixnum> <bignum>)

(type-annotation-syntax (or (enumeration hello salut)
                            (enumeration ciao)
                            (enumeration ohayo ciao)))
@result{} (enumeration hello salut ciao ohayo)
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-annotation=? @metai{type} @metaii{type}
Expand to a boolean constant: @true{} if @metai{type} is equal to
@metaii{type}; otherwise @false{}.

@lisp
(type-annotation=? <top>    <top>)              @result{} #t
(type-annotation=? <fixnum> <fixnum>)           @result{} #t
(type-annotation=? <fixnum> <positive-fixnum>)  @result{} #f

(internal-body
  (define-type <my-fixnum> <fixnum>)
  (type-annotation=? <fixnum> <my-fixnum>))     @result{} #t

(type-annotation=? (lambda (<fixnum>) => (<fixnum>))
                   (lambda (<fixnum>) => (<fixnum>)))
@result{} #t
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-annotation-super-and-sub? @metai{type} @metaii{type}
Expand to a boolean constant: @true{} if @metai{type} is a super--type
of @metaii{type}; otherwise @false{}.  The type @class{top} is
conventionally the super--type of all the types.

@lisp
(type-annotation-super-and-sub? <number> <fixnum>)  @result{} #t
(type-annotation-super-and-sub? <number> <string>)  @result{} #f
(type-annotation-super-and-sub? <top> <number>)     @result{} #t
(type-annotation-super-and-sub? <number> <top>)     @result{} #f

(expansion-of
  (type-annotation-super-and-sub? <number> <fixnum>))
@result{} (quote #t)

(expansion-of
  (type-annotation-super-and-sub? <number> <string>))
@result{} (quote #f)

(define-record-type alpha)

(define-record-type beta
  (parent alpha))

(define-record-type gamma
  (parent beta))

(type-annotation-super-and-sub? alpha beta)        @result{} #t
(type-annotation-super-and-sub? beta alpha)        @result{} #f

(type-annotation-super-and-sub? alpha gamma)       @result{} #t
(type-annotation-super-and-sub? gamma alpha)       @result{} #f

(type-annotation-super-and-sub? beta gamma)        @result{} #t
(type-annotation-super-and-sub? gamma beta)        @result{} #f
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-annotation-matching @metai{type} @metaii{type}
Match the two type annotations as if: @metai{type} is the type of an
argument requested by a closure object; @metaii{type} is the type of the
operand given to a closure object application.

Expand to a quoted symbol:

@table @code
@item exact-match
If there is an exact match between the argument's and operand's
annotation.

@item possible-match
If there is a possible match between the argument's and operand's
annotation; the operand must be further validated at run--time.

@item no-match
If there is no match between the argument's and operand's annotation.
@end table
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-annotation-common-ancestor @metai{type} @metaii{type}
Expand to a syntax object representing the type annotation that is the
common ancestor of @metai{type} and @metaii{type}.

@lisp
(type-annotation-common-ancestor <top> <top>)
@result{} #'<top>

(type-annotation-common-ancestor <top> <fixnum>)
@result{} #'<top>

(type-annotation-common-ancestor <fixnum> <top>)
@result{} #'<top>

(type-annotation-common-ancestor <fixnum> <flonum>)
@result{} #'<real>
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-annotation-ancestors @meta{type}
Expand to a (possibly empty) list of type annotations representing the
ancestors of @meta{type}.  @meta{type} is @strong{not} included.

@lisp
(type-annotation-ancestors <top>)       @result{} ()
(type-annotation-ancestors <void>)      @result{} ()
(type-annotation-ancestors <no-return>) @result{} ()

(type-annotation-ancestors <condition>)
@result{} (<record> <struct> <top>)

(type-annotation-ancestors <positive-fixnum>)
@result{} (<fixnum>
    <exact-integer> <integer> <rational> <rational-valued>
    <real> <real-valued> <complex> <number> <top>)
@end lisp
@end deffn

@c page
@node types syntaxes signatures
@subsection Operating on type signatures


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-signature-super-and-sub? @metai{signature} @metaii{signature}
Expand to a boolean constant: @true{} if @metai{signature} is a
super--signature of @metaii{signature}; otherwise @false{}.  The
arguments @meta{signature} must be proper or improper lists of type
annotations, with @class{list} or @samp{(list-of @meta{type})} in tail
position when the list is improper.

@lisp
(type-signature-super-and-sub? (<number>) (<fixnum>))  @result{} #t
(type-signature-super-and-sub? (<number>) (<string>))  @result{} #f

(expansion-of
  (type-signature-super-and-sub? (<number>) (<fixnum>))
@result{} (quote #t)

(expansion-of
  (type-signature-super-and-sub? (<number>) (<string>))
@result{} (quote #f)

(type-signature-super-and-sub? (<top>) (<number>))   @result{} #t
(type-signature-super-and-sub? (<number>) (<top>))   @result{} #f

(type-signature-super-and-sub? (<number> <number>)
                               (<fixnum> <fixnum>))
@result{} #t
(type-signature-super-and-sub? (<fixnum> <fixnum>)
                               (<number> <number>))
@result{} #f

(type-signature-super-and-sub? (<number> <number> . <list>)
                               (<fixnum> <real>   . <list>))
@result{} #t
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-signature-matching @meta{args-signature} @meta{rands-signature}
Match the two signatures as if: @meta{args-signature} is the type
signature of the arguments requested by a closure object;
@meta{rands-signature} is the type signature of the operands given to a
closure object application.

Expand to a quoted symbol:

@table @code
@item exact-match
If there is an exact match between the arguments' and operands'
signatures.

@item possible-match
If there is a possible match between the arguments' and operands'
signatures; the operands must be further validated at run--time.

@item no-match
If there is no match between the arguments' and operands' signatures.
@end table

@lisp
(type-signature-matching (<top>) (<void>))
@result{} no-match

(type-signature-matching (<void>) (<top>))
@result{} no-match

(type-signature-matching (<top>) (<fixnum>))
@result{} exact-match

(type-signature-matching (<fixnum>) (<positive-fixnum>))
@result{} exact-match

(type-signature-matching (<fixnum>) (<top>))
@result{} possible-match
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-signature-common-ancestor @metai{signature} @metaii{signature}
Expand to a syntax object representing the type signature that is the
common ancestor of @metai{signature} and @metaii{signature}.

@lisp
(type-signature-common-ancestor (<fixnum> <fixnum>)
                                (<flonum> <bignum>))
@result{} #'(<real> <exact-integer>)

(type-signature-common-ancestor (<fixnum> <fixnum> <string>)
                                (<flonum> <bignum>)
@result{} #'(<real> <exact-integer> . <list>)

(type-signature-common-ancestor (<fixnum> <fixnum>)
                                (<flonum> <bignum> <string>)
@result{} #'(<real> <exact-integer> . <list>)
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-signature-union @meta{type-signature} @dots{}
Compute the union between the given type signatures and expand to a
quoted symbolic expression representing the result.  Each
@meta{type-signature} argument must be a symbolic expression
representing a type signature.

@lisp
(type-signature-union)
@result{} <list>

(type-signature-union (<fixnum>) (<exact-integer>))
@result{} (<exact-integer>)

;;If a component is "<void>" the whole union between type
;;annotations becomes "<void>".
(type-signature-union (<fixnum>) (<void>))
@result{} (<void>)

;;If there are both "<true>" and "<false>": they are replaced with a
;;single "<boolean>".
(type-signature-union (<true>) (<false>))
@result{} (<boolean>)

;;Components of type "<no-return>" are discarded from the union.
(type-signature-union (<fixnum>) <no-return>)
@result{} (<fixnum>)

(type-signature-union (<fixnum> <string> <vector>)
                      (<fixnum> <string> <vector>))
@result{} (<fixnum> <string> <vector>)

(type-signature-union (<fixnum> <string> <vector>)
                      (<positive-fixnum> <string> <vector>))
@result{} (<fixnum> <string> <vector>)
@end lisp
@end deffn

@c page
@node types syntaxes assert
@subsection Validating signatures


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax assert-signature @meta{signature} @meta{expr}
@deffnx Syntax assert-signature-and-return @meta{signature} @meta{expr}
@deffnx Syntax cast-signature @meta{signature} @meta{expr}
Validate the type signature of the values returned by @meta{expr},
either at expand--time or run--time.  @meta{expr} can be any Scheme
expression.  @meta{signature} must be a proper or improper list of type
annotations representing the type signature.

The syntax @syntax{assert-signature} returns a single unspecified value.
The syntax @syntax{assert-signature-and-return} returns the return
values of @meta{expr} with the original type signature of @meta{expr}.
The syntax @syntax{cast-signature} returns the return values of
@meta{expr} with the type signature @meta{signature}.

@lisp
(type-of 1)
@result{} #[signature (<positive-fixnum>)]

(type-of (assert-signature-and-return (<top>) 123))
@result{} #[signature (<positive-fixnum>)]

(type-of (cast-signature (<top>) 123))
@result{} #[signature (<top>)]
@end lisp

If it is possible to validate the signature at expand--time: when
successful, the syntax use just expands to the evaluation of
@meta{expr}; when a type mismatch is detected, an expand--time exception
is raised.  Otherwise the syntax use expands to an expression that
validates the values at run--time.

As special cases, when @meta{signature} is @samp{()}, @samp{<no-return>}
a proper or improper list of @class{top} and @class{list} types like:

@lisp
<list>
(<top>)
(<top> <top> <top>)
(<top> <top> . <list>)
@end lisp

@noindent
no validation is performed at run--time, only at expand--time.
@end deffn


Here are some validation examples:

@lisp
(assert-signature () (values))
(assert-signature-and-return (<fixnum>) 123)    @result{} 123
(assert-signature-and-return (<string>) "ciao") @result{} "ciao"

(assert-signature-and-return (<fixnum> <flonum>) (values 1 2.0))
@result{} 1 2.0

(expansion-of
  (assert-signature (<fixnum>) 123))
@result{} (begin (quote 123) (quote #!void))

(expansion-of
  (assert-signature-and-return (<fixnum>) 123))
@result{} (quote 123)

(expansion-of
  (assert-signature-and-return (<fixnum>)
    (unsafe-cast-signature <fixnum> (read))))
@result{} ((primitive read))
@end lisp

There are some interesting special cases:

@itemize
@item
If we want to assert (at expand--time) that an expression returns zero
values, we can do:

@lisp
(assert-signature () @meta{expr})
@end lisp

@item
If we want to assert nothing, we can do:

@lisp
(assert-signature <list> @meta{expr})
@end lisp

@noindent
which will just expand to the evaluation of @meta{expr}; this might be
useful when the syntax is used in the output form of another macro use.

@item
If we want to assert (at expand--time) that an expression returns a
single value, of any type, we can do:

@lisp
(assert-signature (<top>) @meta{expr})
@end lisp

@item
If we want to assert (at expand--time) that an expression returns two
values, of any type, we can do:

@lisp
(assert-signature (<top> <top>) @meta{expr})
@end lisp

@item
If we want to assert (at expand--time) that an expression returns two or
more values, of any type, we can do:

@lisp
(assert-signature (<top> <top> . <list>) @meta{expr})
@end lisp
@end itemize

@c ------------------------------------------------------------------------

@subheading Expansion examples for run--time validation

Let's say we have a function @samp{fun} such that:

@lisp
(type-of (fun))
@result{} #[signature <list>]
@end lisp

@noindent
there is nothing the expander can do to infer the type signature of the
function application.

@c ------------------------------------------------------------------------

@subsubheading Example 1: multiple values and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (<fixnum> <flonum> <string>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(call-with-values
    (lambda () (fun))
  (lambda (arg1 arg2 arg3)
    (values ((lambda (obj value-index caller-who)
               (if (fixnum? obj)
                   obj
                 (expression-return-value-violation
                     caller-who
                   '"return value of invalid type"
                   value-index '(is-a? _ <fixnum>) obj)))
             arg1 '1 'assert-signature-and-return)
            ((lambda (obj value-index caller-who)
               (if (flonum? obj)
                   obj
                 (expression-return-value-violation
                     caller-who
                   '"return value of invalid type"
                   value-index '(is-a? _ <flonum>) obj)))
             arg2 '2 'assert-signature-and-return)
            ((lambda (obj value-index caller-who)
               (if (string? obj)
                   obj
                 (expression-return-value-violation
                     caller-who
                   '"return value of invalid type"
                   value-index '(is-a? _ <string>) obj)))
             arg3 '3 'assert-signature-and-return))))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 2: multiple values and no return values

The following syntax use:

@lisp
(assert-signature
    (<fixnum> <flonum> <string>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(call-with-values
    (lambda () (fun))
  (lambda (arg1 arg2 arg3)
    ((lambda (obj value-index caller-who)
       (if (not (fixnum? obj))
           (expression-return-value-violation
               caller-who '"return value of invalid type"
               value-index '(is-a? _ <fixnum>) obj)
         '#!void))
     arg1 '1 'assert-signature)
    ((lambda (obj value-index caller-who)
       (if (not (flonum? obj))
           (expression-return-value-violation
               caller-who '"return value of invalid type"
               value-index '(is-a? _ <flonum>) obj)
         '#!void))
     arg2 '2 'assert-signature)
    ((lambda (obj value-index caller-who)
       (if (not (string? obj))
           (expression-return-value-violation
               caller-who '"return value of invalid type"
               value-index '(is-a? _ <string>) obj)
         '#!void))
     arg3 '3 'assert-signature)
    (void)))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 3: list of values and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (list-of <fixnum>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
((lambda arg1
   (lambda (list-value first-value-index caller-who)
     (fold-left
         (lambda (item-index item-value)
           ((lambda (obj value-index caller-who)
              (if (not ((letrec
                            ((pred (lambda (obj)
                                     (if (pair? obj)
                                         (if (fixnum? (car obj))
                                             (pred (cdr obj))
                                           '#f)
                                       (null? obj)))))
                          pred)
                        obj))
                  (expression-return-value-violation caller-who
                    '"return value of invalid type"
                    value-index '(is-a? _ (list-of <fixnum>))
                    obj)
                '#!void))
            item-value item-index caller-who)
           (fxadd1 item-index))
       first-value-index list-value)
     list-value))
 (fun))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 5: multiple values and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (<fixnum> <flonum> . (list-of <fixnum>))
  (fun))
@end lisp

@noindent
is expanded to:

@smalllisp
(call-with-values
    (lambda () (fun))
  (lambda (arg1 arg2 . arg3)
    (apply values
           ((lambda (obj value-index caller-who)
              (if (fixnum? obj)
                  obj
                (expression-return-value-violation
                    caller-who
                  '"return value of invalid type"
                  value-index '(is-a? _ <fixnum>) obj)))
            arg1 '1 'assert-signature-and-return)
           ((lambda (obj value-index caller-who)
              (if (flonum? obj)
                  obj
                (expression-return-value-violation
                    caller-who
                  '"return value of invalid type"
                  value-index '(is-a? _ <flonum>) obj)))
            arg2 '2 'assert-signature-and-return)
           (lambda (list-value first-value-index caller-who)
             (fold-left
                 (lambda (item-index item-value)
                   ((lambda (obj value-index caller-who)
                      (if (not ((letrec
                                    ((pred (lambda (obj)
                                             (if (pair? obj)
                                                 (if (fixnum? (car obj))
                                                     (pred (cdr obj))
                                                   '#f)
                                               (null? obj)))))
                                  pred) obj))
                          (expression-return-value-violation
                              caller-who
                            '"return value of invalid type"
                            value-index
                            '(is-a? _ (list-of <fixnum>)) obj)
                        '#!void))
                    item-value item-index caller-who)
                   (fxadd1 item-index))
               first-value-index list-value)
             list-value)
           arg3 '3 'assert-signature-and-return)))
@end smalllisp

@c ------------------------------------------------------------------------

@subsubheading Example 5: single value and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (<fixnum>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
((lambda (arg1)
   ((lambda (obj value-index caller-who)
      (if (fixnum? obj)
          obj
        (expression-return-value-violation caller-who
          '"return value of invalid type"
          value-index '(is-a? _ <fixnum>) obj)))
    arg1 '1 'assert-signature-and-return))
 (fun))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 6: no validation and single return value

The following syntax use:

@lisp
(assert-signature-and-return
    (<top>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(fun)
@end lisp

@noindent
there is no need to insert a validation form because a single value of
any type matches the type signature.

@c ------------------------------------------------------------------------

@subsubheading Example 7: no validation and return values

The following syntax use:

@lisp
(assert-signature-and-return
    <list>
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(fun)
@end lisp

@noindent
there is no need to insert a validation form because any number of
return values of any type matches the type signature.

@c page
@node types syntaxes unsafe-cast
@subsection Casting the type of expressions


It is sometimes useful to explicitly declare the type signature of an
expression, so that the expander can perform more type checks and,
maybe, optimisations.  We might want to do it as an unsafe operation,
without introducing run--time validation of values.  For example, if we
know that the result of an expression is a vector of @math{3} fixnums,
we might write:

@lisp
($vector-ref @meta{expr} 1)
@end lisp

@noindent
and everything is all right, but we are not specifying that the return
value is a fixnum.

In these corner cases, we can use the syntax
@syntax{unsafe-cast-signature}: at expand--time, it tags an expression
as returning values of a specified type signature.  So, in the above
example, we could write:

@lisp
(unsafe-cast-signature (<fixnum>)
  ($vector-ref @meta{expr} 1))
@end lisp

We can easily check how @syntax{unsafe-cast-signature} works at the @repl{}:

@example
vicare> (unsafe-cast-signature (<fixnum>) 123)
$1 = 123
vicare> (expansion-of (unsafe-cast-signature (<fixnum>) 123))
$1 = '123
vicare> (type-of (unsafe-cast-signature (<fixnum>) 123))
$1 = #[signature (<fixnum>)]
@end example

@noindent
for a truly untyped expression:

@example
vicare> (expansion-of (unsafe-cast-signature (<fixnum>) (read)))
$1 = ((primitive read))
vicare> (type-of (unsafe-cast-signature (<fixnum>) (read)))
$1 = #[signature (<fixnum>)]
@end example

@noindent
if the type is incompatible, and we know it at expand--time:

@smallexample
vicare> (unsafe-cast-signature (<fixnum>) "ciao")
Unhandled exception
 Condition components:
   1. &who: unsafe-cast-signature
   2. &message: "expression type is incompatible with the requested tag"
   3. &syntax:
       form: #<syntax expr=(unsafe-cast-signature (<fixnum>) "ciao")>
       subform: #<syntax expr="ciao" mark*=(src)>
   4. &irritants: (#[signature (<string>)])
@end smallexample

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax unsafe-cast-signature @meta{signature} @meta{expr}
Expand to the @meta{expr} expression itself, but, in the expander, tag
the expression as returning a tuple of values with type signature
@meta{signature}.
@end deffn

@c page
@node types syntaxes case-type
@subsection Branching on type of expression


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax case-type @meta{expr} @metao{clause} @meta{clause} @dots{}
@deffnx {Auxiliary Syntax} =>
@deffnx {Auxiliary Syntax} else
Similar to @syntax{case} but branches based on the type of the single
value returned by @meta{expr}.  Each @meta{clause} must have one of the
formats:

@lisp
((@meta{type-id}) . @meta{body})
((@meta{type-id}) => @meta{receiver-expr})
(else . @meta{body})
@end lisp

@noindent
where: @meta{type-id} must be a type identifier; the @syntax{else}
clause is valid only as last clause; @meta{receiver-expr} must be an
expression evaluating to a closure object accepting a single argument.

Examples:

@lisp
(case-type 123
  ((<vector>)   'vector)
  ((<fixnum>)   'fixnum)
  ((<string>)   'string))
@result{} fixnum

(case-type 123
  ((<vector>)   'vector)
  ((<fixnum>)   => (lambda (arg) (list arg 'fixnum)))
  ((<string>)   'string)
  (else   'else))
@result{} (123 fixnum)

(case-type #t
  ((<vector>)   'vector)
  ((<fixnum>)   'fixnum)
  ((<string>)   'string)
  (else         'else))
@result{} else
@end lisp
@end deffn

@c page
@node types syntaxes variables
@subsection Defining typed variables


In all the following syntax definitions, we assume the following formats
for the input form components:

@lisp
@meta{standard-clause} ==
  | (@meta{formals} . @meta{body})

@meta{typed-clause} ==
  | (@meta{typed-clause-formals} . @meta{body})

@meta{typed-clause-formals} ==
  | @meta{typed-formals}
  | (@meta{anonymous-retvals} . @meta{typed-formals})

@meta{anonymous-retvals} ==
  | (brace _ @metao{rv-type} @meta{rv-type} ...)
  | (brace _ @meta{rv-type} ... . @meta{rest-rv-type})

@meta{typed-var} ==
  | @meta{name-id}
  | (brace @meta{name-id} @meta{type})

@meta{typed-who} ==
  | @meta{who-id}
  | (brace @meta{who-id} @metao{rv-type} @meta{rv-type} ...)
  | (brace @meta{who-id} @meta{rv-type} ... . @meta{rest-rv-type})

@meta{formals} ==
  | @meta{args-id}
  | (@meta{arg-id} ...)
  | (@meta{arg-id} @metao{arg-id} ... . @meta{args-id})

@meta{typed-formals} ==
  | @meta{typed-args}
  | (@meta{typed-arg} ...)
  | (@metao{typed-arg} @meta{typed-arg} ... . @meta{typed-rest})

@meta{typed-arg} ==
  | @meta{arg-id}
  | (brace @meta{arg-id} @meta{arg-type})

@meta{typed-args} ==
  | @meta{args-id}
  | (brace @meta{args-id} @meta{args-type})

@meta{typed-rest} ==
  | @meta{rest-id}
  | (brace @meta{rest-id} @meta{rest-type})
@end lisp

@noindent
where the following components are syntactic identifiers:

@lisp
@meta{name-id} @meta{who-id} @meta{arg-id} @meta{args-id} @meta{rest-id}
@end lisp

@noindent
the following components are type annotations:

@lisp
@meta{type} @meta{arg-type} @meta{rv-type}
@end lisp

@noindent
and the following components are type annotations that must represent
lists:

@lisp
@meta{args-type} @meta{rest-type} @meta{rest-rv-type}
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Standard syntaxes


@deffn Syntax define/std @meta{who-id}
@deffnx Syntax define/std @meta{who-id} @meta{expr}
@deffnx Syntax define/std (@meta{who-id} . @meta{formals}) . @meta{body}
This is the @syntax{define} syntax as defined by @rnrs{6}; whenever the
@syntax{define} syntactic binding is used in code with the typed
language @strong{disabled}: it expands into a use of
@syntax{define/std}.
@end deffn


@deffn Syntax case-define/std @meta{who-id} @metao{standard-clause} @meta{standard-clause} @dots{}
This is a @syntax{case-define} syntax compatible with the @rnrs{6}
language; whenever the @syntax{case-define} syntactic binding is used in
code with the typed language @strong{disabled}: it expands into a use of
@syntax{case-define/std}.
@end deffn


@deffn Syntax lambda/std @meta{formals} . @meta{body}
This is the @syntax{lambda} syntax as defined by @rnrs{6}; whenever the
@syntax{lambda} syntactic binding is used in code with the typed
language @strong{disabled}: it expands into a use of
@syntax{lambda/std}.
@end deffn


@c ------------------------------------------------------------------------

@subsubheading Checked syntaxes


@deffn Syntax define/checked @meta{typed-var}
@deffnx Syntax define/checked @meta{typed-var} @meta{expr}
@deffnx Syntax define/checked (@meta{typed-who} . @meta{typed-formals}) . @meta{body}
This is the @syntax{define} syntax that supports the typed language;
whenever the @syntax{define} syntactic binding is used in code with the
typed language @strong{enabled}: it expands into a use of
@syntax{define/checked}.

When defining a variable: the result of the expression is validated
either at expand--time or at run--time, to make sure that it matches the
type of the variable.  The expression's type must be a sub--type of the
variable's type.

When defining a function: the operands and return values are validated
either at expand--time or at run--time, to make sure that they match the
type of the function's type signature.  The operands' types must be
sub--types of the arguments' types; the return values' type must be
sub--types of the declared signature types.
@end deffn


@deffn Syntax case-define/checked @meta{who-id} @metao{typed-clause} @meta{typed-clause} @dots{}
This is a @syntax{case-define} variant that supports the typed language.
Operands and return values are validated either at expand--time or at
run--time, to make sure that they match the type signature.
@end deffn


@deffn Syntax lambda/checked @meta{typed-clause-formals} . @meta{body}
This is the @syntax{lambda} syntax that supports the typed language;
whenever the @syntax{lambda} syntactic binding is used in code with the
typed language @strong{enabled}: it expands into a use of
@syntax{lambda/checked}.

The operands and return values are validated either at expand--time and
at run--time, to make sure that they match the type of the function's
type signature.  The operands' types must be sub--types of the
arguments' types; the return values' type must be sub--types of the
declared signature types.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Typed syntaxes


@deffn Syntax define/typed @meta{typed-var}
@deffnx Syntax define/typed @meta{typed-var} @meta{expr}
@deffnx Syntax define/typed (@meta{typed-who} . @meta{typed-formals}) . @meta{body}
This is a @syntax{define} syntax variant that supports the typed
language.

When defining a variable: the result of the expression is validated only
at expand--time, to make sure that it matches the type of the variable.
The expression's type must be a sub--type of the variable's type.

When defining a function: the operands and return values are validated
only at expand--time, to make sure that they match the type of the
function's type signature.  The operands' types must be sub--types of
the arguments' types; the return values' type must be sub--types of the
declared signature types.
@end deffn


@deffn Syntax case-define/typed @meta{who-id} @metao{typed-clause} @meta{typed-clause} @dots{}
This is a @syntax{case-define} variant that supports the typed language.
Operands and return values are validated only expand--time, to make sure
that they match the type signature.
@end deffn


@deffn Syntax lambda/typed @meta{typed-clause-formals} . @meta{body}
This is a @syntax{lambda} syntax variant supports the typed language.

The operands and return values are validated only at expand--time, to
make sure that they match the type of the function's type signature.
The operands' types must be sub--types of the arguments' types; the
return values' type must be sub--types of the declared signature types.
@end deffn

@c page
@node types syntaxes overloads
@subsection Overloaded functions


@cindex Overloaded functions
@cindex Functions, overloaded


An overloaded function represents an aggregation of functions linked to
the same name and having different number and/or type of arguments.  For
example, in the code:

@lisp
(define/overload (fun @{O <fixnum>@})
  (list 'fixnum O))

(define/overload (fun @{O <string>@})
  (list 'string O))

(define/overload (fun @{A <vector>@} @{B <vector>@})
  (list 'vectors (vector-append A B)))

(fun 123)               @result{} (fixnum 123)
(fun "ciao")            @result{} (string "ciao")
(fun '#(1) '#(2))       @result{} (vectors #(1 2))
@end lisp

@noindent
an overloaded function named @func{fun} is defined by the first use of
@syntax{define/overload}; subsequent uses add new specialisations to the
same function.

In the above example: the selection of the specialised function happens
at expand--time, because the expander can determine the type of the
operands.  Early binding (more precisely: expand--time dispatching) is
available only with the ``canonical'' function application syntax:

@lisp
(@meta{fun} @meta{operand} ...)
@end lisp

Here is an example of late binding (more precisely: run--time
dispatching, or dynamic dispatching):

@lisp
(define/overload (doit @{O <string>@})
  (list 'string O))

(define/overload (doit @{O <fixnum>@})
  (list 'fixnum O))

(map doit '("ciao" 123))
@result{} ((string "ciao") (fixnum 123))
@end lisp

@noindent
putting the overloaded function's syntactic identifier in reference
position will reference a special function that implements dynamic
dispatching.

It is an error to define two specialised functions with the same formals
type signature.  Specialised functions are allowed to have different
type signatures for the returned values, but we should use this feature
with care; it is suggested not to abuse overloaded functions by adding
specialised functions that perform unrelated operations.

We can overload functions only in the same lexical context, the
following code will create @strong{two} functions:

@lisp
(define/overload (fun @{O <fixnum>@})
  ---)

(internal-body
  (define/overload (fun @{O <string>@})
    ---)
  ---)
@end lisp

We can define an overloaded function in a library and then add
specialised functions in a second library which depends on the first
one.

Whenever an overloaded function is applied to a tuple of operands: first
expand--time early binding is attempted; if it fails, run--time late
binding is attempted.  At expand--time:

@enumerate
@item
The expander determines the type of the operands, if it fails a syntax
violation is raised.

@item
The set of specialised functions is visited and the identifier of the
better matching one is inserted in the code to be applied to the
operands.  The return values of the specialised function will become the
return values of the overloaded function application.

@item
If no matching function is found: code performing late binding is
inserted.  If the option @option{-Woverloaded-function-late-binding} was
used: a @condition{warning} exception is raised signalling failure in
early binding.
@end enumerate

@noindent
At run--time:

@enumerate
@item
The type of the operands is determined using @func{type-descriptor-of},
@ref{types descr retrieving, type-descriptor-of}.

@item
The set of specialised functions is visited and the better matching one
is applied to the operands.  The return values of the specialised
function become the return values of the overloaded function
application.

@item
If no matching function is found: an exception is raised with type
@condition{overloaded-function-late-binding-error}, @ref{iklib
conditions late-bind overload}.
@end enumerate

Specialised functions are ranked to select the better matching.  At both
expand--time and run--time, ranking works by iterating a list of
specialised functions:

@enumerate
@item
Get the next function from the list.  When there are no more functions:
if a better matching function was selected, it becomes the one; if no
matching function was found, perform the default action.

@item
If the formals' type signature of the next function is a super--type of
the operands' type signature: the function is the ``next matching one'',
otherwise it is discarded and we iterate to step 1.

@item
If the next matching function is the first in the list: it becomes the
``current better matching'' and we iterate to step 1.

@item
If the formals' type signature of the next matching is a sub--type of
the formals' type signature of the better matching: the next matching
becomes the new better matching; otherwise the old better matching
stands.  We iterate to step 1.
@end enumerate

Here is an example that shows how ranking works:

@lisp
(define/overload (fun @{O <number>@})
  `(number ,O))

(define/overload (fun @{O <real>@})
  `(real ,O))

(define/overload (fun @{O <fixnum>@})
  `(fixnum ,O))

(fun 1+2i)      @result{} (number 1+2i)
(fun 3.4)       @result{} (real   3.4)
(fun 5)         @result{} (fixnum 5)
@end lisp

@noindent
notice that, at expand--time, only the operands' type signature seen by
the expander is the one that matters, with the same definitions above:

@lisp
(fun (cast-signature (<number>) 123))   @result{} (number 123)
(fun (cast-signature (<real>)   123))   @result{} (real   123)
(fun (cast-signature (<fixnum>) 123))   @result{} (fixnum 123)
@end lisp


@deffn Syntax define/overload (@meta{who} . @meta{formals}) . @meta{body}
@deffnx Syntax define/overload ((brace @meta{who} . @meta{rv-types}) . @meta{formals}) . @meta{body}
@deffnx {Auxiliary Syntax} brace
Define a specialisation for the overloaded function @meta{who}.  If this
is the first specialisation for @meta{who}, also define the overloaded
function; otherwise define only the specialisation and register it in
the already existent @meta{who}.

The syntax has the same format of @syntax{define/typed}, it defines a
function with type annotations for both the arguments and the return
values.  The function's type signature is used only at expand--time to
validate the type of the operands used in an application.
@end deffn

@c page
@node types syntaxes operations
@subsection Miscellaneous operations


@value{PRJNAME} allows us to specify special procedures for built--in
Scheme types, record types and label types; they are:

@table @strong
@item Type predicates
When applied to a value the type predicate returns @true{} if the value
matches the type; otherwise it returns @false{}.  It is always possible
to use the type predicate with the @syntax{is-a?} syntax, @pxref{types
syntaxes predicates, is-a?}.

@item Equality predicates
When applied to two values of the same type: the predicate returns
@true{} if the values are equal; otherwise it returns @false{}.

@item Comparison procedures
When applied to two values @var{A} and @var{B} of the same type, the
procedure returns a fixnum:

@table @samp
@item -1
If @var{A} is less than @var{B}.

@item 0
If @var{A} is equal to @var{B}.

@item +1
If @var{A} is greater than @var{B}.
@end table
@end table

The following syntactic bindings are exported by the library
@library{vicare}.


@defmac equality-predicate @meta{type}
Return a function that can be used as equality predicate between
instances of @meta{type}, which must be a type annotation.  If the type
has no equality predicate: raise a syntax violation.
@end defmac


@defmac comparison-procedure @meta{type}
Return a function that can be used as comparison procedure between
instances of @meta{type}, which must be a type annotation.  If the type
has no comparison procedure: raise a syntax violation.
@end defmac


@defmac hash-function @meta{type}
Return @false{} or a function that can be used as hash function for
instances of @meta{type}, which must be a type annotation.  If the type
has no hash function: raise a syntax violation.
@end defmac


@defmac hash @meta{expr}
When the expander succeeds in determining the type of @meta{expr} at
expand--time: if there is a single return value, expand into an
expression that computes and returns a hash value for the return value;
otherwise raise a syntax violation.

When the expander fails to determine the type of @meta{expr} at
expand--time: expand into an expression that attempts, at run--time, to
determine the type of the return value and compute and return a hash
value for it.

The hash function used by this syntax is:

@itemize
@item
For core object--types: the one hard--coded in the object--type
definition; for example: for fixnums it is @func{fixnum-hash}.

@item
For struct--types it is @func{struct-hash}.

@item
For record--types it is the one specified in the record--type definition
with the @syntax{hash-function} clause; when no hash function is
specified, @func{record-hash} is used.
@end itemize
@end defmac

@c page
@node types built-in
@section Built--in object types


The library @library{vicare} exports keyword syntactic bindings
representing the types of built--in objects: fixnum, strings, vectors,
et cetera.

@menu
* types built-in void::         Type of the void object.
* types built-in top::          The universal super-type.
* types built-in bottom::       The universal sub-type.
* types built-in booleans::     Type of boolean objects.
* types built-in chars::        Type of character objects.
* types built-in symbols::      Type of symbol objects.
* types built-in gensyms::      Type of gensym values.
* types built-in keywords::     Type of keyword objects.
* types built-in pointers::     Type of pointer objects.
* types built-in transcoders::  Type of transcoder objects.
* types built-in procedures::   Type of procedures objects.
* types built-in numerics::     Type of numeric objects.
* types built-in strings::      Type of string objects.
* types built-in vectors::      Type of vector objects.
* types built-in lists::        Type of list objects.
* types built-in pairs::        Type of pair objects.
* types built-in ipairs::       Type of immutable pair objects.
* types built-in bytevectors::  Type of bytevector objects.
* types built-in hashtables::   Type of hashtable objects.
* types built-in structs::      Type of struct objects.
* types built-in records::      Type of record objects.
* types built-in conditions::   Type of condition objects.
* types built-in ports::        Types of input/output ports.
* types built-in sentinel::     Type of sentinel object.
* types built-in misc::         Miscellaneous built-in types.
@end menu

@c page
@node types built-in void
@subsection The type of the void value


The type @class{void} is the type of the void object returned by
@func{void}.  We should never use @class{void} in a type annotation,
because the only legitimate use of the void object is as single return
value of functions returning ``unspecified values'' (under
@value{PRJNAME} returning a single value is faster than returning zero
values).  If we need a unique value: we should use the sentinel value
(@pxref{iklib sentinel, The sentinel object}).


@deftp {Core Type} @aclass{void}
The type of the void object.  @class{void} has no parent type.  The
union and intersection between @class{void} and any other type is
@class{void} itself.
@end deftp


@defop Constructor @class{void} new @aclass{void}
Return the void object.
@end defop


@defop {Type predicate} @class{void} is-a? @var{obj} @aclass{void}
The type predicate is @func{void-object?}.  Return @true{} if @var{obj}
is void; otherwise return @false{}.
@end defop

@c page
@node types built-in top
@subsection The universal super--type


@deftp {Core Type} @aclass{top}
The conventional parent of all the types, with the exception of
@class{void} and @class{no-return}.
@end deftp


@defop Constructor @class{top} new @aclass{top} @var{obj}
Return @var{obj} itself.
@end defop


@defop {Type predicate} @class{top} is-a? @var{obj} @aclass{top}
Always return @true{}.
@end defop

@c page
@node types built-in bottom
@subsection The universal sub--type


@deftp {Core Type} @aclass{bottom}
A conventional type that is the sub--type of all the other types.  We
must never use this type annotation for variables.

As usage example, the following type annotation defines a function
signature in which the argument can be any value:

@lisp
(define-type <my-func>
  (lambda (<bottom>) => (<string>)))
@end lisp

The expressions that raise a non--continuable exception have type
@class{bottom}:

@lisp
(type-of (error #f "wrong"))
@result{} #[signature <bottom>]
@end lisp

@noindent
notice that the type signature is the improper list @code{<bottom>},
@strong{not} the list @code{(<bottom>)}.

@class{bottom} is removed from union and intersection type annotations:

@lisp
(type-annotation (and <bottom> <fixnum>))
@result{} #[core-type-spec #[type (<fixnum>)]]

(type-annotation (or  <bottom> <fixnum>))
@result{} #[core-type-spec #[type (<fixnum>)]]
@end lisp
@end deftp

@c page
@node types built-in booleans
@subsection Type of boolean values


@deftp {Core Type} @aclass{boolean}
@deftpx {Parent Type} @aclass{top}
Type of the boolean values @true{} and @false{}.
@end deftp


@defop Constructor @class{boolean} new @aclass{boolean} @var{obj}
Return @true{} if @var{obj} is true; otherwise return @false{}.
@end defop


@defop {Type predicate} @class{boolean} is-a? @var{obj} @aclass{boolean}
The type predicate is @func{boolean?}.  Return @true{} if @var{obj} is
@true{} or @false{}; otherwise return @false{}.
@end defop

@c ------------------------------------------------------------------------

@deftp {Core Type} @aclass{true}
@deftpx {Parent Type} @aclass{boolean}
Type of the boolean value @true{}.  There is no constructor.  There is
no predicate.
@end deftp


@deftp {Core Type} @aclass{false}
@deftpx {Parent Type} @aclass{boolean}
Type of the boolean value @false{}.  There is no constructor.  There is
no predicate.
@end deftp

@c page
@node types built-in chars
@subsection Type of character values


@deftp {Core Type} @aclass{char}
@deftpx {Parent Type} @aclass{top}
Type of character values.
@end deftp


@defop Constructor @class{char} new @aclass{char} @var{obj}
The constructor is @func{integer->char}.
@end defop


@defop {Type predicate} @class{char} is-a? @var{obj} @aclass{char}
The type predicate is @func{char?}.  Return @true{} if @var{obj} is a
character object; otherwise return @false{}.
@end defop


@deftypemethod @class{char} @aclass{string} string @var{self}
Apply @func{string} to the instance.
@end deftypemethod


@deftypemethod @class{char} @aclass{fixnum} integer @var{self}
Apply @func{char->integer} to the instance.
@end deftypemethod


@deftypemethod @class{char} @aclass{fixnum} fixnum @var{self}
Apply @func{char->fixnum} to the instance.
@end deftypemethod

@c page
@node types built-in symbols
@subsection Type of symbol values


@deftp {Core Type} @aclass{symbol}
@deftpx {Parent Type} @aclass{top}
Type of symbol values (including gensyms).
@end deftp


@defop Constructor @class{symbol} new @aclass{symbol} @var{string}
The constructor is @func{string->symbol}.
@end defop


@defop {Type predicate} @class{symbol} is-a? @var{obj} @aclass{symbol}
The type predicate is @func{symbol?}.  Return @true{} if @var{obj} is a
symbol object; otherwise return @false{}.
@end defop


@deftypemethod @class{symbol} @aclass{string} string @var{self}
Apply @func{symbol->string} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{boolean} bound? @var{self}
Apply @func{symbol-bound?} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{top} value @var{self}
@deftypemethodx @class{symbol} @aclass{void} value @var{self} @var{new-value}
When called with no arguments: apply @func{symbol-value} to the instance
to retrieve the current value in the @code{value} slot.  When called
with one argument: apply @func{set-symbol-value!} to the instance to
store a new value @code{value} slot.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{void} putprop @var{self} (@var{key} @aclass{symbol}) @var{value}
Apply @func{putprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{top} getprop @var{self} (@var{key} @aclass{symbol})
Apply @func{getprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{void} remprop @var{self} (@var{key} @aclass{symbol})
Apply @func{remprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{list} property-list @var{self}
Apply @func{property-list} to the instance.
@end deftypemethod

@c page
@node types built-in gensyms
@subsection Type of gensym values


@deftp {Core Type} @aclass{gensym}
@deftpx {Parent Type} @aclass{symbol}
Type of gensym values.
@end deftp


@defop Constructor @class{gensym} new @aclass{gensym}
@defopx Constructor @class{gensym} new @aclass{gensym} @var{string}
@defopx Constructor @class{gensym} new @aclass{gensym} @var{symbol}
The constructor is @func{gensym}.
@end defop


@defop {Type predicate} @class{gensym} is-a? @var{obj} @aclass{gensym}
The type predicate is @func{gensym?}.  Return @true{} if @var{obj} is a
gensym object; otherwise return @false{}.
@end defop

@c page
@node types built-in keywords
@subsection Type of keyword values


@deftp {Core Type} @aclass{keyword}
@deftpx {Parent Type} @aclass{top}
Type of keyword values.
@end deftp


@defop Constructor @class{keyword} new @aclass{keyword} @var{symbol}
The constructor is @func{symbol->keyword}.
@end defop


@defop {Type predicate} @class{keyword} is-a? @var{obj} @aclass{keyword}
The type predicate is @func{keyword?}.  Return @true{} if @var{obj} is a
keyword object; otherwise return @false{}.
@end defop


@deftypemethod @class{keyword} @aclass{symbol} symbol @var{self}
Apply @func{keyword->symbol} to the instance.
@end deftypemethod


@deftypemethod @class{keyword} @aclass{string} string @var{self}
Apply @func{keyword->string} to the instance.
@end deftypemethod

@c page
@node types built-in pointers
@subsection Type of pointer values


@deftp {Core Type} @aclass{pointer}
@deftpx {Parent Type} @class{top}
Type of pointer values.
@end deftp


@defop Constructor @class{pointer} new @aclass{pointer} @var{int}
The constructor is @func{integer->pointer}.
@end defop


@defop {Type predicate} @class{pointer} is-a? @var{obj} @aclass{pointer}
The type predicate is @func{pointer?}.  Return @true{} if @var{obj} is a
pointer object; otherwise return @false{}.
@end defop


@deftypemethod @class{pointer} @aclass{boolean} null? @var{self}
Apply @func{pointer-null?} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{exact-integer} integer @var{self}
Apply @func{pointer->integer} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} = @var{self} @var{ptr} @dots{}
Apply @func{pointer=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} != @var{self} @var{ptr} @dots{}
Apply @func{pointer!=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} < @var{self} @var{ptr} @dots{}
Apply @func{pointer<?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} > @var{self} @var{ptr} @dots{}
Apply @func{pointer>?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} <= @var{self} @var{ptr} @dots{}
Apply @func{pointer<=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} >= @var{self} @var{ptr} @dots{}
Apply @func{pointer>=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} add @var{diff}
Apply @func{pointer-add} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} diff @var{self} @var{pointer}
Apply @func{pointer-diff} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} clone @var{self}
Apply @func{pointer-clone} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{void} set-null! @var{self}
Apply @func{set-pointer-null!)} to the instance.
@end deftypemethod

@c page
@node types built-in transcoders
@subsection Type of transcoder values


@deftp {Core Type} @aclass{transcoder}
@deftpx {Parent Type} @aclass{top}
Type of transcoder values.
@end deftp


@defop Constructor @class{transcoder} new @aclass{transcoder} @var{codec}
@defopx Constructor @class{transcoder} new @aclass{transcoder} @var{codec} @var{eol-style}
@defopx Constructor @class{transcoder} new @aclass{transcoder} @var{codec} @var{eol-style} @var{handling-mode}
The constructor is @func{make-transcoder}.
@end defop


@defop {Type predicate} @class{transcoder} is-a? @var{obj} @aclass{transcoder}
The type predicate is @func{transcoder?}.  Return @true{} if @var{obj}
is a transcoder object; otherwise return @false{}.
@end defop


@deftypemethod @class{transcoder} @aclass{symbol} codec @var{self}
Apply @func{transcoder-codec} to the instance.
@end deftypemethod


@deftypemethod @class{transcoder} @aclass{symbol} eol-style @var{self}
Apply @func{transcoder-eol-style} to the instance.
@end deftypemethod


@deftypemethod @class{transcoder} @aclass{symbol} handling-mode @var{self}
Apply @func{transcoder-error-handling-mode} to the instance.
@end deftypemethod

@c page
@node types built-in procedures
@subsection Type of procedures values


@deftp {Core Type} @aclass{procedure}
@deftpx {Parent Type} @aclass{top}
Type of closure object values.  There is no constructor.
@end deftp


@defop {Type predicate} @aclass{procedure} is-a? @var{obj} @aclass{procedure}
The type predicate is @func{procedure?}.  Return @true{} if @var{obj} is
a closure object; otherwise return @false{}.
@end defop


@deftp {Type Annotation} @aclass{thunk}
Type of procedures accepting no arguments.  The definition of this type
is equivalent to:

@lisp
(define-type <thunk>
  (lambda () => <list>))
@end lisp
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Type procedures

@deftp {Type Annotation} @aclass{type-predicate}
Type of procedures acting as type predicates.  The definition of this
type is equivalent to:

@lisp
(define-type <type-predicate>
  (lambda (<top>) => (<boolean>)))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{type-destructor}
Type of procedures acting as destructors for object of a specified type.
The definition of this type is equivalent to:

@lisp
(define-type <type-destructor>
  (lambda (<bottom>) => <list>))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{type-printer}
Type of procedures acting as custom printers for object of a specified
type.  The definition of this type is equivalent to:

@lisp
(define-type-annotation <type-printer>
  (lambda (<bottom> <textual-output-port> <procedure>) => <list>))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{equality-predicate}
Type of procedures acting as equality predicates.  The definition of
this type is equivalent to:

@lisp
(define-type <equality-predicate>
  (lambda (<bottom> <bottom>) => (<boolean>)))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{comparison-procedure}
Type of procedures acting as equality predicates.  The definition of
this type is equivalent to:

@lisp
(define-type <comparison-procedure>
  (lambda (<bottom> <bottom>) => (<fixnum>)))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{hash-function}
Type of procedures acting as equality predicates.  The definition of
this type is equivalent to:

@lisp
(define-type <hash-function>
  (lambda (<bottom>) => (<non-negative-fixnum>)))
@end lisp
@end deftp


@deftp {Type Annotation} @aclass{type-method-retriever}
Type of procedures acting as run--time method retriever for object of a
specified type.  The definition of this type is equivalent to:

@lisp
(define-type <type-method-retriever>
  (lambda (<symbol>) => ((or <false> <procedure>))))
@end lisp
@end deftp

@c page
@node types built-in numerics
@subsection Type of numeric values


@menu
* types built-in numerics number::           Type of number values.
* types built-in numerics complex::          Type of complex values.
* types built-in numerics real-valued::      Type of real-valued values.
* types built-in numerics real::             Type of real values.
* types built-in numerics rational-valued::  Type of rational-valued values.
* types built-in numerics rational::         Type of rational values.
* types built-in numerics integer-valued::   Type of integer-valued values.
* types built-in numerics integer::          Type of integer values.
* types built-in numerics exact-integer::    Type of exact-integer values.
* types built-in numerics fixnums::          Type of fixnum values.
* types built-in numerics bignums::          Type of bignum values.
* types built-in numerics flonums::          Type of flonum values.
* types built-in numerics ratnums::          Type of ratnum values.
* types built-in numerics compnums::         Type of compnum values.
* types built-in numerics cflonums::         Type of cflonum values.
* types built-in numerics bytes::            Type of byte values.
* types built-in numerics octets::           Type of octet values.
* types built-in numerics exactness::        Exactness of numeric values.
* types built-in numerics sign::             Sign of numeric values.
@end menu

@c page
@node types built-in numerics number
@subsubsection Type of number values


@deftp {Core Type} @aclass{number}
@deftpx {Parent Type} @aclass{top}
Type of numeric values.  There is no constructor.  The type predicate is
@func{number?}.
@end deftp

@c page
@node types built-in numerics complex
@subsubsection Type of complex values


@deftp {Core Type} @aclass{complex}
@deftpx {Parent Type} @aclass{number}
Type of complex numbers.  The constructor is @func{make-rectangular}.
The type predicate is @func{complex?}.
@end deftp

@c page
@node types built-in numerics real-valued
@subsubsection Type of real--valued values


@deftp {Core Type} @aclass{real-valued}
@deftpx {Parent Type} @aclass{complex}
Type of real--valued values.  There is no constructor.  The type
predicate is @func{real-valued?}.
@end deftp

@c page
@node types built-in numerics real
@subsubsection Type of real values


@deftp {Core Type} @aclass{real}
@deftpx {Parent Type} @aclass{real-valued}
Type of real values.  There is no constructor.  The type predicate is
@func{real?}.
@end deftp

@c page
@node types built-in numerics rational-valued
@subsubsection Type of rational--valued values


@deftp {Core Type} @aclass{rational-valued}
@deftpx {Parent Type} @aclass{real}
Type of rational--valued values.  There is no constructor.  The type
predicate is @func{rational-valued?}.
@end deftp

@c page
@node types built-in numerics rational
@subsubsection Type of rational values


@deftp {Core Type} @aclass{rational}
@deftpx {Parent Type} @aclass{rational-valued}
Type of rational values.  There is no constructor.  The type predicate
is @func{rational?}.
@end deftp


@deftp {Core Type} @aclass{exact-rational}
Type of exact rational values.  Its definition is equivalent to:

@lisp
(define-type <exact-rational>
  (or <exact-integer> <ratnum>))
@end lisp
@end deftp

@c page
@node types built-in numerics integer-valued
@subsubsection Type of integer--valued values


@deftp {Core Type} @aclass{integer-valued}
@deftpx {Parent Type} @aclass{rational-valued}
Type of integer--valued values.  There is no constructor.  The type
predicate is @func{integer-valued?}.
@end deftp

@c page
@node types built-in numerics integer
@subsubsection Type of integer values


Notice that @class{integer} is a @class{rational}, not a
@class{integer-valued}.


@deftp {Core Type} @aclass{integer}
@deftpx {Parent Type} @aclass{rational}
Type of integer values.  There is no constructor.  The type predicate is
@func{integer?}.
@end deftp

@c page
@node types built-in numerics exact-integer
@subsubsection Type of exact--integer values


@deftp {Core Type} @aclass{exact-integer}
@deftpx {Parent Type} @aclass{integer}
Type of exact integers.  There is no constructor.  The type predicate is
@func{exact-integer?}.
@end deftp


@deftp {Core Type} @aclass{non-negative-exact-integer}
Type of non--negative exact integers.  Its definition is equivalent to:

@lisp
(define-type <non-negative-exact-integer>
  (or <non-negative-fixnum> <positive-bignum>))
@end lisp
@end deftp


@deftp {Core Type} @aclass{positive-exact-integer}
Type of positive exact integers.  Its definition is equivalent to:

@lisp
(define-type <positive-exact-integer>
  (or <positive-fixnum> <positive-bignum>))
@end lisp
@end deftp


@deftp {Core Type} @aclass{negative-exact-integer}
Type of negative exact integers.  Its definition is equivalent to:

@lisp
(define-type <negative-exact-integer>
  (or <negative-fixnum> <negative-bignum>))
@end lisp
@end deftp

@c page
@node types built-in numerics fixnums
@subsubsection Type of fixnum values


@deftp {Core Type} @aclass{fixnum}
@deftpx {Parent Type} @aclass{exact-integer}
Type of fixnum values.  There is no constructor.  The type predicate is
@func{fixnum?}.
@end deftp


@deftp {Core Type} @aclass{positive-fixnum}
@deftpx {Parent Type} @aclass{fixnum}
Type of positive fixnum values.  There is no constructor.  The type
predicate is @func{positive-fixnum?}.
@end deftp


@deftp {Core Type} @aclass{negative-fixnum}
@deftpx {Parent Type} @aclass{fixnum}
Type of negative fixnum values.  There is no constructor.  The type
predicate is @func{negative-fixnum?}.
@end deftp


@deftp {Core Type} @aclass{zero-fixnum}
@deftpx {Parent Type} @aclass{fixnum}
Type of the zero fixnum value.  There is no constructor.  The type
predicate is @func{zero-fixnum?}.
@end deftp


@deftp {Core Type} @aclass{non-negative-fixnum}
Type of non--negative fixnum values.  Its definition is equivalent to:

@lisp
(define-type <non-negative-fixnum>
  (or <zero-fixnum> <positive-fixnum>))
@end lisp
@end deftp


@deftp {Core Type} @aclass{non-positive-fixnum}
Type of non--positive fixnum values.  Its definition is equivalent to:

@lisp
(define-type <non-positive-fixnum>
  (or <zero-fixnum> <negative-fixnum>))
@end lisp
@end deftp

@c page
@node types built-in numerics bignums
@subsubsection Type of bignum values


@deftp {Core Type} @aclass{bignum}
@deftpx {Parent Type} @aclass{exact-integer}
Type of bignum values.  There is no constructor.  The type predicate is
@func{bignum?}.
@end deftp


@deftp {Core Type} @aclass{positive-bignum}
@deftpx {Parent Type} @aclass{bignum}
Type of positive bignum values.  There is no constructor.  The type
predicate is @func{positive-bignum?}.
@end deftp


@deftp {Core Type} @aclass{negative-bignum}
@deftpx {Parent Type} @aclass{bignum}
Type of negative bignum values.  There is no constructor.  The type
predicate is @func{negative-bignum?}.
@end deftp

@c page
@node types built-in numerics flonums
@subsubsection Type of flonum values


@deftp {Core Type} @aclass{flonum}
@deftpx {Parent Type} @aclass{real}
Type of flonum values.  There is no constructor.  The type predicate is
@func{flonum?}.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Zero flonums


@deftp {Core Type} @aclass{zero-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of zero flonum values.  There is no constructor.  The type
predicate is @func{zero-flonum?}.
@end deftp


@deftp {Core Type} @aclass{positive-zero-flonum}
@deftpx {Parent Type} @aclass{zero-flonum}
Type of positive zero flonum values.  There is no constructor.  The type
predicate is @func{positive-zero-flonum?}.
@end deftp


@deftp {Core Type} @aclass{negative-zero-flonum}
@deftpx {Parent Type} @aclass{zero-flonum}
Type of negative zero flonum values.  There is no constructor.  The type
predicate is @func{negative-zero-flonum?}.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Positive and non--positive flonums

@deftp {Core Type} @aclass{positive-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of positive flonum values.  There is no constructor.  The type
predicate is @func{positive-flonum?}.
@end deftp


@deftp {Core Type} @aclass{non-positive-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of non--positive flonum values.  This type definition is equivalent
to:

@lisp
(define-type <non-positive-flonum>
  (or <negative-flonum> <zero-flonum>))
@end lisp
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Negative and non--negative flonums

@deftp {Core Type} @aclass{negative-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of negative flonum values.  There is no constructor.  The type
predicate is @func{negative-flonum?}.
@end deftp


@deftp {Core Type} @aclass{non-negative-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of non--negative flonum values.  This type definition is equivalent
to:

@lisp
(define-type <non-negative-flonum>
  (or <positive-flonum> <zero-flonum>))
@end lisp
@end deftp

@c page
@node types built-in numerics ratnums
@subsubsection Type of ratnum values


@deftp {Core Type} @aclass{ratnum}
@deftpx {Parent Type} @aclass{rational}
Type of ratnum values.  There is no constructor.  The type predicate is
@func{ratnum?}.
@end deftp


@deftp {Core Type} @aclass{positive-ratnum}
@deftpx {Parent Type} @aclass{ratnum}
Type of positive ratnum values.  There is no constructor.  The type
predicate is @func{positive-ratnum?}.
@end deftp


@deftp {Core Type} @aclass{negative-ratnum}
@deftpx {Parent Type} @aclass{ratnum}
Type of negative ratnum values.  There is no constructor.  The type
predicate is @func{negative-ratnum?}.
@end deftp

@c page
@node types built-in numerics compnums
@subsubsection Type of compnum values


@deftp {Core Type} @aclass{compnum}
@deftpx {Parent Type} @aclass{complex}
Type of compnum values.  There is no constructor.  The type predicate is
@func{compnum?}.
@end deftp


@deftp {Core Type} @aclass{exact-compnum}
@deftpx {Parent Type} @aclass{compnum}
Type of compnum values having exact real and imaginary parts.  There is
no constructor.  The type predicate is @func{exact-compnum?}.
@end deftp


@deftp {Core Type} @aclass{inexact-compnum}
@deftpx {Parent Type} @aclass{compnum}
Type of compnum values having inexact real and imaginary parts.  There
is no constructor.  The type predicate is @func{inexact-compnum?}.
@end deftp


@deftp {Core Type} @aclass{zero-compnum}
@deftpx {Parent Type} @aclass{inexact-compnum}
Type of compnum values having both the real part and imaginary part
equal to zero.  There is no constructor.  The type predicate is
@func{zero-compnum?}.

Remembering that a compnum with exact zero as imaginary part is
converted to a real number by @func{make-rectangular}:

@lisp
1+0i                    @result{} 1
(make-rectangular 1 0)  @result{} 1
@end lisp

@noindent
the compnums of type @class{zero-compnum} are the following:

@example
   0+0.0i    0-0.0i
+0.0+0.0i -0.0+0.0i
+0.0-0.0i -0.0-0.0i
@end example

@noindent
with the imaginary part always inexact.
@end deftp


@deftp {Core Type} @aclass{non-zero-inexact-compnum}
@deftpx {Parent Type} @aclass{inexact-compnum}
Type of inexact compnum values having either the real part or imaginary
part different from zero.  There is no constructor.  The type predicate
is @func{non-zero-inexact-cflonum?}.
@end deftp


@deftp {Core Type} @aclass{non-zero-compnum}
Type of compnum values having either the real part or imaginary part
different from zero.  Its definition is equivalent to:

@lisp
(define-type <non-zero-compnum>
  (or <exact-compnum> <non-zero-inexact-compnum>))
@end lisp
@end deftp

@c page
@node types built-in numerics cflonums
@subsubsection Type of cflonum values


@deftp {Core Type} @aclass{cflonum}
@deftpx {Parent Type} @aclass{complex}
Type of cflonum values.  There is no constructor.  The type predicate is
@func{cflonum?}.
@end deftp


@deftp {Core Type} @aclass{zero-cflonum}
@deftpx {Parent Type} @aclass{cflonum}
Type of cflonum values having both the real part and imaginary part
equal to zero.  There is no constructor.  The type predicate is
@func{zero-cflonum?}.
@end deftp


@deftp {Core Type} @aclass{non-zero-cflonum}
@deftpx {Parent Type} @aclass{cflonum}
Type of cflonum values having either the real part or imaginary part
different from zero.  There is no constructor.  The type predicate is
@func{non-zero-cflonum?}.
@end deftp

@c page
@node types built-in numerics bytes
@subsubsection Type of byte values


@deftp {Core Type} @class{byte}
@deftpx {Parent Type} @aclass{fixnum}
Type of byte values.  A ``byte'' is a fixnum in the range @math{[-128,
127]}.
@end deftp


@defop Constructor @class{byte} new @aclass{byte} @var{obj}
There is no constructor.  Validate @var{obj} as byte value and return
it.
@end defop


@defop {Type predicate} @class{byte} is-a? @var{obj} @aclass{byte}
The type predicate is @func{byte-fixnum?}.  Return @true{} if @var{obj}
is a byte value; otherwise return @false{}.
@end defop

@c page
@node types built-in numerics octets
@subsubsection Type of octet values


@deftp {Core Type} @class{octet}
@deftpx {Parent Type} @aclass{non-negative-fixnum}
Type of octet values.  An ``octet'' is a fixnum in the range @math{[0,
255]}.  There is no constructor.
@end deftp


@defop Constructor @class{byte} new @aclass{octet} @var{obj}
There is no constructor.  Validate @var{obj} as octet value and return
it.
@end defop


@defop {Type predicate} @class{octet} is-a? @var{obj} @aclass{octet}
The type predicate is @func{octet-fixnum?}.  Return @true{} if @var{obj}
is a octet value; otherwise return @false{}.
@end defop

@c page
@node types built-in numerics exactness
@subsubsection Exactness of values


@deftp {Core Type} @class{exact}
Type of exact numeric values.  Its definition is equivalent to:

@lisp
(define-type <exact>
  (or <exact-rational> <exact-compnum>))
@end lisp
@end deftp


@deftp {Core Type} @class{inexact}
Type of inexact numeric values.  Its definition is equivalent to:

@lisp
(define-type <inexact>
  (or <flonum> <cflonum> <inexact-compnum>))
@end lisp
@end deftp

@c page
@node types built-in numerics sign
@subsubsection Sign of numeric values


@deftp {Core Type} @class{positive}
Type of positive numeric values.  Its definition is equivalent to:

@lisp
(define-type <positive>
  (or <positive-fixnum> <positive-bignum>
      <positive-ratnum> <positive-flonum>))
@end lisp
@end deftp


@deftp {Core Type} @class{negative}
Type of negative numeric values.  Its definition is equivalent to:

@lisp
(define-type <negative>
  (or <negative-fixnum> <negative-bignum>
      <negative-ratnum> <negative-flonum>))
@end lisp
@end deftp


@deftp {Core Type} @class{non-negative}
Type of non--negative numeric values.  Its definition is equivalent to:

@lisp
(define-type <non-negative>
  (or <non-negative-fixnum> <positive-bignum> <positive-ratnum>
      <positive-flonum> <positive-zero-flonum>))
@end lisp
@end deftp


@deftp {Core Type} @class{non-positive}
Type of non--positive numeric values.  Its definition is equivalent to:

@lisp
(define-type <non-positive>
  (or <non-positive-fixnum> <negative-bignum> <negative-ratnum>
      <negative-flonum> <negative-zero-flonum>))
@end lisp
@end deftp


@deftp {Core Type} @class{zero}
Type of zero numeric values.  Its definition is equivalent to:

@lisp
(define-type <zero>
  (or <zero-fixnum>  <zero-flonum>
      <zero-compnum> <zero-cflonum>))
@end lisp
@end deftp

@c page
@node types built-in strings
@subsection Type of string values


@menu
* types built-in strings base::         Base string type.
* types built-in strings empty::        Empty string type.
* types built-in strings non-empty::    Non-empty string type.
@end menu

@c page
@node types built-in strings base
@subsubsection Base string type


@deftp {Core Type} @class{string}
@deftpx {Parent Type} @aclass{top}
Type of string values.
@end deftp


@defop Constructor @class{string} new @aclass{string} @var{char} @dots{}
The constructor is @func{string}.
@end defop


@defop {Type predicate} @class{string} is-a? @var{obj} @aclass{string}
The type predicate is @func{string?}.  Return @true{} if @var{obj} is a
string object; otherwise return @false{}.
@end defop

@c ------------------------------------------------------------------------

@subsubheading Inspection


@deftypemethod @class{string} @aclass{boolean} empty? @var{self}
Apply @func{string-empty?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} length @var{self}
Apply @func{string-length} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} for-each @var{self} @var{func} @var{str} @dots{}
Apply @func{string-for-each} to the function @var{func}, the instance
and the arguments.  Example:

@lisp
(.for-each "ciao" display)
@end lisp
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Constructors


@deftypemethod @aclass{string} copy @var{self}
Apply @func{string-copy} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} append @var{self}
Apply @func{string-append} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators


@deftypemethod @aclass{string} fill! @var{self} @var{char}
Apply @func{string-fill!} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Encoding inspection


@deftypemethod @aclass{string} ascii-encoded? @var{self}
Apply @func{ascii-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} latin1-encoded? @var{self}
Apply @func{latin1-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} octets-encoded? @var{self}
Apply @func{octets-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} uri-encoded @var{self}
Apply @func{uri-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} pencent-encoded? @var{self}
Apply @func{percent-encoded-string?} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Comparison


@deftypemethod @aclass{string} = @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} < @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} > @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} <= @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} >= @var{self} @var{str} @dots{}
Apply @func{string=?}, @func{string<?}, @func{string>?},
@func{string<=?}, @func{string>=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @aclass{string} ci= @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci< @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci> @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci<= @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci>= @var{self} @var{str} @dots{}
Apply @func{string-ci=?}, @func{string-ci<?}, @func{string-ci>?},
@func{string-ci<=?}, @func{string-ci>=?}, to the instance and the
arguments.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Case handling


@deftypemethod @aclass{string} titlecase @var{self}
Apply @func{string-titlecase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} upcase @var{self}
Apply @func{string-upcase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} downcase @var{self}
Apply @func{string-downcase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} foldcase @var{self}
Apply @func{string-foldcase} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Normalisation


@deftypemethod @aclass{string} normalize-nfc @var{self}
Apply @func{string-normalize-nfc} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfd @var{self}
Apply @func{string-normalize-nfd} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfkc @var{self}
Apply @func{string-normalize-nfkc} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfkd @var{self}
Apply @func{string-normalize-nfkd} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Conversion


@deftypemethod @aclass{string} flonum @var{self}
Apply @func{string->flonum} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} number @var{self}
@deftypemethodx @aclass{string} number @var{self} @var{radix}
Apply @func{string->number} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} utf8 @var{self}
Apply @func{string->utf8} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16 @var{self}
@deftypemethodx @aclass{string} utf16 @var{self} @var{endianness}
Apply @func{string->utf16} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} utf16be @var{self}
Apply @func{string->utf16be} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16le @var{self}
Apply @func{string->utf16le} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16n @var{self}
Apply @func{string->utf16n} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf32 @var{self}
@deftypemethodx @aclass{string} utf32 @var{self} @var{endianness}
Apply @func{string->utf32} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} bytevector @var{self}
@deftypemethodx @aclass{string} bytevector @var{self} @var{transcoder}
Apply @func{string->bytevector} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} ascii @var{self}
Apply @func{string->ascii} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} latin1 @var{self}
Apply @func{string->latin1} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} octets @var{self}
Apply @func{string->octets} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} percent-encoding @var{self}
Apply @func{string->percent-encoding} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} uri-encoding @var{self}
Apply @func{string->uri-encoding} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} base64->bytevector @var{self}
Apply @func{string-base64->bytevector} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} hex->bytevector @var{self}
Apply @func{string-hex->bytevector} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} symbol @var{self}
Apply @func{string->symbol} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} keyword @var{self}
Apply @func{string->keyword} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} list @var{self}
Apply @func{string->list} to the instance.
@end deftypemethod

@c page
@node types built-in strings empty
@subsubsection Empty string type


@deftp {Core Type} @aclass{empty-string}
@deftpx {Parent Type} @aclass{string}
Type of empty string values.
@end deftp

@c page
@node types built-in strings non-empty
@subsubsection Non--empty string type


@deftp {Core Type} @aclass{nestring}
@deftpx {Parent Type} @aclass{string}
Type of non--empty string values.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators

@deftypemethod @class{nestring} @aclass{top} ref @var{self} @var{idx}
Apply @func{string-ref} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{nestring} @aclass{void} set! @var{self} @var{idx} @var{obj}
Apply @func{string-set!} to the instance and the arguments.
@end deftypemethod

@c page
@node types built-in vectors
@subsection Type of vector values


@menu
* types built-in vectors base::         Base vector type.
* types built-in vectors empty::        Empty vector type.
* types built-in vectors non-empty::    Non-empty vector type.
@end menu

@c page
@node types built-in vectors base
@subsubsection Base vector type


@deftp {Core Type} @aclass{vector}
@deftpx {Parent Type} @aclass{top}
Type of vector values.
@end deftp


@defop Constructor @class{vector} new @aclass{vector} @var{obj} @dots{}
The constructor is @func{vector}.
@end defop


@defop {Type predicate} @class{vector} is-a? @var{obj} @aclass{vector}
The type predicate is @func{vector?}.  Return @true{} if @var{obj} is a
vector object; otherwise return @false{}.
@end defop

@c ------------------------------------------------------------------------

@subsubheading Inspection


@deftypemethod @class{vector} @aclass{non-negative-fixnum} length @var{self}
Apply @func{vector-length} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators

@deftypemethod @class{vector} @aclass{void} fill! @var{self} @var{obj}
Apply @func{vector-fill!} to the instance and the argument.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Other constructors


@deftypemethod @class{vector} @aclass{vector} subvector @var{self} @var{begin} @var{end}
Apply @func{subvector} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{vector} append @var{self} @var{vec} @dots{}
Apply @func{vector-append} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{vector} resize @var{self} @var{new-length}
@deftypemethodx @class{vector} @aclass{vector} resize @var{self} @var{new-length} @var{fill}
Apply @func{vector-resize} to the instance and the arguments.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Iteration and searching


@deftypemethod @class{vector} @aclass{vector} map @var{self} @var{proc} @var{vec} @dots{}
Apply @func{vector-map} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{void} for-each @var{self} @var{proc} @var{vec} @dots{}
Apply @func{vector-for-each} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} for-all @var{self} @var{proc} @var{vec} @dots{}
Apply @func{vector-for-all} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} exists @var{self} @var{proc} @var{vec} @dots{}
Apply @func{vector-exists} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} find @var{self} @var{proc}
Apply @func{vector-find} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} fold-left @var{self} @var{proc} @var{knil} @var{vec} @dots{}
Apply @func{vector-fold-left} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} fold-right @var{self} @var{proc} @var{knil} @var{vec} @dots{}
Apply @func{vector-fold-right} to the instance and the arguments.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Sorting


@deftypemethod @class{vector} @aclass{vector} sort @var{self} @var{proc}
@deftypemethodx @class{vector} @aclass{vector} sort! @var{self} @var{proc}
Apply @func{vector-sort} or @func{vector-sort!} to the instance and the
argument.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Conversion


@deftypemethod @class{vector} @aclass{list} list @var{self}
Apply @func{vector->list} to the instance.
@end deftypemethod

@c page
@node types built-in vectors empty
@subsubsection Empty vector type


@deftp {Core Type} @aclass{empty-vector}
@deftpx {Parent Type} @aclass{vector}
Type of empty vector values.
@end deftp

@c page
@node types built-in vectors non-empty
@subsubsection Non--empty vector type


@deftp {Core Type} @aclass{nevector}
@deftpx {Parent Type} @aclass{vector}
Type of non--empty vector values.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators

@deftypemethod @class{nevector} @aclass{top} ref @var{self} @var{idx}
Apply @func{vector-ref} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{nevector} @aclass{void} set! @var{self} @var{idx} @var{obj}
Apply @func{vector-set!} to the instance and the arguments.
@end deftypemethod

@c page
@node types built-in lists
@subsection Type of list objects


@menu
* types built-in lists base::       Base type of list objects.
* types built-in lists null::       Type of empty lists.
* types built-in lists non-empty::  Type of non-empty list objects.
@end menu

@c page
@node types built-in lists base
@subsubsection Base type of list objects


@deftp {Core Type} @aclass{list}
@deftpx {Parent Type} @aclass{top}
Type of lists, whatever their structure.  The fact that a list structure
is non--empty, non--circular, proper or improper must be checked at
run--time.
@end deftp


@defop Constructor @class{list} new @aclass{list} @var{obj} @dots{}
The constructor is @func{list}.  Return a new list having the given
@var{obj} arguments as items.
@end defop


@defop {Type predicate} @class{list} is-a? @var{obj} @aclass{list}
The type predicate is @func{list?}.  Return @true{} if @var{obj} is null
or a proper list object; otherwise return @false{}.
@end defop

@c page
@node types built-in lists null
@subsubsection Type of empty lists


@deftp {Core Type} @aclass{null}
@deftpx {Parent Type} @aclass{list}
Type of the null object.

The type @class{null} is special in that it is considered sub--type of
both the type @class{list} and the types defined with the annotations
@code{(list-of @meta{type})}.  Notice that types defined with the
annotations @code{(list @metao{type} @meta{type} ...)} are @strong{not}
super--types of @class{null}, because, by definition, they contain at
list one item.
@end deftp


@defop {Type predicate} @class{null} is-a? @var{obj} @aclass{null}
The type predicate is @func{null?}.  Return @true{} if @var{obj} is
null; otherwise return @false{}.
@end defop

@c page
@node types built-in lists non-empty
@subsubsection Type of non--empty list objects


@deftp {Core Type} @aclass{nelist}
@deftpx {Parent Type} @aclass{list}
Type of non--empty lists, whatever their structure.  The fact that a
list structure is non--circular, proper or improper must be checked at
run--time.
@end deftp


@defop Constructor @class{nelist} new @aclass{nelist} @varo{obj} @var{obj} @dots{}
Return a new list having the given @var{obj} arguments as items.
@end defop


@defop {Type predicate} @class{nelist} is-a? @var{obj} @aclass{nelist}
Return @true{} if @var{obj} is a non--empty proper list object;
otherwise return @false{}.
@end defop


@defmethod @class{nelist} car
Apply @func{car} to the type instance.
@end defmethod


@defmethod @class{nelist} cdr
Apply @func{cdr} to the type instance.
@end defmethod

@c page
@node types built-in pairs
@subsection Type of pair objects


@deftp {Core Type} @aclass{pair}
@deftpx {Parent Type} @aclass{list}
Type of pair objects.
@end deftp


@defop Constructor @class{pair} new @aclass{pair} @var{A} @var{D}
The constructor is @func{cons}.  Return a new pair having @var{A} and
@var{D} as car and cdr.
@end defop


@defop {Type predicate} @class{pair} is-a? @var{obj} @aclass{pair}
The type predicate is @func{pair?}.  Return @true{} if @var{obj} is a
pair object; otherwise return @false{}.
@end defop


@defmethod @class{pair} car
Apply @func{car} to the type instance.
@end defmethod


@defmethod @class{pair} cdr
Apply @func{cdr} to the type instance.
@end defmethod

@c page
@node types built-in ipairs
@subsection Type of immutable pair objects


@deftp {Core Type} @aclass{ipair}
@deftpx {Parent Type} @aclass{record}
Type of immutable pair objects.
@end deftp


@defop Constructor @class{ipair} new @aclass{ipair} @var{A} @var{D}
The constructor is @func{ipair}.  Return a new immutable pair having
@var{A} and @var{D} as car and cdr.
@end defop


@defop {Type predicate} @class{ipair} is-a? @var{obj} @aclass{ipair}
The type predicate is @func{ipair?}.  Return @true{} if @var{obj} is an
immutable pair object; otherwise return @false{}.
@end defop


@defmethod @class{ipair} car
Apply @func{icar} to the type instance.
@end defmethod


@defmethod @class{ipair} cdr
Apply @func{icdr} to the type instance.
@end defmethod

@c page
@node types built-in bytevectors
@subsection Type of bytevector objects


@deftp {Core Type} @aclass{bytevector}
@deftpx {Parent Type} @aclass{top}
Type of bytevector objects.  The constructor is @func{make-bytevector}.
The type predicate is @func{bytevector?}.
@end deftp


@deftp {Core Type} @aclass{empty-bytevector}
@deftpx {Parent Type} @aclass{bytevector}
Type of empty bytevector objects.
@end deftp


@deftp {Core Type} @aclass{nebytevector}
@deftpx {Parent Type} @aclass{bytevector}
Type of non--empty bytevector objects.
@end deftp

@c page
@node types built-in hashtables
@subsection Type of hashtable objects


@deftp {Core Type} @aclass{hashtable}
@deftpx {Parent Type} @aclass{top}
Base type for hashtable objects.  There is no constructor.  The type
predicate is @func{hashtable?}.
@end deftp


@deftp {Core Type} @aclass{hashtable-eq}
@deftpx {Parent Type} @aclass{hashtable}
Type of @func{eq?} hashtables.  The constructor is
@func{make-eq-hashtable}.  There type predicate is @func{hashtable-eq?}.
@end deftp


@deftp {Core Type} @aclass{hashtable-eqv}
@deftpx {Parent Type} @aclass{hashtable}
Type of @func{eqv?} hashtables.  The constructor is
@func{make-eqv-hashtable}.  There type predicate is @func{hashtable-eqv?}.
@end deftp


@deftp {Core Type} @aclass{hashtable-equal}
@deftpx {Parent Type} @aclass{hashtable}
Type of @func{equal?} hashtables.  The constructor is
@func{make-hashtable}.  There type predicate is @func{hashtable-equiv?}.
@end deftp

@c page
@node types built-in structs
@subsection Type of struct objects


@deftp {Core Type} @aclass{struct}
@deftpx {Parent Type} @aclass{top}
Type of struct objects.  There is no constructor.  The type predicate is
@func{struct?}.
@end deftp


@deftp {Core Type} @aclass{struct-type-descriptor}
@deftpx {Parent Type} @aclass{struct}
Type of struct--type descriptor objects.  The constructor is
@func{make-struct-type}.  The type descriptor is
@func{struct-type-descriptor?}.
@end deftp

@c page
@node types built-in records
@subsection Type of record objects


@deftp {Core Type} @aclass{record}
@deftpx {Parent Type} @aclass{struct}
Type of record objects.  There is no constructor.  The type predicate is
@func{record?}.
@end deftp


@deftp {Core Type} @aclass{record-type-descriptor}
@deftpx {Parent Type} @aclass{struct}
Type of record--type descriptor objects.  The constructor is
@func{make-record-type-descriptor}.  The type predicate is
@func{record-type-descriptor?}.
@end deftp


@deftp {Core Type} @aclass{record-constructor-descriptor}
@deftpx {Parent Type} @aclass{struct}
Type of record--constructor descriptor objects.  The constructor is
@func{make-record-constructor-descriptor}.  The type predicate is
@func{record-constructor-descriptor?}.
@end deftp

@c page
@node types built-in conditions
@subsection Type of condition objects


@deftp {Core Type} @aclass{condition}
@deftpx {Parent Type} @aclass{record}
Type of condition objects.  There is no constructor.  The type predicate
is @func{condition?}.
@end deftp


@deftp {Core Type} @aclass{compound-condition}
@deftpx {Parent Type} @aclass{condition}
Type of compound condition objects.  The constructor is
@func{condition}.  The type predicate is @func{compound-condition?}.
@end deftp


@defmethod @class{condition} print
@defmethodx @class{compound-condition} print
Apply @func{print-condition} to the instance.
@end defmethod

@c page
@node types built-in ports
@subsection Types of input/output ports


@menu
* types built-in ports base::            Base port types.
* types built-in ports textual in::      Textual input port types.
* types built-in ports textual out::     Textual output port types.
* types built-in ports textual in/out::  Textual input/output port types.
* types built-in ports binary in::       Binary input port types.
* types built-in ports binary out::      Binary output port types.
* types built-in ports binary in/out::   Binary input/output port types.
@end menu

@c page
@node types built-in ports base
@subsubsection Base port types


@deftp {Core Type} @aclass{port}
@deftpx {Parent Type} @aclass{top}
Base type for input, output and input/output ports.  There is no
constructor.  The type predicate is @func{port?}.
@end deftp


@deftp {Core Type} @aclass{input-port}
@deftpx {Parent Type} @aclass{port}
Base type for input ports.  There is no constructor.  The type predicate
is @func{input-port?}.
@end deftp


@deftp {Core Type} @aclass{output-port}
@deftpx {Parent Type} @aclass{port}
Base type for output ports.  There is no constructor.  The type
predicate is @func{output-port?}.
@end deftp


@deftp {Core Type} @aclass{input/output-port}
@deftpx {Parent Type} @aclass{port}
Base type for input/output ports.  There is no constructor.  The type
predicate is @func{input/output-port?}.
@end deftp


@deftp {Core Type} @aclass{textual-port}
Type of textual ports.  Its definition is equivalent to:

@lisp
(define-type <textual-port>
  (or <textual-input-port>
      <textual-output-port>
      <textual-input/output-port>))
@end lisp
@end deftp


@deftp {Core Type} @aclass{binary-port}
Type of binary ports.  Its definition is equivalent to:

@lisp
(define-type <binary-port>
  (or <textual-input-port>
      <textual-output-port>
      <textual-input/output-port>))
@end lisp
@end deftp

@c page
@node types built-in ports textual in
@subsubsection Textual input port types


@deftp {Core Type} @aclass{textual-input-port}
@deftpx {Parent Type} @aclass{input-port}
Type of textual input ports.  There is no constructor.  The type
predicate is @func{textual-input-port?}.
@end deftp

@c page
@node types built-in ports textual out
@subsubsection Textual output port types


@deftp {Core Type} @aclass{textual-output-port}
@deftpx {Parent Type} @aclass{output-port}
Type of textual output port.  There is no constructor.  The type
predicate is @func{textual-output-port?}.
@end deftp

@c page
@node types built-in ports textual in/out
@subsubsection Textual input/output port types


@deftp {Core Type} @aclass{textual-input/output-port}
@deftpx {Parent Type} @aclass{input/output-port}
Type of textual input/output ports.  There is no constructor.  The type
predicate is @func{textual-input/output-port?}.
@end deftp

@c page
@node types built-in ports binary in
@subsubsection Binary input port types


@deftp {Core Type} @aclass{binary-input-port}
@deftpx {Parent Type} @aclass{input-port}
Type of binary input ports.  There is no constructor.  The type
predicate is @func{binary-input-port?}.
@end deftp

@c page
@node types built-in ports binary out
@subsubsection Binary output port types


@deftp {Core Type} @aclass{binary-output-port}
@deftpx {Parent Type} @aclass{output-port}
Type of binary output ports.  There is no constructor.  The type
predicate is @func{binary-output-port?}.
@end deftp

@c page
@node types built-in ports binary in/out
@subsubsection Binary input/output port types


@deftp {Core Type} @aclass{binary-input/output-port}
@deftpx {Parent Type} @aclass{input/output-port}
Type of binary input/output ports.  There is no constructor.  The type
predicate is @func{binary-input/output-port?}.
@end deftp

@c page
@node types built-in sentinel
@subsection Type of sentinel object


@deftp {Built-in Type} @aclass{sentinel}
@deftpx {Parent Type} @aclass{struct}
Type of the sentinel object (@pxref{iklib sentinel, The sentinel
object}).
@end deftp


@defop Constructor @class{sentinel} new @aclass{sentinel}
The constructor is @func{sentinel}.  Return the sentinel object.
@end defop


@defop {Type predicate} @class{sentinel} is-a? @var{obj} @aclass{sentinel}
The type predicate is @func{sentinel?}.  Return @true{} if @var{obj} is
the sentinel object; otherwise return @false{}.
@end defop

@c page
@node types built-in misc
@subsection Miscellaneous built-in types


@deftp {Built--In Type} @class{&who-value}
The type of the field in the built--in condition object type
@condition{who}.  Its definition is equivalent to:

@lisp
(define-type <&who-value>
  (or <false> <symbol> <string>))
@end lisp
@end deftp


@deftp {Built--In Type} @class{file-descriptor}
The type of file descriptor values.  Its definition is equivalent to:

@lisp
(define-type <file-descriptor>
  <non-negative-fixnum>)
@end lisp
@end deftp

@c page
@node types void
@section Handling of void


Expressions of type @class{void} are deprecated as operands in function
applications and forbidden in logic predicates.  For example:

@lisp
(display (vector-set! (vector 1) 0 2))
@end lisp

@noindent
raises a warning because @func{vector-set!} returns the void value.  The
type @class{void} has no parent (it is @strong{not} a sub--type of
@class{top}) and it should be like not--a--number for numeric
computations.  Here are some consequences:

@itemize
@item
Composing @class{void} with other types results in void:

@lisp
(type-annotation-syntax (or <fixnum> <void>))
@result{} <void>

(type-annotation-syntax (and <fixnum> <void>))
@result{} <void>

(type-annotation-syntax (not <void>))
@result{} <void>
@end lisp

@item
A void expression as operand of @syntax{and}, @syntax{or}, @syntax{xor}
and test of @syntax{if} will cause an expand--time syntax violation.

@item
A void expression as operand of @syntax{not} will cause an expand--time
syntax violation if the expander can determine the type of the operand.

@item
Remembering that @syntax{cond} and @syntax{case} return void when no
@clause{else} clause is present and no clause matches: when
@syntax{cond} or @syntax{case} are used as operands, an @syntax{else}
clause is mandatory.

@item
Remembering that @syntax{when} and @syntax{unless} return void when the
body is not evaluated: @syntax{when} and @syntax{unless} cannot be used
as operands.

@item
The syntax @syntax{set!} cannot be used as operand.
@end itemize

The only function that is allowed to have a void operand is the core
primitive @func{void-object?}.

@c page
@node types methods
@section Methods and virtual methods


@cindex Methods
@cindex Concrete methods
@cindex Virtual methods
@cindex Sealing methods
@cindex @clause{method}, record--type definition clause
@cindex @clause{method}, label--type definition clause
@cindex @clause{method}, interface--type definition clause
@cindex @clause{method}, mixin definition clause
@cindex @clause{virtual-method}, record--type definition clause
@cindex @clause{virtual-method}, mixin definition clause
@cindex @clause{seal-method}, record--type definition clause
@cindex @clause{seal-method}, mixin definition clause


Methods are possibly overloaded typed functions whose syntactic binding
resides in a namespace reserved to an object--type and that are
accessible only through an instance of such object--type.

The syntactic bindings @clause{method}, @clause{virtual-method} and
@clause{seal-method} are used as clause keywords in uses of
@syntax{define-record-type} to define methods and virtual methods for a
record--type; they can be used any number of times in the same
@syntax{define-record-type} macro use.

The clause @clause{method} is also accepted by
@syntax{define-label-type}, @syntax{define-interface-type} and
@syntax{define-mixin-type}.

The clauses @clause{virtual-method} and @clause{seal-method} are also
accepted by @syntax{define-mixin-type}.

@menu
* types methods concrete::      Concrete methods.
* types methods virtual::       Virtual methods.
* types methods sealing::       Sealing methods.
* types methods calling::       Calling object-type methods.
@end menu

@c page
@node types methods concrete
@subsection Concrete methods


We can think of @clause{method} as acting like @syntax{define/checked}
with regard to the syntax of arguments to function; the first argument
to a method is the record itself, but it is implicit: we can access it
using the fluid syntax @syntax{this}.  For example, using the procedural
coding style:

@lisp
(define-record-type <duo>
  (strip-angular-parentheses)
  (fields one two)
  (method (sum-them)
    (+ (duo-one this)
       (duo-two this)))
  (method (mul-them)
    (* (duo-one this)
       (duo-two this))))

(define O
  (make-duo 1 2))

(method-call sum-them O)        @result{} 3
@end lisp

@noindent
and using the object--oriented syntax style:

@lisp
(define-record-type <duo>
  (fields one two)
  (method (sum-them)
    (+ (.one this)
       (.two this)))
  (method (mul-them)
    (* (.one this)
       (.two this))))

(define O
  (new <duo> 1 2))

(.sum-them O)   @result{} 3
@end lisp

The syntax @syntax{method-call} searches for a record--type's methods by
using @func{eq?} to search for the method's name, as symbol, in the
record--type's internal table of methods (it does @strong{not} use the
syntactic identifiers with @func{free-identifier=?}).  @ref{types
methods calling, Calling object--type methods}.

@menu
* types methods concrete overloaded::  Overloaded methods.
* types methods concrete fields::      Field methods.
* types methods concrete override::    Overriding methods.
@end menu

@c page
@node types methods concrete overloaded
@subsubsection Overloaded methods


The clause @clause{method} allows the definition of overloaded
functions, with multiple function specialisations associated to the same
method name.  Example:

@lisp
(define-record-type <alpha>
  (fields a b)

  (method (@{doit <list>@} @{A <fixnum>@})
    (list (.a this) (.b this) 'fixnum A))

  (method (@{doit <list>@} @{A <symbol>@})
    (list (.a this) (.b this) 'symbol A))

  (method (@{doit <list>@} @{A <number>@} @{B <number>@})
    (list (.a this) (.b this) 'numbers A B)))

(define O
  (new <alpha> 1 2))

(.doit O 123)           @result{} (1 2 fixnum 123)
(.doit O 'ciao)         @result{} (1 2 symbol ciao)
(.doit O 3 4)           @result{} (1 2 numbers 3 4)
@end lisp

@noindent
we can think of the methods defined above as expanding to the following
definitions:

@lisp
(define/overload (@{doit <list>@} @{subject <alpha>@}
                      @{A <fixnum>@})
  (fluid-let-syntax ((this (make-synonym-transformer #'subject)))
    (list (.a this) (.b this) 'fixnum A)))

(define/overload (@{doit <list>@} @{subject <alpha>@}
                      @{A <symbol>@})
  (fluid-let-syntax ((this (make-synonym-transformer #'subject)))
    (list (.a this) (.b this) 'symbol A)))

(define/overload (@{doit <list>@} @{subject <alpha>@}
                      @{A <number>@} @{B <number>@})
  (fluid-let-syntax ((this (make-synonym-transformer #'subject)))
    (list (.a this) (.b this) 'numbers A B)))
@end lisp

@noindent
where @var{subject} is a non--accessible identifier.

@c page
@node types methods concrete fields
@subsubsection Field methods


When methods are defined for record-types: method names cannot be equal
to field names; field accessors and mutators are accessible as methods
automatically, with a method name equal to the field name.  The syntax
of @syntax{method-call} is:

@example
(method-call @meta{name} @meta{subject-expr} @meta{arg} ...)
@end example

@noindent
when there are no @meta{arg} operand the syntax is compatible with a
field accessor call; when there is a single @meta{arg} operand the
syntax is compatible with a field mutator call.

So we can access and mutate fields as follows:

@lisp
(define-record-type <alpha>
  (fields (mutable a)))

(define O
  (new <alpha> 1))

(.a O)          @result{} 1
(.a O 2)
(.a O)          @result{} 2
@end lisp

@c page
@node types methods concrete override
@subsubsection Overriding methods


When a hierarchy of record--types is defined: the sub--types can
override the super--type's concrete methods by defining methods with the
same name.  Example:

@lisp
(define-record-type <super>
  (method (doit)
    1))

(define-record-type <sub>
  (parent <super>)
  (method (doit)
    2))

(define (super-fun @{O <super>@})
  (.doit O))

(define (sub-fun   @{O <sub>@})
  (.doit O))

(define O
  (new <sub>))

(super-fun O)   @result{} 1
(sub-fun   O)   @result{} 2
@end lisp

The method of the super--type is still accessible if we ``see'' the
object instance through the super--type's type specification.

The sub--type's method is in no way limited by the super--type's method:
the two methods are allowed to have completely different type signature.

@c page
@node types methods virtual
@subsection Virtual methods


The clause @clause{virtual-method} allows the definition of virtual
methods associated to a record--type.  Virtual methods work almost like
concrete methods, but the rules of overriding are different: with
virtual methods we request run--time dynamic dispatching, to have the
methods of the sub--types take precedence over the methods of the
super--types.

@quotation
@strong{NOTE} Virtual methods must have an implementation, there are no
abstract methods.
@end quotation

Example:

@lisp
(define-record-type <super>
  (virtual-method (doit)
    1))

(define-record-type <sub>
  (parent <super>)
  (method (doit)
    2))

(define (super-fun @{O <super>@})
  (.doit O))

(define (sub-fun   @{O <sub>@})
  (.doit O))

(define O
  (new <sub>))

(super-fun O)   @result{} 2
(sub-fun   O)   @result{} 2
@end lisp

@noindent
we see that even though the function @func{super-fun} accesses the
instance of @class{sub} with the type specification @class{super}, the
actually called method is the one defined by @class{sub}.

The overriding method must have type signature being a sub--type of the
overridden type signature.  For example, the following definitions are
fine:

@lisp
(define-record-type <super>
  (fields value)
  (virtual-method (@{doit <number>@} @{S <nestring>@})
    (.value this)))

(define-record-type <sub>
  (parent <super>)
  (virtual-method (@{doit <fixnum>@} @{S <string>@})
    (.value this)))
@end lisp

@noindent
because:

@lisp
(type-annotation-super-and-sub?
   (lambda (<nestring>) => (<number>))
   (lambda (<string>)   => (<fixnum>)))
@result{} #t
@end lisp

@noindent
while the following definitions will cause a syntax violation exception
at expand--time:

@lisp
(define-record-type <super>
  (fields value)
  (virtual-method (@{doit <number>@} @{S <nestring>@})
    (.value this)))

(define-record-type <sub>
  (parent <super>)
  (virtual-method (@{doit <fixnum>@} @{S <vector>@})
    (.value this)))
@end lisp

@noindent
because:

@lisp
(type-annotation-super-and-sub?
   (lambda (<nestring>) => (<number>))
   (lambda (<string>)   => (<vector>)))
@result{} #f
@end lisp

Once a method has been defined as virtual in a super--type, it does not
matter if the sub--type makes use of @clause{method},
@clause{virtual-method} or @clause{seal-method}: all these clauses will
override the super--type's method if they use the same name.  Example:

@lisp
(define-record-type <super>
  (virtual-method (darkness)
    1)
  (virtual-method (light)
    2))

(define-record-type <sub>
  (parent <super>)
  (method (darkness)
    11)
  (virtual-method (light)
    22))

(define O
  (new <sub>))

(define @{P <super>@}
  O)

(.darkness P)   @result{} 11
(.light    P)   @result{} 22
@end lisp

Notice that it is not possible to define a sub--type having a field with
the same name of a super--type's virtual method; the following
definitions will cause an expand--time exception:

@lisp
(define-record-type <super>
  (method (doit)
    1))

(define-record-type <sub>
  (parent <super>)
  (fields doit))
@error{} &syntax
@end lisp

The clause @clause{seal-method} seals a method name so that the
sub--types can no more use it; it does not matter if the super--types
actually use it or not.

@c page
@node types methods sealing
@subsection Sealing methods


It happens that we want to define virtual methods in a super--type,
override them in a sub--type and then forbid further overriding in the
sub--types of the sub-type.  This is possible with sealing methods.

The clause @clause{seal-method} allows the definition of methods
associated to a record--type that might override the super--type's
methods, but that forbid the sub--types from overriding them.  For
everything else: sealing methods work like concrete methods.

In the following example everything works as usual, with @class{sub}
overriding the implementation of @func{doit} in @class{super}:

@lisp
(define-record-type <super>
  (virtual-method (doit)
    1))

(define-record-type <sub>
  (parent <super>)
  (seal-method (doit)
    2))

(define (super-fun @{O <super>@})
  (.doit O))

(define (sub-fun   @{O <sub>@})
  (.doit O))

(define O
  (new <sub>))

(super-fun O)   @result{} 2
(sub-fun   O)   @result{} 2
@end lisp

@noindent
but adding the following definition will cause an expand--time
exception, because sub--types of @class{sub} are forbidden from having a
method named @func{doit}:

@lisp
(define-record-type <sub-sub>
  (parent <sub>)
  (method (doit)
    3))
@error{} &syntax
@end lisp

@noindent
the following definition will also cause an expand--time exception,
because sub--types of @class{sub} are forbidden from having a field
named @func{doit}:

@lisp
(define-record-type <sub-sub>
  (parent <sub>)
  (fields doit))
@error{} &syntax
@end lisp

@c page
@node types methods calling
@subsection Calling object-type methods


The following keyword syntactic bindings are involved in the definition
and use of methods: @clause{method}, @clause{virtual-method},
@clause{seal-method}, @syntax{method-call}.  In addition the function
@func{method-call-late-binding} performs a method call with ``late
binding'' (run--time dispatching).

The keyword @clause{method} is used in @syntax{define-record-type} to
define methods for a record type (@pxref{iklib records defs methods,
Record--type methods}).  For example:

@lisp
(define-record-type duo
  (fields one two)
  (method (sum-them)
    (+ (duo-one this)
       (duo-two this)))
  (method (mul-them)
    (* (duo-one this)
       (duo-two this))))
@end lisp

@noindent
the syntax @syntax{method-call} is then used to call a record's methods:

@lisp
(define @{O duo@}
  (new duo 3 5))

(method-call sum-them O)        @result{} 8
(method-call mul-them O)        @result{} 15
@end lisp

When defining a record or struct: @value{PRJNAME} automatically adds a
method to the methods table, for each field, with the same name of the
field.  When the field is mutable: if the method is called with one
argument, it behaves as a field accessor; if the method is called with
two arguments, it behaves as a field mutator.  When the field is
immutable: the method can be called with one argument only.  Example:

@lisp
(define-record-type duo
  (fields (immutable one)
          (mutable   two)))

(define @{O duo@}
  (new duo 1 2))

(method-call one O)     @result{} 1
(method-call one O 123) @error{} &syntax
(method-call two O)     @result{} 2
(method-call two O 9)
(method-call two O)     @result{} 9
@end lisp

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax method-call @meta{name} @meta{subject-expr} @meta{arg} @dots{}
Apply an object--type's method to the return value of
@meta{subject-expr} and the optional arguments @meta{arg}.

@meta{name} must be a symbol representing a method or field name.
@meta{subject-expr} must be a Scheme expression which, expanded and
evaluated at run--time, returns a single value.  Each @meta{arg} must be
a Scheme expression which, expanded and evaluated at run--time, returns
a single value.

When possible, @syntax{method-call} determines at expand--time the type
of the expression @meta{subject-expr} and searches for a method with
equal name, according to @func{eq?}.  If the method is found, the
syntactic identifier to which the implementation procedure is bound is
inserted in the macro expansion:

@lisp
(@meta{procedure} @meta{subject-expr} @meta{arg} ...)
@end lisp

@noindent
If the object--type of @meta{subject-expr} has no matching method: its
super--type is inspected, then the super--type of the super--type and so
on.  If no method is found in the types hierarchy: an exception is
raised.

@syntax{method-call} is able to retrieve the type of its second argument
at expand--time only when the typed language is enabled.  If
@syntax{method-call} cannot determine the type of @meta{subject-expr} at
expand--time, the macro use is expanded to:

@lisp
(method-call-late-binding (quote @meta{name}) #f
                          @meta{subject-expr} @meta{arg} ...)
@end lisp

@noindent
and the function @func{method-call-late-binding} attempts to determine a
suitable method at run--time.
@end deffn


@defun method-call-late-binding @var{name} @var{td} @var{subject} @var{arg} @dots{}
Apply an object--type's method to @var{subject} and the optional
arguments @meta{arg}.  Return the application results.

The argument @var{name} must be a symbol representing a method or field
name.  The argument @var{subject} must be a Scheme object implementing a
set of methods.  The optional @meta{arg} arguments can be any value.

The argument @var{td} must be @false{} or a predetermined type
descriptor for @var{subject}; this argument is usually @false{}.

This function attempts to determine the type of @var{subject} at
run--time and searches the object--type's table of methods, if any, for
a method whose name equals @var{name} according to @func{eq?}.  If a
method is found, its implementation procedure is retrieved and applied
to @var{subject} and the @var{arg} values.

If the object--type of @var{subject} has no matching method: its
super--type is inspected, then the super--type of the super--type and so
on.  If no method is found in the type's hierarchy: an exception is
raised.

Usually we do not need to call this function explicitly; however, it is
useful for debugging purposes.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Dot notation

When the Scheme reader's textual input port is configured in
@samp{#!vicare} mode: if a list starts with a symbol; the name of the
symbol is a string of length at least @math{2}; the first character of
the string is a dot; the second character of the string is @strong{not}
a dot, then a @syntax{method-call} symbol is inserted and the symbol
stripped of the dot.

We can try it at the @repl{}:

@example
vicare> '(.ciao)
$1 = (method-call ciao)
@end example

Notice that @rnrs{6} forbids symbols starting with a dot, with the
exception of the ellipsis; so this transformation does not influence the
other reader operations.

We can use this notation to call an object--type's methods as in the
following program:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))

  (define-record-type duo
    (fields one two)

    (method (sum-them)
      (+ (.one this) (.two this)))

    (method (mul-them)
      (* (.one this) (.two this)))

    (method (display port)
      (display this port)))

  (define @{O duo@}
    (new duo 3 4))

  (pretty-print (.sum-them O)
                (current-error-port))

  (pretty-print (.mul-them O)
                (current-error-port))

  (.display O (current-error-port))
  (newline (current-error-port))

  #| end of program |# )
@end lisp

@c page
@node types protlev
@section Protection levels


@cindex Protection levels for record--type's members
@cindex Record--types, protection levels for members


When the typed language is enabled, record--type definitions support
protection levels for fields and methods.  Protection levels limit the
way fields and methods can be used both from other types in the
record--type hierarchy and from outside a record--type's definition.

Three protection levels are supported: @clause{public},
@clause{protected} and @clause{private}; they are modeled after the ones
defined in the C++ language.

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn {Auxiliary Syntax} public
Select the @clause{public} protection level for the associated fields
and methods.  When a member of record--type @class{T} is given the
@clause{public} protection level: sub--types of @class{T} can access it;
instances of @class{T} can access it from outside methods.

When no protection level is specified for a member in a record--type
definition: the protection level defaults to @clause{public}.
@end deffn


@deffn {Auxiliary Syntax} protected
Select the @clause{protected} protection level for the associated fields
and methods.  When a member of record--type @class{T} is given the
@clause{protected} protection level: sub--types of @class{T} can access
it; instances of @class{T} cannot access it from outside methods.
@end deffn


@deffn {Auxiliary Syntax} private
Select the @clause{private} protection level for the associated fields
and methods.  When a member of record--type @class{T} is given the
@clause{private} protection level: sub--types of @class{T} cannot access
it; instances of @class{T} cannot access it from outside methods.
@end deffn


The protection level keywords can be used both as ``wrapping syntaxes''
as in:

@lisp
(define-record-type <duo>
  (public
    (fields one two)
    (method (add)
      (+ (.one this) (.two this)))))
@end lisp

@noindent
or as ``attribute syntaxes'' as in:

@lisp
(define-record-type <duo>
  (fields public one two)
  (method public (add)
    (+ (.one this) (.two this))))
@end lisp

The only clauses that can be put in a wrapping syntax and that accept an
attribute syntax are: @clause{fields}, @clause{method},
@clause{virtual-method}, @clause{seal-method}.

@c ------------------------------------------------------------------------

@subsubheading Usage and limitations by examples

The protection levels limit the access to members from outside a
method's body:

@lisp
(define-record-type <blue>
  (method public    (pub)  1)
  (method protected (pro)  2)
  (method private   (pri)  3))

(define O
  (new <blue>))

(.pub O)        @result{} 1
(.pro O)        @error{} not a public method
(.pri O)        @error{} not a public method
@end lisp

When super--type's members are @clause{public}, everything works as
usual:

@lisp
(define-record-type <blue>
  (fields public light))

(define-record-type <dark-blue>
  (parent <blue>)
  (method public (doit)
    (.light this)))

(define O
  (new <dark-blue> 1))

(define @{X <blue>@}
  O)

(.doit  O)      @result{} 1
(.light X)      @result{} 1
@end lisp

When super--type's members are @clause{protected}, we can access them
from the super--type's methods and from the sub--type's methods:

@lisp
(define-record-type <blue>
  (fields protected light)
  (method public (doit)
    (.light this)))

(define-record-type <dark-blue>
  (parent <blue>)
  (method public (doit)
    (.light this)))

(define O
  (new <dark-blue> 1))

(.doit O)       @result{} 1

(define @{X <blue>@}
  O)

(.light X)      @error{} not a public method
(.doit  X)      @result{} 1
@end lisp

When super--type's members are @clause{private}, we can access them from
the super--type's methods only:

@lisp
(define-record-type <blue>
  (fields private light)
  (method public (doit)
    (.light this)))

(define X
  (new <blue> 1))

(.light X)      @error{} not a public method
(.doit  X)      @result{} 1

(define-record-type <dark-blue>
  (parent <blue>)
  (method public (doit)
    (.light this)))     @error{} not a public or protected method
@end lisp

It is not an error to define a private virtual method, but such method
cannot be overridden by the sub--types:

@lisp
(define-record-type <blue>
  (virtual-method private (doit) 1))

(define-record-type <dark-blue>
  (parent <blue>)
  (method (doit) 2))    @error{} cannot override private method
@end lisp

Virtual methods overriding and sealing is possible only among methods of
the same protection level:

@lisp
(define-record-type <blue>
  (protected
    (virtual-method (over)
      'over-blue))
  (method (doit)
    (.over this)))

(define-record-type <dark-blue>
  (parent <blue>)
  (protected
    (method (over)
      'over-dark-blue)))

(define O
  (new <dark-blue>))

(define (fun @{X <blue>@})
  (.doit X))

(fun O)         @result{} over-dark-blue
@end lisp

@c page
@node types mixins
@section Sharing object--type definition clauses


@cindex Library @library{vicare language-extensions mixins}
@cindex @library{vicare language-extensions mixins}, library


@dfn{Mixins} are a way to add definition clauses to record--types and
labels.  Let's consider this situation:

@lisp
(define-record-type <alpha>
  (fields a))

(define-record-type <beta>
  (fields b))

(define-record-type <delta>
  (parent <alpha>)
  (fields v)
  (method (doit)
    (+ 1 (.v this))))

(define-record-type <gamma>
  (parent <beta>)
  (fields v)
  (method (doit)
    (+ 1 (.v this))))
@end lisp

@noindent
the definitions of @class{delta} and @class{gamma} share some clauses;
both of them already have a parent type and multiple inheritance is not
supported by @value{PRJNAME}.  Is it possible to write the shared
clauses only once and attach them to the record--type definitions?  Yes,
with mixins.  The example above is equivalent to the following:

@lisp
(define-record-type <alpha>
  (field a))

(define-record-type <beta>
  (field b))

(define-mixin-type <stuff>
  (field v)
  (method (doit)
    (+ 1 (.v this))))

(define-record-type <delta>
  (parent <alpha>)
  (mixins <stuff>))

(define-record-type <gamma>
  (parent <beta>)
  (mixins <stuff>))
@end lisp

@noindent
the syntax use of @syntax{define-mixin-type} associates a set of clauses to
the identifier @class{stuff}; when the @clause{mixins} clause is used in
the body of a record--type definition:

@enumerate
@item
The clauses associated to the selected mixin identifier are retrieved as
syntax object.

@item
All the instances of the identifier @class{stuff} are substituted with
the identifier of the enclosing record--type; @class{delta} and
@class{gamma} in the example.

@item
The resulting clauses are added to the enclosing definition.
@end enumerate


@deffn {Auxiliary Syntax} mixins @meta{mixin-name} @dots{}
Compose the enclosing record--type, label or mixin definition with the
given list of mixins.  This clause can be used multiple times.

The syntactic identifiers @meta{mixin-name} are used to reference the
mixins to be imported.  The clauses are included in the same order in
which the @meta{mixin-name} identifiers are present in the
@clause{mixins} clause and in the same place in which the
@clause{mixins} clause is present in the enclosing definition.

It is a syntax violation if a mixin identifier name is not already
associated to a set of clauses at the time the receiving definition is
expanded.
@end deffn


@deffn Syntax define-mixin-type @meta{mixin-name} @metao{clause} @meta{clause} ...
Associate a set of mixin clauses to the identifier @meta{mixin-name},
which can be later referenced by a @clause{mixins} clause in the body of
a class or label definition.

The @clause{mixins} clause can be used in the body of a mixin
definition; the result is that the clauses of the selected mixins are
added to the definition of the current mixin.

The following clauses are accepted in the body of a
@syntax{define-mixin-type}:

@lisp
define-type-descriptors strip-angular-parentheses
nongenerative implements
sealed opaque protocol super-protocol fields
method virtual-method seal-method
custom-printer type-predicate equality-predicate
comparison-procedure hash-function
public protected private
implements
@end lisp
@end deffn

@c page
@node types interfaces
@section Interface types


@cindex Library @library{vicare language-extensions interfaces}
@cindex @library{vicare language-extensions interfaces}, library


The @dfn{interfaces} are a mechanism to verify, at expand--time, that
instances of an object--type can be used in a generic expression,
because they implement all the needed methods and such methods can be
called at run--time through dynamic dispatching.

Interfaces are implemented half in the boot image and half in the
library @library{vicare language-extensions interfaces}.

@menu
* types interfaces intro::      Introduction to interfaces.
* types interfaces defs::       Defining interfaces.
* types interfaces descr::      Interfaces type descriptors.
* types interfaces examples::   Interfaces by examples.
@end menu

@c page
@node types interfaces intro
@subsection Introduction to interfaces


Let's consider this code:

@lisp
(define-record-type <a-vector>
  (fields @{vec <nevector>@})
  (method (@{first <top>@})
    (vector-ref (.vec this) 0)))

(define-record-type <a-string>
  (fields @{vec <nestring>@})
  (method (@{first <top>@})
    (string-ref (.vec this) 0)))

(define-record-type <a-list>
  (fields @{vec <nelist>@})
  (method (@{first <top>@})
    (car (.vec this))))

(define (fun O)
  (.first O))

(fun (new <a-vector> '#(1 2 3)))        @result{} 1
(fun (new <a-string> "ABC"))            @result{} #\A
(fun (new <a-list> '(a b c)))           @result{} a
@end lisp

@noindent
everything works fine in the function @func{fun} because all of
@class{a-vector}, @class{a-string} and @class{a-list} implement the
method @samp{first}.  The code @code{(.first O)} expands into a call to
@func{method-call-late-binding}, which, at run--time, finds the method
implementation functions in the type descriptors of @class{a-vector},
@class{a-string} and @class{a-list}.

Fine, but the code is not type--checked at expand--time.  Enter
interfaces.  Let's modify the code as follows:

@lisp
(define-interface-type <Sequence>
  (method-prototype first
    (lambda () => (<top>))))

(define-record-type <a-vector>
  (implements <Sequence>)
  (fields @{vec <nevector>@})
  (method (@{first <top>@})
    (vector-ref (.vec this) 0)))

(define-record-type <a-string>
  (implements <Sequence>)
  (fields @{vec <nestring>@})
  (method (@{first <top>@})
    (string-ref (.vec this) 0)))

(define-record-type <a-list>
  (implements <Sequence>)
  (fields @{vec <nelist>@})
  (method (@{first <top>@})
    (car (.vec this))))

(define (fun @{O <Sequence>@})
  (.first O))

(fun (new <a-vector> '#(1 2 3)))        @result{} 1
(fun (new <a-string> "ABC"))            @result{} #\A
(fun (new <a-list> '(a b c)))           @result{} a
@end lisp

@noindent
everything works almost as before, but the record--type definition
clause @code{(implements <Sequence>)} causes the expander to validate,
at expand-time, that the record--types actually implement a method
@code{first} with the correct type signature.

Also, the function application @code{(fun @meta{operand})} is validated
at expand--time to verify that the type of @meta{operand} is an
object--type that implements @class{Sequence}.  Such validation can
happen @strong{only} if the expander is able to determine the type of
@meta{operand}; this validation cannot happen at run--time, so, for
example, it is impossible for label types to implement interfaces.

@c page
@node types interfaces defs
@subsection Defining interfaces


The following syntactic bindings are exported by the library
@library{vicare language-extensions interfaces}.


@deffn Syntax define-interface-type @meta{name} @meta{clause} @dots{}
@deffnx {Auxiliary Syntax} nongenerative
@deffnx {Auxiliary Syntax} parent
@deffnx {Auxiliary Syntax} implements
@deffnx {Auxiliary Syntax} method-prototype
@deffnx {Auxiliary Syntax} method
Define a new interface type bound to the syntactic identifier
@meta{name}.  The syntactic bindings @clause{nongenerative},
@clause{parent}, @clause{implements}, @clause{method} are the same ones
exported by @library{vicare} and are reexported by the library
@library{vicare language-extensions interfaces}.

Interfaces cannot be instantiated: attempting to do it will raise an
expand--time exception.

A use of the clause @clause{nongenerative} must have one of the formats:

@lisp
(nongenerative)
(nongenerative @meta{uid})
@end lisp

@noindent
when used it causes the interface--type to be non--generative.  This
concept is the same as for record--types, so usually we do want to
define non--generative interface--types.

A use of the clause @clause{parent} must have the format:

@lisp
(parent @meta{parent-name})
@end lisp

@noindent
and causes the new interface--type to become a sub--type of
@meta{parent-name}, which must be a syntactic identifier representing
the name of an already defined interface--type.  An object--type
implementing the interface @meta{name} must also implement all the
methods required by the interface @meta{parent-name}.

A use of the clause @clause{implements} must have format:

@lisp
(implements @meta{iface-name} ...)
@end lisp

@noindent
and declares that an object--type implementing the interface--type
@meta{name} also implements all the methods in the interface--types
@meta{iface-name}.  The definition of @meta{name} must include a
@clause{method-prototype} clause for each method required by the
interfaces @meta{iface-name}, with matching type signatures.

A use of the clause @clause{method-prototype} must have format:

@lisp
(method-prototype @meta{method-name} @meta{signature})
@end lisp

@noindent
where @meta{method-name} is an identifier representing the name of the
method and @meta{signature} is a @syntax{lambda} or @syntax{case-lambda}
type annotation representing the type signature of the method.  Any
object--type that implements an interface, must implement all the
methods with signatures that are sub--types of the method prototypes.

A use of the clause @clause{method} must have format:

@lisp
(method (@meta{who} . @meta{formals})
  . @meta{body})

(method ((brace @meta{who} . @meta{rv-types}) . @meta{formals})
  . @meta{body})
@end lisp

@noindent
which is the same syntax for @syntax{define-record-type}.  The clause
@clause{method} defines a required method prototype which also has a
default implementation.  An object--type implementing the interface
@meta{name} is allowed not to implement a method matching an interface
prototype with default implementation.
@end deffn

@c page
@node types interfaces descr
@subsection Interfaces type descriptors


Interfaces have run--time type descriptors, accessible through the
@syntax{type-descriptor} syntax, @ref{types descr other interface,
Interface type descriptors}.  Example:

@lisp
(import (prefix (vicare system type-descriptors)
                td::))

(define-interface-type <Stuff>
  (method-prototype red
    (lambda () => (<top>)))
  (method (blue)
    2))

(define itd
  (type-descriptor <Stuff>))

(td::interface-type-descr? itd)
@result{} #t

(td::interface-type-descr.type-name itd)
@result{} <Stuff>
@end lisp

@c page
@node types interfaces examples
@subsection Interfaces by examples


Let's illustrate the features and limitations of interface--types by
examples.

Whenever an interface inherits from another interface, it obviously
becomes its sub--type:

@lisp
(define-interface-type <IParent>
  (method-prototype doit
    (lambda (<number>) => (<string>))))

(define-interface-type <IChild>
  (parent <IParent>))

(type-annotation-super-and-sub? <IParent> <IChild>) @result{} #t
(type-annotation-super-and-sub? <IChild> <IParent>) @result{} #f
@end lisp

An interface can implement another interface; the implementer must
declare a matching method prototype for every method prototype of the
implemented.  The method prototype of the implementer must be a
sub--type of the method prototype of the implemented.  Given that:

@lisp
(type-annotation-super-and-sub?
  (lambda (<nestring>) => (<number>))
  (lambda (<string>)   => (<fixnum>)))
@result{} #t
@end lisp

@noindent
we can define:

@lisp
(define-interface-type <IOne>
  (method-prototype doit
    (lambda (<nestring>) => (<number>))))

(define-interface-type <ITwo>
  (implements <IOne>)
  (method-prototype doit
    (lambda (<string>) => (<fixnum>))))

(type-annotation-super-and-sub? <IOne> <ITwo>) @result{} #t
(type-annotation-super-and-sub? <ITwo> <IOne>) @result{} #f
@end lisp

An interface can inherit method prototypes from another interface and
use those to implement another interface:

@lisp
(define-interface-type <I>
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-interface-type <A>
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-interface-type <B>
  (parent <A>)
  (implements <I>))

(type-annotation-super-and-sub? <I> <A>) @result{} #f
(type-annotation-super-and-sub? <I> <B>) @result{} #t
(type-annotation-super-and-sub? <A> <I>) @result{} #f
(type-annotation-super-and-sub? <B> <I>) @result{} #f
@end lisp

If the interface @class{ISub} inherits from @class{ISuper}, to implement
@class{ISub} the interface @class{A} has to declare a method for every
method in @class{ISub} and @class{ISuper}:

@lisp
(define-interface-type <ISuper>
  (method-prototype super-doit
    (lambda (<string>) => (<number>))))

(define-interface-type <ISub>
  (parent <ISuper>)
  (method-prototype sub-doit
    (lambda (<string>) => (<fixnum>))))

(define-interface-type <A>
  (implements <ISub>)
  (method-prototype super-doit
    (lambda (<string>) => (<number>)))
  (method-prototype sub-doit
    (lambda (<string>) => (<fixnum>))))

(type-annotation-super-and-sub? <ISuper> <A>) @result{} #t
(type-annotation-super-and-sub? <ISub>   <A>) @result{} #t
(type-annotation-super-and-sub? <A> <ISuper>) @result{} #f
(type-annotation-super-and-sub? <A> <ISub>)   @result{} #f
@end lisp

Interface @class{B} implements interface @class{A}; interface @class{C}
implements interface @class{B}; automatically, interface @class{C}
implements interface @class{A}:

@lisp
(define-interface-type <A>
  (method-prototype red         (lambda () => (<fixnum>))))

(define-interface-type <B>
  (implements <A>)
  (method-prototype red         (lambda () => (<fixnum>)))
  (method-prototype blue        (lambda () => (<symbol>))))

(define-interface-type <C>
  (implements <B>)
  (method-prototype red         (lambda () => (<fixnum>)))
  (method-prototype blue        (lambda () => (<symbol>))))

(type-annotation-super-and-sub? <A> <B>) @result{} #t
(type-annotation-super-and-sub? <A> <C>) @result{} #t
(type-annotation-super-and-sub? <B> <A>) @result{} #f
(type-annotation-super-and-sub? <B> <C>) @result{} #t
(type-annotation-super-and-sub? <C> <A>) @result{} #f
(type-annotation-super-and-sub? <C> <B>) @result{} #f
@end lisp

An interface that inherits from another interface can ``extend'' its
method prototypes with additional signatures.  The interface
@class{IThree} implements the interfaces @class{IOne} and @class{ITwo}.
@class{IThree} implements the ``composite'' method from @class{IOne} and
@class{ITwo} with multiple @clause{method-prototype} clauses:

@lisp
;;
;;                 <IOne>
;;                    ^
;;                    |
;;   <IThree> +++> <ITwo>
;;
(define-interface-type <IOne>
  (method-prototype doit
    (lambda (<fixnum>) => (<string>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype doit
    (lambda (<flonum>) => (<string>))))

(define-interface-type <IThree>
  (implements <ITwo>)
  (method-prototype doit (lambda (<fixnum>) => (<string>)))
  (method-prototype doit (lambda (<flonum>) => (<string>))))

(type-annotation-super-and-sub? <IOne>   <IThree>) @result{} #t
(type-annotation-super-and-sub? <IOne>   <ITwo>)   @result{} #t
(type-annotation-super-and-sub? <ITwo>   <IThree>) @result{} #t
(type-annotation-super-and-sub? <IThree> <IOne>)   @result{} #f
(type-annotation-super-and-sub? <ITwo>   <IOne>)   @result{} #f
(type-annotation-super-and-sub? <IThree> <ITwo>)   @result{} #f
@end lisp

@noindent
the same as above, but with a single @clause{method-prototype} clause:

@lisp
(define-interface-type <IOne>
  (method-prototype doit
    (lambda (<fixnum>) => (<string>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype doit
    (lambda (<flonum>) => (<string>))))

(define-interface-type <IThree>
  (implements <ITwo>)
  (method-prototype doit
    (case-lambda
      ((<fixnum>) => (<string>))
      ((<flonum>) => (<string>)))))
@end lisp

A record--type can implement an interface by defining a concrete method
for every method prototype:

@lisp
(define-interface-type <IOne>
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-record-type <blue>
  (implements <IOne>)
  (method (@{doit <number>@} @{S <string>@})
    1))

(type-annotation-super-and-sub? <IOne> <blue>) @result{} #t
(type-annotation-super-and-sub? <blue> <IOne>) @result{} #f
@end lisp

A record--type can inherit from another record--type and use its
parent's methods to implement an interface:

@lisp
(define-interface-type <I>
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-record-type <A>
  (method (@{doit <number>@} @{S <string>@})
    1))

(define-record-type <B>
  (parent <A>)
  (implements <I>))

(type-annotation-super-and-sub? <I> <A>) @result{} #f
(type-annotation-super-and-sub? <I> <B>) @result{} #t
(type-annotation-super-and-sub? <A> <I>) @result{} #f
(type-annotation-super-and-sub? <B> <I>) @result{} #f
@end lisp

A record--type must implement a method for every method prototype in the
interface and its parents:

@lisp
(define-interface-type <ISuper>
  (method-prototype super-doit
    (lambda (<string>) => (<number>))))

(define-interface-type <ISub>
  (parent <ISuper>)
  (method-prototype sub-doit
    (lambda (<string>) => (<fixnum>))))

(define-record-type <A>
  (implements <ISub>)
  (method (@{super-doit <number>@} @{S <string>@})
    1)
  (method (@{sub-doit <fixnum>@} @{S <string>@})
    1))

(type-annotation-super-and-sub? <ISuper> <A>) @result{} #t
(type-annotation-super-and-sub? <ISub>   <A>) @result{} #t
(type-annotation-super-and-sub? <A> <ISuper>) @result{} #f
(type-annotation-super-and-sub? <A> <ISub>)   @result{} #f
@end lisp

The record--type @class{C} implements interface @class{B}; the interface
@class{B} implements interface @class{A}; automatically, @class{C}
implements @class{A}:

@lisp
(define-interface-type <A>
  (method-prototype red
    (lambda () => (<fixnum>))))

(define-interface-type <B>
  (implements <A>)
  (method-prototype red
    (lambda () => (<fixnum>)))
  (method-prototype blue
    (lambda () => (<symbol>))))

(define-record-type <C>
  (implements <B>)
  (method (@{red  <fixnum>@})
    1)
  (method (@{blue <symbol>@})
    'ciao))

(type-annotation-super-and-sub? <A> <B>) @result{} #t
(type-annotation-super-and-sub? <A> <C>) @result{} #t
(type-annotation-super-and-sub? <B> <A>) @result{} #f
(type-annotation-super-and-sub? <B> <C>) @result{} #t
(type-annotation-super-and-sub? <C> <A>) @result{} #f
(type-annotation-super-and-sub? <C> <B>) @result{} #f
@end lisp

The record--type @class{dark-blue} inherits from @class{blue} the
implementation of the interfaces @class{IOne} and @class{ITwo}:

@lisp
;;
;;               <IOne>
;;                  ^
;;                  |
;;   <blue> +++> <ITwo>
;;     ^
;;     |
;;   <dark-blue>

(define-interface-type <IOne>
  (method-prototype ione-doit
    (lambda () => (<number>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype itwo-doit
    (lambda () => (<symbol>))))

(define-record-type <blue>
  (implements <ITwo>)
  (fields val)
  (method (@{ione-doit <number>@})
    (+ 10 (.val this)))
  (method (@{itwo-doit <symbol>@})
    'ciao))

(define-record-type <dark-blue>
  (parent <blue>))

(define (fun-1 @{O <IOne>@})
  (.ione-doit O))

(define (fun-2 @{O <ITwo>@})
  (vector (.ione-doit O)
          (.itwo-doit O)))

(define O
  (new <dark-blue> 1))

(fun-1 O)       @result{} 11
(fun-2 O)       @result{} #(11 ciao)
@end lisp

The record--type @class{dark-blue} implements the interface @class{ITwo}
and inherits from @class{blue} the implementation of the interface
@class{IOne}:

@lisp
;;   <blue> +++> <IOne>
;;     ^
;;     |
;;   <dark-blue> +++> <ITwo>

(define-interface-type <IOne>
  (method-prototype ione-doit
    (lambda () => (<number>))))

(define-interface-type <ITwo>
  (method-prototype itwo-doit
    (lambda () => (<symbol>))))

(define-record-type <blue>
  (implements <IOne>)
  (fields val)
  (method (@{ione-doit <number>@})
    (+ 10 (.val this))))

(define-record-type <dark-blue>
  (parent <blue>)
  (implements <ITwo>)
  (method (@{itwo-doit <symbol>@})
    'ciao))

(define (fun-1 @{O <IOne>@})
  (.ione-doit O))

(define (fun-2 @{O <ITwo>@})
  (.itwo-doit O))

(define O
  (new <dark-blue> 1))

(fun-1 O)       @result{} 11
(fun-2 O)       @result{} ciao
@end lisp

The record--type @class{blue} implements the interface @class{ITwo}, its
parent @class{IOne}, and automatically the interface @class{IThree}
implemented by @class{IOne}:

@lisp
;;               <IOne> +++> <IThree>
;;                  ^
;;                  |
;;   <blue> +++> <ITwo>

(define-interface-type <IThree>
  (method-prototype ithree-doit
    (lambda () => (<string>))))

(define-interface-type <IOne>
  (implements <IThree>)
  (method-prototype ione-doit
    (lambda () => (<number>)))
  (method-prototype ithree-doit
    (lambda () => (<string>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype itwo-doit
    (lambda () => (<symbol>))))

(define-record-type <blue>
  (implements <ITwo>)
  (fields val)
  (method (@{ione-doit <number>@})
    (+ 10 (.val this)))
  (method (@{itwo-doit <symbol>@})
    'ciao)
  (method (@{ithree-doit <string>@})
    "hello"))

(define (fun-1 @{O <IOne>@})
  (vector (.ione-doit O)
          (.ithree-doit O)))

(define (fun-2 @{O <ITwo>@})
  (vector (.ione-doit O)
          (.itwo-doit O)
          (.ithree-doit O)))

(define (fun-3 @{O <IThree>@})
  (.ithree-doit O))

(define O
  (new <blue> 1))

(fun-1 O)       @result{} #(11 "hello")
(fun-2 O)       @result{} #(11 ciao "hello")
(fun-3 O)       @result{} "hello"
@end lisp

Two record--types in a hierarchy both implement the same interface:

@lisp
(define-interface-type <Arith>
  (method-prototype add
    (lambda () => (<number>))))

(define-record-type <duo>
  (implements <Arith>)
  (fields one two)
  (method (@{add <number>@})
    (+ (.one this) (.two this))))

(define-record-type <trio>
  (parent <duo>)
  (implements <Arith>)
  (fields three)
  (method (@{add <number>@})
    (+ (.one this) (.two this) (.three this))))

(define (fun @{O <Arith>@})
  (.add O))

(fun (new <duo>  1 2))          @result{} 3
(fun (new <trio> 1 2 3))        @result{} 6
@end lisp

The record--type @class{duo} implements the interface @class{Stringer}
which has a default method @code{to-string}:

@lisp
(define-interface-type <Stringer>
  (method (to-string)
    (with-output-to-string
      (lambda ()
        (display this)))))

(define-record-type <duo>
  (implements <Stringer>)
  (fields one two)
  (custom-printer
    (lambda (@{this <duo>@} port sub-printer)
      (display "#[duo "    port)
      (display (.one this) port)
      (display #\space     port)
      (display (.two this) port)
      (display #\]         port))))

(define (fun @{O <Stringer>@})
  (.to-string O))

(fun (new <duo> 1 2))   @result{} "#[duo 1 2]"
@end lisp

The record--type @class{duo} implements the interface @class{Stringer}
which has a default method @code{to-string}; @class{duo} implements the
method by itself:

@lisp
(define-interface-type <Stringer>
  (method (@{to-string <string>@})
    (with-output-to-string
      (lambda ()
        (display this)))))

(define-record-type <duo>
  (implements <Stringer>)
  (fields one two)
  (method (@{to-string <string>@})
    (with-output-to-string
      (lambda ()
        (display "#[duo ")
        (display (.one this))
        (display #\space)
        (display (.two this))
        (display #\])))))

(define (fun @{O <Stringer>@})
  (.to-string O))

(fun (new <duo> 1 2))   @result{} "#[duo 1 2]"
@end lisp

Default methods have a limitation: they cannot extend other methods.
The following definitions will raise an expand--time exception:

@lisp
(define-interface-type <IOne>
  (method (@{doit <number>@})
    1))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype doit
    (lambda (<string>) => (<number>))))
@end lisp

@noindent
because we cannot extend the default method @code{doit} in @class{IOne}
with a method prototype in @class{ITwo}.  The following definitions will
raise an expand--time exception:

@lisp
(define-interface-type <IOne>
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method (@{doit <number>@})
    1))
@end lisp

@noindent
because we cannot extend the method prototype @code{doit} in
@class{IOne} with a default method in @class{ITwo}.  The following
definitions will raise an expand--time exception:

@lisp
(define-interface-type <IOne>
  (method (@{doit <number>@})
    1))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method (@{doit <number>@} @{S <string>@})
    2))
@end lisp

@noindent
because we cannot extend the default method @code{doit} in @class{IOne}
with the default method @code{doit} in @class{ITwo}.

Here we use an ``instantiable body'' to define a ``generic'' interface--type:

@lisp
(import (vicare language-extensions instantiable-bodies))

(define-instantiable-body define-iface-arith
  (define-interface-type <Iface>
    (method-prototype add
      (lambda () => (<type-name>)))))

(begin
  (define-iface-arith
    ((<Iface>             <NumberArith>)
     (<type-name>         <number>)))
  (define (nfun @{O <NumberArith>@})
    (.add O)))

(begin
  (define-iface-arith
    ((<Iface>             <StringArith>)
     (<type-name>         <string>)))
  (define (sfun @{O <StringArith>@})
    (.add O)))

(define-record-type <duo>
  (implements <NumberArith>)
  (fields one two)
  (method (@{add <number>@})
    (+ (.one this) (.two this))))

(define-record-type <string-duo>
  (implements <StringArith>)
  (fields one two)
  (method (@{add <string>@})
    (string-append (.one this) (.two this))))

(nfun (new <duo> 1 2))                  @result{} 3
(sfun (new <string-duo> "hel" "lo"))    @result{} "hello"
@end lisp

@c page
@node types labels
@section Sub--typing with labels


@cindex Library @library{vicare language-extensions labels}
@cindex @library{vicare language-extensions labels}, library


@dfn{Labels} are types built on top of other types: we put type labels
on values of a parent type to handle them locally in a special way.
There are two kinds of labels:

@itemize
@item
Labels without custom type predicate.  They are synonyms of their parent
type and add methods to it.  A value matches the label type if it
matches the parent type.

@item
Labels with custom type predicate.  A value matches the label type if it
satisfies the label's type predicate; it is possible to establish when a
value matches the label type only at run--time.
@end itemize

The following syntactic bindings are exported by the library
@library{vicare language-extensions labels}.


@deffn Syntax define-label-type @meta{type-name} @meta{clause} @dots{}
@deffnx {Auxiliary Syntax} nongenerative
@deffnx {Auxiliary Syntax} parent
@deffnx {Auxiliary Syntax} constructor
@deffnx {Auxiliary Syntax} destructor
@deffnx {Auxiliary Syntax} type-predicate
@deffnx {Auxiliary Syntax} equality-predicate
@deffnx {Auxiliary Syntax} comparison-procedure
@deffnx {Auxiliary Syntax} hash-function
@deffnx {Auxiliary Syntax} method
@deffnx {Auxiliary Syntax} mixins
Define a new label type.  @meta{type-name} must be a syntactic
identifier representing the label name.

The clause @clause{parent} is mandatory and its single argument must be
a type annotation.

The following clauses can be used in the same way they are used in
@syntax{define-record-type}:

@lisp
parent type-predicate
equality-predicate comparison-procedure hash-function
method mixins
@end lisp

@noindent
notice that labels @strong{cannot} implement interfaces.

The clause @clause{constructor} may appear zero, one or more times;
these clauses define a constructor function to be used with the syntax
@syntax{new}.  The @clause{constructor} clause has a syntax similar to
@syntax{lambda}; it must have the format:

@lisp
(constructor @meta{formals} @metao{body} @meta{body} ...)
@end lisp

@noindent
where @meta{formals} must specify one or more arguments, the first of
which of type @meta{type-name}.  @meta{formals} must @strong{not}
specify a return value: the constructor returns a single value of type
@var{type-name}, and its specification is automatically generated.

The clause @clause{destructor} may appear zero or one time; this clause
defines a destructor function to be used with the syntax
@syntax{delete}; this destructor is @strong{not} used by the garbage
collector.  The @clause{destructor} clause has a syntax similar to
@syntax{lambda}; it must have the format:

@lisp
(destructor @meta{formals} @metao{body} @meta{body} ...)
@end lisp

@noindent
where @meta{formals} must specify a single argument of type
@meta{type-name}.  @meta{formals} must @strong{not} specify a return
value: the destructor should return unspecified values.

The optional clause @clause{nongenerative} must be used with a single
argument being a symbol representing a @uid{} associated with the label
type; such symbol is used by @syntax{type-unique-identifiers} and so it
allows multimethods to use label types.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Examples of simple labels

The following example defines a label @class{String} that is just a
synonym for @class{string}:

@lisp
(define-label-type <String>
  (parent <string>))

(define @{O <String>@}
  "ciao")

(.length O)     @result{} 4
(hash    O)     @expansion{} (string-hash O)
@end lisp

The following example defines a label to represent fixnums returned by
comparison procedures (@samp{-1}, @samp{0}, @samp{+1}):

@lisp
(define-label-type <comparison-fixnum>
  (parent (or <non-negative-fixnum> <negative-fixnum>))
  (type-predicate
    (lambda (@{parent-pred <type-predicate>@})
      (lambda (obj)
        (and (parent-pred obj)
             (fx<=? obj +1)
             (fx>=? obj -1))))))

(is-a? +1 <comparison-fixnum>)  @result{} #t
(is-a? -1 <comparison-fixnum>)  @result{} #t
(is-a?  0 <comparison-fixnum>)  @result{} #t

(is-a? +2 <comparison-fixnum>)  @result{} #f
(is-a? -2 <comparison-fixnum>)  @result{} #f
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Examples of hash function

Now let's define a custom hash function (we ignore the parent hash
function that gets passed as @var{parent-hash} argument):

@lisp
(define-label-type <String>
  (parent <string>)
  (hash-function
    (lambda (parent-hash)
      (lambda (S)
        (if (string-empty? S)
            0
          (char-hash (string-ref S 0)))))))

(define @{O <String>@}
  "ciao")

(hash O)     @equiv{} (char-hash #\c)
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Examples of methods

Let's define a label with a method to increment a fixnum.

@lisp
(define-label-type <fx>
  (parent <fixnum>)
  (method (incr)
    (fxadd1 this)))

(define @{O <fx>@}
  10)

(.incr O)       @result{} 11
@end lisp

Now let's define a method for appending prefixes and suffixes:

@lisp
(define-label-type <String>
  (parent <string>)
  (method (@{append <String>@} @{suff <String>@})
    (string-append this suff))
  (method (@{append <String>@} @{pref <String>@} @{suff <String>@})
    (string-append pref this suff)))

(define @{O <String>@}
  "ciao")

(.append O "-suff")             @result{} "ciao-suff"
(.append O "pref-" "-suff")     @result{} "pref-ciao-suff"

(.length (.append O "pref-" "-suff"))
@result{} 14
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Defining a constructor function

In the following example:

@lisp
(define-label-type <vec>
  (parent <nevector>)
  (constructor (a b)
    (vector a b))
  (constructor (a b c)
    (vector a b c)))

(new <vec> 1 2)         @result{} #(1 2)
(new <vec> 1 2 3)       @result{} #(1 2 3)
@end lisp

@noindent
we can think of the @clause{constructor} clauses as generating the
following functions definition:

@lisp
(define/overload (@{<vec>-constructor <vec>@} a b)
  (vector a b))

(define/overload (@{<vec>-constructor <vec>@} a b c)
  (vector a b c))
@end lisp

@noindent
notice that a type signature for the return value has been automatically
inserted.

@c ------------------------------------------------------------------------

@subsubheading Defining a destructor function

Here we define a bogus destructor function:

@lisp
(define-label-type <vec>
  (parent <vector>)
  (destructor (@{O <vec>@})
    `(deleted ,O)))

(define @{O <vec>@}
  '#(1 2))

(delete O)      @result{} (deleted #(1 2))
@end lisp

@noindent
we can think of the @clause{destructor} clauses as generating the
following function definition:

@lisp
(define (<vec>-destructor @{O <vec>@})
  `(deleted ,O))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example of mixin

Here we show how to include mixin clauses in a label definition:

@lisp
(define-mixin-type <stuff>
  (method (pussy)
    (list 'pussy (.name this))))

(define-label-type <peluche>
  (parent (list <symbol>))
  (method (name)
    (car this))
  (mixins <stuff>))

(define @{O <peluche>@}
  '(cat))

(.name  O)      @result{} cat
(.pussy O)      @result{} (pussy cat)
@end lisp

@c end of file
