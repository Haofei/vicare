@node types
@chapter Typed language


@value{PRJNAME}'s expander implements an extension to the language
defined by @rnrs{6} that allows the definition of typed syntactic
bindings.

@menu
* types intro::                 Introduction to the typed language.
* types syntaxes::              Convenience syntaxes.
* types built-in::              Built-in object types.
@end menu

@c page
@node types intro
@section Introduction to the typed language


@value{PRJNAME}'s typed language adds some expand--time syntactic
binding type--checking and extended @oop{} syntax to the language
specified by @rnrs{6}.  The result is a Scheme language dialect in which
the code writer is invited to explicitly write the type identifiers;
there is, in practice, @strong{no} type inference.

@menu
* types intro philosophy::      Typed language philosophy.
* types intro enabling::        Enabling typed language extensions.
* types intro type ids::        Type identifiers.
* types intro typed vars::      Typed lexical variables.
@end menu

@c page
@node types intro philosophy
@subsection Typed language philosophy


In the following discussion we refer to @rnrs{6} specifications as
@dfn{standard Scheme language}, shortly @dfn{standard language}.  We
refer to a function's operands and return values as its @dfn{signature}.
When a function is applied to a tuple of arguments and a tuple of return
values is expected: the number and types of arguments and return values
must be validated; we refer to such validation as @dfn{application
signature validation}.

To understand the role of @value{PRJNAME}'s typed language extensions,
we have to consider that:

@itemize
@item
Standard Scheme is dynamically typed: language implementations might
perform application signatures validation at run--time every time a
function is called, considering that the return values of a function
application are discarded or become the arguments of another function
application.  For example the function @func{flsin} can be implemented
as:

@example
#!r6rs
(import (except (rnrs (6))
                flsin)
  (vicare system $flonums))

(define (flsin x)
  (assert (flonum? x))
  ($flsin x))
@end example

@item
It is possible to build a standard Scheme language implementation that
performs compile--time type inference; with such implementation:
occasionally the compiler can determine the type of arguments and return
values and collapse multiple validations into a single one.  For
example:

@example
#!r6rs
(import (rnrs (6)))

(define (flsomething x)
  (values (flsin x) (flcos x) (fltan x)))
@end example

@noindent
can be transformed into (pseudo--code):

@example
#!r6rs
(import (rnrs (6))
  (vicare system $flonums))

(define (flsomething x)
  (assert (flonum? x))
  (values ($flsin x) ($flcos x) ($fltan x)))
@end example

@noindent
or automatically defined safe and unsafe variants of the same function:

@example
#!r6rs
(import (rnrs (6))
  (vicare system $flonums))

(define (flsomething x)
  (assert (flonum? x))
  ($flsomething x))

(define ($flsomething x)
  (values ($flsin x) ($flcos x) ($fltan x)))
@end example

@noindent
so that the unsafe @func{$flsomething} can be used later in place of the
safe @func{flsomething} if we know that the argument is a flonum.

@item
The Scheme language is defined to have two steps: expansion; compilation
or interpretation.  Standard Scheme is a ``high--level language'' which
is transformed into a ``core language'' by the process of expansion; the
expander allows macros to implement customised high--level
transformations.  The core language expressions are handed to the
compiler or the interpreter.

@item
Type inference does not blend well with standard Scheme macro expansion;
it is, in general, impossible to infer the types of a macro use before
fully expanding it, or, in special cases, at least partially expanding
it.  True type inference can be performed on the core language that is
the result of fully expanding the standard language.  This means we
cannot integrate the powerful features of the expander in the code
resulting from transformations made possible by type inference.

@item
@value{PRJNAME} is a language dialect whose purpose is to be a standard
Scheme language with extensions; it allows mixed use of standard
language syntax and extended language syntax.  The language extensions
are mostly implemented in the expander, to allow user code to customise
the generation of core language.

@item
By explicitly specifying the types of lexical bindings:
@value{PRJNAME}'s dialect allows some of the expand--time validations
and transformations that would be possible in a language with full type
inference.
@end itemize

@c page
@node types intro enabling
@subsection Enabling typed language extensions


Typed language extensions are @strong{off} by default.  To enable the
extensions we have to use the @code{typed-language} option as follows:

@itemize
@item
For libraries:

@lisp
(library (demo)
  (options typed-language)
  (export)
  (import (vicare))
  ---)
@end lisp

@noindent
@ref{iklib libraries options, typed-language}.

@item
For programs:

@lisp
(program (demo)
  (options typed-language)
  (import (vicare))
  ---)
@end lisp

@noindent
@ref{iklib programs options, typed-language}.
@end itemize

@noindent
we usually want to import the library @library{vicare} to use the
extended syntaxes that recognise type definitions and declarations.

The declaration of types makes use of the @func{brace} syntax
(@pxref{iklib syntaxes misc, brace}) as follows:

@example
(define (brace O <fixnum>)
  123)
@end example

@noindent
to use the extensions in a friendly manner we need to put the reader in
@samp{#!vicare} mode; this way @func{brace} can be inserted using actual
brace characters, as follows:

@example
#!vicare
(define @{O <fixnum>@}
  123)
@end example


@defun enable-typed-language
@defunx disable-typed-language
Enable or disable typed language support.  These functions are meant to
be used at the @repl{}; they do @strong{not} modify support for typed
language for programs and libraries.
@end defun

@c page
@node types intro type ids
@subsection Type identifiers


A @dfn{type identifier} is a bound syntactic identifier whose syntactic
binding's descriptor contains informations about the type's properties.
Examples of type identifiers are:

@itemize
@item
Struct--type name identifiers defined by @func{define-struct}; they are
automatically made type identifiers by @value{PRJNAME}.

@item
Record--type name identifiers defined by @func{define-record-type}; they
are automatically made type identifiers by @value{PRJNAME}.  Condition
object types (like @condition{i/o}) are special cases of these.

@item
The library @library{vicare} exports a set type identifiers (whose
implementation is integrated in @value{PRJNAME}'s expander) representing
the types of built--in objects.  Some of them are: @class{fixnum},
@class{string}, @class{vector}, @class{textual-input-port}.
@end itemize

Type identifiers are organised in a tree hierarchy, with subtypes
inheriting properties of supertypes; by convention, @class{top} is the
parent of all the type identifiers, the root of the tree; @class{top}
has no parent.

Many predefined type identifiers have names enclosed in ``angular
parentheses'' @samp{< >}, but this is just a convention.  Any valid
symbol can be used as name for a type identifier.

@c page
@node types intro typed vars
@subsection Typed lexical variables


A @dfn{typed lexical variable}, shortly @dfn{typed variable}, is a bound
syntactic identifier whose syntactic binding's descriptor contains both
informations about a lexical variable and its type identifier.  Typed
variables are created by the built--in binding syntaxes @func{lambda},
@func{define}, @func{let}, @func{letrec}, @func{let-values}, et cetera.
Typed variables are similar to identifier syntaxes created by
@syntax{identifier-syntax}.

An example of typed binding creation follows:

@example
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare)
  (define @{O <fixnum>@}
    123))
@end example

@noindent
the syntactic identifier @code{O} represents a typed variable with type
identifier @class{fixnum}; the braces are used to type the first
enclosed identifier with the second enclosed identifier.

At the time the typed variable's syntactic binding is established: the
type identifier must already be a type identifier.  So the following
program (where @samp{---} represents an unspecified form) is correct
because @objtype{duo} is bound before @var{O}:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))
  (define-record-type duo
    (fields one two))
  (define @{O duo@}
    ---))
@end lisp

@noindent
the follow program is @strong{not} correct:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))
  (define @{O duo@}
    ---)
  (define-record-type duo
    (fields one two)))
@end lisp

@noindent
and will cause an expand--time syntax violation.

@c page
@node types syntaxes
@section Type syntaxes


Object types are uniquely associated to a syntactic identifier
representing their name; @value{PRJNAME} allows us to perform some
operations on objects through generic syntaxes, provided that we use the
type's name.

Unless otherwise specified, the syntactic bindings documented in this
section are exported by the library @library{vicare}.  When showing code
examples, we always assume: to have imported the library
@library{vicare}; to have enabled the typed language; to have put the
Scheme source code reader in @code{#!vicare} mode.

@menu
* types syntaxes descriptors::  Retrieving type descriptors.
* types syntaxes new-and-del::  Constructors and destructors.
* types syntaxes predicates::   Predicate syntaxes.
* types syntaxes slots::        Slot getter and setter syntaxes.
* types syntaxes methods::      Calling object-type methods.
* types syntaxes unsafe-cast::  Casting the type of expressions.
* types syntaxes super-sub::    Super and sub types.
* types syntaxes assert::       Validating signatures.
@end menu

@c page
@node types syntaxes descriptors
@subsection Retrieving type descriptors


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-descriptor @meta{type}
Expand to an expression which, when evaluated, results in:

@itemize
@item
A struct--type descriptor if the given identifier argument @meta{type}
is a struct--type name.

@item
A record--type descriptor if the given identifier argument @meta{type}
is a record--type name.
@end itemize
@end deffn

@c page
@node types syntaxes new-and-del
@subsection Constructors and destructors


The syntaxes @syntax{new} and @syntax{delete} allow us to retrieve the
constructor and destructor function of Scheme objects of some types.
For example, with records:

@lisp
(define-record-type duo
  (fields one two)
  (destructor-protocol
    (lambda ()
      (lambda (self)
        (fprintf (current-error-port) "destroying ~s\n" self)))))

(define O
  (new duo 1 2))

(delete O)
@print{} destroying #[record duo one=1 two=2]
@end lisp

@noindent
such syntaxes make it easier to code, for example, compensated
allocation of objects:

@lisp
(define (make-compensated-duo one two)
  (compensate
      (new duo one two)
    (with
      (delete <>))))
@end lisp

@noindent
where @syntax{<>} is the fluid syntax exported by @library{vicare} and
@syntax{compensate} binds it to the value returned by the allocation
form (@pxref{iklib compensations api, compensate}).

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax new @meta{type} @meta{arg} @dots{}
Retrieve the default constructor function of the type @var{type-name}
and apply it to the given arguments; return the result of the
application.
@end deffn


@deffn Syntax delete @meta{expr}
Retrieve the destructor function, if any, of the object returned by the
evaluation of the expression @meta{expr} and apply it to the object;
return the return value of the application.  The evaluation of
@meta{expr} must return a single return value.
@end deffn

@c page
@node types syntaxes predicates
@subsection Predicate syntaxes


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax is-a? @meta{expr} @meta{type}
@deffnx Syntax is-a? _ @meta{type}
@deffnx {Auxiliary Syntax} _
Expand to an expression which, when evaluated, returns @true{} if
@meta{expr} evaluates to a struct or record of type @meta{type}.
@meta{expr} can be any expression returning a single value.

When @syntax{_} is used as first argument: the syntax evaluates to a
predicate function.

@example
(define-record-type duo
  (fields one two))

(is-a? (new duo 1 2) two)       @result{} #t

((is-a? _ duo) (new duo 1 2))   @result{} #t

(is-a? 123 duo)                 @result{} #f
@end example
@end deffn

@c page
@node types syntaxes slots
@subsection Slot getter and setter syntaxes


The syntaxes @func{slot-ref} and @func{slot-set!} allow access and
mutation of struct and record fields:

@example
(define-record-type color
  (fields (mutable red)
          (mutable green)
          (mutable blue)))

(define @{R color@}
  (new color 1 2 3))

(slot-set! R red   color 19)
(slot-set! R green color 29)
(slot-set! R blue  color 39)

(slot-ref R red   color)        @result{} 19
(slot-ref R green color)        @result{} 29
(slot-ref R blue  color)        @result{} 39
@end example

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax slot-ref @meta{expr} @meta{field-name} @meta{type}
@deffnx Syntax slot-ref _ @meta{field-name} @meta{type}
@deffnx Syntax slot-ref @meta{expr} @meta{field-name}
@deffnx {Auxiliary Syntax} _
Expand to the slot accessor of @meta{field-name} applied to @meta{expr}.
@meta{expr} can be any expression evaluating to an instance of
@meta{type}.  @meta{type} must be the type identifier of a struct--type
or record--type.  @meta{field-name} must be an identifier representing
the name of a field.  When @syntax{_} is used in place of @meta{expr}:
the syntax evaluates to a slot accessor function.
@end deffn


@deffn Syntax slot-set! @meta{expr} @meta{field-name} @meta{type} @meta{new-val}
@deffnx Syntax slot-set! _ @meta{field-name} @meta{type} _
@deffnx Syntax slot-set! @meta{expr} @meta{field-name} @meta{type} @meta{new-val}
@deffnx {Auxiliary Syntax} _
Expand to the slot mutator of @meta{field-name} applied to @meta{expr}
and @meta{new-val}.  @meta{expr} can be any expression evaluating to an
instance of @meta{type}.  @meta{type} must be the type identifier of a
struct--type or record--type.  @meta{field-name} must be an identifier
representing the name of a field.  When @syntax{_} is used in place of
both @meta{expr} and @meta{new-val}: the syntax evaluates to a slot
mutator function.
@end deffn

@c page
@node types syntaxes methods
@subsection Calling object--type methods


The following keyword syntactic bindings are involved in the definition
and use of methods: @clause{method}, @clause{case-method},
@syntax{method-call}.  In addition the function
@func{method-call-late-binding} performs a method call with ``late
binding'' (run--time dispatching).

The keywords @clause{method} and @clause{case-method} are used in
@syntax{define-record-type} to define methods for a record type
(@pxref{iklib records defs methods, Record--type methods}).  For
example:

@lisp
(define-record-type duo
  (fields one two)
  (method (sum-them self)
    (+ (duo-one self)
       (duo-two self)))
  (method (mul-them self)
    (* (duo-one self)
       (duo-two self))))
@end lisp

@noindent
the syntax @syntax{method-call} is then used to call a record's methods:

@lisp
(define @{O duo@}
  (new duo 3 5))

(method-call sum-them O)        @result{} 8
(method-call mul-them O)        @result{} 15
@end lisp

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax method-call @meta{name} @meta{subject-expr} @meta{arg} @dots{}
Apply an object--type's method to the return value of
@meta{subject-expr} and the optional arguments @meta{arg}.

@meta{name} must be a symbol representing a method name.
@meta{subject-expr} must be a Scheme expression which, expanded and
evaluated at run--time, returns a single value.  Each @meta{arg} must be
a Scheme expression which, expanded and evaluated at run--time, returns
a single value.

When possible, @syntax{method-call} determines at expand--time the type
of the expression @meta{subject-expr} and searches for a method with
equal name, according to @func{eq?}.  If the method is found, the
syntactic identifier to which the implementation procedure is bound is
inserted in the macro expansion:

@lisp
(@meta{procedure} @meta{subject-expr} @meta{arg} ...)
@end lisp

@noindent
If the object--type of @meta{subject-expr} has no matching method: its
super--type is inspected, then the super--type of the super--type and so
on.  If no method is found in the types hierarchy: an exception is
raised.

@syntax{method-call} is able to retrieve the type of its second argument
at expand--time only when the typed language is enabled.  If
@syntax{method-call} cannot determine the type of @meta{subject-expr} at
expand--time, the macro use is expanded to:

@lisp
(method-call-late-binding (quote @meta{name})
                          @meta{subject-expr} @meta{arg} ...)
@end lisp

@noindent
and the function @func{method-call-late-binding} attempts to determine a
suitable method at run--time.
@end deffn


@defun method-call-late-binding @var{name} @var{subject} @var{arg} @dots{}
Apply an object--type's method to @var{subject} and the optional
arguments @meta{arg}.  Return the application results.

@var{name} must be a symbol representing a method name.  @var{subject}
must be a Scheme object implementing a set of methods.  The optional
@meta{arg} arguments can be any value.

This function attempts to determine the type of @var{subject} at
run--time and searches the object--type's table of methods, if any, for
a method whose name equals @var{name} according to @func{eq?}.  If a
method is found, its implementation procedure is retrieved and applied
to @var{subject} and the @var{arg} values.

If the object--type of @var{subject} has no matching method: its
super--type is inspected, then the super--type of the super--type and so
on.  If no method is found in the types hierarchy: an exception is
raised.

Usually we do not need to call this function explicitly; however, it is
useful for debugging purposes.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Dot notation

When the Scheme reader's textual input port is configured in
@samp{#!vicare} mode: if a list starts with a symbol; the name of the
symbol is a string of length at least @math{2}; the first character of
the string is a dot; the second character of the string is @strong{not}
a dot, then a @syntax{method-call} symbol is inserted and the symbol
stripped of the dot.

We can try it at the @repl{}:

@example
vicare> '(.ciao)
$1 = (method-call ciao)
@end example

Notice that @rnrs{6} forbids symbols starting with a dot, with the
exception of the ellipsis; so this transformation does not influence the
other reader operations.

We can use this notation to call an object--type's methods as in the
following program:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))

  (define-record-type duo
    (fields one two)

    (method (sum-them @{O duo@})
      (+ (.one O) (.two O)))

    (method (mul-them @{O duo@})
      (* (.one O) (.two O)))

    (method (display O port)
      (display O port)))

  (define @{O duo@}
    (new duo 3 4))

  (pretty-print (.sum-them O)
                (current-error-port))

  (pretty-print (.mul-them O)
                (current-error-port))

  (.display O (current-error-port))
  (newline (current-error-port))

  #| end of program |# )
@end lisp

@c page
@node types syntaxes unsafe-cast
@subsection Casting the type of expressions


It is sometimes useful to explicitly declare the type of an expression,
so that the expander can perform more type checks and, maybe,
optimisations.  We might want to do it as an unsafe operation, without
introducing run--time validation of values.  For example, if we know
that the result of an expression is a vector of @math{3} fixnums, we
might write:

@lisp
($vector-ref @meta{expr} 1)
@end lisp

@noindent
and everything is all right, but we are not specifying that the return
value is a fixnum.

In these corner cases, we can use the syntax @syntax{unsafe-cast}: at
expand--time, it tags an expression as returning a single value of the
declared type.  So, in the above example, we could write:

@lisp
(unsafe-cast <fixnum>
  ($vector-ref @meta{expr} 1))
@end lisp

We can easily check how @syntax{unsafe-cast} works at the @repl{}:

@example
vicare> (unsafe-cast <fixnum> 123)
$1 = 123
vicare> (expansion-of (unsafe-cast <fixnum> 123))
$1 = '123
vicare> (type-of (unsafe-cast <fixnum> 123))
$1 = (struct <retvals-signature>
       (tags (#<syntactic-identifier expr=<fixnum> mark*=(src)>)))
@end example

@noindent
for a truly untyped expression:

@example
vicare> (expansion-of (unsafe-cast <fixnum> (read)))
$1 = ((primitive read))
vicare> (type-of (unsafe-cast <fixnum> (read)))
$1 = (struct <retvals-signature>
       (tags (#<syntactic-identifier expr=<fixnum> mark*=(src)>)))
@end example

@noindent
if the type is wrong, and we know it at expand--time:

@example
vicare> (unsafe-cast <fixnum> "ciao")
Unhandled exception
 Condition components:
   1. &who: unsafe-cast
   2. &message: "expression type is incompatible with the requested tag"
   3. &syntax:
       form: #<syntax expr=(unsafe-cast <fixnum> "ciao") mark*=(src)>
       subform: #<syntax expr="ciao" mark*=(src)>
   4. &irritants: ((struct <retvals-signature>
   (tags (#<syntactic-identifier expr=<string> mark*=(src)>))))
@end example

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax unsafe-cast @meta{type} @meta{expr}
Expand to the @meta{expr} expression itself, but, in the expander, tags
the expression as returning a single value of type @meta{type}.

If it is possible to determine at expand--time the type of the
@meta{expr}: this syntax checks the compatibility of the type with the
given @meta{type}.
@end deffn

@c page
@node types syntaxes super-sub
@subsection Super and sub types


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-super-and-sub? @metai{type} @metaii{type}
Expand to a boolean constant: @true{} if @metai{type} is a super--type
of @metaii{type}; otherwise @false{}.  @class{top} is conventionally the
super--type of all the types.

@lisp
(type-super-and-sub? <number> <fixnum>)      @result{} #t
(type-super-and-sub? <number> <string>)      @result{} #f
(type-super-and-sub? <top> <number>)         @result{} #t
(type-super-and-sub? <number> <top>)         @result{} #f

(expansion-of
  (type-super-and-sub? <number> <fixnum>))
@result{} (quote #t)

(expansion-of
  (type-super-and-sub? <number> <string>))
@result{} (quote #f)

(define-record-type alpha)

(define-record-type beta
  (parent alpha))

(define-record-type gamma
  (parent beta))

(type-super-and-sub? alpha beta)        @result{} #t
(type-super-and-sub? beta alpha)        @result{} #f

(type-super-and-sub? alpha gamma)       @result{} #t
(type-super-and-sub? gamma alpha)       @result{} #f

(type-super-and-sub? beta gamma)        @result{} #t
(type-super-and-sub? gamma beta)        @result{} #f
@end lisp
@end deffn


@deffn signature-super-and-sub? @metai{signature} @metaii{signature}
Expand to a boolean constant: @true{} if @metai{signature} is a
super--signature of @metaii{signature}; otherwise @false{}.  A ``type
signature'' is a proper or improper list of type identifiers, with
@class{list} or one of its sub--types in tail position when the list is
improper.

@lisp
(signature-super-and-sub? (<number>) (<fixnum>))        @result{} #t
(signature-super-and-sub? (<number>) (<string>))        @result{} #f

(expansion-of
  (signature-super-and-sub? (<number>) (<fixnum>))
@result{} (quote #t)

(expansion-of
  (signature-super-and-sub? (<number>) (<string>))
@result{} (quote #f)

(signature-super-and-sub? (<top>) (<number>))   @result{} #t
(signature-super-and-sub? (<number>) (<top>))   @result{} #f

(signature-super-and-sub? (<number> <number>) (<fixnum> <fixnum>))
@result{} #t
(signature-super-and-sub? (<fixnum> <fixnum>) (<number> <number>))
@result{} #f

(signature-super-and-sub? (<number> <number> . <list>)
                          (<fixnum> <real>   . <list>))
@result{} #t
@end lisp
@end deffn

@c page
@node types syntaxes assert
@subsection Validating signatures


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax assert-signature @meta{signature} @meta{expr}
@deffnx Syntax assert-signature-and-return @meta{signature} @meta{expr}
Validate the type signature of the values returned by @meta{expr},
either at expand--time or run--time.  @meta{expr} can be any Scheme
expression.  @meta{signature} must be a proper or improper list of type
identifiers representing the type signature.  The first syntax returns a
single unspecified value; the second syntax returns the return values of
@meta{expr}.

If it is possible to validate the signature at expand--time: when
successful, the syntax use just expands to the evaluation of
@meta{expr}; when a type mismatch is detected, an expand--time exception
is raised.  Otherwise the syntax use expands to an expression that
validates the values at run--time.
@end deffn


Here are some validation examples:

@lisp
(assert-signature () (values))
(assert-signature-and-return (<fixnum>) 123)    @result{} 123
(assert-signature-and-return (<string>) "ciao") @result{} "ciao"

(assert-signature-and-return (<fixnum> <flonum>) 1 2.0)
@result{} 1 2.0

(expansion-of
  (assert-signature (<fixnum>) 123))
@result{} (begin (quote 123) (quote #!void))

(expansion-of
  (assert-signature-and-return (<fixnum>) 123))
@result{} (quote 123)

(expansion-of
  (assert-signature-and-return (<fixnum>)
    (unsafe-cast <fixnum> (read))))
@result{} ((primitive read))
@end lisp

Given that the signature validation happens at expand--time (when
possible) there are some interesting special cases:

@itemize
@item
If we want to assert that an expression returns zero values, we can do:

@lisp
(assert-signature () @meta{expr})
@end lisp

@item
If we want to assert that an expression returns a single value, of any
type, we can do:

@lisp
(assert-signature (<top>) @meta{expr})
@end lisp

@item
If we want to assert that an expression returns two values, of any type,
we can do:

@lisp
(assert-signature (<top> <top>) @meta{expr})
@end lisp

@item
If we want to assert that an expression returns two or more values, of
any type, we can do:

@lisp
(assert-signature (<top> <top> . <list>) @meta{expr})
@end lisp

@item
If we want to assert nothing, we can do:

@lisp
(assert-signature <list> @meta{expr})
@end lisp

@noindent
which will just expand to the evaluation of @meta{expr}; this might be
useful when the syntax is used in the output form of another macro use.
@end itemize

@c page
@node types built-in
@section Built--in object types


The library @library{vicare} exports keyword syntactic bindings
representing the types of built--in objects: fixnum, strings, vectors,
et cetera.

@menu
* types built-in top::          The conventional parent of all the types.
* types built-in void::         Type of the void object.
* types built-in booleans::     Type of boolean objects.
* types built-in chars::        Type of character objects.
* types built-in symbols::      Type of symbol objects.
* types built-in keywords::     Type of keyword objects.
* types built-in pointers::     Type of pointer objects.
* types built-in transcoders::  Type of transcoder objects.
* types built-in procedures::   Type of procedures objects.
* types built-in numerics::     Type of numeric objects.
* types built-in strings::      Type of string objects.
* types built-in vectors::      Type of vector objects.
* types built-in pairs::        Type of pair objects.
* types built-in lists::        Types of lists.
* types built-in bytevectors::  Type of bytevector objects.
* types built-in hashtables::   Type of hashtable objects.
* types built-in structs::      Type of struct objects.
* types built-in records::      Type of record objects.
* types built-in conditions::   Type of condition objects.
* types built-in ports::        Types of input/output ports.
@end menu

@c page
@node types built-in top
@subsection The conventional parent of all the types


@deftp {Built--in Type} @aclass{top}
The conventional parent of all the types.
@end deftp


@defop Constructor @class{top} new @aclass{top} @var{obj}
Return @var{obj} itself.
@end defop


@defop {Type predicate} @class{top} is-a? @var{obj} @aclass{top}
Always return @true{}.
@end defop


@deftypemethod @class{top} @aclass{fixnum} hash @var{self}
Apply @func{object-hash} to the instance.
@end deftypemethod

@c page
@node types built-in void
@subsection The type of the void value


@deftp {Built--in Type} @aclass{void}
@deftpx {Parent Type} @aclass{top}
The type of the void object.
@end deftp


@defop Constructor @class{void} new @aclass{void}
Return the void object.
@end defop


@defop {Type predicate} @class{void} is-a? @var{obj} @aclass{void}
The type predicate is @func{void-object?}.  Return @true{} if @var{obj}
is void; otherwise return @false{}.
@end defop

@c page
@node types built-in booleans
@subsection Type of boolean values


@deftp {Built--in Type} @aclass{boolean}
@deftpx {Parent Type} @aclass{top}
Type of the boolean values @true{} and @false{}.
@end deftp


@defop Constructor @class{boolean} new @aclass{boolean} @var{obj}
Return @true{} if @var{obj} is true; otherwise return @false{}.
@end defop


@defop {Type predicate} @class{boolean} is-a? @var{obj} @aclass{boolean}
The type predicate is @func{boolean?}.  Return @true{} if @var{obj} is
@true{} or @false{}; otherwise return @false{}.
@end defop

@c ------------------------------------------------------------------------

@deftp {Built--in Type} @aclass{true}
@deftpx {Parent Type} @aclass{boolean}
Type of the boolean value @true{}.  There is no constructor.  There is
no predicate.
@end deftp


@deftp {Built--in Type} @aclass{false}
@deftpx {Parent Type} @aclass{boolean}
Type of the boolean value @false{}.  There is no constructor.  There is
no predicate.
@end deftp

@c page
@node types built-in chars
@subsection Type of character values


@deftp {Built--in Type} @aclass{char}
@deftpx {Parent Type} @aclass{top}
Type of character values.
@end deftp


@defop Constructor @class{char} new @aclass{char} @var{obj}
The constructor is @func{integer->char}.
@end defop


@defop {Type predicate} @class{char} is-a? @var{obj} @aclass{char}
The type predicate is @func{char?}.  Return @true{} if @var{obj} is a
character object; otherwise return @false{}.
@end defop


@deftypemethod @class{char} @aclass{string} string @var{self}
Apply @func{string} to the instance.
@end deftypemethod


@deftypemethod @class{char} @aclass{fixnum} hash @var{self}
Apply @func{char-hash} to the instance.
@end deftypemethod


@deftypemethod @class{char} @aclass{fixnum} integer @var{self}
Apply @func{char->integer} to the instance.
@end deftypemethod


@deftypemethod @class{char} @aclass{fixnum} fixnum @var{self}
Apply @func{char->fixnum} to the instance.
@end deftypemethod

@c page
@node types built-in symbols
@subsection Type of symbol values


@deftp {Built--in Type} @aclass{symbol}
@deftpx {Parent Type} @aclass{top}
Type of symbol values (including gensyms).
@end deftp


@defop Constructor @class{symbol} new @aclass{symbol} @var{string}
The constructor is @func{string->symbol}.
@end defop


@defop {Type predicate} @class{symbol} is-a? @var{obj} @aclass{symbol}
The type predicate is @func{symbol?}.  Return @true{} if @var{obj} is a
symbol object; otherwise return @false{}.
@end defop


@deftypemethod @class{symbol} @aclass{string} string @var{self}
Apply @func{symbol->string} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{fixnum} hash @var{self}
Apply @func{symbol-hash} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{boolean} bound? @var{self}
Apply @func{symbol-bound?} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{top} value @var{self}
@deftypemethodx @class{symbol} @aclass{void} value @var{self} @var{new-value}
When called with no arguments: apply @func{symbol-value} to the instance
to retrieve the current value in the @code{value} slot.  When called
with one argument: apply @func{set-symbol-value!} to the instance to
store a new value @code{value} slot.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{void} putprop @var{self} (@var{key} @aclass{symbol}) @var{value}
Apply @func{putprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{top} getprop @var{self} (@var{key} @aclass{symbol})
Apply @func{getprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{void} remprop @var{self} (@var{key} @aclass{symbol})
Apply @func{remprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{list} property-list @var{self}
Apply @func{property-list} to the instance.
@end deftypemethod

@c page
@node types built-in keywords
@subsection Type of keyword values


@deftp {Built--in Type} @aclass{keyword}
@deftpx {Parent Type} @aclass{top}
Type of keyword values.
@end deftp


@defop Constructor @class{keyword} new @aclass{keyword} @var{symbol}
The constructor is @func{symbol->keyword}.
@end defop


@defop {Type predicate} @class{keyword} is-a? @var{obj} @aclass{keyword}
The type predicate is @func{keyword?}.  Return @true{} if @var{obj} is a
keyword object; otherwise return @false{}.
@end defop


@deftypemethod @class{keyword} @aclass{symbol} symbol @var{self}
Apply @func{keyword->symbol} to the instance.
@end deftypemethod


@deftypemethod @class{keyword} @aclass{string} string @var{self}
Apply @func{keyword->string} to the instance.
@end deftypemethod


@deftypemethod @class{keyword} @aclass{fixnum} hash @var{self}
Apply @func{keyword-hash} to the instance.
@end deftypemethod

@c page
@node types built-in pointers
@subsection Type of pointer values


@deftp {Built--in Type} @aclass{pointer}
@deftpx {Parent Type} @class{top}
Type of pointer values.
@end deftp


@defop Constructor @class{pointer} new @aclass{pointer} @var{int}
The constructor is @func{integer->pointer}.
@end defop


@defop {Type predicate} @class{pointer} is-a? @var{obj} @aclass{pointer}
The type predicate is @func{pointer?}.  Return @true{} if @var{obj} is a
pointer object; otherwise return @false{}.
@end defop


@deftypemethod @class{pointer} @aclass{boolean} null? @var{self}
Apply @func{pointer-null?} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{exact-integer} integer @var{self}
Apply @func{pointer->integer} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} = @var{self} @var{ptr} @dots{}
Apply @func{pointer=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} != @var{self} @var{ptr} @dots{}
Apply @func{pointer!=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} < @var{self} @var{ptr} @dots{}
Apply @func{pointer<?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} > @var{self} @var{ptr} @dots{}
Apply @func{pointer>?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} <= @var{self} @var{ptr} @dots{}
Apply @func{pointer<=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} >= @var{self} @var{ptr} @dots{}
Apply @func{pointer>=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} add @var{diff}
Apply @func{pointer-add} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} diff @var{self} @var{pointer}
Apply @func{pointer-diff} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} clone @var{self}
Apply @func{pointer-clone} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{void} set-null! @var{self}
Apply @func{set-pointer-null!)} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{fixnum} hash @var{self}
Apply @func{pointer-hash} to the instance.
@end deftypemethod

@c page
@node types built-in transcoders
@subsection Type of transcoder values


@deftp {Built--in Type} @aclass{transcoder}
@deftpx {Parent Type} @aclass{top}
Type of transcoder values.
@end deftp


@defop Constructor @class{transcoder} new @aclass{transcoder} @var{codec}
@defopx Constructor @class{transcoder} new @aclass{transcoder} @var{codec} @var{eol-style}
@defopx Constructor @class{transcoder} new @aclass{transcoder} @var{codec} @var{eol-style} @var{handling-mode}
The constructor is @func{make-transcoder}.
@end defop


@defop {Type predicate} @class{transcoder} is-a? @var{obj} @aclass{transcoder}
The type predicate is @func{transcoder?}.  Return @true{} if @var{obj}
is a transcoder object; otherwise return @false{}.
@end defop


@deftypemethod @class{transcoder} @aclass{symbol} codec @var{self}
Apply @func{transcoder-codec} to the instance.
@end deftypemethod


@deftypemethod @class{transcoder} @aclass{symbol} eol-style @var{self}
Apply @func{transcoder-eol-style} to the instance.
@end deftypemethod


@deftypemethod @class{transcoder} @aclass{symbol} handling-mode @var{self}
Apply @func{transcoder-error-handling-mode} to the instance.
@end deftypemethod

@c page
@node types built-in procedures
@subsection Type of procedures values


@deftp {Built--in Type} @aclass{procedure}
@deftpx {Parent Type} @aclass{top}
Type of closure object values.  There is no constructor.
@end deftp


@defop {Type predicate} @class{procedure} is-a? @var{obj} @aclass{procedure}
The type predicate is @func{procedure?}.  Return @true{} if @var{obj} is
a closure object; otherwise return @false{}.
@end defop

@c ------------------------------------------------------------------------

@deftp {Built--in Type} @aclass{predicate}
@deftpx {Parent Type} @aclass{procedure}
Type of closure object values accepting a single argument and returning
a single boolean.  There is no constructor.  There is no type predicate.
@end deftp

@c page
@node types built-in numerics
@subsection Type of numeric values


@menu
* types built-in numerics number::           Type of number values.
* types built-in numerics complex::          Type of complex values.
* types built-in numerics real-valued::      Type of real-valued values.
* types built-in numerics real::             Type of real values.
* types built-in numerics rational-valued::  Type of rational-valued values.
* types built-in numerics rational::         Type of rational values.
* types built-in numerics integer-valued::   Type of integer-valued values.
* types built-in numerics integer::          Type of integer values.
* types built-in numerics exact-integer::    Type of exact-integer values.
* types built-in numerics fixnums::          Type of fixnum values.
* types built-in numerics bignums::          Type of bignum values.
* types built-in numerics flonums::          Type of flonum values.
* types built-in numerics ratnums::          Type of ratnum values.
* types built-in numerics compnums::         Type of compnum values.
* types built-in numerics cflonums::         Type of cflonum values.
@end menu

@c page
@node types built-in numerics number
@subsubsection Type of number values


@deftp {Built--in Type} <number>
@deftpx {Parent Type} <top>
Type of numeric values.  There is no constructor.  The type predicate is
@func{number?}.
@end deftp

@c page
@node types built-in numerics complex
@subsubsection Type of complex values


@deftp {Built--in Type} <complex>
@deftpx {Parent Type} <number>
Type of complex numbers.  The constructor is @func{make-rectangular}.
The type predicate is @func{complex?}.
@end deftp

@c page
@node types built-in numerics real-valued
@subsubsection Type of real--valued values


@deftp {Built--in Type} <real-valued>
@deftpx {Parent Type} <complex>
Type of real--valued values.  There is no constructor.  The type
predicate is @func{real-valued?}.
@end deftp

@c page
@node types built-in numerics real
@subsubsection Type of real values


@deftp {Built--in Type} <real>
@deftpx {Parent Type} <real-valued>
Type of real values.  There is no constructor.  The type predicate is
@func{real?}.
@end deftp

@c page
@node types built-in numerics rational-valued
@subsubsection Type of rational--valued values


@deftp {Built--in Type} <rational-valued>
@deftpx {Parent Type} <real>
Type of rational--valued values.  There is no constructor.  The type
predicate is @func{rational-valued?}.
@end deftp

@c page
@node types built-in numerics rational
@subsubsection Type of rational values


@deftp {Built--in Type} <rational>
@deftpx {Parent Type} <rational-valued>
Type of rational values.  There is no constructor.  The type predicate
is @func{rational?}.
@end deftp

@c page
@node types built-in numerics integer-valued
@subsubsection Type of integer--valued values


@deftp {Built--in Type} <integer-valued>
@deftpx {Parent Type} <rational-valued>
Type of integer--valued values.  There is no constructor.  The type
predicate is @func{integer-valued?}.
@end deftp

@c page
@node types built-in numerics integer
@subsubsection Type of integer values


Notice that @class{integer} is a @class{rational}, not a
@class{integer-valued}.


@deftp {Built--in Type} <integer>
@deftpx {Parent Type} <rational>
Type of integer values.  There is no constructor.  The type predicate is
@func{integer?}.
@end deftp

@c page
@node types built-in numerics exact-integer
@subsubsection Type of exact--integer values


@deftp {Built--in Type} <exact-integer>
@deftpx {Parent Type} <integer>
Type of exact integers.  There is no constructor.  The type predicate is
@func{exact-integer?}.
@end deftp

@c page
@node types built-in numerics fixnums
@subsubsection Type of fixnum values


@deftp {Built--in Type} <fixnum>
@deftpx {Parent Type} <exact-integer>
Type of fixnum values.  There is no constructor.  The type predicate is
@func{fixnum?}.
@end deftp

@c page
@node types built-in numerics bignums
@subsubsection Type of bignum values


@deftp {Built--in Type} <bignum>
@deftpx {Parent Type} <exact-integer>
Type of bignum values.  There is no constructor.  The type predicate is
@func{bignum?}.
@end deftp

@c page
@node types built-in numerics flonums
@subsubsection Type of flonum values


@deftp {Built--in Type} <flonum>
@deftpx {Parent Type} <real-valued>
Type of flonum values.  There is no constructor.  The type predicate is
@func{flonum?}.
@end deftp

@c page
@node types built-in numerics ratnums
@subsubsection Type of ratnum values


@deftp {Built--in Type} <ratnum>
@deftpx {Parent Type} <rational>
Type of ratnum values.  There is no constructor.  The type predicate is
@func{ratnum?}.
@end deftp

@c page
@node types built-in numerics compnums
@subsubsection Type of compnum values


@deftp {Built--in Type} <compnum>
@deftpx {Parent Type} <complex>
Type of compnum values.  There is no constructor.  The type predicate is
@func{compnum?}.
@end deftp

@c page
@node types built-in numerics cflonums
@subsubsection Type of cflonum values


@deftp {Built--in Type} <cflonum>
@deftpx {Parent Type} <complex>
Type of cflonum values.  There is no constructor.  The type predicate is
@func{cflonum?}.
@end deftp

@c page
@node types built-in strings
@subsection Type of string values


@deftp {Built--in Type} @class{string}
@deftpx {Parent Type} @aclass{top}
Type of string values.
@end deftp


@defop Constructor @class{string} new @aclass{string} @var{char} @dots{}
The constructor is @func{string}.
@end defop


@defop {Type predicate} @class{string} is-a? @var{obj} @aclass{string}
The type predicate is @func{string?}.  Return @true{} if @var{obj} is a
string object; otherwise return @false{}.
@end defop

@c ------------------------------------------------------------------------

@subsubheading Inspection


@deftypemethod @class{string} @aclass{boolean} empty? @var{self}
Apply @func{string-empty?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} length @var{self}
Apply @func{string-length} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} for-each @var{self} @var{func} @var{str} @dots{}
Apply @func{string-for-each} to the function @var{func}, the instance
and the arguments.  Example:

@lisp
(.for-each "ciao" display)
@end lisp
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Constructors


@deftypemethod @aclass{string} copy @var{self}
Apply @func{string-copy} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} append @var{self}
Apply @func{string-append} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators


@deftypemethod @aclass{string} ref @var{self} @var{idx}
Apply @func{string-ref} to the instance and the index @var{idx}.
@end deftypemethod


@deftypemethod @aclass{string} set! @var{self} @var{idx} @var{char}
Apply @func{string-set!} to the instance, the index @var{idx} and the
character @var{char}.
@end deftypemethod


@deftypemethod @aclass{string} fill! @var{self} @var{char}
Apply @func{string-fill!} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Encoding inspection


@deftypemethod @aclass{string} ascii-encoded? @var{self}
Apply @func{ascii-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} latin1-encoded? @var{self}
Apply @func{latin1-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} octets-encoded? @var{self}
Apply @func{octets-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} uri-encoded @var{self}
Apply @func{uri-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} pencent-encoded? @var{self}
Apply @func{percent-encoded-string?} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Comparison


@deftypemethod @aclass{string} = @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} < @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} > @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} <= @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} >= @var{self} @var{str} @dots{}
Apply @func{string=?}, @func{string<?}, @func{string>?},
@func{string<=?}, @func{string>=?} to the instance and the arguments.
@end deftypemethod


@deftypemethod @aclass{string} ci= @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci< @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci> @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci<= @var{self} @var{str} @dots{}
@deftypemethodx @aclass{string} ci>= @var{self} @var{str} @dots{}
Apply @func{string-ci=?}, @func{string-ci<?}, @func{string-ci>?},
@func{string-ci<=?}, @func{string-ci>=?}, to the instance and the
arguments.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Case handling


@deftypemethod @aclass{string} titlecase @var{self}
Apply @func{string-titlecase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} upcase @var{self}
Apply @func{string-upcase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} downcase @var{self}
Apply @func{string-downcase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} foldcase @var{self}
Apply @func{string-foldcase} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Normalisation


@deftypemethod @aclass{string} normalize-nfc @var{self}
Apply @func{string-normalize-nfc} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfd @var{self}
Apply @func{string-normalize-nfd} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfkc @var{self}
Apply @func{string-normalize-nfkc} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfkd @var{self}
Apply @func{string-normalize-nfkd} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Conversion


@deftypemethod @aclass{string} flonum @var{self}
Apply @func{string->flonum} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} number @var{self}
@deftypemethodx @aclass{string} number @var{self} @var{radix}
Apply @func{string->number} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} utf8 @var{self}
Apply @func{string->utf8} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16 @var{self}
@deftypemethodx @aclass{string} utf16 @var{self} @var{endianness}
Apply @func{string->utf16} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} utf16be @var{self}
Apply @func{string->utf16be} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16le @var{self}
Apply @func{string->utf16le} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16n @var{self}
Apply @func{string->utf16n} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf32 @var{self}
@deftypemethodx @aclass{string} utf32 @var{self} @var{endianness}
Apply @func{string->utf32} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} bytevector @var{self}
@deftypemethodx @aclass{string} bytevector @var{self} @var{transcoder}
Apply @func{string->bytevector} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} ascii @var{self}
Apply @func{string->ascii} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} latin1 @var{self}
Apply @func{string->latin1} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} octets @var{self}
Apply @func{string->octets} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} percent-encoding @var{self}
Apply @func{string->percent-encoding} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} uri-encoding @var{self}
Apply @func{string->uri-encoding} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} base64->bytevector @var{self}
Apply @func{string-base64->bytevector} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} hex->bytevector @var{self}
Apply @func{string-hex->bytevector} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} symbol @var{self}
Apply @func{string->symbol} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} keyword @var{self}
Apply @func{string->keyword} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} list @var{self}
Apply @func{string->list} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Miscellaneous


@deftypemethod @aclass{string} hash @var{self}
Apply @func{string-hash} to the instance.
@end deftypemethod

@c page
@node types built-in vectors
@subsection Type of vector values


@deftp {Built--in Type} <vector>
@deftpx {Parent Type}         <top>
Type of vector values.  The constructor is @func{vector}.  The type
predicate is @func{vector?}.
@end deftp

@c page
@node types built-in pairs
@subsection Type of pair objects


@deftp {Built--in Type} <pair>
@deftpx {Parent Type} <top>
Type of pair objects.
@end deftp


@defop Constructor @class{pair} new <pair> @var{A} @var{D}
The constructor is @func{cons}.  Return a new pair having @var{A} and
@var{D} as car and cdr.
@end defop


@defop {Type predicate} @class{pair} is-a? @var{obj} <pair>
@defopx {Type predicate} @class{pair} is-a? _ <pair>
The type predicate is @func{pair?}.  Return @true{} if @var{obj} is a
pair object; otherwise return @false{}.
@end defop


@defmethod @class{pair} car
Apply @func{car} to the type instance.
@end defmethod


@defmethod @class{pair} cdr
Apply @func{cdr} to the type instance.
@end defmethod

@c page
@node types built-in lists
@subsection Types of lists


@menu
* types built-in lists proper::         Proper lists.
* types built-in lists null::           Empty lists.
* types built-in lists not-empty::      Not-empty proper lists.
* types built-in lists chars::          Proper lists of @class{char}.
* types built-in lists strings::        Proper lists of @class{string}.
* types built-in lists pointers::       Proper lists of @class{pointer}.
@end menu

@c page
@node types built-in lists proper
@subsubsection Proper lists


@deftp {Built--in Type} @aclass{list}
@deftpx {Parent Type} @aclass{top}
Type of proper lists, both null and non--empty.
@end deftp


@defop Constructor @class{list} new @aclass{list} @var{obj} @dots{}
The constructor is @func{list}.  Return a new list having the given
@var{obj} arguments as items.
@end defop


@defop {Type predicate} @class{list} is-a? @var{obj} @aclass{list}
The type predicate is @func{list?}.  Return @true{} if @var{obj} is null
or a proper list object; otherwise return @false{}.
@end defop

@c page
@node types built-in lists null
@subsubsection Empty lists


@deftp {Built--in Type} @aclass{null}
@deftpx {Parent Type} @aclass{list}
Type of the null object.
@end deftp


@defop {Type predicate} @class{null} is-a? @var{obj} @aclass{null}
The type predicate is @func{null?}.  Return @true{} if @var{obj} is
null; otherwise return @false{}.
@end defop

@c page
@node types built-in lists not-empty
@subsubsection Not--empty proper lists


@deftp {Built--in Type} @aclass{nlist}
@deftpx {Parent Type} @aclass{list}
Type of non--empty lists.
@end deftp


@defop Constructor @class{nlist} new @aclass{nlist} @varo{obj} @var{obj} @dots{}
The constructor is @func{nlist}.  Return a new list having the given
@var{obj} arguments as items.
@end defop


@defop {Type predicate} @class{nlist} is-a? @var{obj} @aclass{nlist}
The type predicate is @func{nlist?}.  Return @true{} if @var{obj} is a
proper non--empty list object; otherwise return @false{}.
@end defop


@defmethod @class{nlist} car
Apply @func{car} to the type instance.
@end defmethod


@defmethod @class{nlist} cdr
Apply @func{cdr} to the type instance.
@end defmethod

@c page
@node types built-in lists chars
@subsubsection Proper lists of @class{char}


@deftp {Built--in Type} @aclass{char*}
@deftpx {Parent Type} @aclass{list}
Type of lists of @class{char} objects.
@end deftp


@defop {Type predicate} @class{char*} is-a? @var{obj} @aclass{char*}
The type predicate for the list's items is the type predicate of
@class{char}.  Return @true{} if @var{obj} is a proper non--empty list
object; otherwise return @false{}.
@end defop

@c page
@node types built-in lists strings
@subsubsection Proper lists of @class{string}


@deftp {Built--in Type} @aclass{string*}
@deftpx {Parent Type} @aclass{list}
Type of lists of @class{string} objects.
@end deftp


@defop {Type predicate} @class{string*} is-a? @var{obj} @aclass{string*}
The type predicate for the list's items is the type predicate of
@class{string}.  Return @true{} if @var{obj} is a proper non--empty list
object; otherwise return @false{}.
@end defop

@c page
@node types built-in lists pointers
@subsubsection Proper lists of @class{pointer}


@deftp {Built--in Type} @aclass{pointer*}
@deftpx {Parent Type} @aclass{list}
Type of lists of @class{pointer} objects.
@end deftp


@defop {Type predicate} @class{pointer*} is-a? @var{obj} @aclass{pointer*}
The type predicate for the list's items is the type predicate of
@class{pointer}.  Return @true{} if @var{obj} is a proper non--empty
list object; otherwise return @false{}.
@end defop

@c page
@node types built-in bytevectors
@subsection Type of bytevector objects


@deftp {Built--in Type} <bytevector>
@deftpx {Parent Type} <top>
Type of bytevector objects.  The constructor is @func{make-bytevector}.
The type predicate is @func{bytevector?}.
@end deftp

@c page
@node types built-in hashtables
@subsection Type of hashtable objects


@deftp {Built--in Type} <hashtable>
@deftpx {Parent Type} <top>
Base type for hashtable objects.  There is no constructor.  The type
predicate is @func{hashtable?}.
@end deftp


@deftp {Built--in Type} <hashtable-eq>
@deftpx {Parent Type} <hashtable>
Type of @func{eq?} hashtables.  The constructor is
@func{make-eq-hashtable}.  There type predicate is @func{hashtable-eq?}.
@end deftp


@deftp {Built--in Type} <hashtable-eqv>
@deftpx {Parent Type} <hashtable>
Type of @func{eqv?} hashtables.  The constructor is
@func{make-eqv-hashtable}.  There type predicate is @func{hashtable-eqv?}.
@end deftp


@deftp {Built--in Type} <hashtable-equal>
@deftpx {Parent Type} <hashtable>
Type of @func{equal?} hashtables.  The constructor is
@func{make-hashtable}.  There type predicate is @func{hashtable-equiv?}.
@end deftp

@c page
@node types built-in structs
@subsection Type of struct objects


@deftp {Built--in Type} <struct>
@deftpx {Parent Type} <top>
Type of struct objects.  There is no constructor.  The type predicate is
@func{struct?}.
@end deftp


@deftp {Built--in Type} <struct-type-descriptor>
@deftpx {Parent Type} <struct>
Type of struct--type descriptor objects.  The constructor is
@func{make-struct-type}.  The type descriptor is
@func{struct-type-descriptor?}.
@end deftp

@c page
@node types built-in records
@subsection Type of record objects


@deftp {Built--in Type} <record>
@deftpx {Parent Type} <struct>
Type of record objects.  There is no constructor.  The type predicate is
@func{record?}.
@end deftp


@deftp {Built--in Type} <record-type-descriptor>
@deftpx {Parent Type} <struct>
Type of record--type descriptor objects.  The constructor is
@func{make-record-type-descriptor}.  The type predicate is
@func{record-type-descriptor?}.
@end deftp


@deftp {Built--in Type} <record-constructor-descriptor>
@deftpx {Parent Type} <struct>
Type of record--constructor descriptor objects.  The constructor is
@func{make-record-constructor-descriptor}.  The type predicate is
@func{record-constructor-descriptor?}.
@end deftp

@c page
@node types built-in conditions
@subsection Type of condition objects


@deftp {Built--in Type} <condition>
@deftpx {Parent Type} <record>
Type of condition objects.  There is no constructor.  The type predicate
is @func{condition?}.
@end deftp


@deftp {Built--in Type} <compound-condition>
@deftpx {Parent Type} <condition>
Type of compound condition objects.  The constructor is
@func{condition}.  The type predicate is @func{compound-condition?}.
@end deftp


@defmethod @class{condition} print
@defmethodx @class{compound-condition} print
Apply @func{print-condition} to the instance.
@end defmethod

@c page
@node types built-in ports
@subsection Types of input/output ports


@menu
* types built-in ports base::            Base port types.
* types built-in ports textual::         Textual port types.
* types built-in ports binary::          Binary port types.
* types built-in ports textual in::      Textual input port types.
* types built-in ports textual out::     Textual output port types.
* types built-in ports textual in/out::  Textual input/output port types.
* types built-in ports binary in::       Binary input port types.
* types built-in ports binary out::      Binary output port types.
* types built-in ports binary in/out::   Binary input/output port types.
@end menu

@c page
@node types built-in ports base
@subsubsection Base port types


@deftp {Built--in Type} <port>
@deftpx {Parent Type} <top>
Base type for input, output and input/output ports.  There is no
constructor.  The type predicate is @func{port?}.
@end deftp


@deftp {Built--in Type} <input-port>
@deftpx {Parent Type} <port>
Base type for input ports.  There is no constructor.  The type predicate
is @func{input-port?}.
@end deftp


@deftp {Built--in Type} <output-port>
@deftpx {Parent Type} <port>
Base type for output ports.  There is no constructor.  The type
predicate is @func{output-port?}.
@end deftp


@deftp {Built--in Type} <input/output-port>
@deftpx {Parent Type} <port>
Base type for input/output ports.  There is no constructor.  The type
predicate is @func{input/output-port?}.
@end deftp

@c page
@node types built-in ports textual
@subsubsection Textual port types


@deftp {Built--in Type} <textual-port>
@deftpx {Parent Type} <port>
Type of textual ports.  There is no constructor.  The type predicate is
@func{textual-port?}.
@end deftp

@c page
@node types built-in ports binary
@subsubsection Binary port types


@deftp {Built--in Type} <binary-port>
@deftpx {Parent Type} <port>
Type of binary ports.  There is no constructor.  The type predicate is
@func{binary-port?}.
@end deftp

@c page
@node types built-in ports textual in
@subsubsection Textual input port types


@deftp {Built--in Type} <textual-input-port>
@deftpx {Parent Type} <input-port>
Type of textual input ports.  There is no constructor.  The type
predicate is @func{textual-input-port?}.
@end deftp

@c page
@node types built-in ports textual out
@subsubsection Textual output port types


@deftp {Built--in Type} <textual-output-port>
@deftpx {Parent Type} <output-port>
Type of textual output port.  There is no constructor.  The type
predicate is @func{textual-output-port?}.
@end deftp

@c page
@node types built-in ports textual in/out
@subsubsection Textual input/output port types


@deftp {Built--in Type} <textual-input/output-port>
@deftpx {Parent Type} <input/output-port>
Type of textual input/output ports.  There is no constructor.  The type
predicate is @func{textual-input/output-port?}.
@end deftp

@c page
@node types built-in ports binary in
@subsubsection Binary input port types


@deftp {Built--in Type} <binary-input-port>
@deftpx {Parent Type} <input-port>
Type of binary input ports.  There is no constructor.  The type
predicate is @func{binary-input-port?}.
@end deftp

@c page
@node types built-in ports binary out
@subsubsection Binary output port types


@deftp {Built--in Type} <binary-output-port>
@deftpx {Parent Type} <output-port>
Type of binary output ports.  There is no constructor.  The type
predicate is @func{binary-output-port?}.
@end deftp

@c page
@node types built-in ports binary in/out
@subsubsection Binary input/output port types


@deftp {Built--in Type} <binary-input/output-port>
@deftpx {Parent Type} <input/output-port>
Type of binary input/output ports.  There is no constructor.  The type
predicate is @func{binary-input/output-port?}.
@end deftp


@c end of file
