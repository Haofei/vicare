@node types
@chapter Typed language


@value{PRJNAME}'s expander implements an extension to the language
defined by @rnrs{6} that allows the definition of typed syntactic
bindings.

@menu
* types intro::                  Introduction to the typed language.
* types syntaxes::               Convenience syntaxes.
@end menu

@c page
@node types intro
@section Introduction to the typed language


@value{PRJNAME}'s typed language adds some expand--time syntactic
binding type--checking and extended @oop{} syntax to the language
specified by @rnrs{6}.  The result is a Scheme language dialect in which
the code writer is invited to explicitly write the type identifiers;
there is, in practice, @strong{no} type inference.

@menu
* types intro philosophy::      Typed language philosophy.
* types intro enabling::        Enabling typed language extensions.
* types intro type ids::        Type identifiers.
* types intro typed vars::      Typed lexical variables.
@end menu

@c page
@node types intro philosophy
@subsection Typed language philosophy


In the following discussion we refer to @rnrs{6} specifications as
@dfn{standard Scheme language}, shortly @dfn{standard language}.  We
refer to a function's operands and return values as its @dfn{signature}.
When a function is applied to a tuple of arguments and a tuple of return
values is expected: the number and types of arguments and return values
must be validated; we refer to such validation as @dfn{application
signature validation}.

To understand the role of @value{PRJNAME}'s typed language extensions,
we have to consider that:

@itemize
@item
Standard Scheme is dynamically typed: language implementations might
perform application signatures validation at run--time every time a
function is called, considering that the return values of a function
application are discarded or become the arguments of another function
application.  For example the function @func{flsin} can be implemented
as:

@example
#!r6rs
(import (except (rnrs (6))
                flsin)
  (vicare system $flonums))

(define (flsin x)
  (assert (flonum? x))
  ($flsin x))
@end example

@item
It is possible to build a standard Scheme language implementation that
performs compile--time type inference; with such implementation:
occasionally the compiler can determine the type of arguments and return
values and collapse multiple validations into a single one.  For
example:

@example
#!r6rs
(import (rnrs (6)))

(define (flsomething x)
  (values (flsin x) (flcos x) (fltan x)))
@end example

@noindent
can be transformed into (pseudo--code):

@example
#!r6rs
(import (rnrs (6))
  (vicare system $flonums))

(define (flsomething x)
  (assert (flonum? x))
  (values ($flsin x) ($flcos x) ($fltan x)))
@end example

@noindent
or automatically defined safe and unsafe variants of the same function:

@example
#!r6rs
(import (rnrs (6))
  (vicare system $flonums))

(define (flsomething x)
  (assert (flonum? x))
  ($flsomething x))

(define ($flsomething x)
  (values ($flsin x) ($flcos x) ($fltan x)))
@end example

@noindent
so that the unsafe @func{$flsomething} can be used later in place of the
safe @func{flsomething} if we know that the argument is a flonum.

@item
The Scheme language is defined to have two steps: expansion; compilation
or interpretation.  Standard Scheme is a ``high--level language'' which
is transformed into a ``core language'' by the process of expansion; the
expander allows macros to implement customised high--level
transformations.  The core language expressions are handed to the
compiler or the interpreter.

@item
Type inference does not blend well with standard Scheme macro expansion;
it is, in general, impossible to infer the types of a macro use before
fully expanding it, or, in special cases, at least partially expanding
it.  True type inference can be performed on the core language that is
the result of fully expanding the standard language.  This means we
cannot integrate the powerful features of the expander in the code
resulting from transformations made possible by type inference.

@item
@value{PRJNAME} is a language dialect whose purpose is to be a standard
Scheme language with extensions; it allows mixed use of standard
language syntax and extended language syntax.  The language extensions
are mostly implemented in the expander, to allow user code to customise
the generation of core language.

@item
By explicitly specifying the types of lexical bindings:
@value{PRJNAME}'s dialect allows some of the expand--time validations
and transformations that would be possible in a language with full type
inference.
@end itemize

@c page
@node types intro enabling
@subsection Enabling typed language extensions


Typed language extensions are @strong{off} by default.  To enable the
extensions we have to use the @code{typed-language} option as follows:

@itemize
@item
For libraries:

@lisp
(library (demo)
  (options typed-language)
  (export)
  (import (vicare))
  ---)
@end lisp

@noindent
@ref{iklib libraries options, typed-language}.

@item
For programs:

@lisp
(program (demo)
  (options typed-language)
  (import (vicare))
  ---)
@end lisp

@noindent
@ref{iklib programs options, typed-language}.
@end itemize

@noindent
we usually want to import the library @library{vicare} to use the
extended syntaxes that recognise type definitions and declarations.

The declaration of types makes use of the @func{brace} syntax
(@pxref{iklib syntaxes misc, brace}) as follows:

@example
(define (brace O <fixnum>)
  123)
@end example

@noindent
to use the extensions in a friendly manner we need to put the reader in
@samp{#!vicare} mode; this way @func{brace} can be inserted using actual
brace characters, as follows:

@example
#!vicare
(define @{O <fixnum>@}
  123)
@end example


@defun enable-typed-language
@defunx disable-typed-language
Enable or disable typed language support.  These functions are meant to
be used at the @repl{}; they do @strong{not} modify support for typed
language for programs and libraries.
@end defun

@c page
@node types intro type ids
@subsection Type identifiers


A @dfn{type identifier} is a bound syntactic identifier whose syntactic
binding's descriptor contains informations about the type's properties.
Examples of type identifiers are:

@itemize
@item
Struct--type name identifiers defined by @func{define-struct}; they are
automatically made type identifiers by @value{PRJNAME}.

@item
Record--type name identifiers defined by @func{define-record-type}; they
are automatically made type identifiers by @value{PRJNAME}.  Condition
object types (like @condition{i/o}) are special cases of these.

@item
The library @library{vicare} exports a set type identifiers (whose
implementation is integrated in @value{PRJNAME}'s expander) representing
the types of built--in objects.  Some of them are: @class{fixnum},
@class{string}, @class{vector}, @class{textual-input-port}.
@end itemize

Type identifiers are organised in a tree hierarchy, with subtypes
inheriting properties of supertypes; by convention, @class{top} is the
parent of all the type identifiers, the root of the tree; @class{top}
has no parent.

Many predefined type identifiers have names enclosed in ``angular
parentheses'' @samp{< >}, but this is just a convention.  Any valid
symbol can be used as name for a type identifier.

@c page
@node types intro typed vars
@subsection Typed lexical variables


A @dfn{typed lexical variable}, shortly @dfn{typed variable}, is a bound
syntactic identifier whose syntactic binding's descriptor contains both
informations about a lexical variable and its type identifier.  Typed
variables are created by the built--in binding syntaxes @func{lambda},
@func{define}, @func{let}, @func{letrec}, @func{let-values}, et cetera.
Typed variables are similar to identifier syntaxes created by
@syntax{identifier-syntax}.

An example of typed binding creation follows:

@example
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare)
  (define @{O <fixnum>@}
    123))
@end example

@noindent
the syntactic identifier @code{O} represents a typed variable with type
identifier @class{fixnum}; the braces are used to type the first
enclosed identifier with the second enclosed identifier.

At the time the typed variable's syntactic binding is established: the
type identifier must already be a type identifier.  So the following
program (where @samp{---} represents an unspecified form) is correct
because @objtype{duo} is bound before @var{O}:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))
  (define-record-type duo
    (fields one two))
  (define @{O duo@}
    ---))
@end lisp

@noindent
the follow program is @strong{not} correct:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))
  (define @{O duo@}
    ---)
  (define-record-type duo
    (fields one two)))
@end lisp

@noindent
and will cause an expand--time syntax violation.

@c page
@node types syntaxes
@section Type syntaxes


Object types are uniquely associated to a syntactic identifier
representing their name; @value{PRJNAME} allows us to perform some
operations on objects through generic syntaxes, provided that we use the
type's name.

Unless otherwise specified, the syntactic bindings documented in this
section are exported by the library @library{vicare}.  When showing code
examples, we always assume: to have imported the library
@library{vicare}; to have enabled the typed language; to have put the
Scheme source code reader in @code{#!vicare} mode.

@menu
* types syntaxes descriptors::  Retrieving type descriptors.
* types syntaxes new-and-del::  Constructors and destructors.
* types syntaxes predicates::   Predicate syntaxes.
* types syntaxes slots::        Slot getter and setter syntaxes.
* types syntaxes methods::      Calling object-type methods.
* types syntaxes unsafe-cast::  Casting the type of expressions.
* types syntaxes super-sub::    Super and sub types.
@end menu

@c page
@node types syntaxes descriptors
@subsection Retrieving type descriptors


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-descriptor @meta{type}
Expand to an expression which, when evaluated, results in:

@itemize
@item
A struct--type descriptor if the given identifier argument @meta{type}
is a struct--type name.

@item
A record--type descriptor if the given identifier argument @meta{type}
is a record--type name.
@end itemize
@end deffn

@c page
@node types syntaxes new-and-del
@subsection Constructors and destructors


The syntaxes @syntax{new} and @syntax{delete} allow us to retrieve the
constructor and destructor function of Scheme objects of some types.
For example, with records:

@lisp
(define-record-type duo
  (fields one two)
  (destructor-protocol
    (lambda ()
      (lambda (self)
        (fprintf (current-error-port) "destroying ~s\n" self)))))

(define O
  (new duo 1 2))

(delete O)
@print{} destroying #[record duo one=1 two=2]
@end lisp

@noindent
such syntaxes make it easier to code, for example, compensated
allocation of objects:

@lisp
(define (make-compensated-duo one two)
  (compensate
      (new duo one two)
    (with
      (delete <>))))
@end lisp

@noindent
where @syntax{<>} is the fluid syntax exported by @library{vicare} and
@syntax{compensate} binds it to the value returned by the allocation
form (@pxref{iklib compensations api, compensate}).

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax new @meta{type} @meta{arg} @dots{}
Retrieve the default constructor function of the type @var{type-name}
and apply it to the given arguments; return the result of the
application.
@end deffn


@deffn Syntax delete @meta{expr}
Retrieve the destructor function, if any, of the object returned by the
evaluation of the expression @meta{expr} and apply it to the object;
return the return value of the application.  The evaluation of
@meta{expr} must return a single return value.
@end deffn

@c page
@node types syntaxes predicates
@subsection Predicate syntaxes


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax is-a? @meta{expr} @meta{type}
@deffnx Syntax is-a? _ @meta{type}
@deffnx {Auxiliary Syntax} _
Expand to an expression which, when evaluated, returns @true{} if
@meta{expr} evaluates to a struct or record of type @meta{type}.
@meta{expr} can be any expression returning a single value.

When @syntax{_} is used as first argument: the syntax evaluates to a
predicate function.

@example
(define-record-type duo
  (fields one two))

(is-a? (new duo 1 2) two)       @result{} #t

((is-a? _ duo) (new duo 1 2))   @result{} #t

(is-a? 123 duo)                 @result{} #f
@end example
@end deffn

@c page
@node types syntaxes slots
@subsection Slot getter and setter syntaxes


The syntaxes @func{slot-ref} and @func{slot-set!} allow access and
mutation of struct and record fields:

@example
(define-record-type color
  (fields (mutable red)
          (mutable green)
          (mutable blue)))

(define @{R color@}
  (new color 1 2 3))

(slot-set! R red   color 19)
(slot-set! R green color 29)
(slot-set! R blue  color 39)

(slot-ref R red   color)        @result{} 19
(slot-ref R green color)        @result{} 29
(slot-ref R blue  color)        @result{} 39
@end example

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax slot-ref @meta{expr} @meta{field-name} @meta{type}
@deffnx Syntax slot-ref _ @meta{field-name} @meta{type}
@deffnx Syntax slot-ref @meta{expr} @meta{field-name}
@deffnx {Auxiliary Syntax} _
Expand to the slot accessor of @meta{field-name} applied to @meta{expr}.
@meta{expr} can be any expression evaluating to an instance of
@meta{type}.  @meta{type} must be the type identifier of a struct--type
or record--type.  @meta{field-name} must be an identifier representing
the name of a field.  When @syntax{_} is used in place of @meta{expr}:
the syntax evaluates to a slot accessor function.
@end deffn


@deffn Syntax slot-set! @meta{expr} @meta{field-name} @meta{type} @meta{new-val}
@deffnx Syntax slot-set! _ @meta{field-name} @meta{type} _
@deffnx Syntax slot-set! @meta{expr} @meta{field-name} @meta{type} @meta{new-val}
@deffnx {Auxiliary Syntax} _
Expand to the slot mutator of @meta{field-name} applied to @meta{expr}
and @meta{new-val}.  @meta{expr} can be any expression evaluating to an
instance of @meta{type}.  @meta{type} must be the type identifier of a
struct--type or record--type.  @meta{field-name} must be an identifier
representing the name of a field.  When @syntax{_} is used in place of
both @meta{expr} and @meta{new-val}: the syntax evaluates to a slot
mutator function.
@end deffn

@c page
@node types syntaxes methods
@subsection Calling object--type methods


The following keyword syntactic bindings are involved in the definition
and use of methods: @clause{method}, @clause{case-method},
@syntax{method-call}.  In addition the function
@func{method-call-late-binding} performs a method call with ``late
binding'' (run--time dispatching).

The keywords @clause{method} and @clause{case-method} are used in
@syntax{define-record-type} to define methods for a record type
(@pxref{iklib records defs methods, Record--type methods}).  For
example:

@lisp
(define-record-type duo
  (fields one two)
  (method (sum-them self)
    (+ (duo-one self)
       (duo-two self)))
  (method (mul-them self)
    (* (duo-one self)
       (duo-two self))))
@end lisp

@noindent
the syntax @syntax{method-call} is then used to call a record's methods:

@lisp
(define @{O duo@}
  (new duo 3 5))

(method-call sum-them O)        @result{} 8
(method-call mul-them O)        @result{} 15
@end lisp

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax method-call @meta{name} @meta{subject-expr} @meta{arg} @dots{}
Apply an object--type's method to the return value of
@meta{subject-expr} and the optional arguments @meta{arg}.

@meta{name} must be a symbol representing a method name.
@meta{subject-expr} must be a Scheme expression which, expanded and
evaluated at run--time, returns a single value.  Each @meta{arg} must be
a Scheme expression which, expanded and evaluated at run--time, returns
a single value.

When possible, @syntax{method-call} determines at expand--time the type
of the expression @meta{subject-expr} and searches for a method with
equal name, according to @func{eq?}.  If the method is found, the
syntactic identifier to which the implementation procedure is bound is
inserted in the macro expansion:

@lisp
(@meta{procedure} @meta{subject-expr} @meta{arg} ...)
@end lisp

@noindent
If the object--type of @meta{subject-expr} has no matching method: its
super--type is inspected, then the super--type of the super--type and so
on.  If no method is found in the types hierarchy: an exception is
raised.

@syntax{method-call} is able to retrieve the type of its second argument
at expand--time only when the typed language is enabled.  If
@syntax{method-call} cannot determine the type of @meta{subject-expr} at
expand--time, the macro use is expanded to:

@lisp
(method-call-late-binding (quote @meta{name})
                          @meta{subject-expr} @meta{arg} ...)
@end lisp

@noindent
and the function @func{method-call-late-binding} attempts to determine a
suitable method at run--time.
@end deffn


@defun method-call-late-binding @var{name} @var{subject} @var{arg} @dots{}
Apply an object--type's method to @var{subject} and the optional
arguments @meta{arg}.  Return the application results.

@var{name} must be a symbol representing a method name.  @var{subject}
must be a Scheme object implementing a set of methods.  The optional
@meta{arg} arguments can be any value.

This function attempts to determine the type of @var{subject} at
run--time and searches the object--type's table of methods, if any, for
a method whose name equals @var{name} according to @func{eq?}.  If a
method is found, its implementation procedure is retrieved and applied
to @var{subject} and the @var{arg} values.

If the object--type of @var{subject} has no matching method: its
super--type is inspected, then the super--type of the super--type and so
on.  If no method is found in the types hierarchy: an exception is
raised.

Usually we do not need to call this function explicitly; however, it is
useful for debugging purposes.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Dot notation

When the Scheme reader's textual input port is configured in
@samp{#!vicare} mode: if a list starts with a symbol; the name of the
symbol is a string of length at least @math{2}; the first character of
the string is a dot; the second character of the string is @strong{not}
a dot, then a @syntax{method-call} symbol is inserted and the symbol
stripped of the dot.

We can try it at the @repl{}:

@example
vicare> '(.ciao)
$1 = (method-call ciao)
@end example

Notice that @rnrs{6} forbids symbols starting with a dot, with the
exception of the ellipsis; so this transformation does not influence the
other reader operations.

We can use this notation to call an object--type's methods as in the
following program:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))

  (define-record-type duo
    (fields one two)

    (method (sum-them @{O duo@})
      (+ (.one O) (.two O)))

    (method (mul-them @{O duo@})
      (* (.one O) (.two O)))

    (method (display O port)
      (display O port)))

  (define @{O duo@}
    (new duo 3 4))

  (pretty-print (.sum-them O)
                (current-error-port))

  (pretty-print (.mul-them O)
                (current-error-port))

  (.display O (current-error-port))
  (newline (current-error-port))

  #| end of program |# )
@end lisp

@c page
@node types syntaxes unsafe-cast
@subsection Casting the type of expressions


It is sometimes useful to explicitly declare the type of an expression,
so that the expander can perform more type checks and, maybe,
optimisations.  We might want to do it as an unsafe operation, without
introducing run--time validation of values.  For example, if we know
that the result of an expression is a vector of @math{3} fixnums, we
might write:

@lisp
($vector-ref @meta{expr} 1)
@end lisp

@noindent
and everything is all right, but we are not specifying that the return
value is a fixnum.

In these corner cases, we can use the syntax @syntax{unsafe-cast}: at
expand--time, it tags an expression as returning a single value of the
declared type.  So, in the above example, we could write:

@lisp
(unsafe-cast <fixnum>
  ($vector-ref @meta{expr} 1))
@end lisp

We can easily check how @syntax{unsafe-cast} works at the @repl{}:

@example
vicare> (unsafe-cast <fixnum> 123)
$1 = 123
vicare> (expansion-of (unsafe-cast <fixnum> 123))
$1 = '123
vicare> (type-of (unsafe-cast <fixnum> 123))
$1 = (struct <retvals-signature>
       (tags (#<syntactic-identifier expr=<fixnum> mark*=(src)>)))
@end example

@noindent
for a truly untyped expression:

@example
vicare> (expansion-of (unsafe-cast <fixnum> (read)))
$1 = ((primitive read))
vicare> (type-of (unsafe-cast <fixnum> (read)))
$1 = (struct <retvals-signature>
       (tags (#<syntactic-identifier expr=<fixnum> mark*=(src)>)))
@end example

@noindent
if the type is wrong, and we know it at expand--time:

@example
vicare> (unsafe-cast <fixnum> "ciao")
Unhandled exception
 Condition components:
   1. &who: unsafe-cast
   2. &message: "expression type is incompatible with the requested tag"
   3. &syntax:
       form: #<syntax expr=(unsafe-cast <fixnum> "ciao") mark*=(src)>
       subform: #<syntax expr="ciao" mark*=(src)>
   4. &irritants: ((struct <retvals-signature>
   (tags (#<syntactic-identifier expr=<string> mark*=(src)>))))
@end example

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax unsafe-cast @meta{type} @meta{expr}
Expand to the @meta{expr} expression itself, but, in the expander, tags
the expression as returning a single value of type @meta{type}.

If it is possible to determine at expand--time the type of the
@meta{expr}: this syntax checks the compatibility of the type with the
given @meta{type}.
@end deffn

@c page
@node types syntaxes super-sub
@subsection Super and sub types


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-super-and-sub? @metai{type} @metaii{type}
Expand to a boolean constant: @true{} if @metai{type} is a super--type
of @metaii{type}; otherwise @false{}.  @class{top} is conventionally the
super--type of all the types.

@lisp
(type-super-and-sub? <number> <fixnum>)         @result{} #t
(type-super-and-sub? <number> <string>)         @result{} #f
(type-super-and-sub? <top> <number>)            @result{} #t
(type-super-and-sub? <number> <top>)            @result{} #f

(expansion-of (type-super-and-sub? <number> <fixnum>))
@result{} (quote #t)

(expansion-of (type-super-and-sub? <number> <string>))
@result{} (quote #f)

(define-record-type alpha)

(define-record-type beta
  (parent alpha))

(define-record-type gamma
  (parent beta))

(type-super-and-sub? alpha beta)        @result{} #t
(type-super-and-sub? beta alpha)        @result{} #f

(type-super-and-sub? alpha gamma)       @result{} #t
(type-super-and-sub? gamma alpha)       @result{} #f

(type-super-and-sub? beta gamma)        @result{} #t
(type-super-and-sub? gamma beta)        @result{} #f
@end lisp
@end deffn

@c end of file
