@node libutils
@chapter Scheme libraries utilities


@cindex @library{vicare libraries}, library
@cindex Library @library{vicare libraries}


The library @library{vicare libraries} exports bindings to deal with the
libraries infrastructure of @value{PRJNAME}; this library is integrated
in the boot image.  It is suggested to import it using the prefix
@samp{libs.}, as in

@example
(import (prefix (vicare libraries) libs.))
@end example

@menu
* libutils names::              Library name utilities.
* libutils refs::               Library reference utilities.
* libutils libraries::          Library objects.
* libutils interning::          Interning libraries.
* libutils expanding::          Expanding libraries from source.
* libutils loading::            Loading libraries.
* libutils locating::           Locating libraries.
* libutils file-system::        Locating libraries on the file system.
* libutils dynamic::            Dynamically loading Scheme libraries.
* libutils compiling::          Compiling libraries.
@end menu

@c page
@node libutils names
@section Library name utilities


Library names are defined by @rnrs{6} to be used in @syntax{library}
forms to uniquely identify a library; @ref{scheme library form names,
Library names}.

@menu
* libutils names pred::         Library name predicates.
* libutils names split::        Decomposing library names.
* libutils names compar::       Library names comparison.
@end menu

@c page
@node libutils names pred
@subsection Library name predicates


The following bindings are exported by the library @library{vicare
libraries}.


@defun library-name? @var{sexp}
Return @true{} if @var{sexp} is a symbolic expressions compliant with
the definition of @meta{library-name} according to @rnrs{6}.

@example
(library-name? '())                             @result{} #f
(library-name? '(alpha))                        @result{} #t
(library-name? '(alpha beta))                   @result{} #t
(library-name? '(alpha beta gamma))             @result{} #t
(library-name? '(alpha beta gamma ()))          @result{} #t
(library-name? '(alpha beta gamma (1)))         @result{} #t
(library-name? '(alpha beta gamma (1 2 3)))     @result{} #t
(library-name? '(alpha 123 gamma))              @result{} #f
(library-name? '(alpha beta gamma (1 ciao)))    @result{} #f
@end example
@end defun


@defun library-version-numbers? @var{obj}
Return @true{} if @var{obj} is a list of library version numbers
according to @rnrs{6}, this includes @var{obj} being null.

@example
(library-version-numbers? '(1))         @result{} #t
(library-version-numbers? '(1 2 3))     @result{} #t
(library-version-numbers? '(1 -2 3))    @result{} #f
(library-version-numbers? '(1 A 3))     @result{} #f
@end example

@quotation
@strong{NOTE} According to @rnrs{6}: @var{obj} should be an exact
integer, which means a finxum or bignum for @value{PRJNAME}.  This
predicate accepts only fixnums because they are faster to handle and
``big enough''.
@end quotation
@end defun


@defun library-version-number? @var{obj}
Return @true{} if @var{obj} is a single version number according to
@rnrs{6}.
@end defun

@c page
@node libutils names split
@subsection Decomposing library names


The following bindings are exported by the library @library{vicare
libraries}.


@defun library-name-decompose @var{obj}
Scan @var{obj} validating it as a @meta{library-name} as specified by
@rnrs{6}.  Return two values: the list of identifiers, the version
specification.  The version can be null.  If @var{obj} is not a valid
@meta{library-name}: return @false{} and @false{}.  The returned values
may share structure with @var{obj}.

@example
(library-name-decompose '(alpha))
@result{} (alpha) ()

(library-name-decompose '(alpha beta))
@result{} (alpha beta) ()

(library-name-decompose '(alpha beta gamma))
@result{} (alpha beta gamma) ()

(library-name-decompose '(alpha beta gamma ()))
@result{} (alpha beta gamma) ()

(library-name-decompose '(alpha beta gamma (1)))
@result{} (alpha beta gamma) (1)

(library-name-decompose '(alpha beta gamma (1 2 3)))
@result{} (alpha beta gamma) (1 2 3)

(library-name-decompose '(alpha beta gamma (1 A 3)))
@result{} #f #f

(library-name-decompose '(alpha 1 gamma (1 2 3)))
@result{} #f #f
@end example
@end defun


@defun library-name->identifiers @var{sexp}
Given a symbolic expression compliant with the definition of
@meta{library-name} according to @rnrs{6}: return the list of
identifiers.  If @var{sexp} is not compliant return @false{}.

@example
(library-name->identifiers '(alpha))
@result{} (alpha)

(library-name->identifiers '(alpha beta))
@result{} (alpha beta)

(library-name->identifiers '(alpha beta gamma))
@result{} (alpha beta gamma)

(library-name->identifiers '(alpha beta gamma ()))
@result{} (alpha beta gamma)

(library-name->identifiers '(alpha beta gamma (1)))
@result{} (alpha beta gamma)

(library-name->identifiers '(alpha beta gamma (1 2 3)))
@result{} (alpha beta gamma)
@end example
@end defun


@defun library-name->version @var{sexp}
Given a symbolic expression compliant with the definition of
@meta{library-name} according to @rnrs{6}: return the list of version
numbers.  If @var{sexp} is not compliant return @false{}.

@example
(library-name->version '(alpha))
@result{} ()

(library-name->version '(alpha beta))
@result{} ()

(library-name->version '(alpha beta gamma))
@result{} ()

(library-name->version '(alpha beta gamma ()))
@result{} ()

(library-name->version '(alpha beta gamma (1)))
@result{} (1)

(library-name->version '(alpha beta gamma (1 2 3)))
@result{} (1 2 3)
@end example
@end defun

@c page
@node libutils names compar
@subsection Library names comparison


The following functions can be used to sort library names according to
the version number:

@example
(list-sort library-name<? '((x y (1 2))
                            (x y (1 3))))
@result{} ((x y (1 2))
    (x y (1 3)))

(list-sort library-name<? '((x y (1 4))
                            (x y (1 2))
                            (x y (2 1))
                            (x y (1 3))))
@result{} ((x y (1 2))
    (x y (1 3))
    (x y (1 4))
    (x y (2 1)))
@end example

The following bindings are exported by the library @library{vicare
libraries}.


@defun library-name=? @vari{sexp} @varii{sexp}
Given two symbolic expressions compliant with the definition of
@meta{library-name} according to @rnrs{6}: return @true{} if they have
the same list of identifiers and the same version numbers.
@end defun


@defun library-name<? @vari{sexp} @varii{sexp}
Given two symbolic expressions compliant with the definition of
@meta{library-name} according to @rnrs{6}: return @true{} if they have
the same list of identifiers and the version of @vari{sexp} is less than
the version of @varii{sexp}.
@end defun


@defun library-name<=? @vari{sexp} @varii{sexp}
Given two symbolic expressions compliant with the definition of
@meta{library-name} according to @rnrs{6}: return @true{} if they have
the same list of identifiers and the version of @vari{sexp} is less than
or equal to the version of @varii{sexp}.
@end defun


@defun library-name-identifiers=? @vari{sexp} @varii{sexp}
Given two symbolic expressions compliant with the definition of
@meta{library-name} according to @rnrs{6}: return @true{} if they have
the same list of identifiers.
@end defun

@c ------------------------------------------------------------

@defun library-version=? @vari{vrs} @varii{vrs}
Given two lists of version numbers compliant with the definition of
@meta{library-name} according to @rnrs{6}: return @true{} if they have
the same numbers.

If one of the lists is longer and the elements up to the end of the
shortest are equal: the lists are ``equal'' if the tail of the longest
is made of zeros.

Examples:

@example
(1 2 3) == (1 2 3)
(1 2 3) != (1 2 3 4)
(1 2 3) == (1 2 3 0 0 0)
@end example
@end defun


@defun library-version<? @vari{vrs} @varii{vrs}
Given two lists of version numbers compliant with the definition of
@meta{library-name} according to @rnrs{6}: return @true{} if the version
number represented by @vari{vrs} is less than the version number
represented by @varii{vrs}.

Comparison of digits stops at the first digit for which @func{<} or
@func{>} return true.

If one of the lists is longer and the elements up to the end of the
shortest are equal: the lists are ``equal'' if the tail of the longest
is made of zeros.

Examples:

@example
(1 2 3) <  (4 2 3)
(1 2 3) <  (1 4 3)
(1 2 3) <  (1 2 4)
(1 2 3) <  (1 2 3 4)
(1 2 3) !< (1 2 3 0 0 0)
@end example
@end defun


@defun library-version<=? @vari{vrs} @varii{vrs}
Given two lists of version numbers compliant with the definition of
@meta{library-name} according to @rnrs{6}: return @true{} if the version
number represented by @vari{vrs} is less than or equal to the version
number represented by @varii{vrs}.

Comparison of digits stops at the first digit for which @func{<=}
returns false.

If one of the lists is longer and the elements up to the end of the
shortest are equal: the lists are ``equal'' if the tail of the longest
is made of zeros.

Examples:

@example
(1 2 3) <= (1 2 3)
(1 2 3) <= (4 2 3)
(1 2 3) <= (1 4 3)
(1 2 3) <= (1 2 4)
(1 2 3) <= (1 2 3 4)
(1 2 3 0) <= (1 2 3)
@end example
@end defun

@c page
@node libutils refs
@section Library reference utilities


Library references are defined by @rnrs{6} to be used in @clause{import}
forms to select a dependency library; @ref{scheme library form import,
The import specification}.

@menu
* libutils refs pred::          Library reference predicates.
* libutils refs split::         Decomposing library references.
* libutils refs compar::        Library references comparison.
* libutils refs conform::       Conformity among library references
                                and names.
@end menu

@c page
@node libutils refs pred
@subsection Library reference predicates


The following bindings are exported by the library @library{vicare
libraries}.


@defun library-reference? @var{obj}
Return @true{} if @var{obj} is a valid library reference as specified by
@rnrs{6}.

@example
(library-reference? '())                        @result{} #f
(library-reference? '(alpha))                   @result{} #t
(library-reference? '(alpha beta gamma))        @result{} #t
(library-reference? '(alpha beta gamma ()))     @result{} #t
(library-reference? '(alpha beta gamma (1)))    @result{} #t
(library-reference?
    '(alpha beta (1
                  (<= 2)
                  (or 10 (and (>= 4)
                              (<= 2))))))
@result{} #t
@end example
@end defun


@defun library-version-reference? @var{obj}
Return @true{} if @var{obj} is a valid library version reference as
specified by @rnrs{6}.

@example
(library-version-reference? '())                @result{} #t
(library-version-reference? '(1))               @result{} #t
(library-version-reference? '(1 2 3))           @result{} #t

(library-version-reference? '(and))             @result{} #t
(library-version-reference? '(and (1)))         @result{} #t
(library-version-reference? '(and (1) (2)))     @result{} #t

(library-version-reference? '(or))              @result{} #t
(library-version-reference? '(or (1)))          @result{} #t
(library-version-reference? '(or (1) (2)))      @result{} #t

(library-version-reference? '(not))             @result{} #f
(library-version-reference? '(not (1)))         @result{} #t

(library-version-reference?
   '(1
     (<= 2)
     (or 10
         (and (<= 4)
              (>= 2)))))
@result{} #t
@end example
@end defun


@defun library-sub-version-reference? @var{obj}
Return @true{} if @var{obj} is a valid library sub--version reference as
specified by @rnrs{6}.
@end defun


@defun library-sub-version? @var{obj}
Return @true{} if @var{obj} is a @meta{sub-version} number according to
@rnrs{6}.

@quotation
@strong{NOTE} According to @rnrs{6}: @var{obj} should be an exact
non--negative integer, which means a non--negative finxum or bignum.
@value{PRJNAME} accepts only fixnums because they are faster to handle
and ``big enough''.
@end quotation
@end defun

@c page
@node libutils refs split
@subsection Decomposing library references


The following bindings are exported by the library @library{vicare
libraries}.


@defun library-reference-decompose @var{obj}
Interpret @var{obj} as a symbolic expression representing a library
reference as specified by @rnrs{6}.  Return two values: the list of
identifiers, the version reference.  If @var{obj} is not a valid library
reference: return @false{} and @false{}.

@example
(library-reference-decompose
   '(alpha beta (1 (<= 2) (or 10 (and (>= 4) (>= 2))))))
@result{} (alpha beta) (1 (<= 2) (or 10 (and (>= 4) (>= 2))))
@end example
@end defun


@defun library-reference->identifiers @var{obj}
If @var{obj} is a valid library reference as specified by @rnrs{6},
return the list of identifiers; else return @false{}.
@end defun


@defun library-reference->version @var{obj}
If @var{obj} is a valid library reference as specified by @rnrs{6},
return the version reference; else return @false{}.
@end defun

@c page
@node libutils refs compar
@subsection Library references comparison


The following bindings are exported by the library @library{vicare
libraries}.


@defun library-reference-identifiers=? @vari{reference} @varii{reference}
Return @true{} if the arguments are library references having equal
lists of identifiers; else return @false{}.
@end defun

@c page
@node libutils refs conform
@subsection Conformity among library references and names


The following bindings are exported by the library @library{vicare
libraries}.


@defun conforming-sub-version-and-sub-version-reference? @var{sub-version} @var{sub-version-reference}
Interpret @var{sub-version} as a sub--version number as specified by
@rnrs{6} and @var{sub-version-reference} as a sub--version reference as
specified by @rnrs{6}.  Return @true{} if the sub--version conforms to
the sub--version reference; else return @false{}; if the arguments are
invalid: raise an assertion violation.

@example
(conforming-sub-version-and-sub-version-reference?
    1 1)
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    1 0)
@result{} #f

(conforming-sub-version-and-sub-version-reference?
    1 '(<= 1))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    2 '(<= 1))
@result{} #f

(conforming-sub-version-and-sub-version-reference?
    0 '(<= 1))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    1 '(>= 1))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    2 '(>= 1))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    0 '(>= 1))
@result{} #f

(conforming-sub-version-and-sub-version-reference?
    1 '(not 1))
@result{} #f

(conforming-sub-version-and-sub-version-reference?
    1 '(not 0))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    1 '(or 1 2))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    1 '(or 2 1))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    1 '(or 2 3))
@result{} #f

(conforming-sub-version-and-sub-version-reference?
    1 '(or 2 3 4))
@result{} #f

(conforming-sub-version-and-sub-version-reference?
    4 '(or 2 3 4))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    1 '(and (>= 0) (<= 2)))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    0 '(and (>= 0) (<= 2)))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    1 '(and (>= 0) (<= 2) (not 3)))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    1 '(and (>= 0) (<= 2) (not 1)))
@result{} #f


(conforming-sub-version-and-sub-version-reference?
    4 '(or (and (>= 0) (<= 2)) 4))
@result{} #t

(conforming-sub-version-and-sub-version-reference?
    3 '(or (and (>= 0) (<= 2)) 4))
@result{} #f
@end example
@end defun


@defun conforming-version-and-version-reference? @vari{version} @varii{version-reference}
Interpret @var{version} as a version symbolic expression as specified by
@rnrs{6} and @var{version-reference} as a version reference symbolic
expression as specified by @rnrs{6}.  Return @true{} if the version
conforms to the version reference; else return @false{}; if the
arguments are invalid: raise an assertion violation.

@example
(conforming-version-and-version-reference?
    '() '())
@result{} #t

(conforming-version-and-version-reference?
    '(1) '())
@result{} #t

(conforming-version-and-version-reference?
    '() '(1))
@result{} #f

(conforming-version-and-version-reference?
    '(1) '(1))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '(0))
@result{} #f

(conforming-version-and-version-reference?
    '(1) '((<= 1)))
@result{} #t

(conforming-version-and-version-reference?
    '(2) '((<= 1)))
@result{} #f

(conforming-version-and-version-reference?
    '(0) '((<= 1)))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((>= 1)))
@result{} #t

(conforming-version-and-version-reference?
    '(2) '((>= 1)))
@result{} #t

(conforming-version-and-version-reference?
    '(0) '((>= 1)))
@result{} #f

(conforming-version-and-version-reference?
    '(1) '((not 1)))
@result{} #f

(conforming-version-and-version-reference?
    '(1) '((not 0)))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((or 1 2)))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((or 2 1)))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((or 2 3)))
@result{} #f

(conforming-version-and-version-reference?
    '(1) '((or 2 3 4)))
@result{} #f

(conforming-version-and-version-reference?
    '(4) '((or 2 3 4)))
@result{} #t

(conforming-version-and-version-reference?
    '(5) '((or 2 (or 3 (or 4 (or 5))))))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((and 1)))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((and 1 1)))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((and 1 1 1)))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((and 1 (and 1 (and 1 (and 1))))))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((and (>= 0) (<= 2))))
@result{} #t

(conforming-version-and-version-reference?
    '(0) '((and (>= 0) (<= 2))))
@result{} #t

(conforming-version-and-version-reference?
    '(2) '((and (>= 0) (<= 2))))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((and (>= 0) (<= 2) (not 3))))
@result{} #t

(conforming-version-and-version-reference?
    '(1) '((and (>= 0) (<= 2) (not 1))))
@result{} #f

(conforming-version-and-version-reference?
    '(1) '((or (and (>= 0) (<= 2)) 4)))
@result{} #t

(conforming-version-and-version-reference?
    '(4) '((or (and (>= 0) (<= 2)) 4)))
@result{} #t

(conforming-version-and-version-reference?
    '(3) '((or (and (>= 0) (<= 2)) 4)))
@result{} #f

(conforming-version-and-version-reference?
    '(1 2 3) '(1 2 3))
@result{} #t

(conforming-version-and-version-reference?
    '(1 2 3) '(1 2 4))
@result{} #f

(conforming-version-and-version-reference?
    '(1 2 0) '(1 2))
@result{} #t

(conforming-version-and-version-reference?
    '(1 2 1) '(1 2))
@result{} #t

(conforming-version-and-version-reference?
    '(1 2 3)
    '(1 (>= 1) (not 1)))
@result{} #t

(conforming-version-and-version-reference?
    '(1 2 3)
    '(1 (<= 1) (not 1)))
@result{} #f

(conforming-version-and-version-reference?
    '(1 2 3)
    '(or (1 (<= 1) (not 1)) (1 (>= 1) (not 1))))
@result{} #t

(conforming-version-and-version-reference?
    '(1 2 3) '(or (1 2 5) (1 2 10)))
@result{} #f

(conforming-version-and-version-reference?
    '(1 2 3)
    '(and (1 (>= 1) (not 1)) (1 2 (not 5))))
@result{} #t

(conforming-version-and-version-reference?
    '(1 2 3)
    '(and (1 (<= 1) (not 1)) (1 2 (not 5))))
@result{} #f)

(conforming-version-and-version-reference?
    '(1 2 3) '(not (1 5 4)))
@result{} #t

(conforming-version-and-version-reference?
    '(1 2 3) '(not (1 2 3)))
@result{} #f
@end example
@end defun


@defun conforming-library-name-and-library-reference? @var{name} @var{reference}
Interpret @var{name} as a library name symbolic expression as specified
by @rnrs{6} and @var{reference} as a library reference symbolic
expression as specified by @rnrs{6}.  Return @true{} if the name
conforms to the reference; else return @false{}; if the arguments are
invalid: raise an assertion violation.

@example
(conforming-library-name-and-library-reference?
    '(a (1)) '(a (1)))
@result{} #t

(conforming-library-name-and-library-reference?
    '(a (1)) '(a (0)))
@result{} #f

(conforming-library-name-and-library-reference?
    '(a b c (1)) '(a b c (1)))
@result{} #t

(conforming-library-name-and-library-reference?
    '(a b c (1)) '(a b c (0)))
@result{} #f

(conforming-library-name-and-library-reference?
    '(a b c (1)) '(a z c (1)))
@result{} #f
@end example
@end defun

@c page
@node libutils libraries
@section Library objects


Objects of type @class{library} are created when a source library is
processed by the expander and when a binary library is loaded from a
@fasl{} file; @class{library} is a disjoint type.

@menu
* libutils libraries typedef::       @class{library} object type.
* libutils libraries global-env::    The @code{global-env} field.
* libutils libraries ops::           Library operations.
@end menu

@c page
@node libutils libraries typedef
@subsection @class{library} object type


The following bindings are exported by the library @library{vicare
libraries}.


@deftp {Record Type} @aclass{library}
Record type representing Scheme libraries.
@end deftp


@defun library? @var{obj}
Return @true{} if @var{obj} is an object of type @class{library};
otherwise return @false{}.
@end defun


@deffn {Accessor for @class{library}} library-uid @var{lib}
Return a gensym uniquely identifying this interned library; it also
identifies the corresponding serialised library.  This gensym is
registered in:

@itemize
@item
The @class{library} object created by a @value{EXECUTABLE} process at
run--time.

@item
The binary file containing this library in compiled and serialised form.

@item
The binary files containing the compiled libraries that import this one.
@end itemize

Whenever a compiled library imports this one, the @uid{} stored in the
binary file is compared to this field: if they are @func{eq?}  the
compiled versions are in sync, otherwise the importing library must be
recompiled.
@end deffn


@deffn {Accessor for @class{library}} library-name @var{lib}
A library name as defined by @rnrs{6}; it is the symbolic expression:

@example
(@metao{identifier} @meta{identifier} ...)
(@metao{identifier} @meta{identifier} ... @meta{version})
@end example

@noindent
where the @meta{identifier} are symbols and @meta{version} is a list of
non--negative fixnums representing the version numbers.  Library names
can be manipulated with appropriate functions, @ref{libutils names,
Library name utilities}.
@end deffn


@deffn {Accessor for @class{library}} library-imp-lib* @var{lib}
The list of @class{library} objects selected by the @clause{import}
clause in the source code of @var{lib}.
@end deffn


@deffn {Accessor for @class{library}} library-vis-lib* @var{lib}
The list of @class{library} objects selecting libraries needed by the
visit code.
@end deffn


@deffn {Accessor for @class{library}} library-inv-lib* @var{lib}
The list of @class{library} objects selecting libraries needed by the
invoke code.
@end deffn


@deffn {Accessor for @class{library}} library-export-subst @var{lib}
Return the @code{export-subst} of @var{lib}: an alist representing the
global bindings exported by the library.  The cars of the alist are
symbols representing the public names of the exported syntactic
bindings.  The cdrs of the alist are the label gensyms of the exported
syntactic bindings.

The @code{export-subst} includes both syntactic bindings defined by the
library itself and syntactic bindings imported and re--exported by the
library.  For example:

@lisp
(define ell
  (expand-library->sexp
     '(library (demo)
        (options typed-language)
        (export display <fixnum>)
        (import (vicare))
        (define @{x <fixnum>@} 123))))

(cdr (assq 'export-subst ell))
@result{} ((<fixnum> . prim-label.<fixnum>) (display . g14256))

(cdr (assq 'global-env ell))
@result{} ((g9 . (global-typed . g8)))
@end lisp

@noindent
notice that the re--exported bindings do not appear in the
@code{global-env}.
@end deffn


@deffn {Accessor for @class{library}} library-typed-locs @var{lib}
Return an alist having labels as keys and loc gensyms as values.  The
labels are the ones of the @code{global-env} whose descriptor has type
@code{global-typed} or @code{global-typed-mutable}.  The loc gensyms are
the ones of the variables actually holding the typed values.  This alist
allows to map the public name of global typed variables to the loc
gensyms holding the values.
@end deffn


@deffn {Accessor for @class{library}} library-visit-state @var{lib}
When set to a procedure: it is the thunk to call to compile and evaluate
the visit code.  When set to something else: this library has been
already visited.
@end deffn


@deffn {Accessor for @class{library}} library-invoke-state @var{lib}
When set to a procedure: it is the thunk to call to compile and evaluate
the invoke code.  When set to something else: this library has been
already invoked.
@end deffn


@deffn {Accessor for @class{library}} library-visit-code @var{lib}
When @var{lib} is created from source code: this field is a core
language symbolic expression representing the visit code.  When
@var{lib} is created from a binary file: this field is a thunk to
evaluate to visit the library.
@end deffn


@deffn {Accessor for @class{library}} library-invoke-code @var{lib}
When @var{lib} is created from source code: this field is a core
language symbolic expression representing the invoke code.  When
@var{lib} is created from a binary file: this field is a thunk to
evaluate to invoke the library.
@end deffn


@deffn {Accessor for @class{library}} library-guard-code @var{lib}
When @var{lib} is created from source code: this field is a core
language symbolic expression representing the guard code.  When
@var{lib} is created from a binary file: this field is a thunk to
evaluate to run the @syntax{stale-when} composite test expression.
@end deffn


@deffn {Accessor for @class{library}} library-guard-lib* @var{lib}
The list of @class{library} objects selecting libraries needed by the
@syntax{stale-when} composite test expression.

@quotation
@strong{NOTE} These are the libraries accumulated by the
@func{inv-collector} while expanding the @syntax{stale-when} test
expressions.
@end quotation
@end deffn


@deffn {Accessor for @class{library}} library-visible? @var{lib}
A boolean determining if the library is visible.  This attribute is used
by @func{interned-libraries} to select libraries to report as interned.

A library should be marked as visible if it is meant to be imported by
client code in ``normal'' use; unsafe libraries in the hierarchy
@library{vicare system ---)} should @strong{not} be visible.
@end deffn


@deffn {Accessor for @class{library}} library-source-file-name @var{lib}
The boolean @false{} or a string representing the pathname of the file
from which the source code of the library was read.
@end deffn


@deffn {Accessor for @class{library}} library-option* @var{lib}
A list of symbolic expressions holding library options.
@end deffn


@deffn {Accessor for @class{library}} library-foreign-library* @var{lib}
A list of strings each representing the identifier of a foreign library
that must be dynamically loaded for this @var{lib} object.  These
libraries are the ones especially written to interface @value{PRJNAME}
with platform--specific services.
@end deffn


@defun library-loaded-from-source-file? @var{lib}
The argument @var{lib} must be a @class{library} object.  Return
@true{} if @var{lib} was loaded from a source file; otherwise return
@false{}.
@end defun


@defun library-loaded-from-binary-file? @var{lib}
The argument @var{lib} must be a @class{library} object.  Return
@true{} if @var{lib} was loaded from a binary file; otherwise return
@false{}.
@end defun


@defun library-descriptor @var{lib}
Given a @class{library} object return an object representing the
library descriptor.  Library descriptors are uniquely associated to a
compiled library.
@end defun


@defun library-descriptor? @var{obj}
Return @true{} if @var{obj} is a library descriptor object; otherwise
return @false{}.
@end defun


@defun library-descriptor-uid @var{libdescr}
Given a library descriptor object return the @uid{}.
@end defun


@defun library-descriptor-name @var{libdescr}
Given a library descriptor object return the @rnrs{6} library name.
@end defun

@c ------------------------------------------------------------------------

As example of @class{library} fields, expanding the library:

@lisp
(library (ciao)
  (export var fun mac etv)
  (import (vicare))
  (define var 1)
  (define (fun)
    2)
  (define-syntax (mac stx)
    3)
  (define-syntax etv
    (make-expand-time-value
     (+ 4 5))))
@end lisp

@noindent
yields the @code{invoke-code}:

@lisp
(library-letrec*
    ((lex.var loc.var '1)
     (lex.fun loc.fun (annotated-case-lambda fun (() '2))))
  ((primitive void)))
@end lisp

@noindent
the @code{visit-code}:

@lisp
(begin
  (set! loc.mac
        (annotated-case-lambda
            (#'lambda (#'stx) #'3)
          ((lex.stx) '3)))
  (set! loc.etv
        (annotated-call
            (make-expand-time-value (+ 4 5))
          (primitive make-expand-time-value)
          (annotated-call (+ 4 5) (primitive +) '4 '5))))
@end lisp

@noindent
the @code{export-subst}:

@lisp
((etv . lab.etv)
 (mac . lab.mac)
 (fun . lab.fun)
 (var . lab.var))
@end lisp

@noindent
the @code{global-env}:

@lisp
((lab.var global        . loc.var)
 (lab.fun global        . loc.fun)
 (lab.mac global-macro  . loc.mac)
 (lab.etv global-etv    . loc.etv))
@end lisp

Another example, for the library:

@lisp
(library (ciao (1 2))
  (export doit)
  (import (vicare))
  (stale-when (< 1 2)
    (define a 123))
  (stale-when (< 2 3)
    (define b 123))
  (define (doit)
    123))
@end lisp

@noindent
the @code{guard-code} is:

@lisp
(if (if '#f
        '#t
       (annotated-call (< 1 2) (primitive <) '1 '2))
    '#t
  (annotated-call (< 2 3) (primitive <) '2 '3))
@end lisp

@c page
@node libutils libraries global-env
@subsection The @code{global-env} field


@deffn {Accessor for @class{library}} library-global-env @var{lib}
Return the lexical environment exported by the @class{library} object
@var{lib}.
@end deffn


The @code{global-env} is a data structure used to map the label gensyms
of top level syntactic bindings defined by a library to the
corresponding storage location gensyms.  ``Top level bindings'' does not
mean ``exported bindings'': not all the entries in @code{global-env}
represent exported bindings, it is the role of the @code{export-subst}
to select the exported ones.

An @code{global-env} is an alist whose entries have the format:

@example
(@meta{label} . @meta{export-descriptor})
@end example

@noindent
and @meta{export-descriptor} has the format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
where: @meta{label} is the syntactic binding's label gensym;
@meta{binding-type} is a symbol representing the syntactic binding's
type; the format of @meta{binding-value} depends upon the type.

The symbol @meta{binding-type} is one among:

@table @code
@item global
Denotes a syntactic binding representing a variable binding which is
never assigned in the code (it is initialised to a value and that value
never changes).  The export descriptor has the format:

@example
(global . @meta{lex/loc})
@end example

@noindent
where @meta{lex/loc} is a gensym acting both as lexical gensym and
storage location gensym; after the library is invoked: the loc gensym
holds the variable's value in its @code{value} slot (immutable).  This
binding can be exported.

@item mutable
Denotes a syntactic binding representing a variable binding which is
assigned somewhere in the code.  The export descriptor has the format:

@example
(mutable . @meta{lex/loc})
@end example

@noindent
where @meta{lex/loc} is a gensym acting both as lexical gensym and
storage location gensym; after the library is invoked: the loc gensym
holds the variable's value in its @code{value} slot (mutable).  This
binding @strong{cannot} be exported.

@item global-macro
Denotes a syntactic binding representing a non--variable macro.  The
export descriptor has the format:

@example
(global-macro . @meta{loc})
@end example

@noindent
where @meta{loc} is the storage location gensym; after the library has
been visited: @meta{loc} holds the macro transformer in its @code{value}
slot.  This binding can be exported.

Syntactic bindings of this type are established by uses of
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating the right--hand side expression is a function.

@item global-macro!
Denotes a syntactic binding representing a variable macro.  The export
descriptor has the format:

@example
(global-macro! . @meta{loc})
@end example

@noindent
where @meta{loc} is the storage location gensym; after the library has
been visited: @meta{loc} holds the macro transformer in its @code{value}
slot.  This binding can be exported.

Syntactic bindings of this type are established by uses of
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating the right--hand side expression is the return value of a
call to @func{make-variable-transformer}.

@item global-etv
Denotes a syntactic binding representing an expand--time value.  The
export descriptor has the format:

@example
(global-etv . @meta{loc})
@end example

@noindent
where @meta{loc} is the storage location gensym; after the library has
been visited: @meta{loc} holds the actual expand--time object.  This
binding can be exported.

Syntactic bindings of this type are established by
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating their right--hand side expression is the return value of a
call to @func{make-expand-time-value}.

@item $struct-type-descriptor
Denotes a syntactic binding representing a @value{PRJNAME}'s
struct--type name.  The export descriptor has the format:

@example
($struct-type-descriptor . @meta{type-descriptor-struct})
@end example

@noindent
where @meta{type-descriptor-struct} is a struct representing the
struct--type descriptor.

Syntactic bindings of this type are established by uses of the syntax
@syntax{define-struct}.

@item $record-type-descriptor
Denotes a syntactic binding representing a @rnrs{6} record--type name.
The export descriptor has one of the formats:

@example
($record-type-descriptor . (@meta{rtd-id} @meta{rcd-id}))
($record-type-descriptor . (@meta{rtd-id} @meta{rcd-id} . @meta{spec}))
@end example

@noindent
where: @meta{rtd-id} is the syntactic identifier to which the
record--type descriptor is bound; @meta{rcd-id} is the syntactic
identifier to which the default record--constructor descriptor is bound;
@meta{spec} is an instance of record type
@objtype{r6rs-record-type-spec}.

Syntactic bindings of this type are established by uses of the syntaxes
@syntax{define-record-type} and @syntax{define-condition-type}.

@item $module
Denotes a syntactic binding representing a module interface.  The export
descriptor has format:

@example
($module . @meta{module-interface})
@end example

@noindent
where @meta{module-interface} is a record of type
@objtype{module-interface}.

Syntactic bindings of this type are established by uses of the syntax
@syntax{module}.

@item $fluid
Denotes a syntactic binding representing a fluid syntax.  The export
descriptor has format:

@example
($fluid . @meta{fluid-label})
@end example

@noindent
where @meta{fluid-label} is the label gensym associated to the fluid
syntax.

@item $synonym
Denotes a syntactic binding representing a synonym syntax.  The export
descriptor has format:

@example
($synonym . @meta{synonym-label})
@end example

@noindent
where @meta{synonym-label} is the label gensym associated to the aliased
syntax.
@end table

@c ------------------------------------------------------------------------

@subsubheading Example library

We can toy with the @code{global-env} with the following program:

@lisp
(import (vicare)
  (vicare libraries))

(library (demo)
  (export var macro var-macro macro-id
          etv color <color> modu fluid synonym alias)
  (import (vicare))
  (define var 1)
  (define (fun) 2)
  (define-syntax macro (lambda (stx) 3))
  (define-syntax macro-id (identifier-syntax 4))
  (define-syntax var-macro
    (make-variable-transformer (lambda (stx) 5)))
  (define-syntax etv (make-expand-time-value 6))
  (module modu (modu-var) (define modu-var 7))
  (define-fluid-syntax fluid (lambda (stx) 8))
  (define-syntax synonym (make-synonym-transformer #'var))
  (define-alias alias var)
  (define-struct color (red green blue))
  (define-record-type <color> (fields red green blue))
  (define mvar 9)
  (set! mvar 10)
  #| end of library |# )

(define lib
  (find-library-by-name '(demo)))

(print-gensym #f)
(pretty-print
 (library-global-env lib))

(flush-output-port (current-output-port))
@end lisp

@c page
@node libutils libraries ops
@subsection Library operations


The following bindings are exported by the library @library{vicare
libraries}.


@defun invoke-library @var{lib}
Evaluate the invoke code of the @class{library} object @var{lib} and
all its dependency libraries.  When successful: return @var{lib} itself;
otherwise raise an exception.  If we apply this function to @var{lib}
multiple times: the code is evaluated only the first time; subsequent
applications do nothing.
@end defun


@defun visit-library @var{lib}
Evaluate the visit code of the @class{library} object @var{lib} and
all its dependency libraries When successful: return @var{lib} itself;
otherwise raise an exception.  If we apply this function to @var{lib}
multiple times: the code is evaluated only the first time; subsequent
applications do nothing.
@end defun

@c page
@node libutils interning
@section Interning libraries


When a library is loaded in source or binary form, it is ``interned'';
to intern a library means to add it to an internal collection along with
all its dependency libraries.  Interned libraries are neither invoked
nor visited; the invoke--time and visit--time depend upon the usage we
make of them.

In a @value{PRJNAME} process, there can be only one library with a given
sequence of symbols in its name; if we have already loaded the library
@library{a b (1)}, it is not possible to load a library @library{a b
(2)}, because they have the sequence @library{a b} in common.

The following bindings are exported by the library @library{vicare
libraries}.


@defun interned-libraries
@defunx interned-libraries @var{all?}
Return a list of @class{library} objects representing interned
libraries.  If @var{all?}  is non--false: return all the interned
libraries, else return only the visible ones.
@end defun


@defun find-library-by-name @var{libname}
Given a @rnrs{6} library name: try to search and intern the
corresponding library, if it is not already interned; when successful
return the corresponding @class{library} object, otherwise raise an
exception.

First search for the library among the interned ones then, if not found,
in an external libraries repository using the procedure referenced by
the parameter @func{current-library-loader}.
@end defun


@defun find-library-by-reference @var{libref}
Given a @rnrs{6} library reference: try to search and intern the
corresponding library, if it is not already interned; when successful
return the corresponding @class{library} object, otherwise raise an
exception.

First search for the library among the interned ones then, if not found,
in an external libraries repository using the procedure referenced by
the parameter @func{current-library-loader}.
@end defun


@defun find-library-by-descriptor @var{libdescr}
Given a library descriptor, as generated by the function
@func{library-descriptor} (@pxref{libutils libraries,
library-descriptor}): try to search and intern the corresponding
library, if it is not already interned; when successful return the
corresponding @class{library} object, otherwise raise an exception.

First search for the library among the interned ones then, if not found,
in an external libraries repository using the procedure referenced by
the parameter @func{current-library-loader}.
@end defun


@defun find-library-in-collection-by-predicate @var{pred}
Visit the collection of interned libraries and return the first for
which @var{pred} returns non--false.  If @var{pred} returns @false{} for
all the interned libraries: return @false{}.

@var{pred} must be a function accepting as single argument a
@class{library} object.
@end defun


@defun find-library-in-collection-by-name @var{libname}
Given a symbolic expression representing a @rnrs{6} library name: visit
the collection of interned libraries and return the first
@class{library} object having conforming library name identifiers.  If
no matching library is found: return @false{}.
@end defun


@defun find-library-in-collection-by-reference @var{libref}
Given a symbolic expression representing a @rnrs{6} library reference:
visit the collection of interned libraries and return the first
@class{library} object having conforming library name identifiers.  If
no matching library is found: return @false{}.
@end defun


@defun find-library-in-collection-by-descriptor @var{libdescr}
Given a library descriptor, as generated by the function
@func{library-descriptor}: visit the collection of interned libraries
and return the first @class{library} object having the same library
@uid{}.  If no matching library is found: @strong{raise an exception}.
@end defun


@defun unintern-library @var{libname}
@defunx unintern-library @var{libname} @var{err?}
Interned libraries can be uninterned, either to free system resources or
to allow reinterning from new files.

This function uninterns a library given its @rnrs{6} library name.  If
@var{err?} is non--false: if the library is not currently interned an
exception is raised; otherwise nothing happens.  Return unspecified
values.

@quotation
@strong{NOTE} The implementation of this function is incomplete.  It is
to be used at the @repl{} when experimenting does not hurt.
@end quotation
@end defun

@c page
@node libutils expanding
@section Expanding libraries from source


The following bindings are exported by the library @library{vicare
libraries}.


@defun expand-library @var{sexp}
@defunx expand-library @var{sexp} @var{filename}
@defunx expand-library @var{sexp} @var{filename} @var{verify-libname}
Expand the symbolic expression @var{sexp} and intern the result
(@pxref{libutils interning}).  When successful: return a
@class{library} object; if an error occurs: raise an exception.

@var{sexp} must be a symbolic expression @code{(library . ---)}
representing a @rnrs{6} library form with optional @value{PRJNAME}
extensions.

The optional @var{filename} must be @false{} or a string representing
the source file from which the library was loaded; it is used for
information purposes.  When not given defaults to @false{}.

The optional argument @var{verify-libname} must be a procedure accepting
a @rnrs{6} library name as argument and returning unspecified values; it
is meant to perform some validation upon the library name components and
raise an exception if something is wrong; otherwise it should just
return.
@end defun


@defun expand-library->sexp @var{sexp}
This function is for debugging purposes.  Expand the library form
@var{sexp} and return the return values of @func{expand-library} in an
alist with the following symbols as keys:

@example
uid libname
import-libdesc* visit-libdesc* invoke-libdesc*
invoke-code visit-code
export-subst global-env
guard-code guard-libdesc*
option*
@end example
@end defun


We can toy with the library expander using the following code:

@example
#!r6rs
(import (vicare)
  (prefix (vicare libraries) libs.))
(print-gensym #f)
(debug-print (libs.expand-library->sexp @meta{sexp}))
@end example

@noindent
where @meta{sexp} is the @syntax{library} symbolic expression.  For
example, expanding the library:

@example
(library (ciao)
  (export var fun mac etv)
  (import (vicare))
  (define var 1)
  (define (fun)
    2)
  (define-syntax (mac stx)
    3)
  (define-syntax etv
    (make-expand-time-value
     (+ 4 5))))
@end example

@noindent
yields the @code{invoke-code}:

@example
(library-letrec*
    ((lex.var loc.lex.var '1)
     (lex.fun loc.lex.fun (annotated-case-lambda fun (() '2))))
  ((primitive void)))
@end example

@noindent
the @code{visit-code}:

@example
(begin
  (set! loc.lab.mac
        (annotated-case-lambda
            (#'lambda (#'stx) #'3)
          ((lex.stx) '3)))
  (set! loc.lab.etv
        (annotated-call
            (make-expand-time-value (+ 4 5))
          (primitive make-expand-time-value)
          (annotated-call (+ 4 5) (primitive +) '4 '5))))
@end example

@noindent
the @code{export-subst}:

@example
((etv . lab.etv)
 (mac . lab.mac)
 (fun . lab.fun)
 (var . lab.var))
@end example

@noindent
the @code{global-env}:

@example
((lab.var global        . loc.lex.var)
 (lab.fun global        . loc.lex.fun)
 (lab.mac global-macro  . loc.lab.mac)
 (lab.etv global-etv    . loc.lab.etv))
@end example

Another example, for the library:

@example
(library (ciao (1 2))
  (export doit)
  (import (vicare))
  (stale-when (< 1 2)
    (define a 123))
  (stale-when (< 2 3)
    (define b 123))
  (define (doit)
    123))
@end example

@noindent
the @code{guard-code} is:

@example
(if (if '#f
        '#t
       (annotated-call (< 1 2) (primitive <) '1 '2))
    '#t
  (annotated-call (< 2 3) (primitive <) '2 '3))
@end example

@c page
@node libutils loading
@section Loading libraries


Libraries are interned using the functions @code{find-library-*},
@ref{libutils interning, Interning libraries}.  All those functions
first search the internal collection, then load libraries through the
procedure referenced by the parameter @func{current-library-loader}.

The following bindings are exported by the library @library{vicare
libraries}.


@deffn Parameter current-library-loader
Reference a function used to load a library, either source or binary,
given a @rnrs{6} library reference; the referenced function must intern
the library and all its dependencies.  The parameter is used as follows:

@example
((current-library-loader) @meta{libref})
@end example

The referenced function is meant to be called after we have checked that
a compliant library is not already interned.  The referenced function is
allowed to return unspecified values.
@end deffn


@defun default-library-loader @var{libref}
Default value for the parameter @func{current-library-loader}.  Given a
@rnrs{6} library reference: attempt to locate the library in an external
repository and load it; all the dependency libraries are interned.
Return unspecified values.

This function makes use of: the library locator referenced by the
parameter @func{current-library-locator}; the source library loader
referenced by the parameter @func{current-source-library-loader}; the
binary library loader referenced by the parameter
@func{current-binary-library-loader}.

@var{libref} must be a library reference as defined by @rnrs{6}:

@example
(@metao{identifier} @meta{identifier})
(@metao{identifier} @meta{identifier} ... @meta{version-reference})
@end example

@noindent
@ref{scheme library form import} for details on library references.
@end defun

@c ------------------------------------------------------------

@subsubheading Interning source libraries

Any function we set in the parameter @func{current-library-loader} can
use the following @api{} to intern a source library.


@deffn Parameter current-source-library-loader
Reference a function used to load a source library from a textual input
port.

The referenced function must accept two arguments: a @rnrs{6} library
reference, a textual input port from which the source library can be
read.  It must: read from the port a @syntax{library} symbolic
expression; verify that its library name conforms to the library
reference; load and intern all its dependency libraries; expand it;
compile it; intern it.

If successful the function must return a symbolic expression
representing the @rnrs{6} library name of the loaded library; otherwise
return @false{}.
@end deffn


@defun default-source-library-loader @var{libref} @var{textual-port}
Default value for the parameter @func{current-source-library-loader}.
Given a textual input port:

@enumerate
@item
Read from it a @syntax{library} symbolic expression.

@item
Verify that its version reference conforms to @var{libref}.

@item
Using the expander procedure referenced by
@func{current-library-expander}: load and intern all its dependency
libraries; expand it; compile it; intern it.
@end enumerate

If successful return a symbolic expression representing the @rnrs{6}
library name of the loaded library; otherwise return @false{}.

This function assumes that applying the function @func{port-id} to
@var{textual-port} will return a string representing a file name
associated to the port (or equivalent).
@end defun

@c ------------------------------------------------------------

@subsubheading Interning binary libraries

Any function we set in the parameter @func{current-library-loader} can
use the following @api{} to intern a binary library.


@deffn Parameter current-binary-library-loader
Reference a function used to load a binary library.

The referenced function must accept two arguments: a @rnrs{6} library
reference, a binary input port from which the serialised library can be
read.  It must: read from the port a serialised library; verify that its
library name conforms to the library reference; intern it along with all
its dependency libraries.

If successful the function must return a symbolic expression
representing the @rnrs{6} library name of the interned library;
otherwise return @false{}.
@end deffn


@defun default-binary-library-loader @var{libref} @var{binary-port}
Default value for the parameter @func{current-binary-library-loader}.
Given a binary input port: read from it a serialised library; verify
that its version reference conforms to @var{libref}; intern it along
with all its dependency libraries.

If successful return a symbolic expression representing the @rnrs{6}
library name of the interned library; otherwise return @false{}.

This function assumes that applying the function @func{port-id} to
@var{binary-port} will return a string representing a file name
associated to the port (or equivalent).
@end defun

@c page
@node libutils locating
@section Locating libraries


The function @func{default-library-loader} is the default value of the
parameter @func{current-library-loader}, which is used to intern
libraries; @ref{libutils loading, default-library-loader}.  Such default
procedure makes use of the function referenced by the parameter
@func{current-library-locator} to find libraries in some external
repository.

The following bindings are exported by the library @library{vicare
libraries}.


@deffn Parameter current-library-locator
Hold a function used to locate a library from its @rnrs{6} library
reference.  The selected locator function must accept as single argument
a @rnrs{6} library reference and it must return a thunk as single value.
@end deffn


When invoked, the returned thunk must return two values:

@itemize
@item
When a matching source library is found:

@enumerate
@item
A textual input port from which the library can be read.

@item
A thunk to be called to continue the search in case the source library
is rejected.
@end enumerate

@item
When a matching binary library is found:

@enumerate
@item
A binary input port from which the library can be read.

@item
A thunk to be called to continue the search in case the binary library
is rejected.
@end enumerate

@item
When a matching library is found and interned by the thunk itself:

@enumerate
@item
The boolean @true{}.

@item
A thunk to be called to continue the search in case the library is
rejected.
@end enumerate

@item
When no matching library is found:

@enumerate
@item
The boolean @false{}.

@item
The boolean @false{}.
@end enumerate
@end itemize

When an input port is returned as first value: it is responsibility of
the caller to close the returned port when no more needed; the thunk
discharges any responsibility.

When a thunk is returned as second value: it must have the same @api{}
of the thunk returned by the locator function; the possibility to
continue the search allows the caller to reject a library if it does not
meet some additional constraint.

The parameter is meant to be used as in the following pseudo--code:

@example
(let loop
    ((next-locator-search ((current-library-locator) libref)))
  (receive (rv further-locator-search)
      (next-locator-search)
    (cond ((binary-port?  rv)
           (read-validate-intern-binary-library rv
              (lambda ()
                (loop further-locator-search))))
          ((textual-port? rv)
           (read-validate-intern-source-library rv
              (lambda ()
                (loop further-locator-search))))
          ((and (boolean? rv) rv)
           (library-already-interned))
          ((not rv)
           (no-matching-library-was-found))
          (else
           (assertion-violation __who__
             "invalid return values from library locator" rv)))))
@end example

Usually the locator function visits the host file system in search of a
file whose pathname matches the given library reference; other
possibilities are: programmatically fabricating the library on the spot;
downloading the library from a remote site.

@c page
@node libutils file-system
@section Locating libraries on the file system


The library @library{vicare libraries} exports an @api{} to configure
and extend the process of searching for library files in source or
binary format.  Here is an overview of the ``finding libraries''
process:

@enumerate
@item
To use a library we must first intern it.  Libraries are interned by the
functions @code{find-library-*} (@pxref{libutils interning, Interning
libraries}), which make use of the parameter
@func{current-library-loader}.

@item
The parameter @func{current-library-loader} references a function used
to intern libraries given a @rnrs{6} library reference (@pxref{libutils
loading, current-library-loader}).

@item
The function @func{default-library-loader} is the default value of the
parameter @func{current-library-loader} (@pxref{libutils loading,
default-library-loader}).

@item
The function @func{default-library-loader} makes use of the function
referenced by the parameter @func{current-library-locator} to find
libraries in some external repository (@pxref{libutils locating,
current-library-locator}).

@item
The parameter @func{current-library-locator} is usually initialised to
one of the functions:

@example
    run-time-library-locator
compile-time-library-locator
      source-library-locator
@end example

@noindent
either by default, or by direct selection with the command line option
@option{--library-locator} (@pxref{using invoking, library-locator}).

@item
The library locators @func{run-time-library-locator},
@func{compile-time-library-locator} and @func{source-library-locator}
search the file system for a library file pathname matching a specified
@rnrs{6} library reference.
@end enumerate

@menu
* libutils file-system extensions::     File extensions.
* libutils file-system pathnames::      Library file pathnames.
* libutils file-system paths::          Library search paths.
* libutils file-system binary::         Scanning the compiled
                                        libraries path.
* libutils file-system source::         Scanning the source
                                        libraries path.
* libutils file-system locators::       Library file locators.
@end menu

@c page
@node libutils file-system extensions
@subsection File extensions


Usually file extensions are the tail part of a file name: everything
after the last dot character; if the file name has no dot character: the
extension is the empty string.  @value{PRJNAME} extends this concept by
defining as file extensions strings that must be appended to a library
stem to build a library pathname (@pxref{libutils file-system pathnames}
for details on library stems).

Source library file extensions are basically:

@example
.vicare.sls
.sls
@end example

@noindent
and, usually, @code{.sls} is used.  If the command line option
@option{--more-file-extensions} is used, the following extensions are
also considered:

@example
/main.vicare.sls
/main.sls
/main.vicare.ss
/main.ss
/main.vicare.scm
/main.scm
.vicare.ss
.ss
.vicare.scm
.scm
@end example

There is a single binary library file extension: @code{.fasl}.

The following bindings are exported by the library @library{vicare
libraries}.


@deffn Parameter library-extensions
Hold a list of strings representing source library file name extensions,
leading dot included.  This parameter is initialised to:

@example
(".vicare.sls" ".sls")
@end example
@end deffn

@c page
@node libutils file-system pathnames
@subsection Library file pathnames


The following bindings are exported by the library @library{vicare
libraries}.


@defun library-name->filename-stem @var{libname}
@defunx library-reference->filename-stem @var{libref}
Convert the non--empty list of identifiers from a @rnrs{6} library name
@var{libname} or reference @var{libref} into a string representing the
corresponding relative file pathname, without extension but including a
leading @code{#\/} character.  Examples:

@example
(library-name->filename-stem '(alpha beta gamma (1 2 3)))
@result{} "/alpha/beta/gamma"

(library-name->filename-stem '(alpha beta main (1 2 3)))
@result{} "/alpha/beta/main_"

(library-reference->filename-stem '(alpha beta gamma ((>= 3))))
@result{} "/alpha/beta/gamma"

(library-reference->filename-stem '(alpha beta main ((>= 3))))
@result{} "/alpha/beta/main_"
@end example

@noindent
notice how the component @samp{main}, when appearing last, is ``quoted''
by appending an underscore.

The returned value can be used as:

@itemize
@item
Source library name, by appending an extension like @code{.sls}.

@item
Compiled library name, by appending an extension like @code{.fasl}.
@end itemize
@end defun


@defun directory+library-stem->library-source-pathname @var{directory} @var{stem}
@defunx directory+library-stem->library-binary-pathname @var{directory} @var{stem}
Given a string directory pathname and a string library stem: build and
return a source or binary library file pathname.

@example
(directory+library-stem->library-source-pathname "a/b/c" "/d/e")
@result{} "a/b/c/d/e.sls"

(directory+library-stem->library-binary-pathname "a/b/c" "/d/e")
@result{} "a/b/c/d/e.fasl"
@end example
@end defun


@defun library-name->library-binary-pathname-in-build-directory @var{libname}
@defunx library-reference->library-binary-pathname-in-build-directory @var{libref}
Given a @rnrs{6} compliant library name or reference: build and return a
string representing the pathname of a binary library in the current
build directory.  The current build directory is the pathname currently
referenced by the parameter @func{compiled-libraries-build-directory}.

@example
(parametrise ((compiled-libraries-build-directory "/a/b"))
   (library-name->library-binary-pathname-in-build-directory
      '(c d (1 2 3))))
@result{} "/a/b/c/d.fasl"

(parametrise ((compiled-libraries-build-directory "/a/b"))
   (library-reference->library-binary-pathname-in-build-directory
      '(c d ((>= 2)))))
@result{} "/a/b/c/d.fasl"
@end example
@end defun


@defun library-source-pathname->library-stem-pathname @var{source-pathname}
Given a string representing the file pathname of a source library: strip
the file extensions if it is equal to a supported @value{PRJNAME} file
extension and return the result.  If the file extension is not
recognised: return @var{source-pathname} itself.

@example
(library-source-pathname->library-stem-pathname "a/b/c.sls")
@result{} "a/b/c"

(library-source-pathname->library-stem-pathname "a/b/c.vicare.sls")
@result{} "a/b/c"

(library-source-pathname->library-stem-pathname "a/b/c.scm")
@result{} "a/b/c"

(library-source-pathname->library-stem-pathname "a/b/c.ss")
@result{} "a/b/c"

(library-source-pathname->library-stem-pathname "a/b/c.ciao")
@result{} "a/b/c.ciao"
@end example
@end defun


@defun library-source-pathname->library-binary-tail-pathname @var{source-pathname}
Given a string representing the file pathname of a source library: strip
the file extension if it is equal to a supported @value{PRJNAME} file
extension, append the binary library extension and return the result.
If the file extension is not recognised: return @var{source-pathname}
itself with the binary library extension appended.

@example
(library-source-pathname->library-binary-tail-pathname
   "a/b/c.sls")
@result{} "a/b/c.fasl"

(library-source-pathname->library-binary-tail-pathname
   "a/b/c.vicare.sls")
@result{} "a/b/c.fasl"

(library-source-pathname->library-binary-tail-pathname
   "a/b/c.scm")
@result{} "a/b/c.fasl"

(library-source-pathname->library-binary-tail-pathname
   "a/b/c.ss")
@result{} "a/b/c.fasl"

(library-source-pathname->library-binary-tail-pathname
   "a/b/c.ciao")
@result{} "a/b/c.ciao.fasl"
@end example
@end defun

@c page
@node libutils file-system paths
@subsection Library search paths


The following bindings are exported by the library @library{vicare
libraries}.


@deffn Parameter library-binary-search-path
Hold a list of strings representing relative or absolute directory
pathnames; the strings must represent syntactically valid pathname
specifications, but the directories might not exist.  The list is used
as search path for binary libraries serialised in @fasl{} files,
iterating from head to tail.

Files in the binary search path have pathnames formed by appending a
binary library file extension to the library stem and prepending a
directory from the search path to the result.  Such pathnames can be
constructed as follows:

@example
(define dir-pathname
  (car (library-binary-search-path)))

(define libstem
  (library-reference->filename-stem @meta{libref}))

(define binary-pathname
  (directory+library-stem->library-binary-pathname
     dir-pathname libstem))
@end example

The value of the parameter @func{library-binary-search-path} is composed
as follows:

@enumerate
@item
The parameter is initialised to a list of directory pathnames built at
package configuration time; the list contains:

@example
$(libdir)/vicare-scheme
@end example

@noindent
on 64-bit @gnu{}+Linux systems, it is usually:

@example
/usr/local/lib64/vicare-scheme
@end example

@noindent
and on 32-bit @gnu{}+Linux systems:

@example
/usr/local/lib/vicare-scheme
@end example

@item
@cindex @env{VICARE_LIBRARY_PATH}, system environment variable
@cindex Environment variable @env{VICARE_LIBRARY_PATH}
@cindex System environment variable @env{VICARE_LIBRARY_PATH}
At the beginning of execution @value{PRJNAME} consults the environment
variable @env{VICARE_LIBRARY_PATH}; when set, it is expected to hold a
colon separated list of directory pathnames, in Unix--style.  The list
is parsed and the directories are pepended, in the given order, in
@func{library-binary-search-path}.

@item
If the option @option{-L} or @option{--library-path} is present on the
command line one or more time: every option's value is expected to be a
string representing a directory pathname.  Such pathnames are prepended,
in the given order, to @func{library-binary-search-path}.

@item
While @value{EXECUTABLE} is running: we can modify at will the content
of @func{library-binary-search-path}.
@end enumerate
@end deffn

@c ------------------------------------------------------------

@deffn Parameter library-source-search-path
@anchor{library-source-search-path}
Hold a list of strings representing relative or absolute directory
pathnames; the strings must represent syntactically valid pathname
specifications, but the directories might not exist.  The list is used
as search path for source libraries stored in text files (in @ascii{} or
@utf{}-8 format), iterating from head to tail.

Files in the source search path have pathnames formed by appending a
source library file extension to the library stem and prepending a
directory from the search path to the result.  Such pathnames can be
constructed as follows:

@example
(define dir-pathname
  (car (library-binary-search-path)))

(define libstem
  (library-name->filename-stem @meta{libname}))

(define source-pathname
  (directory+library-stem->library-source-pathname
     dir-pathname libstem))
@end example

The value of the parameter @func{library-source-search-path} is composed
as follows:

@enumerate
@item
The parameter is initialised to the empty list.

@item
@cindex @env{VICARE_SOURCE_PATH}, system environment variable
@cindex Environment variable @env{VICARE_SOURCE_PATH}
@cindex System environment variable @env{VICARE_SOURCE_PATH}
At the beginning of execution, @value{PRJNAME} consults the environment
variable @env{VICARE_SOURCE_PATH}; when set, it is expected to hold a
colon separated list of directory pathnames, in Unix--style.  The list
is parsed and the directories are prepended, in the given order, to
@func{library-source-search-path}.

@item
If the option @option{--source-path} is present on the command line one
or more time: every option's value is expected to be a string
representing a directory pathname.  Such pathnames are prepended, in the
given order, to @func{library-source-search-path}.

@item
While @value{EXECUTABLE} is running: we can modify at will the content
of @func{library-source-search-path}.
@end enumerate
@end deffn

@c page
@node libutils file-system binary
@subsection Scanning the compiled libraries path


The following bindings are exported by the library @library{vicare
libraries}.


@deffn Parameter current-library-binary-search-path-scanner
Hold a function used to convert a @rnrs{6} library reference into the
corresponding compiled library file pathname in the search path
specified by the parameter @func{library-binary-search-path}.

The referenced function must accept, as single value, a @rnrs{6} library
reference and it must return two values.  When successful: a string
representing the @fasl{} file pathname; a thunk to be called to continue
the search from the next directory in the search path.  When no matching
library is found: it must return @false{} and @false{}.

This parameter can be used as follows:

@lisp
(define scanner
  (current-library-binary-search-path-scanner))

(let loop ((next-file-match (lambda ()
                              (scanner libref))))
  (receive (pathname further-file-match)
      (next-file-match)
    (if pathname
        (if (valid-library? pathname)
            (use-the-library pathname)
          (loop further-file-match))
      (search-failed))))
@end lisp
@end deffn


@defun default-library-binary-search-path-scanner @var{libref}
Default value for the parameter
@func{current-library-binary-search-path-scanner}.  Given a @rnrs{6}
library reference: scan the search path specified by the parameter
@func{library-binary-search-path} for the corresponding file.

Return two values.  When successful: a string representing the file
pathname; a thunk to be called to continue the search from the next
directory in the search path.  When no matching library is found: return
@false{} and @false{}.

The file pathname is built using the stem returned by
@func{library-reference->filename-stem}.  Notice that the file pathnames
built by this function have no version number embedded in the pathname;
if we want to search for a binary file with version number included: we
must set the parameter @func{current-library-binary-search-path-scanner}
to a different function.
@end defun

@c page
@node libutils file-system source
@subsection Scanning the source libraries path


The following bindings are exported by the library @library{vicare
libraries}.


@deffn Parameter current-library-source-search-path-scanner
Hold a function used to convert a @rnrs{6} library reference into the
corresponding source library file pathname in the search path specified
by the parameter @func{library-source-search-path}.

The referenced function must accept, as single value, a @rnrs{6} library
reference and it must return two values.  When successful: a string
representing the source file pathname; a thunk to be called to continue
the search from the next directory in the search path.  Otherwise it
must return @false{} and @false{}.

This parameter can be used as follows:

@lisp
(define scanner
  (current-library-source-search-path-scanner))

(let loop ((next-file-match (lambda ()
                              (scanner libref))))
  (receive (pathname further-file-match)
      (next-file-match)
    (if pathname
        (if (valid-library? pathname)
            (use-the-library pathname)
          (loop further-file-match))
      (search-failed))))
@end lisp
@end deffn


@defun default-library-source-search-path-scanner @var{libref}
Default value for the parameter
@func{current-library-source-search-path-scanner}.  Given a @rnrs{6}
library reference: scan the source library search path for the
corresponding file.

Return two values.  When successful: a string representing the source
file pathname; a thunk to be called to continue the search from the next
directory in the search path.  Otherwise it must return @false{} and
@false{}.

The file pathname is built using the stem returned by
@func{library-reference->filename-stem}.  Notice that the file pathnames
built by this function have no version number embedded in the pathname;
if we want to search for a source file with version number included: we
must set the parameter @func{current-library-source-search-path-scanner}
to a different function.
@end defun

@c page
@node libutils file-system locators
@subsection Library file locators


@menu
* libutils file-system locators run::     Run-time library file locator.
* libutils file-system locators compile:: Compile-time library file locator.
* libutils file-system locators source::  Source library file locator.
@end menu

@c page
@node libutils file-system locators run
@subsubsection Run--time library file locator


The run--time library locator is the default; it can be selected
explicitly with the command line option @code{--library-locator
run-time} or by setting the parameter @func{current-library-locator} to
@func{run-time-library-locator}; it is meant to be used by an
installation of @value{PRJNAME} to run applications.  The reference
scenario for the run--time library locator is this:

@enumerate
@item
We install the package @value{PACKAGE}, compiling bundled libraries and
putting them in some system directory; the libraries might be installed
with pathnames like:

@center @file{/usr/local/lib/vicare-scheme/vicare/posix.fasl}

@item
We install additional packages, compiling distributed libraries and
putting them in some system directory; the libraries might be installed
with pathnames like:

@center @file{/usr/local/lib/vicare-scheme/vicare/something.fasl}

@item
We configure the library binary search path to make sure that it
includes the system directory:

@lisp
(library-binary-search-path)
@result{} (... "/usr/local/lib/vicare-scheme" ...)
@end lisp

@item
We configure the library binary file scanner parameter:

@lisp
(current-library-binary-search-path-scanner
   default-library-binary-search-path-scanner)
@end lisp

@noindent
which will scan the search path returned by
@code{(library-binary-search-path)}.

@item
We compose a Scheme program @file{demo.sps} which imports the libraries:

@lisp
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare something))
@end lisp

@noindent
and we execute it selecting the run--time library locator:

@example
$ vicare --library-locator run-time --r6rs-script demo.sps
@end example

@noindent
the command line option @option{--library-locator} will put
@func{run-time-library-locator} in the parameter
@func{current-library-locator}.
@end enumerate

@noindent
the result is that @value{PRJNAME} will search the binary libraries
search path for library files.

The following bindings are exported by the library @library{vicare
libraries}.


@defun run-time-library-locator @var{libref}
Possible value for the parameter @func{current-library-locator}; this
function is meant to be used to search for libraries when running an
application.

Given a @rnrs{6} library reference: return a thunk to be used to start
the search for a matching library.  The returned thunk scans the search
path for compiled libraries in search of a matching binary file; if a
matching compiled library is not found: it scans the search path for
source libraries in search of a matching source file.

When successful the returned thunk returns 2 values:

@enumerate
@item
An input port from which the library can be read; if the port is binary:
a compiled library can be read from it; if the port is textual a source
library can be read from it.  It is responsibility of the caller to
close the returned port when no more needed.

@item
A thunk to be called to continue the search.  This thunk allows the
caller to reject a library if it does not meet some additional
constraints; for example: if its version number does not conform to
@var{libref}.
@end enumerate

When no matching library is found: the returned thunk returns @false{}
and @false{}.
@end defun

@c page
@node libutils file-system locators compile
@subsubsection Compile--time library file locator


The compile--time library locator must be selected explicitly with the
command line option @code{--library-locator compile-time} or by setting
the parameter @func{current-library-locator} to
@func{compile-time-library-locator}; it is meant to be used from the
build directory of a package while compiling libraries for development
or future installation.  The reference scenario for the compile--time
library locator is this:

@enumerate
@item
We install the package @value{PACKAGE}, compiling bundled libraries and
putting them in some system directory; the libraries might be installed
with pathnames like:

@center @file{/usr/local/lib/vicare-scheme/vicare/posix.fasl}

@item
We install additional packages, compiling distributed libraries and
putting them in some system directory; the libraries might be installed
with pathnames like:

@center @file{/usr/local/lib/vicare-scheme/vicare/something.fasl}

@item
We unpack the distribution tarball of a package providing even more
libraries.  We have the source libraries under:

@example
$(srcdir)/lib/vicare/this.sls
$(srcdir)/lib/vicare/that.sls
@end example

@noindent
we want to compile them under the build directory:

@example
$(builddir)/lib/vicare/this.fasl
$(builddir)/lib/vicare/that.fasl
@end example

@noindent
and then install them in a system directory:

@example
/usr/local/lib/vicare-scheme/vicare/this.fasl
/usr/local/lib/vicare-scheme/vicare/that.fasl
@end example

In the package's building infrastructure (for example a Makefile managed
by the @gnu{} Autotools) we need to write appropriate invocations of
@value{EXECUTABLE} to build the libraries locally and pick the
appropriate source libraries and compiled libraries.

@item
It may be that the libraries in the source tree need to load installed
libraries and also have local dependencies:

@lisp
(library (vicare this)
  (export)
  (import (vicare)
    (vicare that))
  ---)

(library (vicare that)
  (export)
  (import (vicare)
    (prefix (vicare posix) px.)
    (vicare something))
  ---)
@end lisp

@item
It may be that an older version of the package is already installed, so
there already exist installed binary libraries:

@example
/usr/local/lib/vicare-scheme/vicare/this.fasl
/usr/local/lib/vicare-scheme/vicare/that.fasl
@end example

@noindent
we want the libraries under @code{$(builddir)/lib} to take precedence
over the libraries under @file{/usr/@/local/@/lib/@/vicare-scheme}.  It
may be that there exist installed source libraries:

@example
/usr/local/lib/vicare-scheme/vicare/this.sls
/usr/local/lib/vicare-scheme/vicare/that.sls
@end example

@noindent
we want the libraries under @code{$(srcdir)/lib} to take precedence over
the libraries under @file{/usr/@/local/@/lib/@/vicare-scheme}.
@end enumerate

At the Scheme level we want the following:

@itemize
@item
Configure the library source search path to include only the local
source directory:

@lisp
(library-source-search-path)
@result{} ("$(srcdir)/lib")
@end lisp

@item
Configure the library binary search path to include the system
directory:

@lisp
(library-binary-search-path)
@result{} (... "/usr/local/lib/vicare-scheme" ...)
@end lisp

@item
Configure the build directory to reference the local build directory:

@lisp
(compiled-libraries-build-directory)
@result{} "$(builddir)/lib
@end lisp

@item
Configure the library binary file scanner parameter:

@lisp
(current-library-binary-search-path-scanner
   default-library-binary-search-path-scanner)
@end lisp

@noindent
which will scan the search path returned by
@code{(library-binary-search-path)}.

@item
Configure the library source file scanner parameter:

@lisp
(current-library-source-search-path-scanner
   default-library-source-search-path-scanner)
@end lisp

@noindent
which will scan the search path returned by
@code{(library-source-search-path)}.

@item
Configure the library locator parameter:

@lisp
(current-library-locator compile-time-library-locator)
@end lisp

@noindent
which implements the appropriate policy.
@end itemize

Assuming Makefiles generated by @gnu{} Automake: to achieve the desired
result, we have two options:

@enumerate
@item
For every library to be compiled locally, we write in the Makefile an
explicit dependency rule:

@example
lib/vicare/that.fasl: lib/vicare/that.sls
        VICARE_SOURCE_PATH=; export VICARE_SOURCE_PATH;    \
        vicare --library-locator compile-time              \
           --library-path    /usr/local/lib/vicare-scheme  \
           --source-path     $(srcdir)/lib                 \
           --build-directory $(builddir)/lib               \
           -o $@@ -c $<

lib/vicare/this.fasl: lib/vicare/this.sls lib/vicare/that.fasl
        VICARE_SOURCE_PATH=; export VICARE_SOURCE_PATH;    \
        vicare --library-locator compile-time              \
           --library-path    /usr/local/lib/vicare-scheme  \
           --source-path     $(srcdir)/lib                 \
           --build-directory $(builddir)/lib               \
           -o $@@ -c $<
@end example

@noindent
this is the solution to prefer, because it allows parallel builds.

@item
We write a script @file{compile-all.sps} that imports at least the local
libraries that are leaves in the local package dependency tree:

@lisp
(import (only (vicare that))
        (only (vicare this)))
@end lisp

@noindent
write a single Makefile rule that compiles in the build directory all
the dependencies of the script:

@example
.PHONY: vfasl

vfasl:
        VICARE_SOURCE_PATH=; export VICARE_SOURCE_PATH;    \
        vicare --library-locator compile-time              \
           --library-path    /usr/local/lib/vicare-scheme  \
           --source-path     $(srcdir)/lib                 \
           --build-directory $(builddir)/lib               \
           --compile-dependencies compile-all.sps
@end example
@end enumerate

The following bindings are exported by the library @library{vicare
libraries}.


@defun compile-time-library-locator @var{libref}
Possible value for the parameter @func{current-library-locator}; this
function is meant to be used to search for libraries to be compiled for
installation.

Given a @rnrs{6} library reference: return a thunk to be used to start
the search for a matching library.  The search for source libraries is
performed using the library source file scanner in
@func{current-library-source-search-path-scanner}.  The search for
compiled libraries is performed using the library binary file scanner in
@func{current-library-binary-search-path-scanner}.

The returned thunk does the following:

@enumerate
@item
Ask the library source file scanner for the next matching source file.

@item
If a matching source is found: look for an already compiled library file
in the @func{compiled-libraries-build-directory}:

@enumerate a
@item
If no compiled file exists or it if exists but it is older than the
source file: accept the source file as matching.

@item
If a compiled file exists and it is newer than the source file: accept
the compiled file as matching.

@item
Return to the caller the matching file pathname.

@item
If the caller rejects the binary file pathname: return to the caller the
source file pathname.

@item
If the caller rejects the source file: loop to 1.
@end enumerate

@item
If no source file exists: loop to 1.
@end enumerate

Remember that the binary file can be rejected if it has been compiled by
another boot image or it has the wrong library @uid{}.

When successful (a source or binary file matching @var{libref} is found)
the returned thunk returns 2 values:

@enumerate
@item
An input port.  If the port is binary: a compiled library can be read
from it.  If the port is textual: a source library can be read from it.
It is responsibility of the caller to close the returned port when no
more needed.

@item
A thunk to be called to continue the search.  This thunk allows the
caller to reject a library if it does not meet some additional
constraint; for example: if its version number does not conform to
@var{libref}.
@end enumerate

When no matching library is found: the returned thunk returns @false{}
and @false{}.
@end defun

@c page
@node libutils file-system locators source
@subsubsection Source library file locator


The source library locator must be selected explicitly with the command
line option @code{--library-locator source} or by setting the parameter
@func{current-library-locator} to @func{source-library-locator}; it is
meant to be used to search for source libraries first and then for
compiled ones.  The reference scenario for the source library locator is
this:

@enumerate
@item
We install the package @value{PACKAGE}, compiling bundled libraries and
putting them in some system directory; the libraries might be installed
with pathnames like:

@center @file{/usr/local/lib/vicare-scheme/vicare/posix.fasl}

@item
We install additional packages, compiling distributed libraries and
putting them in some system directory; the libraries might be installed
with pathnames like:

@center @file{/usr/local/lib/vicare-scheme/vicare/something.fasl}

@item
We checkout the source tree of a package repository to develop even more
libraries.  We have the source libraries under:

@example
$(srcdir)/lib/vicare/this.sls
$(srcdir)/lib/vicare/that.sls
@end example

@noindent
we want to compile them under the build directory:

@example
$(builddir)/lib/vicare/this.fasl
$(builddir)/lib/vicare/that.fasl
@end example

@noindent
and then install them in a system directory:

@example
/usr/local/lib/vicare-scheme/vicare/this.fasl
/usr/local/lib/vicare-scheme/vicare/that.fasl
@end example

In the package's building infrastructure (for example a Makefile managed
by the @gnu{} Autotools) we need to write appropriate invocations of
@value{EXECUTABLE} to build the libraries locally and pick the
appropriate source libraries and compiled libraries.

This is the gist: we want to automatically generate an include Makefile
holding the compilation and installation recipes correctly describing
the dependencies among libraries.  For this we need to load all the
source libraries in the package's source tree.

@item
It may be that the libraries in the source tree need to load installed
libraries and also have local dependencies:

@lisp
(library (vicare this)
  (export)
  (import (vicare)
    (vicare that))
  ---)

(library (vicare that)
  (export)
  (import (vicare)
    (prefix (vicare posix) px.)
    (vicare something))
  ---)
@end lisp

@item
It may be that an older version of the package is already installed, so
there already exist installed binary libraries:

@example
/usr/local/lib/vicare-scheme/vicare/this.fasl
/usr/local/lib/vicare-scheme/vicare/that.fasl
@end example

@noindent
we want these installed libraries to be ignored.  It may be that there
exist installed source libraries:

@example
/usr/local/lib/vicare-scheme/vicare/this.sls
/usr/local/lib/vicare-scheme/vicare/that.sls
@end example

@noindent
we want the libraries under @code{$(srcdir)/lib} to take precedence over
the libraries under @file{/usr/@/local/@/lib/@/vicare-scheme}.
@end enumerate

At the Scheme level we want the following:

@itemize
@item
Configure the library source search path to include only the local
source directory:

@lisp
(library-source-search-path)
@result{} ("$(srcdir)/lib")
@end lisp

@item
Configure the library binary search path to include the system
directory:

@lisp
(library-binary-search-path)
@result{} (... "/usr/local/lib/vicare-scheme" ...)
@end lisp

@item
Configure the library binary file scanner parameter:

@lisp
(current-library-binary-search-path-scanner
    default-library-binary-search-path-scanner)
@end lisp

@noindent
which will scan the search path returned by
@code{(library-binary-search-path)}.

@item
Configure the library source file scanner parameter:

@lisp
(current-library-source-search-path-scanner
    default-library-source-search-path-scanner)
@end lisp

@noindent
which will scan the search path returned by
@code{(library-source-search-path)}.

@item
Configure the library locator parameter:

@example
(current-library-locator source-library-locator)
@end example

@noindent
which implements the appropriate policy.
@end itemize

To achieve the desired result, in the Makefile we write rules as
follows:

@example
.PHONY: dependencies

DEPSCRIPT = $(srcdir)/scripts/build-makefile-rules.sps

dependencies:
        VICARE_SOURCE_PATH=; export VICARE_SOURCE_PATH; \
        vicare --library-locator source                 \
          --library-path /usr/local/lib/vicare-scheme   \
          --source-path  $(srcdir)/lib                  \
          --r6rs-script  $(DEPSCRIPT) --                \
          $(slsdir)/libraries.scm >$(slsdir)/dependencies.make
@end example

@noindent
where the executed Scheme script generates the Makefile rules
automatically.

The following bindings are exported by the library @library{vicare
libraries}.


@defun source-library-locator @var{libref}
Possible value for the parameter @func{current-library-locator}; this
function is meant to be used to search for source libraries first and
for binary libraries later.

Given a @rnrs{6} library reference: return a thunk to be used to start
the search for a matching library.  The returned thunk uses the current
source library scanner referenced by
@func{current-library-source-search-path-scanner}, with the purpose of
finding a library file that matches a given @rnrs{6} library reference.
If no source library is found: the current binary library scanner
referenced by @func{current-library-binary-search-path-scanner} is used.

When successful the returned thunk returns 2 values:

@enumerate
@item
An input port.  If it is a textual input port: a source library can be
read from it.  If it is a binary input port: a binary library can be
read from it.  It is responsibility of the caller to close the returned
port when no more needed.

@item
A thunk to be called to continue the search.  This thunk allows the
caller to reject a library if it does not meet some additional
constraint; for example: if its version number does not conform to
@var{libref}.
@end enumerate

When no matching library is found: the returned thunk returns @false{}
and @false{}.
@end defun

@c page
@node libutils dynamic
@section Dynamically loading Scheme libraries


It is possible to dynamically load a Scheme library after the program
has been compiled.  Here is an example of: creating a library, importing
it, then dynamically loading its syntactic bindings:

@lisp
(import (vicare)
  (prefix (vicare libraries) libs.))

(library (demo-01)
  (export fun var)
  (import (rnrs))
  (define (fun a b)
    (+ a b))
  (define var 123))

(import (demo-01))

(let* ((lib (libs.library-dynamic-load-and-intern '(demo-01)))
       (fun (libs.library-dynamic-retrieve lib 'fun))
       (var (libs.library-dynamic-retrieve lib 'var)))
  (values (fun 1 2) var))
@result{} 3 123
@end lisp

@noindent
another example which loads the installed @library{vicare pregexp}:

@lisp
(import (vicare)
  (prefix (vicare libraries) libs.))

(define-values (pregexp-match)
  (let ((lib (libs.library-dynamic-load-and-intern
                 '(vicare pregexp))))
    (values (libs.library-dynamic-retrieve lib 'pregexp-match))))

(pregexp-match "[a-z]+" "ciao hello ciao")
@result{} ("ciao")
@end lisp


@defun library-dynamic-load-and-intern @var{libref}
Search for a library whose name matches the library reference
@var{libref}, intern it and invoke it.  When successful return a
@class{library} object.  If an error occurs: raise an exception.

This function makes use of @func{find-library-by-name} to search and
intern the requested library.
@end defun


@defun library-dynamic-retrieve @var{lib} @var{name}
Search in the @GlobalEnv{} of the @class{library} object @var{lib} an
exported syntactic binding whose public name is the symbol @var{name}.
When successful: return the value bound to the syntactic binding.  If an
error occurs: raise an exception.
@end defun

@c page
@node libutils compiling
@section Compiling libraries


@menu
* libutils compiling special::  Special directories.
@end menu

@c page
@node libutils compiling special
@subsection Special directories


@menu
* libutils compiling special build::  The build directory.
@end menu

@c page
@node libutils compiling special build
@subsubsection The build directory


@cindex Build directory
@cindex Directory, build


The following bindings are exported by the library @library{vicare
libraries}.


@deffn Parameter compiled-libraries-build-directory
Hold @false{} or a string representing the absolute or relative pathname
of a directory; the string must represent a syntactically valid
pathname, but the directory might not exist.  The build directory is
meant to be used when compiling libraries in the build directory of a
source package for later installation.

When the selected library locator is @code{compile-time}: the store
directory is used to search for compiled libraries.  It is an error if
the library locator is @code{compile-time} and no build directory is
selected.

Under the build directory: @fasl{} files are stored with pathnames
composed from the library stem, which is generated from the library
name.  For example, if the build directory is @code{$(builddir)/lib} the
source library:

@example
$(srcdir)/lib/vicare/posix.sls
@end example

@noindent
is stored as:

@example
$(builddir)/lib/vicare/posix.fasl
@end example

Such pathnames can be built as follows:

@smallexample
(define binary-pathname-0
  (library-name->library-binary-pathname-in-build-directory
    @meta{libname}))

(define binary-pathname-1
  (library-reference->library-binary-pathname-in-build-directory
    @meta{libref}))
@end smallexample

The value of the parameter @func{compiled-libraries-build-directory} is
composed as follows:

@enumerate
@item
The parameter is initialised to @false{}.

@item
@cindex @env{VICARE_STORE_DIRECTORY}, system environment variable
@cindex Environment variable @env{VICARE_STORE_DIRECTORY}
@cindex System environment variable @env{VICARE_STORE_DIRECTORY}
If the environment variable @env{VICARE_STORE_DIRECTORY} is set and
holding an valid directory pathname: select its value as parameter
value; the directory itself might not exist.

@item
If the option @option{--build-directory} is present on the command line:
its value is expected to be a string representing a directory pathname,
otherwise an error is raised; the directory itself might not exist.
Such pathname becomes the value of
@func{compiled-libraries-build-directory}.

@item
While @value{EXECUTABLE} is running: we can modify at will the content
of @func{compiled-libraries-build-directory}.
@end enumerate
@end deffn

@c end of file
@c mode: texinfo
@c TeX-master: "vicare-scheme"
@c End:
