@node bst
@chapter Binary search trees


@cindex Library @library{vicare containers binary-search-trees}
@cindex @library{vicare containers binary-search-trees}, library


The library @library{vicare containers binary-search-trees} implements the
skeleton functions needed by binary search trees.

@menu
* bst intro::                   Introduction to binary search trees.
* bst bnodes::                  Binary node objects.
* bst unodes::                  Unbalanced binary node objects.
@end menu

@c page
@node bst intro
@section Introduction to binary search trees


The @dfn{binary search trees} are tree structures in which every node
has at most two children.  Every node is associated to a ``sort key'': a
value that can be used to establish an ordering among the nodes.  The
node insertion and node removal operations are implemented in such a way
that:

@itemize
@item
The left child of a node has key less than the one the node.

@item
The right child of a node has key greater than, or equal to, the one of
the node.
@end itemize

Here is an example of binary search tree, with nodes in the correct
order:

@example
5-------10----12
|        |     |
1--3--4  7--9 11
   |     |  |
   2     6  8
@end example

@noindent
the root node has sort key @samp{5}; the left child of the root has sort
key @samp{1}; the right child of the root has sort key @samp{10}.  Let's
take @samp{10} as example: every node in its left subtree has key less
than @samp{10}; every node in its right subtree has key greater than, or
equal to, @samp{10}.  This is a general property of binary search trees.

The library @library{vicare containers binary-search-trees} is the core
library for binary search tree implementation; it implements trees in
such a way that:

@itemize
@item
The empty tree is represented by @false{}.

@item
A node is represented by an instance of type @objtype{<binary-node>} or
a subtype of this type.

@item
The type @objtype{<binary-node>} has @math{3} fields: @code{parent},
@code{left}, @code{right}.  The value of these fields can be @false{} or
an instance of @objtype{<binary-node>}.

@item
If the @code{parent} field of a node is set to @false{}: it means that
node is the root of a tree.
@end itemize

All the functions acting on instances of @objtype{<binary-node>} are
meant to be usable on trees implementing any node balancing strategy;
they only expect the binary tree to be a binary search tree as defined
above.  The core library only implements unbalanced binary search trees,
in which nodes have the type @objtype{<unbalanced-binary-node>}.  The
type hierarchy is:

@lisp
(define-record-type <binary-node>
  ---)

(define-record-type <unbalanced-binary-node>
  (parent <binary-node>)
  ---)
@end lisp

By themselves, these types have no sort key; to associate a sort key
with a node instance we need to subtype them.  The following is an
example of binary search tree of fixnums:

@lisp
(import (vicare)
  (vicare containers binary-search-trees))

(define-record-type <fixnum-node>
  (parent <unbalanced-binary-node>)

  (fields (immutable sort-key))

  (protocol
   (lambda (make-unbalanced-binary-node)
     (case-lambda*
       (()
        ((make-unbalanced-binary-node #f #f) (void)))

       ((key)
        ((make-unbalanced-binary-node #f #f) key))

       ((@{key   fixnum?@}
         @{left  false-or-unbalanced-binary-node?@}
         @{right false-or-unbalanced-binary-node?@})
        ((make-unbalanced-binary-node left right) key)))))

  #| end of DEFINE-RECORD-TYPE |# )

(define (key< new old)
  (fx<? (<fixnum-node>-sort-key new)
        (<fixnum-node>-sort-key old)))

(define (make-comparison-proc target-key)
  (lambda (node)
    (let ((key (<fixnum-node>-sort-key node)))
      (cond ((fx=? target-key key)       0)
            ((fx<? target-key key)      -1)
            (else                       +1)))))
@end lisp

@noindent
we can build a tree from a list and then search for a node as follows:

@lisp
(define (tree . key*)
  (fold-left (lambda (root key)
               (unbalanced-tree-insert! root key<
                  (make-<fixnum-node> key)))
    #f key*))

;; 5-------10----12
;; |        |     |
;; 1--3--4  7--9 11
;;    |     |  |
;;    2     6  8
(define root
  (tree 5 1 3 2 4 10 7 12 6 9 8 11))

(define node
  (binary-tree-find root (make-comparison-proc 8)))
@end lisp

@noindent
we can perform a forwards in--order iteration as follows:

@lisp
(binary-tree-fold-in-order-forwards
    (lambda (knil node)
      (cons (<fixnum-node>-sort-key node) knil))
  '() root))
@result{} (12 11 10 9 8 7 6 5 4 3 2 1)
@end lisp

@noindent
in the result of this operation: the sort key in the first node from the
search is the last item in the list.

@c page
@node bst bnodes
@section Binary node objects


Binary search trees are composed of ``binary node objects'' linked
together in a tree hierarchy.  The object type @objtype{<binary-node>}
is the base type of all the node types.

@menu
* bst bnodes objects::          Binary node data type.
* bst bnodes access::           Accessors and mutators for binary nodes.
* bst bnodes pred::             Structure predicates for binary nodes.
* bst bnodes searching::        Searching in binary trees.
* bst bnodes iterating::        Iterating over binary trees.
* bst bnodes validating::       Validating binary trees.
@end menu

@c page
@node bst bnodes objects
@subsection Binary node data type


The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.


@deftp {@rnrs{6} Record Type} <binary-node>
@cindex @var{bnode} argument
@cindex Argument @var{bnode}
Record type representing a node in a binary tree.  The
@objtype{<binary-node>} type is non--generative and available for
subtyping.  In this documentation @objtype{<binary-node>} object
arguments to functions are indicated as @var{bnode}.

This type has the following fields:

@table @code
@item parent
An instance of @objtype{<binary-node>} representing the parent node;
@false{} if this node has no parent.

@item left
An instance of @objtype{<binary-node>} representing the left child, the
root of the left subtree; @false{} if this node has no left subtree.

@item right
An instance of @objtype{<binary-node>} representing the right child, the
root of the right subtree; @false{} if this node has no right subtree.
@end table
@end deftp


@defun make-binary-node
@defunx make-binary-node @var{left} @var{right}
Build and return a new instance of @objtype{<binary-node>}.  The
optional @var{left} and @var{right} arguments must be @false{} or
instances of @objtype{<binary-node>} representing the left and right
subtrees.  The @code{parent} field of the new instance is set to
@false{}.
@end defun


@defun binary-node? @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{<binary-node>};
otherwise return @false{}.
@end defun

@c page
@node bst bnodes access
@subsection Accessors and mutators for binary nodes


The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-node-parent @var{bnode}
@defunx $binary-node-parent @var{bnode}
Accessor for the parent node of @var{bnode}.  Return @false{} or an
instance of @objtype{<binary-node>}.
@end defun

@c ------------------------------------------------------------------------

@defun binary-node-left @var{bnode}
@defunx $binary-node-left @var{bnode}
Accessor for the left subtree of @var{bnode}.  Return @false{} or an
instance of @objtype{<binary-node>}.
@end defun


@defun binary-node-left-set! @var{bnode} @var{left}
@defunx $binary-node-left-set! @var{bnode} @var{left}
Mutator for the left subtree of a @objtype{<binary-node>} instance.  The
argument @var{left} must be @false{} or an instance of
@objtype{<binary-node>} representing the root of the left subtree.  When
@var{left} is a node: it is mutated to reference @var{bnode} as parent.
@end defun

@c ------------------------------------------------------------------------

@defun binary-node-right @var{bnode}
@defunx $binary-node-right @var{bnode}
Accessor for the right subtree of @var{bnode}.  Return @false{} or an
instance of @objtype{<binary-node>}.
@end defun


@defun binary-node-right-set! @var{bnode} @var{right}
@defunx $binary-node-right-set! @var{bnode} @var{right}
Mutator for the right subtree of a @objtype{<binary-node>} instance.
The argument @var{right} must be @false{} or an instance of
@objtype{<binary-node>} representing the root of the right subtree.
When @var{right} is a node: it is mutated to reference @var{bnode} as
parent.
@end defun

@c ------------------------------------------------------------------------

@defun binary-node-replace-in-parent! @var{old-child} @var{new-child}
@defunx $binary-node-replace-in-parent! @var{old-child} @var{new-child}
Replace one child node with another child node.

The argument @var{old-child} must be an instance of
@objtype{<binary-node>}; the argument @var{new-child} must be @false{}
or an instance of @objtype{<binary-node>}.

Let's name @var{dad} the parent of @var{old-child}, @var{dad} can be
@false{} or an instance of @objtype{<binary-node>}; this function
performs the following operations:

@itemize
@item
If @var{dad} is a node and @var{old-child} is the left child of
@var{dad}: set @var{new-child} as left child of @var{dad}.

@item
If @var{dad} is a node and @var{old-child} is the right child of
@var{dad}: set @var{new-child} as right child of @var{dad}.

@item
The parent of @var{old-child} is set to @false{}.

@item
If @var{new-child} is a node: the parent of @var{new-child} is set to
@var{dad}.
@end itemize

As example, let's consider this simple tree:

@example
2--3  0
|
1
@end example

@noindent
applying this function to @var{old-child} having key @samp{1} and
@var{new-child} having key @samp{0}, results in the following tree:

@example
2--3  1
|
0
@end example
@end defun

@c page
@node bst bnodes pred
@subsection Structure predicates for binary nodes


The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-node-parent-and-left-child? @vari{bnode} @varii{bnode}
@defunx $binary-node-parent-and-left-child? @vari{bnode} @varii{bnode}
Return @true{} if @varii{bnode} is the left child of @vari{bnode};
otherwise return @false{}.
@end defun


@defun binary-node-parent-and-right-child? @vari{bnode} @varii{bnode}
@defunx $binary-node-parent-and-right-child? @vari{bnode} @varii{bnode}
Return @true{} if @varii{bnode} is the right child of @vari{bnode};
otherwise return @false{}.
@end defun


@defun binary-node-parent-and-child? @vari{bnode} @varii{bnode}
@defunx $binary-node-parent-and-child? @vari{bnode} @varii{bnode}
Return @true{} if @varii{bnode} is the left or right child of
@vari{bnode}; otherwise return @false{}.
@end defun

@c page
@node bst bnodes searching
@subsection Searching in binary trees


The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-tree-root @var{node}
@defunx $binary-tree-root @var{node}
Find the root of a binary tree.  The argument @var{node} must be:

@itemize
@item
@false{} to represent an empty tree; in this case the return value is
@false{}.

@item
An instance of @objtype{<binary-node>}; in this case the return value is
an instance of @objtype{<binary-node>}.
@end itemize
@end defun


@defun binary-tree-minimum @var{root}
@defunx binary-tree-minimum @var{root} @var{empty-tree-handler}
@defunx $binary-tree-minimum @var{root} @var{empty-tree-handler}
Search and return the minimum node in the tree starting from @var{root};
the minimum node is the leftmost from @var{root}.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The optional argument @var{empty-tree-handler} must be a thunk.  If
@var{root} is @false{} and @var{empty-tree-handler} is not used: the
return value is @false{}.  If @var{root} is @false{} and
@var{empty-tree-handler} is used: the return value is the return value
of @var{empty-tree-handler}.
@end defun


@defun binary-tree-maximum @var{root}
@defunx binary-tree-maximum @var{root} @var{empty-tree-handler}
@defunx $binary-tree-maximum @var{root} @var{empty-tree-handler}
Search and return the maximum node in the tree starting from @var{root};
the maximum node is the rightmost from @var{root}.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The optional argument @var{empty-tree-handler} must be a thunk.  If
@var{root} is @false{} and @var{empty-tree-handler} is not used: the
return value is @false{}.  If @var{root} is @false{} and
@var{empty-tree-handler} is used: the return value is the return value
of @var{empty-tree-handler}.
@end defun


@defun binary-tree-find @var{root} @var{compare}
@defunx binary-tree-find @var{root} @var{compare} @var{empty-tree-handler}
@defunx $binary-tree-find @var{root} @var{compare} @var{empty-tree-handler}
Search and return a node in the tree starting from @var{root} based on
its sort key.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The argument @var{compare} must be a procedure accepting an instance of
@objtype{<binary-node>} as single argument; it must return a single
value:

@table @code
@item 0
If the argument node satisfies the search criterion.

@item -1
If the argument node has sort key less than the sort key of the target
node.

@item +1
If the argument node has sort key greater than, or equal to, the sort
key of the target node.
@end table

The optional argument @var{empty-tree-handler} must be a thunk.  If the
target node is not found and @var{empty-tree-handler} is not used: the
return value is @false{}.  If the target node it not found and
@var{empty-tree-handler} is used: the return value is the return value
of @var{empty-tree-handler}.
@end defun

@c page
@node bst bnodes iterating
@subsection Iterating over binary trees


@menu
* bst bnodes iterating in-order::       In-order iterations.
* bst bnodes iterating pre-order::      Pre-order iterations.
* bst bnodes iterating post-order::     Post-order iterations.
* bst bnodes iterating level-order::    Level-order iterations.
@end menu

@c page
@node bst bnodes iterating in-order
@subsubsection In--order iterations


Forwards in--order iteration: visit all the nodes from the leftmost to
the rightmost.  Backwards in--order iteration: visit all the nodes from
the rightmost to the leftmost.  As example, given the tree:

@example
5-------10----12
|        |     |
1--3--4  7--9 11
   |     |  |
   2     6  8
@end example

@noindent
the inorder iteration is:

@example
forward:   1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12
backward: 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1
@end example

Here is an example of forwards and backwards in--order iteration using
trees of fixnums (@pxref{bst intro}):

@lisp
(define (make-tree)
  ;; 5-------10----12
  ;; |        |     |
  ;; 1--3--4  7--9 11
  ;;    |     |  |
  ;;    2     6  8
  (tree 5 1 3 2 4 10 7 12 6 9 8 11))

;;By reversing we return a list in which: the first item
;;is the sort key of the first node visited in the iteration.
(reverse
  (binary-tree-fold-in-order-forwards
      (lambda (knil node)
        (cons (<fixnum-node>-sort-key node) knil))
    '() (make-tree)))
@result{} (1 2 3 4 5 6 7 8 9 10 11 12)

;;By reversing we return a list in which: the first item
;;is the sort key of the first node visited in the iteration.
(reverse
  (binary-tree-fold-in-order-backwards
      (lambda (node knil)
        (cons (<fixnum-node>-sort-key node) knil))
    '() (make-tree)))
@result{} (12 11 10 9 8 7 6 5 4 3 2 1)
@end lisp

The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.  The bindings whose
name is prefixed with @code{$} are unsafe operations: they do
@strong{not} validate their arguments before accessing them.

@c ------------------------------------------------------------------------

@subsubheading Forwards iteration


@defun binary-tree-fold-in-order-forwards @var{kons} @var{knil} @var{root}
Like @func{fold-left} for lists, but visit the nodes of a binary tree
with a in--order forwards iteration.  The argument @var{root} must be
@false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.
@end defun


@defun binary-tree-begin-in-order-forwards @var{root}
@defunx $binary-tree-begin-in-order-forwards @var{root}
Perform the first step in a in--order forwards iteration.  The argument
@var{root} must be @false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.  If the tree is
empty: return @false{}; otherwise return an instance of
@objtype{<binary-node>} representing the first visited node.
@end defun


@defun binary-tree-step-in-order-forwards @var{bnode}
@defunx $binary-tree-step-in-order-forwards @var{bnode}
Advance an in--order forwards iteration by one step starting from
@var{bnode}, which must be an instance of @objtype{<binary-node>}.  If
@var{bnode} is the last in the iteration: return @false{}; otherwise
return an instance of @objtype{<binary-node>} representing the next
visited node.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Backwards iteration


@defun binary-tree-fold-in-order-backwards @var{kons} @var{knil} @var{root}
Like @func{fold-right} for lists, but visit the nodes of a binary tree
with a in--order backwards iteration.  The argument @var{root} must be
@false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.
@end defun


@defun binary-tree-begin-in-order-backwards @var{root}
@defunx $binary-tree-begin-in-order-backwards @var{root}
Perform the first step in a in--order backwards iteration.  The argument
@var{root} must be @false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.  If the tree is
empty: return @false{}; otherwise return an instance of
@objtype{<binary-node>} representing the first visited node.
@end defun


@defun binary-tree-step-in-order-backwards @var{bnode}
@defunx $binary-tree-step-in-order-backwards @var{bnode}
Advance an in--order backwards iteration by one step starting from
@var{bnode}, which must be an instance of @objtype{<binary-node>}.  If
@var{bnode} is the last in the iteration: return @false{}; otherwise
return an instance of @objtype{<binary-node>} representing the next
visited node.
@end defun

@c page
@node bst bnodes iterating pre-order
@subsubsection Pre--order iterations


Pre--order iteration: visit the current node then the left child then
the right child.  As example, given the tree:

@example
5-------10----12
|        |     |
1--3--4  7--9 11
   |     |  |
   2     6  8
@end example

@noindent
the pre--order iteration is:

@example
forward:    5,  1,  3,  2,  4, 10,  7,  6,  9,  8, 12, 11
backward:   5, 10, 12, 11,  7,  9,  8,  6,  1,  3,  4,  2
@end example

@noindent
the forwards iteration is a ``worm that always turns right'', while the
backwards iteration is a ``worm that always turns left''.

The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.  The bindings whose
name is prefixed with @code{$} are unsafe operations: they do
@strong{not} validate their arguments before accessing them.

@c ------------------------------------------------------------------------

@subsubheading Forwards iteration


@defun binary-tree-fold-pre-order-forwards @var{kons} @var{knil} @var{root}
Like @func{fold-left} for lists, but visit the nodes of a binary tree
with a pre--order forwards iteration.  The argument @var{root} must be
@false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.
@end defun


@defun binary-tree-begin-pre-order-forwards @var{root}
@defunx $binary-tree-begin-pre-order-forwards @var{root}
Perform the first step in a pre--order forwards iteration.  The argument
@var{root} must be @false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.  If the tree is
empty: return @false{}; otherwise return an instance of
@objtype{<binary-node>} representing the first visited node.
@end defun


@defun binary-tree-step-pre-order-forwards @var{bnode}
@defunx $binary-tree-step-pre-order-forwards @var{bnode}
Advance an pre--order forwards iteration by one step starting from
@var{bnode}, which must be an instance of @objtype{<binary-node>}.  If
@var{bnode} is the last in the iteration: return @false{}; otherwise
return an instance of @objtype{<binary-node>} representing the next
visited node.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Backwards iteration


@defun binary-tree-fold-pre-order-backwards @var{kons} @var{knil} @var{root}
Like @func{fold-right} for lists, but visit the nodes of a binary tree
with a pre--order backwards iteration.  The argument @var{root} must be
@false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.
@end defun


@defun binary-tree-begin-pre-order-backwards @var{root}
@defunx $binary-tree-begin-pre-order-backwards @var{root}
Perform the first step in a pre--order backwards iteration.  The argument
@var{root} must be @false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.  If the tree is
empty: return @false{}; otherwise return an instance of
@objtype{<binary-node>} representing the first visited node.
@end defun


@defun binary-tree-step-pre-order-backwards @var{bnode}
@defunx $binary-tree-step-pre-order-backwards @var{bnode}
Advance an pre--order backwards iteration by one step starting from
@var{bnode}, which must be an instance of @objtype{<binary-node>}.  If
@var{bnode} is the last in the iteration: return @false{}; otherwise
return an instance of @objtype{<binary-node>} representing the next
visited node.
@end defun

@c page
@node bst bnodes iterating post-order
@subsubsection Post--order iterations


Post--order iteration: visit the left--child, then the right--child,
then the parent node.  As example, given the tree:

@example
5-------10----12
|        |     |
1--3--4  7--9 11
   |     |  |
   2     6  8
@end example

@noindent
the post--order iteration is:

@example
forward:    2,  4,  3,  1,  6,  8,  9,  7, 11, 12, 10,  5
backward:  11, 12,  8,  9,  6,  7, 10,  4,  2,  3,  1,  5
@end example

The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.  The bindings whose
name is prefixed with @code{$} are unsafe operations: they do
@strong{not} validate their arguments before accessing them.

@c ------------------------------------------------------------------------

@subsubheading Forwards iteration


@defun binary-tree-fold-post-order-forwards @var{kons} @var{knil} @var{root}
Like @func{fold-left} for lists, but visit the nodes of a binary tree
with a post--order forwards iteration.  The argument @var{root} must be
@false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.
@end defun


@defun binary-tree-begin-post-order-forwards @var{root}
@defunx $binary-tree-begin-post-order-forwards @var{root}
Perform the first step in a post--order forwards iteration.  The argument
@var{root} must be @false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.  If the tree is
empty: return @false{}; otherwise return an instance of
@objtype{<binary-node>} representing the first visited node.
@end defun


@defun binary-tree-step-post-order-forwards @var{bnode}
@defunx $binary-tree-step-post-order-forwards @var{bnode}
Advance an post--order forwards iteration by one step starting from
@var{bnode}, which must be an instance of @objtype{<binary-node>}.  If
@var{bnode} is the last in the iteration: return @false{}; otherwise
return an instance of @objtype{<binary-node>} representing the next
visited node.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Backwards iteration


@defun binary-tree-fold-post-order-backwards @var{kons} @var{knil} @var{root}
Like @func{fold-right} for lists, but visit the nodes of a binary tree
with a post--order backwards iteration.  The argument @var{root} must be
@false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.
@end defun


@defun binary-tree-begin-post-order-backwards @var{root}
@defunx $binary-tree-begin-post-order-backwards @var{root}
Perform the first step in a post--order backwards iteration.  The argument
@var{root} must be @false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.  If the tree is
empty: return @false{}; otherwise return an instance of
@objtype{<binary-node>} representing the first visited node.
@end defun


@defun binary-tree-step-post-order-backwards @var{bnode}
@defunx $binary-tree-step-post-order-backwards @var{bnode}
Advance an post--order backwards iteration by one step starting from
@var{bnode}, which must be an instance of @objtype{<binary-node>}.  If
@var{bnode} is the last in the iteration: return @false{}; otherwise
return an instance of @objtype{<binary-node>} representing the next
visited node.
@end defun

@c page
@node bst bnodes iterating level-order
@subsubsection Level--order iterations


Level--order iteration: visit the tree level by level.  Example:

@example
5-------10----12
|        |     |
1--3--4  7--9 11
   |     |  |
   2     6  8
@end example

@noindent
the order of the forwards iteration is: 5, 1, 10, 3, 7, 12, 2, 4, 6, 9,
11, 8.  To do it we need a moving cursor that always ``turns right''
keeping the count of the level.  The order of the backwards iteration
is: 5, 10, 1, 12, 7, 3, 11, 9, 6, 4, 2, 8.

The implementation of the level--order iteration is particularly slow,
but the current implementation has the current node as the only state.
The level--order iteration is usually called ``breadth--first
iteration'' or ``breadth--first search''; this name is reserved for
another implementation.

The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.  The bindings whose
name is prefixed with @code{$} are unsafe operations: they do
@strong{not} validate their arguments before accessing them.

@c ------------------------------------------------------------------------

@subsubheading Forwards iteration


@defun binary-tree-fold-level-order-forwards @var{kons} @var{knil} @var{root}
Like @func{fold-left} for lists, but visit the nodes of a binary tree
with a level--order forwards iteration.  The argument @var{root} must be
@false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.
@end defun


@defun binary-tree-begin-level-order-forwards @var{root}
@defunx $binary-tree-begin-level-order-forwards @var{root}
Perform the first step in a level--order forwards iteration.  The argument
@var{root} must be @false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.  If the tree is
empty: return @false{}; otherwise return an instance of
@objtype{<binary-node>} representing the first visited node.
@end defun


@defun binary-tree-step-level-order-forwards @var{bnode}
@defunx $binary-tree-step-level-order-forwards @var{bnode}
Advance an level--order forwards iteration by one step starting from
@var{bnode}, which must be an instance of @objtype{<binary-node>}.  If
@var{bnode} is the last in the iteration: return @false{}; otherwise
return an instance of @objtype{<binary-node>} representing the next
visited node.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Backwards iteration


@defun binary-tree-fold-level-order-backwards @var{kons} @var{knil} @var{root}
Like @func{fold-right} for lists, but visit the nodes of a binary tree
with a level--order backwards iteration.  The argument @var{root} must be
@false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.
@end defun


@defun binary-tree-begin-level-order-backwards @var{root}
@defunx $binary-tree-begin-level-order-backwards @var{root}
Perform the first step in a level--order backwards iteration.  The argument
@var{root} must be @false{} to represent an empty tree or an instance of
@objtype{<binary-node>} representing the root of a tree.  If the tree is
empty: return @false{}; otherwise return an instance of
@objtype{<binary-node>} representing the first visited node.
@end defun


@defun binary-tree-step-level-order-backwards @var{bnode}
@defunx $binary-tree-step-level-order-backwards @var{bnode}
Advance an level--order backwards iteration by one step starting from
@var{bnode}, which must be an instance of @objtype{<binary-node>}.  If
@var{bnode} is the last in the iteration: return @false{}; otherwise
return an instance of @objtype{<binary-node>} representing the next
visited node.
@end defun

@c page
@node bst bnodes validating
@subsection Validating binary trees


The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.  The bindings whose
name is prefixed with @code{$} are unsafe operations: they do
@strong{not} validate their arguments before accessing them.


@defun binary-tree-valid? @var{root} @var{key<}
@defunx $binary-tree-valid? @var{root} @var{key<}
Traverse a binary search tree from @var{root} verifying that: all the
left subtrees have sort key less than that of their parents; all the
right subtrees have sort key greater than, or equal to, that of their
parents.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>} representing the root of the
tree.

The argument @var{key<} must be a procedure taking @math{2} arguments
being instances of @objtype{<binary-node>}: it must return true if the
first argument has sort key less than the sort key of the second
argument; otherwise it must return @false{}.
@end defun

@c page
@node bst unodes
@section Unbalanced binary node objects


The @dfn{unbalanced binary search trees} support insertion and removal
of nodes without implementing any balancing algorithm.  The performance
of these trees is low, but they are useful for debugging purposes.

@menu
* bst unodes objects::          Unbalanced binary node data type.
* bst unodes ops::              Operations on unbalanced trees.
@end menu

@c page
@node bst unodes objects
@subsection Unbalanced binary node data type


The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.


@deftp {@rnrs{6} Record Type} <unbalanced-binary-node>
@cindex @var{unode} argument
@cindex Argument @var{unode}
Record type representing a node in a binary tree.  The
@objtype{<unbalanced-binary-node>} type is non--generative and available
for subtyping.  It is derived from @objtype{<binary-node>}.  In this
documentation @objtype{<unbalanced-binary-node>} object arguments to
functions are indicated as @var{unode}.
@end deftp


@defun make-unbalanced-binary-node
@defunx make-unbalanced-binary-node @var{left} @var{right}
Build and return a new instance of @objtype{<unbalanced-binary-node>}.
The optional arguments @var{left} and @var{right} must be @false{} or
instances of @objtype{<unbalanced-binary-node>} representing the left
and right subtrees.  The @code{parent} field of the new instance is set
to @false{}.
@end defun


@defun unbalanced-binary-node? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{<unbalanced-binary-node>}; otherwise return @false{}.
@end defun

@c page
@node bst unodes ops
@subsection Operations on unbalanced binary nodes


The following syntactic bindings are exported by the library
@library{vicare containers binary-search-trees}.  The bindings whose
name is prefixed with @code{$} are unsafe operations: they do
@strong{not} validate their arguments before accessing them.


@defun unbalanced-tree-insert! @var{root} @var{key<} @var{unode}
@defunx $unbalanced-tree-insert! @var{root} @var{key<} @var{unode}
Insert a new node into an unbalanced binary tree.

The argument @var{root} must be @false{} or an instance of
@objtype{<unbalanced-binary-node>} representing the root of the tree.

The argument @var{key<} must be a procedure accepting two arguments of
type @objtype{<binary-node>} and returning: true if the first argument
has sort key less than the second argument; @false{} otherwise.  Example
for the trees of fixnums defined in the introduction (@pxref{bst
intro}):

@lisp
(define (key< one two)
  (fx<? (<fixnum-node>-sort-key one)
        (<fixnum-node>-sort-key two)))
@end lisp

The argument @var{unode} must be an instance of
@objtype{<unbalanced-binary-node>} representing the new node to insert.
This node is meant to have left and right fields set to @false{}.

The return value is the root node after the insertion operation.  If the
argument @var{root} is @false{}: the return value is @var{unode}.  If
the argument @var{root} is a node: the return value is @var{root}
itself.
@end defun


@defun unbalanced-tree-remove! @var{unode} @var{root}
@defunx $unbalanced-tree-remove! @var{unode} @var{root}
Remove a node from an unbalanced binary tree.  @var{unode} must be the
instance of @objtype{<unbalanced-binary-node>} to remove.  @var{root}
must be an instance of @objtype{<unbalanced-binary-node>} representing
the root of the binary tree; it can be that @var{unode} equals
@var{root}.

Return an instance of @objtype{<unbalanced-binary-node>} representing
the new tree root after @var{unode} removal.  If, after the removal, the
tree is left empty: the return value is @false{}.
@end defun


@c Local Variables:
@c mode: texinfo
@c TeX-master: "vicare-libs"
@c End:
