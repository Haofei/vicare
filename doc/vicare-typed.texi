\input texinfo.tex
@c %**start of header
@setfilename vicare-typed.info
@settitle Vicare Scheme's typed language
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set PRJNAME                    Vicare

@set TITLE                      Vicare Scheme's Typed Language

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare Scheme

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare-scheme

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2016


@set TARBALLURL                 @url{https://bitbucket.org/marcomaggi/vicare-scheme/downloads}
@set REPOSITORYURL              @url{http://github.com/marcomaggi/vicare/}
@set EXECUTABLE                 @command{vicare}
@set RAWEXECUTABLE              vicare

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @value{VERSION} of @value{PACKAGE}, an
@rnrs{6} compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit and 64-bit
processors.  @emph{Vicare} is pronounced the etruscan way.  The focus of
this document is over the typed language extension.

The package, including its documentation, is distributed under the terms
of the @gnu{} General Public License (@gpl{}) and can be downloaded
from:

@center @value{TARBALLURL}

@noindent
the home page of the project is at:

@center @url{http://marcomaggi.github.io/vicare.html}

@noindent
development takes place at:

@center @url{http://github.com/marcomaggi/vicare/}

@noindent
and, as a backup, at:

@center @url{https://bitbucket.org/marcomaggi/vicare-scheme/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by Marco Maggi.@*
Copyright @copyright{} 2006-2010 by Abdulaziz Ghuloum.

@quotation
This program is free software: you can redistribute it and/or modify it
under the terms of the @gnu{} General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the @gnu{} General Public License
along with this program.  If not, see
@url{http://www.gnu.org/licenses/}.
@end quotation

Trademarks used herein are the property of their respective owners.
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare-typed: (vicare-typed). @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the typed language.
* annotations::                 Type annotations.
* specifications::              Type specifications.
* descriptors::                 Type descriptors.
* syntaxes::                    Type-exploiting syntaxes.
* built-in::                    Built-in object types.
* methods::                     Methods and virtual methods.
* protlev::                     Protection levels.
* mixins::                      Sharing object-type definition clauses.
* interfaces::                  Interface types.
* labels::                      Sub-typing with labels.
* friends::                     Friend functions.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


@value{PRJNAME}'s expander implements an extension to the language
defined by @rnrs{6} that allows the definition of typed syntactic
bindings.  Type annotations are optional: we are free to specify them or
leave the type of variables unspecified.

@menu
* overview philosophy::         Typed language philosophy.
* overview enabling::           Enabling typed language extensions.
* overview type ids::           Type identifiers.
* overview typed vars::         Typed lexical variables.
@end menu

@c page
@node overview philosophy
@section Typed language philosophy


In this document we refer to the standard Scheme language defined by the
@rnrs{6} specifications as the @dfn{standard language}; we refer to the
typed Scheme language defined by @value{PRJNAME} as the @dfn{typed
language}.

To understand how @value{PRJNAME} represents the types of values, we
must remember that every Scheme expression might return multiple values;
so we can think of an expression evaluation as follows:

@lisp
(call-with-values
     (lambda () @meta{epxr})
  (lambda @meta{formals} @meta{body}))
@end lisp

@noindent
the return values of @meta{expr} are bound to the @meta{formals} and
used in the @meta{body}.  For example, in the code:

@lisp
(call-with-values
     (lambda () (values 1 2 3))
  (lambda (a b c) @meta{body}))
@end lisp

@noindent
while the expansion of @meta{body} takes place: a typed language would
annotate the syntactic bindings @code{a}, @code{b} and @code{c} with the
information that the values are fixnums.

The tuple of type annotations associated to the @meta{formals} is called
@dfn{type signature}; a type signature represents informations about
both the number of values and their type.  We need a type signature to
represent the types of values returned by an expression.  We need a type
signature to represent the types of the arguments accepted in a function
application.

Given the @func{call-with-values} model of thinking to expressions
evaluations: the whole purpose of a typed language is to verify, at
expand--time, that the type signature of an expression matches the type
signature of the arguments of a function.

The standard language already mandates that the operands in a function
application must be validated at run--time; this means the type
signature of the operands is matched, at run--time, with the type
signature of the arguments.  The typed language extends this feature to
make it possible at expand--time.

Type annotations are not mandatory in the typed language, so some
operands are validated and others are not.

To understand the role of @value{PRJNAME}'s typed language extensions,
we have to consider that:

@itemize
@item
Standard Scheme is dynamically typed: language implementations might
perform application signatures validation at run--time every time a
function is called, considering that the return values of a function
application are discarded or become the arguments of another function
application.  For example the function @func{flsin} can be implemented
as:

@example
#!r6rs
(import (except (rnrs (6))
                flsin)
  (vicare system $flonums))

(define (flsin x)
  (assert (flonum? x))
  ($flsin x))
@end example

@item
It is possible to build a standard Scheme language implementation that
performs compile--time type inference; with such implementation:
occasionally the compiler can determine the type of operands and return
values and collapse multiple validations into a single one.  For
example:

@example
#!r6rs
(import (rnrs (6)))

(define (flsomething x)
  (values (flsin x) (flcos x) (fltan x)))
@end example

@noindent
can be transformed into (pseudo--code):

@example
#!r6rs
(import (rnrs (6))
  (vicare system $flonums))

(define (flsomething x)
  (assert (flonum? x))
  (values ($flsin x) ($flcos x) ($fltan x)))
@end example

@noindent
or automatically defined safe and unsafe variants of the same function:

@example
#!r6rs
(import (rnrs (6))
  (vicare system $flonums))

(define (flsomething x)
  (assert (flonum? x))
  ($flsomething x))

(define ($flsomething x)
  (values ($flsin x) ($flcos x) ($fltan x)))
@end example

@noindent
so that the unsafe @func{$flsomething} can be used later in place of the
safe @func{flsomething} if we know that the argument is a flonum.

@item
The evaluation of a Scheme language program or library is defined to
have two steps: expansion; compilation--and--evaluation or
interpretation.  Standard Scheme is a ``high--level language'' which is
transformed into a ``core language'' by the process of expansion; the
expander allows macros to implement customised high--level
transformations.  The core language expressions are handed to the
compiler or the interpreter.

@item
Type inference does not blend well with standard Scheme macro expansion;
it is, in general, impossible to infer the types of a macro use before
fully expanding it, or, in special cases, at least partially expanding
it.  True type inference can be performed on the core language that is
the result of fully expanding the standard language.  This means we
cannot integrate the powerful features of the expander in the code
resulting from transformations made possible by type inference.

@item
@value{PRJNAME} is a language dialect whose purpose is to be a standard
Scheme language with extensions; it allows mixed use of standard
language syntax and extended language syntax.  The language extensions
are mostly implemented in the expander, to allow user code to customise
the generation of core language.

@item
By explicitly specifying the types of lexical bindings:
@value{PRJNAME}'s dialect allows some of the expand--time validations
and transformations that would be possible in a language with full type
inference.
@end itemize

Since there is no type inference: the code writer is invited to
explicitly add type annotations to the syntaxes that establish syntactic
bindings.

@c page
@node overview enabling
@section Enabling typed language extensions


Typed language extensions are @strong{off} by default.  To enable the
extensions we have to use the @code{typed-language} option as follows:

@itemize
@item
For libraries:

@lisp
(library (demo)
  (options typed-language)
  (export)
  (import (vicare))
  ---)
@end lisp

@noindent
@vicareref{iklib libraries options, typed-language}.

@item
For programs:

@lisp
(program (demo)
  (options typed-language)
  (import (vicare))
  ---)
@end lisp

@noindent
@vicareref{iklib programs options, typed-language}.
@end itemize

@noindent
we usually want to import the library @library{vicare} to use the
extended syntaxes that recognise type definitions and annotations.

We can use the function @func{typed-language-enabled?} to enable the
typed language at the @repl{} (@vicarepxref{iklib expander language,
typed-language-enabled?}).

@c ------------------------------------------------------------------------

@subsubheading Strict type checking

An additional option is available for both programs and libraries:
@code{strict-type-checking}.  It enables expand--time warnings about
non--exact matching between values and the typed variables they are
assigned to.

Under the typed language, the types of variables and values are matched
as with the following forms:

@lisp
(import (prefix (vicare expander) xp::))

(xp::type-annotation-matching <number> <fixnum>)
@result{} exact-match

(xp::type-annotation-matching <fixnum> <number>)
@result{} possible-match
@end lisp

@noindent
that is:

@itemize
@item
An operand with type @class{fixnum} exactly matches an expected argument
of type @class{number}.  The operand validation is successful at
expand--time.

@item
An operand with type @class{number} is compatible with an expected
argument of type @class{fixnum}.  The operand validation is successful
at expand--time, but further validation at run--time is required.
@end itemize

When the option @code{strict-type-checking} is used: a warning is raised
when a possible match is detected.  For example, the following
@syntax{let} syntax use will raise a warning because the right--hand
side expression returns a @class{integer}, while the syntactic binding
for @code{O} expects a @class{fixnum}:

@lisp
(let ((@{O <fixnum>@} (cast-signature (<integer>) (read))))
  ---)
@end lisp

When examining the raised warnings we must remember that some binding
syntaxes expand into uses of other binding syntaxes; for some built--in
syntaxes of this type:

@itemize
@item
Multiple warnings may be raised for the same non--exact type matching.

@item
A warning may be raised by the target syntax use rather than the source
syntax use.
@end itemize

@c page
@node overview type ids
@section Type identifiers


A @dfn{type identifier} is a bound syntactic identifier whose syntactic
binding's descriptor contains informations about the type's properties.
Examples of type identifiers are:

@itemize
@item
Struct--type name identifiers defined by @func{define-struct}; they are
automatically made type identifiers by @value{PRJNAME}.

@item
Record--type name identifiers defined by @func{define-record-type}; they
are automatically made type identifiers by @value{PRJNAME}.  Condition
object types (like @condition{i/o}) are special cases of these.

@item
The library @library{vicare} exports a set type identifiers (whose
implementation is integrated in @value{PRJNAME}'s expander) representing
the types of built--in objects.  Some of them are: @class{fixnum},
@class{string}, @class{vector}, @class{textual-input-port}.
@ref{built-in, Built-in object types}.
@end itemize

Type identifiers are organised in a tree hierarchy, with subtypes
inheriting properties of supertypes; by convention, @class{top} is the
parent of all the type annotations, the root of the tree; @class{top}
has no parent.

Many predefined type identifiers have names enclosed in ``angular
parentheses'' @samp{< >}, but this is just a convention.  Any valid
Scheme symbol can be used as name for a type identifier.

@c page
@node overview typed vars
@section Typed lexical variables


A @dfn{typed lexical variable}, shortly @dfn{typed variable}, is a bound
syntactic identifier whose syntactic binding's descriptor contains both
informations about a lexical variable and its type annotation.  Typed
variables are created by the built--in binding syntaxes @func{lambda},
@func{define}, @func{let}, @func{letrec}, @func{let-values}, et cetera.

An example of typed binding creation follows:

@example
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare)
  (define @{O <fixnum>@}
    123))
@end example

@noindent
the syntactic identifier @code{O} represents a typed variable with type
annotation @class{fixnum}.

At the time the typed variable's syntactic binding is established: the
type annotation must hold only already bound type identifiers.  So the
following program (where @samp{---} represents an unspecified form) is
correct because @class{duo} is bound before @var{O}:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))
  (define-record-type <duo>
    (fields one two))
  (define @{O <duo>@}
    ---))
@end lisp

@noindent
the follow program is @strong{not} correct:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))
  (define @{O <duo>@}
    ---)
  (define-record-type <duo>
    (fields one two)))
@end lisp

@noindent
and will cause an expand--time syntax violation.

@c page
@node annotations
@chapter Type annotations


Type annotations are special forms that make use of the @func{brace}
syntax to associate a type specification to a lexical variable
(@vicarepxref{iklib syntaxes misc, brace}).  It works as follows:

@lisp
(define (brace O @aclass{fixnum})
  123)
@end lisp

@noindent
in which the variable @samp{O} is defined as having type @class{fixnum}.

@quotation
@strong{NOTE} To use the extensions in a friendly manner we need to put
the source code reader in @samp{#!vicare} mode, this way @func{brace}
can be inserted using actual brace characters:

@lisp
#!vicare
(define @braces{O @aclass{fixnum}}
  123)
@end lisp
@end quotation

@menu
* annotations inserting::       Inserting type annotations.
* annotations syntaxes::        The syntax of type annotations.
* annotations relations::       Relations between type annotations.
* annotations signatures::      Relations between type signatures.
@end menu

@c page
@node annotations inserting
@section Inserting type annotations


Everywhere the name of a syntactic binding appears in binding position:
we can add a type annotation by wrapping the syntactic identifier in
braces and appending a type syntax.  With @syntax{let}--like syntaxes we
can do:

@lisp
(let ((@{a @aclass{fixnum}@} 1)
      (@{b @aclass{string}@} "ciao")
      (@{c @aclass{symbol}@} 'hello))
  (list a b c))
@end lisp

@noindent
with @syntax{lambda} and @syntax{case-lambda} syntaxes we can do:

@lisp
(lambda (@{a @aclass{fixnum}@} @{b @aclass{string}@})
  (list a b))

(case-lambda
  ((@{a @aclass{fixnum}@} @{b @aclass{string}@})
   (list a b))
  ((@{a @aclass{fixnum}@} @{b @aclass{string}@} @{c @aclass{symbol}@})
   (list a b c)))
@end lisp

@noindent
with @syntax{define} and @syntax{case-define} syntaxes we can do:

@lisp
(define (fun1 @{a @aclass{fixnum}@} @{b @aclass{string}@})
  (list a b))

(case-define fun2
  ((@{a @aclass{fixnum}@} @{b @aclass{string}@})
   (list a b))
  ((@{a @aclass{fixnum}@} @{b @aclass{string}@} @{c @aclass{symbol}@})
   (list a b c)))
@end lisp

When using the syntaxes @syntax{lambda}, @syntax{case-lambda},
@syntax{define}, @syntax{case-define}, @syntax{receive},
@syntax{let-values} and @syntax{let*-values} we can specify a ``rest''
argument that is bound to a list of the rest of the operands; this
syntactic binding can be annotated only with a type that is a sub--type
of @class{list}, and so represents a list.  For example:

@lisp
((lambda (@{a @aclass{fixnum}@} @{b @aclass{string}@} . @{rest (list-of @aclass{symbol})@})
   (vector a b rest))
 1 "ciao" 'x 'y 'z)
@result{} #(1 "ciao" (x y z))

((lambda @{args @aclass{list}@} args)
 1 2 3)
@result{} (1 2 3)

(receive (@{a @aclass{fixnum}@} @{b @aclass{string}@} . @{rest @aclass{list}@})
    (values 1 "ciao" 'x 'y 'z)
  rest)
@result{} (x y z)
@end lisp

@c page
@node annotations syntaxes
@section The syntax of type annotations


Type annotations are either standalone type identifiers like
@class{fixnum}, @class{string}, @condition{message} or compound type
syntaxes like the following:

@lisp
(pair      <fixnum> <string>)
(list      <fixnum> <string> <symbol>)
(vector    <fixnum> <string> <symbol>)
(pair-of   <fixnum>)
(list-of   <fixnum>)
(nelist-of <fixnum>)
(vector-of <fixnum>)
(nevector-of <fixnum>)
(hashtable <symbol> <string>)
(alist     <symbol> <string>)
(enumeration @metao{symbol} @meta{symbol} ...)
(condition &who &message &irritants)
(or    <false> <symbol> <string>)
(and   <exact> <positive>)
(not   <exact>)
(lambda (<fixnum>) => (<string>))
(case-lambda
  ((<fixnum>) => (<string>))
  ((<flonum>) => (<string>)))
(type-of @meta{expr})
@end lisp

@noindent
and others; compound type annotations can be nested at will:

@lisp
(or (list-of   <fixnum>)
    (vector-of <fixnum>))
@end lisp

For every type annotation: a parent type is documented, but the
super--type/sub--type relation is ``flexible''.  For example,
@syntax{list-of} and @syntax{list} annotations are both sub--types of
@class{list}; but it also stands that:

@lisp
(type-annotation-super-and-sub? (list-of <fixnum>)
                                (list <fixnum> <fixnum>))
@result{} #t

(type-annotation-super-and-sub? (list-of <fixnum>)
                                (list <fixnum> <string>))
@result{} #f
@end lisp


The following syntactic bindings are exported by @library{vicare}.


@deftp {Type Annotation} pair @meta{car-type} @meta{car-type}
@deftpx {Parent Type} @aclass{pair}
Describe a pair having car of type @meta{car-type} and cdr of type
@meta{car-type}.  Both @meta{car-type} and @meta{cdr-type} are nested
type annotations.

@lisp
(is-a? '(1 . 2.3) (pair <fixnum> <flonum>))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} list @metao{item-type} @meta{item-type} @dots{}
@deftpx {Parent Type} @aclass{list}
Describe a proper list holding a fixed number of items of the specified
types (in the given order).  Every @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '(1 2.3) (list <fixnum> <flonum>))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} vector @metao{item-type} @meta{item-type} @dots{}
@deftpx {Parent Type} @aclass{vector}
Describe a vector holding a fixed number of items of the specified types
(in the given order).  Every @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '#(1 2.3) (vector <fixnum> <flonum>))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} pair-of @meta{item-type}
@deftpx {Parent Type} @aclass{pair}
Describe a pair having both the car and cdr of type @meta{item-type}.
The syntax @meta{item-type} is a nested type annotation.

@lisp
(is-a? '(1 . 2) (pair-of <fixnum>))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} list-of @meta{item-type}
@deftpx {Parent Type} @aclass{list}
Describe a proper list holding any number of items (including zero) all
of the specified type.  The syntax @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '(1 2) (list-of <fixnum>))       @result{} #t
(is-a? '()    (list-of <fixnum>))       @result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} nelist-of @meta{item-type}
@deftpx {Parent Type} @aclass{pair}
Describe a proper non--empty list holding any number of items all of the
specified type.  The syntax @meta{item-type} is a nested type
annotation.  This type annotation is expanded to:

@lisp
(pair @meta{item-type} (list-of @meta{item-type}))
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} vector-of @meta{item-type}
@deftpx {Parent Type} @aclass{vector}
Describe a vector holding any number of items (including zero) all of
the specified type.  The syntax @meta{item-type} is a nested type
annotation.

@lisp
(is-a? '#(1 2) (vector-of <fixnum>))    @result{} #t
(is-a? '#()    (vector-of <fixnum>))    @result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} nevector-of @meta{item-type}
@deftpx {Parent Type} @aclass{nevector}
Describe a vector holding one or more items all of the specified type.
The syntax @meta{item-type} is a nested type annotation.

@lisp
(is-a? '#(1 2) (nevector-of <fixnum>))  @result{} #t
(is-a? '#()    (nevector-of <fixnum>))  @result{} #f
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} hashtable @meta{key-type} @meta{value-type}
@deftpx {Parent Type} @aclass{hashtable}
Describe a hashtable having keys of type @meta{key-type} and values of
type @meta{value-type}.  Both @meta{key-type} and @meta{value-type} are
nested type annotations.
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} enumeration @metao{symbol} @meta{symbol} @dots{}
@deftpx {Parent Type} @aclass{symbol}
Describe an enumeration of symbols; it is used to match a symbol in a
specified enumeration set.

@lisp
(is-a? 'ciao (enumeration hello ciao salut ohayo))
@result{} #t

(is-a? 'blue (enumeration hello ciao salut ohayo))
@result{} #f
@end lisp

As special case, if we define an alias for an @syntax{enumeration} type
annotation: we can use such identifier to validate symbols.  Example:

@lisp
(define-type greetings
  (enumeration hello ciao salut ohayo))

(is-a? 'ciao greetings) @result{} #t
(greetings ciao)        @result{} ciao
(greetings blue)        @error{} symbol not in enumeration
@end lisp

The enumeration identifier is indeed used in the implementation of the
@syntax{define-enumeration} built--in syntax; @vicareref{stdlib enum,
define-enumeration}.

@lisp
(define-enumeration greetings
  (hello ciao salut ohayo)
  make-greetings)

(is-a? 'ciao greetings) @result{} #t
(greetings ciao)        @result{} ciao
(greetings blue)        @error{} symbol not in enumeration
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} alist @meta{key-type} @meta{value-type}
@deftpx {Parent Type} @aclass{list}
Describe an association list having keys of type @meta{key-type} and
values of type @meta{value-type}.  Both @meta{key-type} and
@meta{value-type} are nested type annotations.
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} condition @metao{cond-type} @meta{cond-type} @dots{}
@deftpx {Parent Type} @aclass{compound-condition}
Describe a compound condition object holding at least one instance of
the specified types (the order does not matter).  Every @meta{cond-type}
is a nested type annotation that must be one among: @class{condition},
@class{compound-condition}, a sub--type of @condition{condition}.

@lisp
(is-a? (condition (make-who-condition 'I)
                  (make-message-condition "hello"))
       (condition &who &message))
@result{} #t

(is-a? (condition (make-who-condition 'I)
                  (make-message-condition "hello"))
       (condition &message &who))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} lambda @meta{args-signature} => @meta{rv-signature}
@deftpx {Parent Type} @aclass{procedure}
Describe a sub--type of @class{procedure} having a single clause, like
procedures defined by @syntax{lambda}.  @syntax{=>} is the syntactic
binding exported by @rsixlibrary{base}.

The argument @meta{args-signature} must be a syntax object representing
the type signature of the procedure's arguments.  The argument
@meta{rv-signature} must be a syntax object representing the type
signature of the procedure's return values.
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} case-lambda @metao{clause} @meta{clause} @dots{}
@deftpx {Parent Type} @aclass{procedure}
Describe a sub--type of @class{procedure} having multiple clauses, like
procedures defined by @syntax{case-lambda}.  @syntax{=>} is the
syntactic binding exported by @rsixlibrary{base}.

Each @meta{clause} argument must have the format:

@example
(@meta{args-signature} => @meta{rv-signature})
@end example

@noindent
where: @meta{args-signature} must be a syntax object representing the
type signature of the clause's arguments; @meta{rv-signature} must be a
syntax object representing the type signature of the clause's return
values.
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} or @metao{type} @meta{type} @dots{}
@deftpx {Parent Type} @aclass{top}
Describe the union between the specified types.  Every @meta{type} is a
nested type annotation.  A value matches a union of types if its type
matches at least one of the union's types.

@lisp
(is-a? 1      (or <fixnum> <string>))   @result{} #t
(is-a? "ciao" (or <fixnum> <string>))   @result{} #t
(is-a? 1.23   (or <fixnum> <string>))   @result{} #f
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} and @metao{type} @meta{type} @dots{}
@deftpx {Parent Type} @aclass{top}
Describe the intersection between the specified types.  Every
@meta{type} is a nested type annotation.  A value matches an
intersection of types if its type matches all the intersection's types.

@lisp
(is-a? 1   (and <fixnum> <positive>))   @result{} #t
(is-a? 1.0 (and <exact>  <positive>))   @result{} #f
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} not @meta{type}
@deftpx {Parent Type} @aclass{top}
Describe the complement of the type.  The argument @meta{type} is a
nested type annotation.  A value of type @meta{val-type} matches the
complement of @meta{type} if @meta{val-type} is neither @meta{type} nor
a sub--type of @meta{type}.

@lisp
(is-a? 1   (not <string>))      @result{} #t
(is-a? 1.0 (not <fixnum>))      @result{} #f

;;If something is not a "<number>", for sure it is
;;not a "<fixnum>".
(type-annotation-super-and-sub? (not <fixnum>) (not <number>))
@result{} #t
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} parent-of @meta{type}
@deftpx {Parent Type} @aclass{top}
Describe the parent of the type; an exception is raised if the type has
no parent.  The argument @meta{type} is a nested type annotation.

@lisp
(type-annotation=? <struct> (parent-of <record>))
@result{} #t

(type-annotation=? <fixnum> (parent-of <positive-fixnum>))
@result{} #t

(type-annotation=? <positive-fixnum> (parent-of <fixnum>))
@result{} #f
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} ancestor-of @meta{type}
@deftpx {Parent Type} @aclass{top}
Describe the ancestors of the type; if the type has no parent: the list
of ancestors is empty.  The argument @meta{type} is a nested type
annotation and it is not included in its list of ancestors.

This type annotation can be used to match @strong{exactly} a type
annotation with one of the ancestors of @meta{type}:

@lisp
(type-annotation-matching (ancestor-of &condition)
                          &condition)
@result{} no-match

(type-annotation-matching (ancestor-of &condition)
                          <condition>)
@result{} exact-match

(type-annotation-matching (ancestor-of &condition)
                          <record>)
@result{} exact-match

(type-annotation-matching (ancestor-of &condition)
                          <struct>)
@result{} exact-match

(type-annotation-matching (ancestor-of &condition)
                          <top>)
@result{} exact-match

(type-annotation-matching <condition>
                          (ancestor-of &condition))
@result{} exact-match
@end lisp

When used along with @syntax{not}, it is used to avoid matching exactly
a type annotation with one of the ancestors of @meta{type}:

@lisp
(type-annotation-matching (not (ancestor-of &condition))
                          <condition>)
@result{} no-match
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} type-predicate @meta{type}
A short--cut to specify:

@lisp
(lambda (@meta{type}) => (<boolean>))
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} equality-predicate @meta{type}
A short--cut to specify:

@lisp
(lambda (@meta{type} @meta{type}) => (<boolean>))
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} comparison-procedure @meta{type}
A short--cut to specify:

@lisp
(lambda (@meta{type} @meta{type}) => (<fixnum>))
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} hash-function @meta{type}
A short--cut to specify:

@lisp
(lambda (@meta{type}) => (<non-negative-fixnum>))
@end lisp
@end deftp

@c ------------------------------------------------------------

@deftp {Type Annotation} type-of @meta{expr}
Describe the type of @meta{expr}, which must be a Scheme expression.
The type signature of @meta{expr} must hold a single value.  The
expression is expanded and not evaluated; the side effects of the
expansion are performed, so this type annotation must be used with care.

@lisp
(type-annotation-syntax (type-of 123))
@result{} <positive-fixnum>

(type-annotation-syntax (type-of (void)))
@result{} <void>

(let ((fun (lambda () 123)))
  (type-annotation-syntax (type-of (fun))))
@result{} <positive-fixnum>

(type-annotation-syntax (or (type-of 1)
                            (type-of "ciao")
                            (type-of 'hey)))
@result{} (or <positive-fixnum> <string> (enumeration hey))
@end lisp

The expression is not allowed not to return:

@lisp
(type-annotation-syntax (type-of (error #f "error")))
@error{} &assertion
@end lisp

The expression is not allowed to return zero, two or more values:

@lisp
(type-annotation-syntax (type-of (values)))
@error{} &assertion

(type-annotation-syntax (type-of (values 1 2)))
@error{} &assertion

(type-annotation-syntax (type-of (values 1 2 3)))
@error{} &assertion
@end lisp

The expression is not allowed to return unspecified values:

@lisp
(letrec ((fun (lambda (@{_ . <list>@}) (fun))))
  (type-annotation-syntax (type-of (fun))))
@error{} &assertion
@end lisp

The expression is expanded in the current lexical environment for phase
zero, but with empty lexical environment for the other phases:

@lisp
(let-syntax ((outer (lambda (stx) 123)))
  (type-annotation-syntax (outer)))
@error{} identifier OUTER out of context

(let-syntax  ((outer (lambda (stx) 123)))
  (type-annotation-syntax
     (type-of (let-syntax ((inner (lambda (stx) (outer))))
                (inner)))))
@error{} identifier OUTER out of context
@end lisp
@end deftp

@c page
@node annotations relations
@section Relations between type annotations


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deffn Syntax type-annotation-syntax @meta{type}
Expand to a syntax object representing the type annotation of
@meta{type}.  If @meta{type} is a compound annotation (@syntax{or},
@syntax{and}, @syntax{condition}, @dots{}) some simplification may have
been applied to the input to produce the output.

@lisp
(type-annotation-syntax (or <fixnum> <bignum>))
@result{} (or <fixnum> <bignum>)

(type-annotation-syntax (or (enumeration hello salut)
                            (enumeration ciao)
                            (enumeration ohayo ciao)))
@result{} (enumeration hello salut ciao ohayo)
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-annotation=? @metai{type} @metaii{type}
Expand to a boolean constant: @true{} if @metai{type} is equal to
@metaii{type}; otherwise @false{}.

@lisp
(type-annotation=? <top>    <top>)              @result{} #t
(type-annotation=? <fixnum> <fixnum>)           @result{} #t
(type-annotation=? <fixnum> <positive-fixnum>)  @result{} #f

(internal-body
  (define-type <my-fixnum> <fixnum>)
  (type-annotation=? <fixnum> <my-fixnum>))     @result{} #t

(type-annotation=? (lambda (<fixnum>) => (<fixnum>))
                   (lambda (<fixnum>) => (<fixnum>)))
@result{} #t
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-annotation-super-and-sub? @metai{type} @metaii{type}
Expand to a boolean constant: @true{} if @metai{type} is a super--type
of @metaii{type}; otherwise @false{}.

@quotation
@strong{NOTE} The type @class{top} is conventionally the super--type of
all the types, with the exception of @class{void}.  The type
@class{bottom} is conventionally the sub--type of all the types.
@end quotation

@lisp
(type-annotation-super-and-sub? <number> <fixnum>)  @result{} #t
(type-annotation-super-and-sub? <number> <string>)  @result{} #f
(type-annotation-super-and-sub? <top> <number>)     @result{} #t
(type-annotation-super-and-sub? <number> <top>)     @result{} #f

(expansion-of
  (type-annotation-super-and-sub? <number> <fixnum>))
@result{} (quote #t)

(expansion-of
  (type-annotation-super-and-sub? <number> <string>))
@result{} (quote #f)

(define-record-type alpha)

(define-record-type beta
  (parent alpha))

(define-record-type gamma
  (parent beta))

(type-annotation-super-and-sub? alpha beta)        @result{} #t
(type-annotation-super-and-sub? beta alpha)        @result{} #f

(type-annotation-super-and-sub? alpha gamma)       @result{} #t
(type-annotation-super-and-sub? gamma alpha)       @result{} #f

(type-annotation-super-and-sub? beta gamma)        @result{} #t
(type-annotation-super-and-sub? gamma beta)        @result{} #f
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-annotation-matching @metai{type} @metaii{type}
Match the two type annotations as if: @metai{type} is the type of an
argument requested by a closure object; @metaii{type} is the type of the
operand given to a closure object application.

Expand to a quoted symbol:

@table @code
@item exact-match
If there is an exact match between the argument's and operand's
annotation.

@item possible-match
If there is a possible match between the argument's and operand's
annotation; the operand must be further validated at run--time.

@item no-match
If there is no match between the argument's and operand's annotation.
@end table
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-annotation-common-ancestor @metai{type} @metaii{type}
Expand to a syntax object representing the type annotation that is the
common ancestor of @metai{type} and @metaii{type}.

@lisp
(type-annotation-common-ancestor <top> <top>)
@result{} #'<top>

(type-annotation-common-ancestor <top> <fixnum>)
@result{} #'<top>

(type-annotation-common-ancestor <fixnum> <top>)
@result{} #'<top>

(type-annotation-common-ancestor <fixnum> <flonum>)
@result{} #'<real>
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-annotation-ancestors @meta{type}
Expand to a (possibly empty) list of type annotations representing the
ancestors of @meta{type}.  @meta{type} is @strong{not} included.

@lisp
(type-annotation-ancestors <top>)       @result{} ()
(type-annotation-ancestors <void>)      @result{} ()

(type-annotation-ancestors <condition>)
@result{} (<record> <struct> <top>)

(type-annotation-ancestors <positive-fixnum>)
@result{} (<fixnum>
    <exact-integer> <integer> <rational> <rational-valued>
    <real> <real-valued> <complex> <number> <top>)
@end lisp
@end deffn

@c page
@node annotations signatures
@section Relations between type signatures


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deffn Syntax type-signature-super-and-sub? @metai{signature} @metaii{signature}
Expand to a boolean constant: @true{} if @metai{signature} is a
super--signature of @metaii{signature}; otherwise @false{}.  The
arguments @meta{signature} must be proper or improper lists of type
annotations.

@lisp
(type-signature-super-and-sub? (<number>) (<fixnum>))  @result{} #t
(type-signature-super-and-sub? (<number>) (<string>))  @result{} #f

(expansion-of
  (type-signature-super-and-sub? (<number>) (<fixnum>))
@result{} (quote #t)

(expansion-of
  (type-signature-super-and-sub? (<number>) (<string>))
@result{} (quote #f)

(type-signature-super-and-sub? (<top>) (<number>))   @result{} #t
(type-signature-super-and-sub? (<number>) (<top>))   @result{} #f

(type-signature-super-and-sub? (<number> <number>)
                               (<fixnum> <fixnum>))
@result{} #t
(type-signature-super-and-sub? (<fixnum> <fixnum>)
                               (<number> <number>))
@result{} #f

(type-signature-super-and-sub? (<number> <number> . <list>)
                               (<fixnum> <real>   . <list>))
@result{} #t
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-signature-matching @meta{args-signature} @meta{rands-signature}
Match the two signatures as if: @meta{args-signature} is the type
signature of the arguments requested by a closure object;
@meta{rands-signature} is the type signature of the operands given to a
closure object application.

Expand to a quoted symbol:

@table @code
@item exact-match
If there is an exact match between the arguments' and operands'
signatures.

@item possible-match
If there is a possible match between the arguments' and operands'
signatures; the operands must be further validated at run--time.

@item no-match
If there is no match between the arguments' and operands' signatures.
@end table

@lisp
(type-signature-matching (<top>) (<void>))
@result{} no-match

(type-signature-matching (<void>) (<top>))
@result{} no-match

(type-signature-matching (<top>) (<fixnum>))
@result{} exact-match

(type-signature-matching (<fixnum>) (<positive-fixnum>))
@result{} exact-match

(type-signature-matching (<fixnum>) (<top>))
@result{} possible-match
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-signature-common-ancestor @metai{signature} @metaii{signature}
Expand to a syntax object representing the type signature that is the
common ancestor of @metai{signature} and @metaii{signature}.

@lisp
(type-signature-common-ancestor (<fixnum> <fixnum>)
                                (<flonum> <bignum>))
@result{} #'(<real> <exact-integer>)

(type-signature-common-ancestor (<fixnum> <fixnum> <string>)
                                (<flonum> <bignum>)
@result{} #'(<real> <exact-integer> . <list>)

(type-signature-common-ancestor (<fixnum> <fixnum>)
                                (<flonum> <bignum> <string>)
@result{} #'(<real> <exact-integer> . <list>)
@end lisp
@end deffn

@c ------------------------------------------------------------------------

@deffn Syntax type-signature-union @meta{type-signature} @dots{}
Compute the union between the given type signatures and expand to a
quoted symbolic expression representing the result.  Each
@meta{type-signature} argument must be a symbolic expression
representing a type signature.

@lisp
(type-signature-union)
@result{} <list>

(type-signature-union (<fixnum>) (<exact-integer>))
@result{} (<exact-integer>)

;;If a component is "<void>" the whole union between type
;;annotations becomes "<void>".
(type-signature-union (<fixnum>) (<void>))
@result{} (<void>)

;;If there are both "<true>" and "<false>": they are
;;replaced with a single "<boolean>".
(type-signature-union (<true>) (<false>))
@result{} (<boolean>)

(type-signature-union (<fixnum> <string> <vector>)
                      (<fixnum> <string> <vector>))
@result{} (<fixnum> <string> <vector>)

(type-signature-union (<fixnum> <string> <vector>)
                      (<positive-fixnum> <string> <vector>))
@result{} (<fixnum> <string> <vector>)
@end lisp
@end deffn

@c page
@node specifications
@chapter Type specifications


Type specifications are expand--time objects that describe the
characteristics of object--types.  Type specifications are part of the
lexical environment and are contained in syntactic binding's
descriptors.

Every type annotation has an internal representation as type
specification.  Usually we do not have to deal with type specifications;
so most of the syntactic bindings are exported by the library
@library{vicare expander}.  For details @vicareref{expander specs,
Object-type specifications}.

@c page
@node descriptors
@chapter Type descriptors


@cindex @library{vicare system type-descriptors}, library
@cindex Library @library{vicare system type-descriptors}


Type descriptors are run--time objects that ``describe'' the
characteristics of object--types.  For example @rnrs{6} record--type
descriptors, @rnrs{6} record--constructor descriptors, @value{PRJNAME}'s
struct descriptors are all special cases of type descriptors.

Every expand--time type annotation has a corresponding run--time type
descriptor.  Usually we do not have to deal with type descriptors; so
most of the syntactic bindings are exported by the library
@library{vicare system type-descriptors}, while the public @api{} is
exported by @library{vicare}.

Whenever we need a type descriptor, we must use the syntax
@syntax{type-descriptor} or the function @func{type-descriptor-of}; we
should never call directly the constructors of the type descriptor
types.

@menu
* descriptors retrieving::      Retrieving type descriptors.
* descriptors core::            Core object-type descriptors.
* descriptors compound::        Compound object-type descriptors.
* descriptors other::           Other object-type descriptors.
* descriptors signatures::      Type descriptor signatures.
* descriptors relations::       Relations between type descriptors.
@end menu

@c page
@node descriptors retrieving
@section Retrieving type descriptors


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-descriptor @meta{type-annotation}
Expand to an expression which, compiled and evaluated, results in the
type descriptor of the specified type annotation.

@lisp
(type-descriptor @aclass{fixnum})
@expansion{} @actdname{fixnum}

(type-descriptor (list @aclass{fixnum} @aclass{flonum}))
@expansion{} (make-list-type-descr (list @actdname{fixnum} @actdname{flonum}))
@end lisp

Internally, first an expand--time type specification is built; then the
type descriptor is built from the specification.
@end deffn


@defun type-descriptor-of @var{obj}
Return the type descriptor of @var{obj}.

@lisp
(type-descriptor-of +1)         @result{} @actdname{positive-fixnum}
(type-descriptor-of "ciao")     @result{} @actdname{nestring}
@end lisp
@end defun

@c page
@node descriptors core
@section Core object--type descriptors


Core object--type descriptors gather the run--time characteristics of
object--types like fixnums and strings; for every core object--type
there is an already defined type descriptor, bound to a syntactic
binding exported by the library @library{vicare system
type-descriptors}.

Such syntactic bindings have name derived from the type name by
appending @samp{-ctd} (where @samp{ctd} stands for Core Type
Descriptor).  So the type name @class{fixnum} has the associated type
descriptor @ctdname{fixnum}, the type name @class{string} has the
associated type descriptor @ctdname{string}, et cetera.

Some usage examples:

@lisp
(import (only (vicare system type-descriptors)
              @actdname{string}))

(type-descriptor @aclass{string})         @result{} @actdname{string}
(.name @actdname{string})               @result{} @aclass{string}
(.parent @actdname{string})             @result{} @actdname{top}

(.uids-list @actdname{string})
@result{} (vicare:core-type:@aclass{string} vicare:core-type:@aclass{top})

(let* ((retriever (.method-retriever <string>-ctd))
       (strlen    (retriever 'length)))
  (strlen "ciao"))
@result{} 4
@end lisp

The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{core-type-descriptor}
The type name of objects describing core object--types.  It has the
following immutable fields:

@table @code
@item name
A symbol representing the name of this type.  For example:
@samp{@aclass{string}}.

@item parent
If this type has a parent: an instance of @class{core-type-descriptor}
representing the parent of this type; otherwise @false{}.

@item type-predicate
@false{} or a function implementing the type predicate.

@item equality-predicate
@false{} or a function implementing the equality predicate.

@item comparison-procedure
@false{} or a function implementing the comparison procedure.

@item hash-function
@false{} or a function implementing the hash function.

@item uids-list
A list of symbols representing the hierarchy of unique identifiers
(@uid{}s) for this type.  The first item in the list is the @uid{} of
this type, then the parent's @uid{}, then the grandparent's @uid{}, et
cetera.

@item method-retriever
If this type has methods: a procedure to be applied to the method name
(a symbol) to retrieve the method implementation function; otherwise
@false{}.
@end table
@end deftp


@defun core-type-descriptor? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{core-type-descriptor}; otherwise return @false{}.
@end defun


@defun core-type-descriptor.name @var{ctd}
@defunx core-type-descriptor.parent @var{ctd}
@defunx core-type-descriptor.uids-list @var{ctd}
@defunx core-type-descriptor.type-predicate @var{ctd}
@defunx core-type-descriptor.equality-predicate @var{ctd}
@defunx core-type-descriptor.comparison-procedure @var{ctd}
@defunx core-type-descriptor.hash-function @var{ctd}
@defunx core-type-descriptor.method-retriever @var{ctd}
Accessors for the fields of @class{core-type-descriptor}.
@end defun

@defun core-type-descriptor.uid @var{ctd}
Return the @uid{} of the core--type descriptor @var{ctd}.
@end defun

@c page
@node descriptors compound
@section Compound object-type descriptors


@menu
* descriptors compound pair::      Pair type descriptors.
* descriptors compound pair-of::   Pair-of type descriptors.
* descriptors compound list::      List type descriptors.
* descriptors compound list-of::   List-of type descriptors.
* descriptors compound vector::    Vector type descriptors.
* descriptors compound vector-of:: Vector-of type descriptors.
* descriptors compound condobj::   Condition-object type descriptors.
* descriptors compound enum::      Enumeration type descriptors.
* descriptors compound hashtable:: Hashtable type descriptors.
* descriptors compound alist::     Association list type descriptors.
* descriptors compound closure::   Closure object type descriptors.
* descriptors compound union::     Union type descriptors.
* descriptors compound intersect:: Intersection type descriptors.
* descriptors compound complem::   Complement type descriptors.
* descriptors compound ancestor::  Ancestor-of type descriptors.
@end menu

@c page
@node descriptors compound pair
@subsection Pair type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{pair-type-descr}
Name of type descriptors for pairs of heterogeneous values.  It has the
following fields:

@table @code
@item car-des
A type descriptor describing the type of the car.

@item cdr-des
A type descriptor describing the type of the cdr.
@end table
@end deftp


@defun make-pair-type-descr @var{car-des} @var{cdr-des}
Build and return a new instance of @class{pair-type-descr}.
@end defun


@defun pair-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of @class{pair-type-descr};
otherwise return @false{}.
@end defun


@defun pair-type-descr.car-des @var{des}
@defunx pair-type-descr.cdr-des @var{des}
Accessors for the fields of @class{pair-type-descr} instances.
@end defun

@c page
@node descriptors compound pair-of
@subsection Pair-of type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{pair-of-type-descr}
Name of type descriptors for pairs of homogeneous values.  It has the
following fields:

@table @code
@item item-des
A type descriptor describing the type of the car and cdr.
@end table
@end deftp


@defun make-pair-of-type-descr @var{item-des}
Build and return a new instance of @class{pair-of-type-descr}.
@end defun


@defun pair-of-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{pair-of-type-descr}; otherwise return @false{}.
@end defun


@defun pair-of-type-descr.item-des @var{des}
Accessor for the field of @class{pair-of-type-descr} instances.
@end defun

@c page
@node descriptors compound list
@subsection List type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{list-type-descr}
Name of type descriptors for lists of heterogeneous values.  It has the
following fields:

@table @code
@item item-des*
A list of type descriptors describing the types of the items.
@end table
@end deftp


@defun make-list-type-descr @var{des-list}
Build and return a new instance of @class{list-type-descr}.
@end defun


@defun list-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{list-type-descr}; otherwise return @false{}.
@end defun


@defun list-type-descr.item-des* @var{des}
Accessor for the field of @class{list-type-descr} instances.
@end defun


@defun list-type-descr.length @var{des}
Return the length of the list, a non--negative exact integer.
@end defun

@c page
@node descriptors compound list-of
@subsection List-of type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{list-of-type-descr}
Name of type descriptors for lists of homogeneous values.  It has the
following fields:

@table @code
@item item-des
A type descriptor describing the type of the items.
@end table
@end deftp


@defun make-list-of-type-descr @var{item-des}
Build and return a new instance of @class{list-of-type-descr}.
@end defun


@defun list-of-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{list-of-type-descr}; otherwise return @false{}.
@end defun


@defun list-of-type-descr.item-des @var{des}
Accessor for the field of @class{list-of-type-descr} instances.
@end defun

@c page
@node descriptors compound vector
@subsection Vector type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{vector-type-descr}
Name of type descriptors for vectors of heterogeneous values.  It has
the following fields:

@table @code
@item item-des*
A list of type descriptors describing the types of the items.
@end table
@end deftp


@defun make-vector-type-descr @var{des-list}
Build and return a new instance of @class{vector-type-descr}.
@end defun


@defun vector-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{vector-type-descr}; otherwise return @false{}.
@end defun


@defun vector-type-descr.item-des* @var{des}
Accessor for the field of @class{vector-type-descr} instances.
@end defun


@defun vector-type-descr.length @var{des}
Return the length of the vector, a non--negative exact integer.
@end defun

@c page
@node descriptors compound vector-of
@subsection Vector-of type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{vector-of-type-descr}
Name of type descriptors for vectors of homogeneous values.  It has the
following fields:

@table @code
@item item-des
A type descriptor describing the type of the items.
@end table
@end deftp


@defun make-vector-of-type-descr @var{item-des}
Build and return a new instance of @class{vector-of-type-descr}.
@end defun


@defun vector-of-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{vector-of-type-descr}; otherwise return @false{}.
@end defun


@defun vector-of-type-descr.item-des @var{des}
Accessor for the field of @class{vector-of-type-descr} instances.
@end defun

@c page
@node descriptors compound condobj
@subsection Condition-object type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{compound-condition-type-descr}
Name of type descriptors for compound condition objects.  It has the
following fields:

@table @code
@item component-des*
A list of type descriptors describing the types of the component
condition objects.
@end table
@end deftp


@defun make-compound-condition-type-descr @var{des-list}
Build and return a new instance of
@class{compound-condition-type-descr}.
@end defun


@defun compound-condition-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{compound-condition-type-descr}; otherwise return @false{}.
@end defun


@defun compound-condition-type-descr.component-des* @var{des}
Accessor for the field of @class{compound-condition-type-descr}
instances.
@end defun

@c page
@node descriptors compound enum
@subsection Enumeration type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{enumeration-type-descr}
Name of type descriptors for symbols enumerations.  It has the following
fields:

@table @code
@item symbol*
A list of symbols representing the enumerated items.
@end table
@end deftp


@defun make-enumeration-type-descr @var{symbols}
Build and return a new instance of @class{enumeration-type-descr}.
@end defun


@defun enumeration-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{enumeration-type-descr}; otherwise return @false{}.
@end defun


@defun enumeration-type-descr.symbols* @var{des}
Accessor for the field of @class{enumeration-type-descr} instances.
@end defun

@c page
@node descriptors compound hashtable
@subsection Hashtable type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{hashtable-type-descr}
Name of type descriptors for hashtables.  It has the following fields:

@table @code
@item key-des
A type descriptor describing the type of the keys.

@item val-des
A type descriptor describing the type of the values.
@end table
@end deftp


@defun make-hashtable-type-descr @var{key-des} @var{val-des}
Build and return a new instance of @class{hashtable-type-descr}.
@end defun


@defun hashtable-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{hashtable-type-descr}; otherwise return @false{}.
@end defun


@defun hashtable-type-descr.key-des @var{des}
@defunx hashtable-type-descr.val-des @var{des}
Accessors for the fields of @class{hashtable-type-descr} instances.
@end defun

@c page
@node descriptors compound alist
@subsection Association list type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{alist-type-descr}
Name of type descriptors for association lists.  It has the following
fields:

@table @code
@item key-des
A type descriptor describing the type of the keys.

@item val-des
A type descriptor describing the type of the values.
@end table
@end deftp


@defun make-alist-type-descr @var{key-des} @var{val-des}
Build and return a new instance of @class{alist-type-descr}.
@end defun


@defun alist-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{alist-type-descr}; otherwise return @false{}.
@end defun


@defun alist-type-descr.key-des @var{des}
@defunx alist-type-descr.val-des @var{des}
Accessors for the fields of @class{alist-type-descr} instances.
@end defun

@c page
@node descriptors compound closure
@subsection Closure object type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{closure-type-descr}
Name of type descriptors for closure objects.  It has the following
fields:

@table @code
@item signature
An instance of @class{case-lambda-descriptors} representing the type
signatures of the closure's clauses.
@end table
@end deftp


@defun make-closure-type-descr @var{signature}
Build and return a new instance of @class{closure-type-descr}.
@end defun


@defun closure-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{closure-type-descr}; otherwise return @false{}.
@end defun


@defun closure-type-descr.signature @var{des}
Accessor for the field of @class{closure-type-descr} instances.
@end defun

@c page
@node descriptors compound union
@subsection Union type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{union-type-descr}
Name of type descriptors for unions of type descriptors.  It has the
following fields:

@table @code
@item item-des*
A list of type descriptors describing the types of the components.
@end table
@end deftp


@defun make-union-type-descr @var{des-list}
Build and return a new instance of @class{union-type-descr}.
@end defun


@defun union-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{union-type-descr}; otherwise return @false{}.
@end defun


@defun union-type-descr.item-des* @var{des}
Accessor for the field of @class{union-type-descr} instances.
@end defun

@c page
@node descriptors compound intersect
@subsection Intersection type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{intersection-type-descr}
Name of type descriptors for intersections of type descriptors.  It has
the following fields:

@table @code
@item item-des*
A list of type descriptors describing the types of the components.
@end table
@end deftp


@defun make-intersection-type-descr @var{des-list}
Build and return a new instance of @class{intersection-type-descr}.
@end defun


@defun intersection-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{intersection-type-descr}; otherwise return @false{}.
@end defun


@defun intersection-type-descr.item-des* @var{des}
Accessor for the field of @class{intersection-type-descr} instances.
@end defun

@c page
@node descriptors compound complem
@subsection Complement type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{complement-type-descr}
Name of type descriptors for the complement of a type descriptor.  It
has the following fields:

@table @code
@item item-des
The type descriptor to be complemented.
@end table
@end deftp


@defun make-complement-type-descr @var{des}
Build and return a new instance of @class{complement-type-descr}.
@end defun


@defun complement-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{complement-type-descr}; otherwise return @false{}.
@end defun


@defun complement-type-descr.item-des @var{des}
Accessor for the field of @class{complement-type-descr} instances.
@end defun

@c page
@node descriptors compound ancestor
@subsection Ancestor-of type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{ancestor-of-type-descr}
Name of type descriptors representing the ancestors of a type
descriptor.  It has the following fields:

@table @code
@item item-des
The type descriptor of which we describe the ancestors.

@item ancestor-des*
List of type descriptors representing the ancestors.  The head of the
list is the parent type descriptor.
@end table
@end deftp


@defun make-ancestor-of-type-descr @var{des}
Build and return a new instance of @class{ancestor-of-type-descr}.
@end defun


@defun ancestor-of-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{ancestor-of-type-descr}; otherwise return @false{}.
@end defun


@defun ancestor-of-type-descr.item-des @var{des}
@defunx ancestor-of-type-descr.ancestor-des* @var{des}
Accessors for the fields of @class{ancestor-of-type-descr} instances.
@end defun

@c page
@node descriptors other
@section Other object-type descriptors


@menu
* descriptors other interface::         Interface type descriptors.
@end menu

@c page
@node descriptors other interface
@subsection Interface type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{interface-type-descr}
Name of type descriptors representing interfaces.  It has the following
fields:

@table @code
@item type-name
A symbol representing the name of this interface type.

@item uid
A symbol acting as unique identifier associated to this type descriptor.

@item parent-type-descriptor
An instance of @class{interface-type-descr} representing the parent of
this interface--type; @false{} if this interface--type has no parent.

@item implemented-interface-uids
A list of symbols representing the @uid{}s of the interfaces implemented
by this interface--type.

@item method-prototype-names
A list of symbols representing the names of public methods that must be
provided by object--types implementing this interface.

@item method-retriever
A function that retrieves method implementation functions given the name
of a method as symbol.
@end table
@end deftp


@defun make-interface-type-descr @var{type-name} @var{uid} @var{parent-type-descriptor} @var{implemented-interface-uids} @var{method-prototype-names} @var{method-retriever}
Build and return a new instance of @class{interface-type-descr}.
@end defun


@defun interface-type-descr? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{interface-type-descr}; otherwise return @false{}.
@end defun


@defun interface-type-descr.type-name @var{des}
@defunx interface-type-descr.uid @var{des}
@defunx interface-type-descr.parent-type-descriptor @var{des}
@defunx interface-type-descr.implemented-interface-uids @var{des}
@defunx interface-type-descr.method-prototype-names @var{des}
@defunx interface-type-descr.method-retriever @var{des}
Accessors for the fields of @class{interface-type-descr} instances.
@end defun


@defun object-type-implements-interface? @var{interface-uid} @var{descr}
The argument @var{descr} must be an object--type's run--time descriptor.
Return @true{} if the object--type implements the interface--type whose
@uid{} is @var{interface-uid}; otherwise return @false{}.

Usage example, a record--type implements an interface--type:

@lisp
(define-interface-type <IOne>
  (nongenerative dummy:<IOne>)
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-record-type <blue>
  (implements <IOne>)
  (method (@{doit <number>@} @{S <string>@})
    1))

(object-type-implements-interface?
  'dummy:<IOne>
  (record-type-descriptor <blue>))
@result{} #t

(object-type-implements-interface?
  (car (type-unique-identifiers <IOne>))
  (record-type-descriptor <blue>))
@result{} #t

(define O
  (new <blue>))

(is-a? O <IOne>)                                @result{} #t
(is-a? (cast-signature (<top>) O) <IOne>)       @result{} #t
@end lisp

Another usage example, a record--type implements an interface--type and
its parent:

@lisp
(define-interface-type <IOne>
  (method-prototype one
    (lambda (<string>) => (<number>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype two
    (lambda (<string>) => (<number>))))

(define-record-type <blue>
  (implements <ITwo>)
  (method (@{one <number>@} @{S <string>@})
    1)
  (method (@{two <number>@} @{S <string>@})
    1))

(object-type-implements-interface?
  (car (type-unique-identifiers <IOne>))
  (record-type-descriptor <blue>))
@result{} #t

(object-type-implements-interface?
  (car (type-unique-identifiers <ITwo>))
  (record-type-descriptor <blue>))
@result{} #t

(define O
  (new <blue>))

(is-a? O <IOne>)        @result{} #t
(is-a? O <ITwo>)        @result{} #t

(is-a? (cast-signature (<top>) O) <IOne>)       @result{} #t
(is-a? (cast-signature (<top>) O) <ITwo>)       @result{} #t
@end lisp
@end defun

@c page
@node descriptors signatures
@section Type descriptor signatures


@menu
* descriptors signatures descriptors::  Descriptors signatures.
* descriptors signatures lambda::       Lambda signature descriptors.
* descriptors signatures case-lambda::  Case-lambda signature descriptors.
@end menu

@c page
@node descriptors signatures descriptors
@subsection Descriptors signatures


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{descriptors-signature}
Type name of descriptors representing tuples of values signatures.  It
has the following fields:

@table @code
@item object-type-descrs
A proper or improper list of type descriptors representing the
signatures of lambda formals.
@end table
@end deftp


@defun make-descriptors-signature @var{descriptors}
Build and return a new instance of @class{descriptors-signature}.
@end defun


@defun descriptors-signature? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{descriptors-signature}; otherwise return @false{}.
@end defun


@defun descriptors-signature.object-type-descrs @var{des}
Accessor for the field of @class{descriptors-signature} instances.
@end defun

@c page
@node descriptors signatures lambda
@subsection Lambda signature descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{lambda-descriptors}
Type name of descriptors representing the type signature of single
lambda clauses.  It has the following fields:

@table @code
@item retvals
An instance of @class{descriptors-signature} representing the types of
values returned by this lambda clause.

@item argvals
An instance of @class{descriptors-signature} representing the types of
arguments expected by this lambda clause.
@end table
@end deftp


@defun make-lambda-descriptors @var{retvals} @var{argvals}
Build and return a new instance of @class{lambda-descriptors}.
@end defun


@defun lambda-descriptors? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{lambda-descriptors}; otherwise return @false{}.
@end defun


@defun lambda-descriptors.retvals @var{des}
@defunx lambda-descriptors.argvals @var{des}
Accessors for the fields of @class{lambda-descriptors} instances.
@end defun

@c page
@node descriptors signatures case-lambda
@subsection Case-lambda signature descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deftp {Record Type} @aclass{case-lambda-descriptors}
Type name of descriptors representing the type signature of a tuple of
lambda clauses.  It has the following fields:

@table @code
@item clause-signature*
A list of @class{lambda-descriptors} representing the type signatures of
the clauses.
@end table
@end deftp


@defun make-case-lambda-descriptors @var{clause-signature*}
Build and return a new instance of @class{case-lambda-descriptors}.
@end defun


@defun case-lambda-descriptors? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{case-lambda-descriptors}; otherwise return @false{}.
@end defun


@defun case-lambda-descriptors.clause-signature* @var{des}
Accessor for the field of @class{case-lambda-descriptors} instances.
@end defun

@c page
@node descriptors relations
@section Relations between type descriptors


The following syntactic bindings are exported by the library
@library{vicare system type-descriptors}.


@deffn Syntax type-descriptor-parent @meta{type-annotation}
Expand to an expression which, compiled and evaluated, returns the type
descriptor of the parent of the specified type annotation.

@lisp
(type-descriptor-parent @aclass{fixnum})
@result{} @actdname{exact-integer}

(type-descriptor-parent (pair @aclass{fixnum} @aclass{flonum}))
@result{} @actdname{pair}

(define-record-type alpha)

(type-descriptor-parent alpha)  @result{} @actdname{record}

(define-record-type beta
  (parent alpha))

(type-descriptor-parent beta)
@expansion{} (record-type-descriptor alpha)
@end lisp
@end deffn


@deffn Syntax type-descriptor-ancestors @meta{type-annotation}
Expand to an expression which, compiled and evaluated, returns the list
of type descriptors representing the ancestors of the specified type
annotation.  The descriptor of the annotation itself is @strong{not}
included.

@lisp
(type-descriptor-ancestors @aclass{top})
@result{} ()

(type-descriptor-ancestors @aclass{string})
@result{} (@actdname{top})

(type-descriptor-ancestors @aclass{record})
@result{} (@actdname{struct} @actdname{top})

(type-descriptor-ancestors @aclass{nelist})
@result{} (@actdname{list} @actdname{top})
@end lisp
@end deffn


@deffn Syntax type-descriptor=? @metai{type-annotation} @metaii{type-annotation}
Expand to an expression which, compiled and evaluated, returns @true{}
if the type descriptors associated to the specified type annotations are
equal; otherwise it returns @false{}.

@lisp
(type-descriptor=? @aclass{top} @aclass{top})
@result{} #t

(type-descriptor=? @aclass{top} @aclass{number})
@result{} #f

(type-descriptor=? (pair @aclass{fixnum} @aclass{string})
                   (pair @aclass{fixnum} @aclass{string}))
@result{} #t
@end lisp
@end deffn


@deffn Syntax type-descriptor-super-and-sub? @metai{type-annotation} @metaii{type-annotation}
Expand to an expression which, compiled and evaluated, returns @true{}
if the type descriptor associated to @metai{type-annotation} is a
matching super--type of the type descriptor associated to
@metaii{type-annotation}; otherwise it returns @false{}.

@lisp
(type-descriptor-super-and-sub?
   @aclass{top} @aclass{top})
@result{} #t

(type-descriptor-super-and-sub?
   @aclass{top} @aclass{number})
@result{} #t

(type-descriptor-super-and-sub?
   @aclass{number} @aclass{top})
@result{} #f

(type-descriptor-super-and-sub?
   (pair @aclass{fixnum} @aclass{null}) (list @aclass{fixnum}))
@result{} #t
@end lisp
@end deffn


@deffn Syntax type-descriptor-matching @metai{type-annotation} @metaii{type-annotation}
Expand to an expression which, compiled and evaluated, matches the
arguments as if: the descriptor associated to @metai{type-annotation} is
the type of a formal argument requested by a closure object; the type
descriptor associated to @metaii{type-annotation} is the type of the
operand given to a closure object application.

Expand to a quoted symbol:

@table @code
@item exact-match
If there is an exact match between the argument's and operand's
descriptors.

@item possible-match
If there is a possible match between the argument's and operand's
descriptors; the operand must be further validated at run--time.

@item no-match
If there is no match between the argument's and operand's descriptors.
@end table
@end deffn


@deffn Syntax descriptors-signature-matching @metai{signature-annotation} @metaii{signature-annotation}
The arguments @var{signature-annotation} must be proper or improper
lists of type annotations.  Expand to an expression which, compiled and
evaluated, matches the arguments as if:

@itemize
@item
The @class{descriptors-signature} instance associated to
@metai{signature-annotation} represents the types of formal arguments
requested by a closure object.

The @class{descriptors-signature} instance associated to
@metaii{signature-annotation} represents the types of the operands given
to a closure object application.
@end itemize

Expand to a quoted symbol:

@table @code
@item exact-match
If there is an exact match between the argument's and operand's
descriptors.

@item possible-match
If there is a possible match between the argument's and operand's
descriptors; the operand must be further validated at run--time.

@item no-match
If there is no match between the argument's and operand's descriptors.
@end table

Usage examples:

@lisp
(descriptors-signature-matching
  (<number> <string>)
  (<fixnum> <nestring>))
@result{} exact-match

(descriptors-signature-matching
  (<number> <string>)
  (<fixnum> <top>))
@result{} possible-match

(descriptors-signature-matching
  (<number> <string>)
  (<fixnum> <vector>))
@result{} no-match
@end lisp
@end deffn

@c page
@node syntaxes
@chapter Type--exploiting syntaxes


@value{PRJNAME} allows us to perform some operations on objects through
generic syntaxes, provided that we use the type annotation.

Unless otherwise specified, the syntactic bindings documented in this
section are exported by the library @library{vicare}.  When showing code
examples, we always assume: to have imported the library
@library{vicare}; to have enabled the typed language; to have put the
Scheme source code reader in @code{#!vicare} mode.

@menu
* syntaxes type-of::      Determining the type of expressions.
* syntaxes define::       Defining type annotations.
* syntaxes new-delete::   Constructors and destructors.
* syntaxes predicates::   Predicate syntaxes.
* syntaxes assert::       Validating signatures.
* syntaxes unsafe-cast::  Casting the type of expressions.
* syntaxes case-type::    Branching on type of expression.
* syntaxes variables::    Defining typed variables.
* syntaxes overloads::    Overloaded functions.
* syntaxes operations::   Miscellaneous operations.
@end menu

@c page
@node syntaxes type-of
@section Determining the type of expressions


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax type-of @meta{expr}
Fully expand the given expression in the current lexical environment and
return a structure of type @class{type-signature} representing the types
of the tuple of returned values.  The expression is @strong{not}
evaluated, only expanded; this means that the expansion side effects are
performed.

Examples:

@example
(type-of (values))
@result{} #[signature ()]

(type-of (values 1 2))
@result{} #[signature (<positive-fixnum> <positive-fixnum>)]

(type-of 123)
@result{} #[signature (<positive-fixnum>)]

(type-of ((lambda (@{_ symbol@}) 'ciao)))
@result{} #[signature (<symbol>)]

(type-of (+ 1 2))
@result{} #[signature (<exact-integer>)]

(type-of (+ 1.2 2.3))
@result{} #[signature (<flonum>)]

(type-of (list 1 2.3))
@result{} #[signature ((list <positive-fixnum> <positive-flonum>))]

(type-of (condition (make-who-condition 'io)
                    (make-message-condition "ciao")))
@result{} #[signature ((condition &who &message))]
@end example
@end deffn


@deffn Syntax type-unique-identifiers @meta{type-name}
Expand into a list of symbols representing the type hierarchy of
@meta{type-name}, which must be a syntactic identifier bound to an
object type specification.

@lisp
(type-unique-identifiers <top>)
@result{} (vicare:scheme-type:<top>)

(type-unique-identifiers <string>)
@result{} (vicare:scheme-type:<string>
    vicare:scheme-type:<top>)

(type-unique-identifiers <condition>)
@result{} (vicare:scheme-type:<condition>
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(type-unique-identifiers <compound-condition>)
@result{} (vicare:scheme-type:<compound-condition>
    vicare:scheme-type:<condition>
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(type-unique-identifiers &condition)
@result{} (vicare:scheme-type:&condition
    vicare:scheme-type:<condition>
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(type-unique-identifiers &message)
@result{} (vicare:scheme-type:&message
    vicare:scheme-type:&condition
    vicare:scheme-type:<condition>
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(internal-body
  (define-struct duo
    (one two)
    (nongenerative yeah))
  (type-unique-identifiers duo))
@result{} (yeah
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(internal-body
  (define-record-type duo
    (nongenerative duo)
    (fields one two))
  (type-unique-identifiers duo))
@result{} (duo
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)

(internal-body
   (define-record-type alpha
     (nongenerative alpha))
   (define-record-type beta
     (parent alpha)
     (nongenerative beta))
   (type-unique-identifiers beta))
@result{} (beta
    alpha
    vicare:scheme-type:<record>
    vicare:scheme-type:<struct>
    vicare:scheme-type:<top>)
@end lisp
@end deffn

@c page
@node syntaxes define
@section Defining type annotations


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax define-type @meta{name}
@deffnx Syntax define-type @meta{name} @meta{annotation}
Define a new type annotation bound to @meta{name}.  The argument
@meta{name} must be a syntactic identifier.  The argument
@meta{annotation} must be a type annotation syntax.
@end deffn


We can define new type annotations using the syntax
@syntax{define-type}:

@lisp
(define-type <nnfx>
  <non-negative-fixnum>)

(define-type <compound>
  (or <vector> <list>))
@end lisp

This syntax allows recursive type definitions:

@lisp
(define-type <it>
  (or (list-of <fixnum>)
      (vector-of <it>)))
@end lisp

This syntax allows @dfn{forward definitions}: type annotations that are
half--defined to allow for mutually recursive type definitions.  Here is
an example of forward definition that does nothing useful:

@lisp
(define-type <it>)      ;forward definition
(define-type <it>)      ;does nothing

;;Complete the definition of "<it>".
(define-type <it> <number>)
@end lisp

@noindent
Here is a possible definition for a @class{syntax-object} type using
mutually recursive definitions:

@lisp
(import (rename (only (vicare expander)
                      <stx> <syntactic-identifier>)
                (<stx> <wrapped-syntax-object>)))

(define-type <datum>
  (or <null> <boolean> <char> <number> <string> <bytevector>))

(define-type <syntax-object>)

(define-type <pair-of-syntax-objects>
  (pair-of <syntax-object>))

(define-type <vector-of-syntax-objects>
  (vector-of <syntax-object>))

(define-type <syntax-object>
  (or <datum>
      <wrapped-syntax-object>
      <syntactic-identifier>
      <pair-of-syntax-objects>
      <vector-of-syntax-objects>))
@end lisp

Forward definitions work only for identifiers defined in the same
lexical contour.  So the following works:

@lisp
(define-type <it>)
(define-type <it>
  <fixnum>)
@end lisp

@noindent
but the following will fail:

@lisp
(define-type <it>)
(module (<it>)
  (define-type <it>
    <fixnum>))
@end lisp

@noindent
because the concrete definition is inside a module, which represents a
lexical contour.

@c page
@node syntaxes new-delete
@section Constructors and destructors


The syntaxes @syntax{new} and @syntax{delete} allow us to retrieve the
constructor and destructor functions of Scheme objects of some types.
For example, with records:

@lisp
(define-record-type duo
  (fields one two)
  (destructor-protocol
    (lambda ()
      (lambda (self)
        (fprintf (current-error-port) "destroying ~s\n" self)))))

(define O
  (new duo 1 2))

(delete O)
@print{} destroying #[record duo one=1 two=2]
@end lisp

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax new @meta{type} @meta{arg} @dots{}
Retrieve the default constructor function of the type @var{type-name}
and apply it to the given arguments; return the result of the
application.
@end deffn


@deffn Syntax delete @meta{expr}
Retrieve the destructor function, if any, of the object returned by the
evaluation of the expression @meta{expr} and apply it to the object;
return the return value of the application.  The evaluation of
@meta{expr} must return a single return value.

If the object has no destructor function: an exception is raised.
@end deffn

@c page
@node syntaxes predicates
@section Predicate syntaxes


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax is-a? @meta{expr} @meta{type}
@deffnx Syntax is-a? _ @meta{type}
@deffnx {Auxiliary Syntax} _
Expand to an expression which, when evaluated, returns @true{} if
@meta{expr} evaluates to a value of type @meta{type}.  @meta{expr} can
be any expression returning a single value.

When @syntax{_} is used as first argument: the syntax evaluates to a
predicate function.

@example
(define-record-type duo
  (fields one two))

(is-a? (new duo 1 2) two)       @result{} #t

((is-a? _ duo) (new duo 1 2))   @result{} #t

(is-a? 123 duo)                 @result{} #f

(is-a? '(1 2 3) (list <fixnum> <exact-integer> <number>))
@result{} #t
@end example
@end deffn

@c page
@node syntaxes assert
@section Validating signatures


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax assert-signature @meta{signature} @meta{expr}
@deffnx Syntax assert-signature-and-return @meta{signature} @meta{expr}
@deffnx Syntax cast-signature @meta{signature} @meta{expr}
Validate the type signature of the values returned by @meta{expr},
either at expand--time or run--time.  @meta{expr} can be any Scheme
expression.  @meta{signature} must be a proper or improper list of type
annotations representing the type signature.

The syntax @syntax{assert-signature} returns a single unspecified value.
The syntax @syntax{assert-signature-and-return} returns the return
values of @meta{expr} with the original type signature of @meta{expr}.
The syntax @syntax{cast-signature} returns the return values of
@meta{expr} with the type signature @meta{signature}.

@lisp
(type-of 123)
@result{} #[signature (<positive-fixnum>)]

(type-of (assert-signature-and-return (<top>) 123))
@result{} #[signature (<positive-fixnum>)]

(type-of (cast-signature (<top>) 123))
@result{} #[signature (<top>)]
@end lisp

If it is possible to validate the signature at expand--time: when
successful, the syntax use just expands to the evaluation of
@meta{expr}; when a type mismatch is detected, an expand--time exception
is raised.  Otherwise the syntax use expands to an expression that
validates the values at run--time.

As special cases, when @meta{signature} is @samp{()}, a proper or
improper list of @class{top} and @class{list} types like:

@lisp
<list>
(<top>)
(<top> <top> <top>)
(<top> <top> . <list>)
@end lisp

@noindent
no validation is performed at run--time, only at expand--time.
@end deffn


Here are some validation examples:

@lisp
(assert-signature () (values))
(assert-signature-and-return (<fixnum>) 123)    @result{} 123
(assert-signature-and-return (<string>) "ciao") @result{} "ciao"

(assert-signature-and-return (<fixnum> <flonum>) (values 1 2.0))
@result{} 1 2.0

(expansion-of
  (assert-signature (<fixnum>) 123))
@result{} (begin (quote 123) (quote #!void))

(expansion-of
  (assert-signature-and-return (<fixnum>) 123))
@result{} (quote 123)

(expansion-of
  (assert-signature-and-return (<fixnum>)
    (unsafe-cast-signature <fixnum> (read))))
@result{} ((primitive read))
@end lisp

There are some interesting special cases:

@itemize
@item
If we want to assert (at expand--time) that an expression returns zero
values, we can do:

@lisp
(assert-signature () @meta{expr})
@end lisp

@item
If we want to assert nothing, we can do:

@lisp
(assert-signature <list> @meta{expr})
@end lisp

@noindent
which will just expand to the evaluation of @meta{expr}; this might be
useful when the syntax is used in the output form of another macro use.

@item
If we want to assert (at expand--time) that an expression returns a
single value, of any type, we can do:

@lisp
(assert-signature (<top>) @meta{expr})
@end lisp

@item
If we want to assert (at expand--time) that an expression returns two
values, of any type, we can do:

@lisp
(assert-signature (<top> <top>) @meta{expr})
@end lisp

@item
If we want to assert (at expand--time) that an expression returns two or
more values, of any type, we can do:

@lisp
(assert-signature (<top> <top> . <list>) @meta{expr})
@end lisp
@end itemize

@c ------------------------------------------------------------------------

@subheading Expansion examples for run--time validation

Let's say we have a function @samp{fun} such that:

@lisp
(type-of (fun))
@result{} #[signature <list>]
@end lisp

@noindent
there is nothing the expander can do to infer the type signature of the
function application.

@c ------------------------------------------------------------------------

@subsubheading Example 1: multiple values and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (<fixnum> <flonum> <string>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(call-with-values
    (lambda () (fun))
  (lambda (arg1 arg2 arg3)
    (values ((lambda (obj value-index caller-who)
               (if (fixnum? obj)
                   obj
                 (expression-return-value-violation
                     caller-who
                   '"return value of invalid type"
                   value-index '(is-a? _ <fixnum>) obj)))
             arg1 '1 'assert-signature-and-return)
            ((lambda (obj value-index caller-who)
               (if (flonum? obj)
                   obj
                 (expression-return-value-violation
                     caller-who
                   '"return value of invalid type"
                   value-index '(is-a? _ <flonum>) obj)))
             arg2 '2 'assert-signature-and-return)
            ((lambda (obj value-index caller-who)
               (if (string? obj)
                   obj
                 (expression-return-value-violation
                     caller-who
                   '"return value of invalid type"
                   value-index '(is-a? _ <string>) obj)))
             arg3 '3 'assert-signature-and-return))))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 2: multiple values and no return values

The following syntax use:

@lisp
(assert-signature
    (<fixnum> <flonum> <string>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(call-with-values
    (lambda () (fun))
  (lambda (arg1 arg2 arg3)
    ((lambda (obj value-index caller-who)
       (if (not (fixnum? obj))
           (expression-return-value-violation
               caller-who '"return value of invalid type"
               value-index '(is-a? _ <fixnum>) obj)
         '#!void))
     arg1 '1 'assert-signature)
    ((lambda (obj value-index caller-who)
       (if (not (flonum? obj))
           (expression-return-value-violation
               caller-who '"return value of invalid type"
               value-index '(is-a? _ <flonum>) obj)
         '#!void))
     arg2 '2 'assert-signature)
    ((lambda (obj value-index caller-who)
       (if (not (string? obj))
           (expression-return-value-violation
               caller-who '"return value of invalid type"
               value-index '(is-a? _ <string>) obj)
         '#!void))
     arg3 '3 'assert-signature)
    (void)))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 3: list of values and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (list-of <fixnum>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
((lambda arg1
   (lambda (list-value first-value-index caller-who)
     (fold-left
         (lambda (item-index item-value)
           ((lambda (obj value-index caller-who)
              (if (not ((letrec
                            ((pred (lambda (obj)
                                     (if (pair? obj)
                                         (if (fixnum? (car obj))
                                             (pred (cdr obj))
                                           '#f)
                                       (null? obj)))))
                          pred)
                        obj))
                  (expression-return-value-violation caller-who
                    '"return value of invalid type"
                    value-index '(is-a? _ (list-of <fixnum>))
                    obj)
                '#!void))
            item-value item-index caller-who)
           (fxadd1 item-index))
       first-value-index list-value)
     list-value))
 (fun))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 5: multiple values and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (<fixnum> <flonum> . (list-of <fixnum>))
  (fun))
@end lisp

@noindent
is expanded to:

@smalllisp
(call-with-values
    (lambda () (fun))
  (lambda (arg1 arg2 . arg3)
    (apply values
           ((lambda (obj value-index caller-who)
              (if (fixnum? obj)
                  obj
                (expression-return-value-violation
                    caller-who
                  '"return value of invalid type"
                  value-index '(is-a? _ <fixnum>) obj)))
            arg1 '1 'assert-signature-and-return)
           ((lambda (obj value-index caller-who)
              (if (flonum? obj)
                  obj
                (expression-return-value-violation
                    caller-who
                  '"return value of invalid type"
                  value-index '(is-a? _ <flonum>) obj)))
            arg2 '2 'assert-signature-and-return)
           (lambda (list-value first-value-index caller-who)
             (fold-left
                 (lambda (item-index item-value)
                   ((lambda (obj value-index caller-who)
                      (if (not ((letrec
                                    ((pred (lambda (obj)
                                             (if (pair? obj)
                                                 (if (fixnum? (car obj))
                                                     (pred (cdr obj))
                                                   '#f)
                                               (null? obj)))))
                                  pred) obj))
                          (expression-return-value-violation
                              caller-who
                            '"return value of invalid type"
                            value-index
                            '(is-a? _ (list-of <fixnum>)) obj)
                        '#!void))
                    item-value item-index caller-who)
                   (fxadd1 item-index))
               first-value-index list-value)
             list-value)
           arg3 '3 'assert-signature-and-return)))
@end smalllisp

@c ------------------------------------------------------------------------

@subsubheading Example 5: single value and return values

The following syntax use:

@lisp
(assert-signature-and-return
    (<fixnum>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
((lambda (arg1)
   ((lambda (obj value-index caller-who)
      (if (fixnum? obj)
          obj
        (expression-return-value-violation caller-who
          '"return value of invalid type"
          value-index '(is-a? _ <fixnum>) obj)))
    arg1 '1 'assert-signature-and-return))
 (fun))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example 6: no validation and single return value

The following syntax use:

@lisp
(assert-signature-and-return
    (<top>)
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(fun)
@end lisp

@noindent
there is no need to insert a validation form because a single value of
any type matches the type signature.

@c ------------------------------------------------------------------------

@subsubheading Example 7: no validation and return values

The following syntax use:

@lisp
(assert-signature-and-return
    <list>
  (fun))
@end lisp

@noindent
is expanded to:

@lisp
(fun)
@end lisp

@noindent
there is no need to insert a validation form because any number of
return values of any type matches the type signature.

@c page
@node syntaxes unsafe-cast
@section Casting the type of expressions


It is sometimes useful to explicitly declare the type signature of an
expression, so that the expander can perform more type checks and,
maybe, optimisations.  We might want to do it as an unsafe operation,
without introducing run--time validation of values.  For example, if we
know that the result of an expression is a vector of @math{3} fixnums,
we might write:

@lisp
($vector-ref @meta{expr} 1)
@end lisp

@noindent
and everything is all right, but we are not specifying that the return
value is a fixnum.

In these corner cases, we can use the syntax
@syntax{unsafe-cast-signature}: at expand--time, it tags an expression
as returning values of a specified type signature.  So, in the above
example, we could write:

@lisp
(unsafe-cast-signature (<fixnum>)
  ($vector-ref @meta{expr} 1))
@end lisp

We can easily check how @syntax{unsafe-cast-signature} works at the @repl{}:

@example
vicare> (unsafe-cast-signature (<fixnum>) 123)
$1 = 123
vicare> (expansion-of (unsafe-cast-signature (<fixnum>) 123))
$1 = '123
vicare> (type-of (unsafe-cast-signature (<fixnum>) 123))
$1 = #[signature (<fixnum>)]
@end example

@noindent
for a truly untyped expression:

@example
vicare> (expansion-of (unsafe-cast-signature (<fixnum>) (read)))
$1 = ((primitive read))
vicare> (type-of (unsafe-cast-signature (<fixnum>) (read)))
$1 = #[signature (<fixnum>)]
@end example

@noindent
if the type is incompatible, and we know it at expand--time:

@smallexample
vicare> (unsafe-cast-signature (<fixnum>) "ciao")
Unhandled exception
 Condition components:
   1. &who: unsafe-cast-signature
   2. &message: "expression type is incompatible with the requested tag"
   3. &syntax:
       form: #<syntax expr=(unsafe-cast-signature (<fixnum>) "ciao")>
       subform: #<syntax expr="ciao" mark*=(src)>
   4. &irritants: (#[signature (<string>)])
@end smallexample

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax unsafe-cast-signature @meta{signature} @meta{expr}
Expand to the @meta{expr} expression itself, but, in the expander, tag
the expression as returning a tuple of values with type signature
@meta{signature}.
@end deffn

@c page
@node syntaxes case-type
@section Branching on type of expression


The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax case-type @meta{expr} @metao{clause} @meta{clause} @dots{}
@deffnx {Auxiliary Syntax} =>
@deffnx {Auxiliary Syntax} else
Similar to @syntax{case} but branches based on the type of the single
value returned by @meta{expr}.  Each @meta{clause} must have one of the
formats:

@lisp
((@meta{type-id}) . @meta{body})
((@meta{type-id}) => @meta{receiver-expr})
(else . @meta{body})
@end lisp

@noindent
where: @meta{type-id} must be a type identifier; the @syntax{else}
clause is valid only as last clause; @meta{receiver-expr} must be an
expression evaluating to a closure object accepting a single argument.

Examples:

@lisp
(case-type 123
  ((<vector>)   'vector)
  ((<fixnum>)   'fixnum)
  ((<string>)   'string))
@result{} fixnum

(case-type 123
  ((<vector>)   'vector)
  ((<fixnum>)   => (lambda (arg) (list arg 'fixnum)))
  ((<string>)   'string)
  (else   'else))
@result{} (123 fixnum)

(case-type #t
  ((<vector>)   'vector)
  ((<fixnum>)   'fixnum)
  ((<string>)   'string)
  (else         'else))
@result{} else
@end lisp
@end deffn

@c page
@node syntaxes variables
@section Defining typed variables


In all the following syntax definitions, we assume the following formats
for the input form components:

@lisp
@meta{standard-clause} ==
  | (@meta{standard-formals} . @meta{body})

@meta{typed-clause} ==
  | (@meta{typed-clause-formals} . @meta{body})

@meta{typed-clause-formals} ==
  | @meta{typed-formals}
  | (@meta{anonymous-retvals} . @meta{typed-formals})

@meta{anonymous-retvals} ==
  | (brace _ @metao{rv-type} @meta{rv-type} ...)
  | (brace _ @meta{rv-type} ... . @meta{rest-rv-type})

@meta{typed-var} ==
  | @meta{name-id}
  | (brace @meta{name-id} @meta{type})

@meta{typed-who} ==
  | @meta{who-id}
  | (brace @meta{who-id} @metao{rv-type} @meta{rv-type} ...)
  | (brace @meta{who-id} @meta{rv-type} ... . @meta{rest-rv-type})

@meta{standard-formals} ==
  | @meta{args-id}
  | (@meta{arg-id} ...)
  | (@meta{arg-id} @metao{arg-id} ... . @meta{args-id})

@meta{typed-formals} ==
  | @meta{typed-args}
  | (@meta{typed-arg} ...)
  | (@metao{typed-arg} @meta{typed-arg} ... . @meta{typed-rest})

@meta{typed-arg} ==
  | @meta{arg-id}
  | (brace @meta{arg-id} @meta{arg-type})

@meta{typed-args} ==
  | @meta{args-id}
  | (brace @meta{args-id} @meta{args-type})

@meta{typed-rest} ==
  | @meta{rest-id}
  | (brace @meta{rest-id} @meta{rest-type})

@meta{standard-binding} ==
  | @meta{standard-var}

@meta{standard-var} ==
  | @meta{name-id}

@meta{typed-binding} ==
  | @meta{standard-var}
@end lisp

@noindent
where the following components are syntactic identifiers:

@lisp
@meta{name-id} @meta{who-id} @meta{arg-id} @meta{args-id} @meta{rest-id}
@end lisp

@noindent
the following components are type annotations:

@lisp
@meta{type} @meta{arg-type} @meta{rv-type}
@end lisp

@noindent
and the following components are type annotations that must represent
lists:

@lisp
@meta{args-type} @meta{rest-type} @meta{rest-rv-type}
@end lisp

The following syntactic bindings are exported by the library
@library{vicare}.

@c ------------------------------------------------------------------------

@subsubheading Standard syntaxes


@deffn Syntax define/std @meta{who-id}
@deffnx Syntax define/std @meta{who-id} @meta{expr}
@deffnx Syntax define/std (@meta{who-id} . @meta{standard-formals}) . @meta{body}
This is the @syntax{define} syntax as defined by @rnrs{6}; whenever the
@syntax{define} syntactic binding is used in code with the typed
language @strong{disabled}: it expands into a use of
@syntax{define/std}.
@end deffn


@deffn Syntax case-define/std @meta{who-id} @metao{standard-clause} @meta{standard-clause} @dots{}
This is a @syntax{case-define} syntax compatible with the @rnrs{6}
language; whenever the @syntax{case-define} syntactic binding is used in
code with the typed language @strong{disabled}: it expands into a use of
@syntax{case-define/std}.
@end deffn


@deffn Syntax lambda/std @meta{standard-formals} . @meta{body}
This is the @syntax{lambda} syntax as defined by @rnrs{6}; whenever the
@syntax{lambda} syntactic binding is used in code with the typed
language @strong{disabled}: it expands into a use of
@syntax{lambda/std}.
@end deffn


@deffn Syntax named-lambda/std @meta{name} @meta{standard-formals} . @meta{body}
This is like @syntax{lambda/std}, but accepts an argument @meta{name}
which must be a syntactic identifier representing the name of the
generated closure object.  In the body of the clauses the quoted name is
bound to the fluid syntax @syntax{__who__}.
@end deffn


@deffn Syntax case-lambda/std @metao{standard-clause} @meta{standard-clause} @dots{}
This is a @syntax{case-lambda} syntax defined by @rnrs{6}; whenever the
@syntax{case-lambda} syntactic binding is used in code with the typed
language @strong{disabled}: it expands into a use of
@syntax{case-lambda/std}.
@end deffn


@deffn Syntax named-case-lambda/std @meta{name} @metao{standard-clause} @meta{standard-clause} @dots{}
This is like @syntax{case-lambda/std}, but accepts an argument
@meta{name} which must be a syntactic identifier representing the name
of the generated closure object.  In the body of the clauses the quoted
name is bound to the fluid syntax @syntax{__who__}.
@end deffn


@deffn Syntax let/std (@meta{standard-binding} @dots{}) . @meta{body}
@deffnx Syntax let*/std (@meta{standard-binding} @dots{}) . @meta{body}
@deffnx Syntax letrec/std (@meta{standard-binding} @dots{}) . @meta{body}
@deffnx Syntax letrec*/std (@meta{standard-binding} @dots{}) . @meta{body}
These are the binding syntaxes defined by @rnrs{6}: whenever the
syntaxes @syntax{let}, @syntax{let*}, @syntax{letrec}, @syntax{letrec*}
are used in code with the typed language @strong{disabled}: they expand
into a uses of @syntax{let/std}, @syntax{let*/std}, @syntax{letrec/std},
@syntax{letrec*/std}.
@end deffn


@deffn Syntax receive/std @meta{standard-formals} @meta{producer-expr} . @meta{body}
@deffnx Syntax receive-and-return/std @meta{standard-formals} @meta{producer-expr} . @meta{body}
These are @syntax{receive} and @syntax{receive-and-return} syntaxes
which define standard syntactic bindings: whenever the syntaxes
@syntax{receive}, @syntax{receive-and-return} are used in code with the
typed language @strong{disabled}: they expand into a uses of
@syntax{receive/std} and @syntax{receive-and-return/std}.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Checked syntaxes


@deffn Syntax define/checked @meta{typed-var}
@deffnx Syntax define/checked @meta{typed-var} @meta{expr}
@deffnx Syntax define/checked (@meta{typed-who} . @meta{typed-formals}) . @meta{body}
This is the @syntax{define} syntax that supports the typed language;
whenever the @syntax{define} syntactic binding is used in code with the
typed language @strong{enabled}: it expands into a use of
@syntax{define/checked}.

When defining a variable: the result of the expression is validated
either at expand--time or at run--time, to make sure that it matches the
type of the variable.  The expression's type must be a sub--type of the
variable's type.

When defining a function: the operands and return values are validated
either at expand--time or at run--time, to make sure that they match the
type of the function's type signature.  The operands' types must be
sub--types of the arguments' types; the return values' types must be
sub--types of the declared signature types.

Usage examples:

@lisp
(define/checked var1
  123)

(define/checked @{var2 <string>@}
  "hello")

(define/checked (@{fun <string>@} @{N <fixnum>@})
  (fixnum->string N))
@end lisp
@end deffn


@deffn Syntax case-define/checked @meta{who-id} @metao{typed-clause} @meta{typed-clause} @dots{}
This is a @syntax{case-define} variant that supports the typed language.
Operands and return values are validated either at expand--time or at
run--time, to make sure that they match the type signature.

Usage examples:

@lisp
(case-define/checked fun-1
  ((a b c)
   (list a b c))
  ((a b c . rest)
   (cons* a b c rest)))

(case-define/checked fun-2
  ((@{_ (list <fixnum> <fixnum> <fixnum>)@}
      @{a <fixnum>@} @{b <fixnum>@} @{c <fixnum>@})
   (list a b c))
  ((@{_ (list-of <fixnum>)@}
      @{a <fixnum>@} @{b <fixnum>@} @{c <fixnum>@}
      . @{rest (list-of <fixnum>)@})
   (cons* a b c rest)))
@end lisp
@end deffn


@deffn Syntax lambda/checked @meta{typed-clause-formals} . @meta{body}
This is the @syntax{lambda} syntax that supports the typed language;
whenever the @syntax{lambda} syntactic binding is used in code with the
typed language @strong{enabled}: it expands into a use of
@syntax{lambda/checked}.

The operands and return values are validated either at expand--time and
at run--time, to make sure that they match the type of the function's
type signature.  The operands' types must be sub--types of the
arguments' types; the return values' types must be sub--types of the
declared signature types.

Usage examples:

@lisp
(lambda/checked (a b)
  (list a b))

(lambda/checked (@{_ (list <fixnum> <fixnum>)@}
                  @{a <fixnum>@} @{b <fixnum>@})
  (list a b))
@end lisp
@end deffn


@deffn Syntax named-lambda/checked @meta{name} @meta{typed-clause-formals} . @meta{body}
This is like @syntax{lambda/checked}, but accepts an argument
@meta{name} which must be a syntactic identifier representing the name
of the generated closure object.  In the body of the clauses the quoted
name is bound to the fluid syntax @syntax{__who__}.

Usage examples:

@lisp
(named-lambda/checked fun (@{_ <string>@} @{N <fixnum>@})
  (fixnum->string N))
@end lisp
@end deffn


@deffn Syntax case-lambda/checked @metao{typed-clause} @meta{typed-clause} @dots{}
This is a @syntax{case-lambda} syntax that supports the typed language;
whenever the @syntax{case-lambda} syntactic binding is used in code with
the typed language @strong{enabled}: it expands into a use of
@syntax{case-lambda/checked}.

Usage examples:

@lisp
(case-lambda/checked
  ((@{_ <string>@} @{N <fixnum>@})
   (fixnum->string N))
  ((@{_ <string>@} @{N <fixnum>@} @{base <fixnum>@})
   (fixnum->string N base)))
@end lisp
@end deffn


@deffn Syntax named-case-lambda/checked @meta{name} @metao{typed-clause} @meta{typed-clause} @dots{}
This is like @syntax{case-lambda/checked}, but accepts an argument
@meta{name} which must be a syntactic identifier representing the name
of the generated closure object.  In the body of the clauses the quoted
name is bound to the fluid syntax @syntax{__who__}.
@end deffn


@deffn Syntax let/checked (@meta{typed-binding} @dots{}) . @meta{body}
@deffnx Syntax let*/checked (@meta{typed-binding} @dots{}) . @meta{body}
@deffnx Syntax letrec/checked (@meta{typed-binding} @dots{}) . @meta{body}
@deffnx Syntax letrec*/checked (@meta{typed-binding} @dots{}) . @meta{body}
These are the binding syntaxes that support the typed language: whenever
the syntaxes @syntax{let}, @syntax{let*}, @syntax{letrec},
@syntax{letrec*} are used in code with the typed language
@strong{enabled}: they expand into a uses of @syntax{let/checked},
@syntax{let*/checked}, @syntax{letrec/checked},
@syntax{letrec*/checked}.
@end deffn


@deffn Syntax receive/checked @meta{typed-formals} @meta{producer-expr} . @meta{body}
@deffnx Syntax receive-and-return/checked @meta{typed-formals} @meta{producer-expr} . @meta{body}
These are @syntax{receive} and @syntax{receive-and-return} syntaxes
which define typed syntactic bindings: whenever the syntaxes
@syntax{receive}, @syntax{receive-and-return} are used in code with the
typed language @strong{enabled}: they expand into a uses of
@syntax{receive/checked} and @syntax{receive-and-return/checked}.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Typed syntaxes


@deffn Syntax define/typed @meta{typed-var}
@deffnx Syntax define/typed @meta{typed-var} @meta{expr}
@deffnx Syntax define/typed (@meta{typed-who} . @meta{typed-formals}) . @meta{body}
This is a @syntax{define} syntax variant that supports the typed
language: with expand--time validation, without run--time validation.

When defining a variable: the result of the expression is validated only
at expand--time, to make sure that it matches the type of the variable.
The expression's type must be a sub--type of the variable's type.

When defining a function: the operands and return values are validated
only at expand--time, to make sure that they match the type of the
function's type signature.  The operands' types must be sub--types of
the arguments' types; the return values' types must be sub--types of the
declared signature types.
@end deffn


@deffn Syntax case-define/typed @meta{who-id} @metao{typed-clause} @meta{typed-clause} @dots{}
This is a @syntax{case-define} variant that supports the typed language.
Operands and return values are validated only expand--time, to make sure
that they match the type signature.
@end deffn


@deffn Syntax lambda/typed @meta{typed-clause-formals} . @meta{body}
This is a @syntax{lambda} syntax variant supports the typed language:
with expand--time validation, without run--time validation.

The operands and return values are validated only at expand--time, to
make sure that they match the type of the function's type signature.
The operands' types must be sub--types of the arguments' types; the
return values' types must be sub--types of the declared signature types.
@end deffn


@deffn Syntax named-lambda/typed @meta{name} @meta{typed-clause-formals} . @meta{body}
This is like @syntax{lambda/typed}, but accepts an argument @meta{name}
which must be a syntactic identifier representing the name of the
generated closure object.  In the body of the clauses the quoted name is
bound to the fluid syntax @syntax{__who__}.
@end deffn


@deffn Syntax case-lambda/typed @metao{typed-clause} @meta{typed-clause} @dots{}
This is a @syntax{case-lambda} syntax that supports the typed language:
with expand--time validation, without run--time validation.
@end deffn


@deffn Syntax named-case-lambda/typed @meta{name} @metao{typed-clause} @meta{typed-clause} @dots{}
This is like @syntax{case-lambda/typed}, but accepts an argument
@meta{name} which must be a syntactic identifier representing the name
of the generated closure object.  In the body of the clauses the quoted
name is bound to the fluid syntax @syntax{__who__}.
@end deffn

@c page
@node syntaxes overloads
@section Overloaded functions


@cindex Overloaded functions
@cindex Functions, overloaded


An @dfn{overloaded function} represents an aggregation of functions
linked to the same name and having different number and/or type of
arguments.  For example, in the code:

@lisp
(define/overload (fun @{O <fixnum>@})
  (list 'fixnum O))

(define/overload (fun @{O <string>@})
  (list 'string O))

(define/overload (fun @{A <vector>@} @{B <vector>@})
  (list 'vectors (vector-append A B)))

(fun 123)               @result{} (fixnum 123)
(fun "ciao")            @result{} (string "ciao")
(fun '#(1) '#(2))       @result{} (vectors #(1 2))
@end lisp

@noindent
an overloaded function named @func{fun} is defined by the first use of
@syntax{define/overload}; subsequent uses add new specialisations to the
same function.

In the above example: the selection of the specialised function happens
at expand--time, because the expander can determine the type of the
operands.  Early binding (more precisely: expand--time dispatching) is
available only with the ``canonical'' function application syntax:

@lisp
(@meta{fun} @meta{operand} ...)
@end lisp

Here is an example of late binding (more precisely: run--time
dispatching, or dynamic dispatching):

@lisp
(define/overload (doit @{O <string>@})
  (list 'string O))

(define/overload (doit @{O <fixnum>@})
  (list 'fixnum O))

(map doit '("ciao" 123))
@result{} ((string "ciao") (fixnum 123))
@end lisp

@noindent
putting the overloaded function's syntactic identifier in reference
position will reference a special function that implements dynamic
dispatching.

It is an error to define two specialised functions with the same formals
type signature.  Specialised functions are allowed to have different
type signatures for the returned values, but we should use this feature
with care; it is suggested not to abuse overloaded functions by adding
specialised functions that perform unrelated operations.

We can overload functions only in the same lexical context, the
following code will create @strong{two} functions:

@lisp
(define/overload (fun @{O <fixnum>@})
  ---)

(internal-body
  (define/overload (fun @{O <string>@})
    ---)
  ---)
@end lisp

We can define an overloaded function in a library and then add
specialised functions in a second library which depends on the first
one.

Whenever an overloaded function is applied to a tuple of operands: first
expand--time early binding is attempted; if it fails, run--time late
binding is attempted.  At expand--time:

@enumerate
@item
The expander determines the type of the operands, if it fails a syntax
violation is raised (for example if an operand expression returns
multiple values).

@item
The set of specialised functions is visited and the syntactic identifier
bound to the better matching one is inserted in the code to be applied
to the operands.  The return values of the specialised function will
become the return values of the overloaded function application.

@item
If no matching function is found: code performing late binding is
inserted.  If the option @option{-Woverloaded-function-late-binding} was
used: a @condition{warning} exception is raised signalling failure in
early binding.
@end enumerate

@noindent
At run--time:

@enumerate
@item
The type of the operands is determined using @func{type-descriptor-of},
@ref{descriptors retrieving, type-descriptor-of}.

@item
The set of specialised functions is visited and the better matching one
is applied to the operands.  The return values of the specialised
function become the return values of the overloaded function
application.

@item
If no matching function is found: an exception is raised with type
@condition{overloaded-function-late-binding-error}, @vicareref{iklib
conditions late-bind overload, Overloaded function late binding
conditions}.
@end enumerate

Specialised functions are ranked to select the better matching.  At both
expand--time and run--time, ranking works by iterating a list of
specialised functions:

@enumerate
@item
Get the next function from the list.  When there are no more functions:
if a better matching function was selected, it becomes the one; if no
matching function was found, perform the default action.

@item
If the formals' type signature of the next function is a super--type of
the operands' type signature: the function is the ``next matching one'',
otherwise it is discarded and we iterate to step 1.

@item
If the next matching function is the first in the list: it becomes the
``current better matching'' and we iterate to step 1.

@item
If the formals' type signature of the next matching is a sub--type of
the formals' type signature of the better matching: the next matching
becomes the new better matching; otherwise the old better matching
stands.  We iterate to step 1.
@end enumerate

Here is an example that shows how ranking works:

@lisp
(define/overload (fun @{O <number>@})
  `(number ,O))

(define/overload (fun @{O <real>@})
  `(real ,O))

(define/overload (fun @{O <fixnum>@})
  `(fixnum ,O))

(fun 1+2i)      @result{} (number 1+2i)
(fun 3.4)       @result{} (real   3.4)
(fun 5)         @result{} (fixnum 5)
@end lisp

@noindent
notice that, at expand--time, only the operands' type signature seen by
the expander is the one that matters, with the same definitions above:

@lisp
(fun (cast-signature (<number>) 123))   @result{} (number 123)
(fun (cast-signature (<real>)   123))   @result{} (real   123)
(fun (cast-signature (<fixnum>) 123))   @result{} (fixnum 123)
@end lisp

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax define/overload (@meta{who} . @meta{formals}) . @meta{body}
@deffnx Syntax define/overload ((brace @meta{who} . @meta{rv-types}) . @meta{formals}) . @meta{body}
@deffnx {Auxiliary Syntax} brace
Define a specialisation for the overloaded function @meta{who}.  If this
is the first specialisation for @meta{who}, also define the overloaded
function; otherwise define only the specialisation and register it in
the already existent @meta{who}.

The syntax has the same format of @syntax{define/typed}, it defines a
function with type annotations for both the arguments and the return
values.  The function's type signature is used only at expand--time to
validate the type of the operands used in an application.
@end deffn

@c page
@node syntaxes operations
@section Miscellaneous operations


@value{PRJNAME} allows us to specify special procedures for built--in
Scheme types, record--types and label--types; they are:

@table @strong
@item Type predicates
When applied to a value the type predicate returns @true{} if the value
matches the type; otherwise it returns @false{}.  It is always possible
to use the type predicate with the @syntax{is-a?} syntax,
@pxref{syntaxes predicates, is-a?}.

@item Equality predicates
When applied to two values of the same type: the predicate returns
@true{} if the values are equal; otherwise it returns @false{}.

@item Comparison procedures
When applied to two values @var{A} and @var{B} of the same type, the
procedure returns a fixnum:

@table @samp
@item -1
If @var{A} is less than @var{B}.

@item 0
If @var{A} is equal to @var{B}.

@item +1
If @var{A} is greater than @var{B}.
@end table

@item Hash functions
When applied to an instance of the type: compute and return  a
non--negative fixnum suitable to be used by hashtables.
@end table

The following syntactic bindings are exported by the library
@library{vicare}.


@defmac equality-predicate @meta{type}
Return a function that can be used as equality predicate between
instances of @meta{type}, which must be a type annotation.  If
@meta{type} itself has no equality predicate: traverse the hierarchy of
parents in search of a predicate.  If the hierarchy has no equality
predicate: raise a syntax violation.
@end defmac


@defmac comparison-procedure @meta{type}
Return a function that can be used as comparison procedure between
instances of @meta{type}, which must be a type annotation.  If
@meta{type} itself has no comparison procedure: traverse the hierarchy
of parents in search of a procedure.  If the hierarchy has no comparison
procedure: raise a syntax violation.
@end defmac


@defmac hash-function @meta{type}
Return @false{} or a function that can be used as hash function for
instances of @meta{type}, which must be a type annotation.  If
@meta{type} itself has no hash function: traverse the hierarchy of
parents in search of a function.  If the hierarchy has no hash function:
raise a syntax violation.
@end defmac


@defmac hash @meta{expr}
When the expander succeeds in determining the type of @meta{expr} at
expand--time: if there is a single return value, expand into an
expression that computes and returns a hash value for the return value;
otherwise raise a syntax violation.

When the expander fails to determine the type of @meta{expr} at
expand--time: expand into an expression that attempts, at run--time, to
determine the type of the return value and compute and return a hash
value for it.

The hash function used by this syntax is:

@itemize
@item
For core object--types: the one hard--coded in the object--type
definition; for example: for fixnums it is @func{fixnum-hash}.

@item
For struct--types it is @func{struct-hash}.

@item
For record--types it is the one specified in the record--type definition
with the @syntax{hash-function} clause; when no hash function is
specified, @func{record-hash} is used.
@end itemize
@end defmac

@c page
@node built-in
@chapter Built--in object types


The library @library{vicare} exports keyword syntactic bindings
representing the types of built--in objects: fixnum, strings, vectors,
et cetera.

@menu
* built-in void::         Type of the void object.
* built-in top::          The universal super-type.
* built-in bottom::       The universal sub-type.
* built-in booleans::     Type of boolean objects.
* built-in chars::        Type of character objects.
* built-in symbols::      Type of symbol objects.
* built-in keywords::     Type of keyword objects.
* built-in pointers::     Type of pointer objects.
* built-in transcoders::  Type of transcoder objects.
* built-in procedures::   Type of procedures objects.
* built-in numerics::     Type of numeric objects.
* built-in strings::      Type of string objects.
* built-in vectors::      Type of vector objects.
* built-in lists::        Type of list objects.
* built-in pairs::        Type of pair objects.
* built-in bytevectors::  Type of bytevector objects.
* built-in hashtables::   Type of hashtable objects.
* built-in structs::      Type of struct objects.
* built-in records::      Type of record objects.
* built-in conditions::   Type of condition objects.
* built-in ports::        Types of input/output ports.
* built-in sentinel::     Type of sentinel object.
* built-in time::         Type of time objects.
* built-in misc::         Miscellaneous built-in types.
@end menu

@c page
@node built-in void
@section The type of the void value


The type @class{void} is the type of the void object returned by
@func{void}.  We should never use @class{void} in a type annotation,
because the only legitimate use of the void object is as single return
value of functions returning ``unspecified values'' (under
@value{PRJNAME} returning a single value is faster than returning zero
values).  If we need a unique value: we should use the sentinel value,
@vicarepxref{iklib sentinel, The sentinel object}.

Expressions of type @class{void} are deprecated as operands in function
applications and forbidden in logic predicates.  For example:

@lisp
(display (vector-set! (vector 1) 0 2))
@end lisp

@noindent
raises an exception because @func{vector-set!} returns the void value.
The type @class{void} has no parent (it is @strong{not} a sub--type of
@class{top}) and it should be like not--a--number for numeric
computations.  Here are some consequences when the expander can
determine the type of an operand:

@itemize
@item
Composing @class{void} with other types results in void:

@lisp
(type-annotation-syntax (or <fixnum> <void>))
@result{} <void>

(type-annotation-syntax (and <fixnum> <void>))
@result{} <void>

(type-annotation-syntax (not <void>))
@result{} <void>
@end lisp

@item
A void expression as operand of @syntax{and}, @syntax{or}, @syntax{xor}
and test of @syntax{if} will cause an expand--time syntax violation.

@item
A void expression as operand of @syntax{not} will cause an expand--time
syntax violation.

@item
Remembering that @syntax{cond} and @syntax{case} return void when no
@clause{else} clause is present and no clause matches: when
@syntax{cond} or @syntax{case} are used as operands, an @syntax{else}
clause is mandatory.

@item
Remembering that @syntax{when} and @syntax{unless} return void when the
body is not evaluated: @syntax{when} and @syntax{unless} cannot be used
as operands.

@item
Uses of the syntax @syntax{set!} cannot be operand expressions.
@end itemize

The only function that is allowed to have a void operand is the core
primitive @func{void-object?}.


@deftp {Core Type} @aclass{void}
The type of the void object.  @class{void} has no parent type.  The
union and intersection between @class{void} and any other type is
@class{void} itself.
@end deftp


@deftypeop Constructor @class{void} @aclass{void} type-constructor
Return the void object.
@end deftypeop


@deftypeop {Type predicate} @class{void} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{void-object?}.  Return @true{} if @var{obj}
is void; otherwise return @false{}.
@end deftypeop

@c page
@node built-in top
@section The universal super--type


@deftp {Core Type} @aclass{top}
The conventional parent of all the types, with the exception of
@class{void}.
@end deftp


@deftypeop Constructor @class{top} @aclass{top} type-constructor @var{obj}
Return @var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{top} @aclass{true} type-predicate @var{obj}
Always return @true{}.
@end deftypeop

@c page
@node built-in bottom
@section The universal sub--type


@deftp {Core Type} @aclass{bottom}
A conventional type that is the sub--type of all the other types.

We must never use @class{bottom} as type annotation for variables,
because no value is of this type:

@lisp
(define @{O <bottom>@}
  123)
@error{} &expand-time-type-signature-violation

(let ((@{O <bottom>@} 123))
  O)
@error{} &expand-time-type-signature-violation
@end lisp

@noindent
casting to @class{bottom} also fails:

@lisp
(cast-signature (<bottom>) 123)
@error{} &expand-time-type-signature-violation

(unsafe-cast-signature (<bottom>) 123)
@error{} &expand-time-type-signature-violation
@end lisp

The expressions that raise a non--continuable exception have type
@class{bottom}:

@lisp
(type-of (error #f "wrong"))
@result{} #[signature <bottom>]
@end lisp

@noindent
notice that the type signature is the improper list @code{<bottom>},
@strong{not} the list @code{(<bottom>)}.

As usage example, the following type annotation defines a function
signature in which the argument can be any value:

@lisp
(define-type <my-func>
  (lambda (<bottom>) => (<string>)))
@end lisp

@class{bottom} is removed from union and intersection type annotations:

@lisp
(type-annotation (and <bottom> <fixnum>))
@result{} #[core-type-spec #[type (<fixnum>)]]

(type-annotation (or  <bottom> <fixnum>))
@result{} #[core-type-spec #[type (<fixnum>)]]
@end lisp
@end deftp

@c page
@node built-in booleans
@section Type of boolean values


@menu
* built-in booleans boolean::     Type of boolean values.
* built-in booleans true::        Type of true booleans.
* built-in booleans false::       Type of false booleans.
@end menu

@c page
@node built-in booleans boolean
@subsection Type of boolean values


@deftp {Core Type} @class{boolean}
@deftpx {Parent Type} @class{top}
Type of the boolean values @true{} and @false{}.
@end deftp


@deftypeop Constructor @class{boolean} @aclass{boolean} type-constructor @var{obj}
Return @true{} if @var{obj} is true; otherwise return @false{}.

@lisp
(new <boolean> #f)      @result{} #f
(new <boolean> #t)      @result{} #t
(new <boolean> 12)      @result{} #t
@end lisp
@end deftypeop


@deftypeop {Type predicate} @class{boolean} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{boolean?}.  Return @true{} if @var{obj} is
@true{} or @false{}; otherwise return @false{}.

@lisp
(is-a? #t <boolean>)    @result{} #t
(is-a? #f <boolean>)    @result{} #t
(is-a? 12 <boolean>)    @result{} #f
@end lisp
@end deftypeop


@deftypeop {Hash function} @class{boolean} @aclass{non-negative-fixnum} hash-function @var{bool}
The hash function is @func{boolean-hash}.

@lisp
(hash #f)       @result{} 0
(hash #t)       @result{} 1
@end lisp
@end deftypeop

@c page
@node built-in booleans true
@subsection Type of true booleans


@deftp {Core Type} @class{true}
@deftpx {Parent Type} @class{boolean}
Type of the boolean value @true{}.
@end deftp


@deftypeop Constructor @class{true} @aclass{true} type-constructor @var{obj}
Return @true{} if @var{obj} is @true{}.

@lisp
(new <true> #t)         @result{} #t
(new <true> 12)         @error{} type violation
@end lisp
@end deftypeop


@deftypeop {Type predicate} @class{true} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{true?}.  Return @true{} if @var{obj} is
@true{}.

@lisp
(is-a? #t <true>)       @result{} #t
(is-a? #f <true>)       @error{} type error
@end lisp
@end deftypeop


@deftypeop {Hash function} @class{true} @aclass{non-negative-fixnum} hash-function @var{true}
The hash function is @func{boolean-hash}.

@lisp
(hash #t)       @result{} 1
@end lisp
@end deftypeop

@c page
@node built-in booleans false
@subsection Type of false booleans


@deftp {Core Type} @aclass{false}
@deftpx {Parent Type} @aclass{boolean}
Type of the boolean value @false{}.
@end deftp


@deftypeop Constructor @class{false} @aclass{false} type-constructor @var{obj}
Return @false{} if @var{obj} is @false{}.

@lisp
(new <false> #f)         @result{} #f
(new <false> 12)         @error{} type violation
@end lisp
@end deftypeop


@deftypeop {Type predicate} @class{false} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{false?}.  Return @false{} if @var{obj} is
@false{}.

@lisp
(is-a? #f <false>)       @result{} #f
(is-a? #t <false>)       @error{} type error
@end lisp
@end deftypeop


@deftypeop {Hash function} @class{false} @aclass{non-negative-fixnum} hash-function @var{false}
The hash function is @func{boolean-hash}.

@lisp
(hash #f)       @result{} 0
@end lisp
@end deftypeop


@c page
@node built-in chars
@section Type of character values


@deftp {Core Type} @aclass{char}
@deftpx {Parent Type} @aclass{top}
Type of character values.
@end deftp


@deftypeop Constructor @class{char} @aclass{char} type-constructor @bracearg{fx, non-negative-fixnum}
The constructor is @func{integer->char}.

@lisp
(new <char> 65)         @result{} #\A
@end lisp
@end deftypeop


@deftypeop {Type predicate} @class{char} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{char?}.  Return @true{} if @var{obj} is a
character object; otherwise return @false{}.

@lisp
(is-a? #\A <char>)      @result{} #t
(is-a? 123 <char>)      @result{} #f
@end lisp
@end deftypeop


@deftypeop {Hash function} @class{char} @aclass{non-negative-fixnum} hash-function @var{ch}
The hash function is @func{char-hash}.

@lisp
(hash #\A)      @result{} 65
@end lisp
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods


@deftypemethod @class{char} @aclass{string} string @var{this}
Apply @func{string} to the instance.

@lisp
(.string #\A)   @result{} "A"
@end lisp
@end deftypemethod


@deftypemethod @class{char} @aclass{non-negative-fixnum} integer @var{this}
Apply @func{char->integer} to the instance.

@lisp
(.integer #\A)  @result{} 65
@end lisp
@end deftypemethod


@deftypemethod @class{char} @aclass{non-negative-fixnum} fixnum @var{this}
Apply @func{char->fixnum} to the instance.

@lisp
(.fixnum #\A)   @result{} 65
@end lisp
@end deftypemethod

@c ------------------------------------------------------------------------

@deftypemethod @class{char} @aclass{boolean} = @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} != @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char!=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} < @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char<?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} > @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char>?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} <= @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char<=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} >= @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char>=?} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@deftypemethod @class{char} @aclass{boolean} ci= @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char-ci=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} ci!= @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char-ci!=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} ci< @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char-ci<?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} ci> @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char-ci>?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} ci<= @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char-ci<=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} ci>= @var{this} @braceargo{ch, char} @bracearg{ch, char} @dots{}
Apply @func{char-ci>=?} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@deftypemethod @class{char} @aclass{char} min @var{this} @bracearg{ch, char} @dots{}
Apply @func{chmin} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{char} max @var{this} @bracearg{ch, char} @dots{}
Apply @func{chmax} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@deftypemethod @class{char} @aclass{char} downcase @var{this}
Apply @func{char-downcase} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{char} foldcase @var{this}
Apply @func{char-foldcase} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{char} titlecase @var{this}
Apply @func{char-titlecase} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{char} upcase @var{this}
Apply @func{char-upcase} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{symbol} general-category @var{this}
Apply @func{char-general-category} to the argument and return its return
value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} alphabetic? @var{this}
Apply @func{char-alphabetic?} to the argument and return its return
value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} lower-case? @var{this}
Apply @func{char-lower-case?} to the argument and return its return
value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} numeric? @var{this}
Apply @func{char-numeric?} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} title-case? @var{this}
Apply @func{char-title-case?} to the argument and return its return
value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} upper-case? @var{this}
Apply @func{char-upper-case?} to the argument and return its return
value.
@end deftypemethod


@deftypemethod @class{char} @aclass{boolean} whitespace? @var{this}
Apply @func{char-whitespace?} to the argument and return its return
value.
@end deftypemethod

@c page
@node built-in symbols
@section Type of symbol values


@menu
* built-in symbols symbols::    The @class{symbol} object-type.
* built-in symbols gensyms::    The @class{gensym} object-type.
@end menu

@c page
@node built-in symbols symbols
@subsection The @class{symbol} object--type


@deftp {Core Type} @aclass{symbol}
@deftpx {Parent Type} @aclass{top}
Type of symbol values (including gensyms).
@end deftp


@deftypeop Constructor @class{symbol} @aclass{symbol} type-constructor @bracearg{S, string}
The constructor is @func{string->symbol}.
@end deftypeop


@deftypeop {Type predicate} @class{symbol} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{symbol?}.  Return @true{} if @var{obj} is a
symbol object; otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{symbol} @aclass{non-negative-fixnum} hash-function @var{sym}
The hash function is @func{symbol-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods


@deftypemethod @class{symbol} @aclass{string} string @var{this}
Apply @func{symbol->string} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{boolean} bound? @var{this}
Apply @func{symbol-bound?} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{top} value @var{this}
@deftypemethodx @class{symbol} @aclass{void} value @var{this} @var{new-value}
When called with no arguments: apply @func{symbol-value} to the instance
to retrieve the current value in the @code{value} slot.  When called
with one argument: apply @func{set-symbol-value!} to the instance to
store a new value @code{value} slot.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: comparison


@deftypemethod @class{symbol} @aclass{boolean} = @var{this} @braceargo{sym, symbol} @bracearg{sym, symbol} @dots{}
Apply @func{symbol=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{boolean} != @var{this} @braceargo{sym, symbol} @bracearg{sym, symbol} @dots{}
Apply @func{symbol!=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{boolean} < @var{this} @braceargo{sym, symbol} @bracearg{sym, symbol} @dots{}
Apply @func{symbol<?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{boolean} > @var{this} @braceargo{sym, symbol} @bracearg{sym, symbol} @dots{}
Apply @func{symbol>?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{boolean} <= @var{this} @braceargo{sym, symbol} @bracearg{sym, symbol} @dots{}
Apply @func{symbol<=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{boolean} >= @var{this} @braceargo{sym, symbol} @bracearg{sym, symbol} @dots{}
Apply @func{symbol>=?} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@deftypemethod @class{symbol} @aclass{symbol} min @var{this} @bracearg{sym, symbol} @dots{}
Apply @func{symbol-min} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{symbol} max @var{this} @bracearg{sym, symbol} @dots{}
Apply @func{symbol-max} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: property lists


@deftypemethod @class{symbol} @aclass{void} putprop @var{this} (@var{key} @aclass{symbol}) @var{value}
Apply @func{putprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{top} getprop @var{this} (@var{key} @aclass{symbol})
Apply @func{getprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{void} remprop @var{this} (@var{key} @aclass{symbol})
Apply @func{remprop} to the instance.
@end deftypemethod


@deftypemethod @class{symbol} @aclass{list} property-list @var{this}
Apply @func{property-list} to the instance.
@end deftypemethod

@c page
@node built-in symbols gensyms
@subsection The @class{gensym} object--type


@deftp {Core Type} @aclass{gensym}
@deftpx {Parent Type} @aclass{symbol}
Type of gensym values.
@end deftp


@deftypeop Constructor @class{gensym} @aclass{gensym} type-constructor
@deftypeopx Constructor @class{gensym} @aclass{gensym} type-constructor @var{string}
@deftypeopx Constructor @class{gensym} @aclass{gensym} type-constructor @var{symbol}
The constructor is @func{gensym}.
@end deftypeop


@deftypeop {Type predicate} @class{gensym} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{gensym?}.  Return @true{} if @var{obj} is a
gensym object; otherwise return @false{}.
@end deftypeop

@c page
@node built-in keywords
@section Type of keyword values


@deftp {Core Type} @aclass{keyword}
@deftpx {Parent Type} @aclass{top}
Type of keyword values.
@end deftp


@deftypeop Constructor @class{keyword} @aclass{keyword} type-constructor @var{symbol}
The constructor is @func{symbol->keyword}.
@end deftypeop


@deftypeop {Type predicate} @class{keyword} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{keyword?}.  Return @true{} if @var{obj} is a
keyword object; otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{keyword} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{keyword-hash}.
@end deftypeop


@deftypeop {Equality predicate} @class{keyword} @aclass{boolean} equality-predicate @var{this} @bracearg{K, keyword}
The equality predicate is @func{keyword=?}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods


@deftypemethod @class{keyword} @aclass{symbol} symbol @var{this}
Apply @func{keyword->symbol} to the instance.
@end deftypemethod


@deftypemethod @class{keyword} @aclass{string} string @var{this}
Apply @func{keyword->string} to the instance.
@end deftypemethod

@c page
@node built-in pointers
@section Type of pointer values


@deftp {Core Type} @aclass{pointer}
@deftpx {Parent Type} @class{top}
Type of pointer values.
@end deftp


@deftypeop Constructor @class{pointer} @aclass{pointer} type-constructor @bracearg{addr, non-negative-exact-integer}
The constructor is @func{integer->pointer}.
@end deftypeop


@deftypeop {Type predicate} @class{pointer} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{pointer?}.  Return @true{} if @var{obj} is a
pointer object; otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{pointer} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{pointer-hash}.
@end deftypeop


@deftypeop {Equality predicate} @class{pointer} @aclass{boolean} equality-predicate @var{this} @bracearg{K, pointer}
The equality predicate is @func{pointer=?}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods


@deftypemethod @class{pointer} @aclass{boolean} null? @var{this}
Apply @func{pointer-null?} to the instance.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{exact-integer} integer @var{this}
Apply @func{pointer->integer} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: comparison


@deftypemethod @class{pointer} @aclass{boolean} = @var{this} @braceargo{ptr, pointer} @bracearg{ptr, pointer} @dots{}
Apply @func{pointer=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} != @var{this} @braceargo{ptr, pointer} @bracearg{ptr, pointer} @dots{}
Apply @func{pointer!=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} < @var{this} @braceargo{ptr, pointer} @bracearg{ptr, pointer} @dots{}
Apply @func{pointer<?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} > @var{this} @braceargo{ptr, pointer} @bracearg{ptr, pointer} @dots{}
Apply @func{pointer>?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} <= @var{this} @braceargo{ptr, pointer} @bracearg{ptr, pointer} @dots{}
Apply @func{pointer<=?} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{boolean} >= @var{this} @braceargo{ptr, pointer} @bracearg{ptr, pointer} @dots{}
Apply @func{pointer>=?} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: arithmetics


@deftypemethod @class{pointer} @aclass{pointer} add @var{this} @bracearg{diff, exact-integer}
Apply @func{pointer-add} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} diff @var{this} @bracearg{P, pointer}
Apply @func{pointer-diff} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{pointer} clone @var{this}
Apply @func{pointer-clone} to the instance and return its return value.
@end deftypemethod


@deftypemethod @class{pointer} @aclass{void} set-null! @var{this}
Apply @func{set-pointer-null!} to the instance.
@end deftypemethod

@c page
@node built-in transcoders
@section Type of transcoder values


@deftp {Core Type} @aclass{transcoder}
@deftpx {Parent Type} @aclass{top}
Type of transcoder values.
@end deftp


@deftypeop Constructor @class{transcoder} @aclass{transcoder} type-constructor @var{codec}
@deftypeopx Constructor @class{transcoder} @aclass{transcoder} type-constructor @var{codec} @var{eol-style}
@deftypeopx Constructor @class{transcoder} @aclass{transcoder} type-constructor @var{codec} @var{eol-style} @var{handling-mode}
The constructor is @func{make-transcoder}.
@end deftypeop


@deftypeop {Type predicate} @class{transcoder} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{transcoder?}.  Return @true{} if @var{obj}
is a transcoder object; otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{transcoder} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{transcoder-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods


@deftypemethod @class{transcoder} @aclass{symbol} codec @var{this}
Apply @func{transcoder-codec} to the instance and return its return
value.
@end deftypemethod


@deftypemethod @class{transcoder} @aclass{symbol} eol-style @var{this}
Apply @func{transcoder-eol-style} to the instance and return its return
value.
@end deftypemethod


@deftypemethod @class{transcoder} @aclass{symbol} handling-mode @var{this}
Apply @func{transcoder-error-handling-mode} to the instance and return
its return value.
@end deftypemethod

@c page
@node built-in procedures
@section Type of procedures values


@menu
* built-in procedures procedures::       The @class{procedure} object-type.
* built-in procedures thunk::            The @class{thunk} object-type.
* built-in procedures type-predicate::   The @class{type-predicate} object-type.
* built-in procedures type-destructor::  The @class{type-destructor} object-type.
* built-in procedures type-printer::     The @class{type-printer} object-type.
* built-in procedures equality-predicate:: The @class{equality-predicate} object-type.
* built-in procedures comparison-procedure:: The @class{comparison-procedure} object-type.
* built-in procedures hash-function::    The @class{hash-function} object-type.
* built-in procedures type-method-retriever:: The @class{type-method-retriever} object-type.
@end menu

@c page
@node built-in procedures procedures
@subsection The @class{procedure} object--type


@deftp {Core Type} @aclass{procedure}
@deftpx {Parent Type} @aclass{top}
Type of closure object values.  There is no constructor.
@end deftp


@deftypeop {Type predicate} @class{procedure} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{procedure?}.  Return @true{} if @var{obj} is
a closure object; otherwise return @false{}.
@end deftypeop

@c page
@node built-in procedures thunk
@subsection The @class{thunk} object--type


@deftp {Type Annotation} @aclass{thunk}
Type of procedures accepting no arguments.  The definition of this type
is equivalent to:

@lisp
(define-type <thunk>
  (lambda () => <list>))
@end lisp
@end deftp

@c page
@node built-in procedures type-predicate
@subsection The @class{type-predicate} object--type


@deftp {Type Annotation} @aclass{type-predicate}
Type of procedures acting as type predicates.  The definition of this
type is equivalent to:

@lisp
(define-type <type-predicate>
  (lambda (<top>) => (<boolean>)))
@end lisp
@end deftp

@c page
@node built-in procedures type-destructor
@subsection The @class{type-destructor} object--type


@deftp {Type Annotation} @aclass{type-destructor}
Type of procedures acting as destructors for object of a specified type.
The definition of this type is equivalent to:

@lisp
(define-type <type-destructor>
  (lambda (<top>) => <list>))
@end lisp
@end deftp

@c page
@node built-in procedures type-printer
@subsection The @class{type-printer} object--type


@deftp {Type Annotation} @aclass{type-printer}
Type of procedures acting as custom printers for object of a specified
type.  The definition of this type is equivalent to:

@lisp
(define-type <type-printer>
  (lambda (<bottom> <textual-output-port> <procedure>) => <list>))
@end lisp
@end deftp

@c page
@node built-in procedures equality-predicate
@subsection The @class{equality-predicate} object--type


@deftp {Type Annotation} @aclass{equality-predicate}
Type of procedures acting as equality predicates.  The definition of
this type is equivalent to:

@lisp
(define-type <equality-predicate>
  (lambda (<bottom> <bottom>) => (<boolean>)))
@end lisp
@end deftp

@c page
@node built-in procedures comparison-procedure
@subsection The @class{comparison-procedure} object--type


@deftp {Type Annotation} @aclass{comparison-procedure}
Type of procedures acting as equality predicates.  The definition of
this type is equivalent to:

@lisp
(define-type <comparison-procedure>
  (lambda (<bottom> <bottom>) => (<fixnum>)))
@end lisp
@end deftp

@c page
@node built-in procedures hash-function
@subsection The @class{hash-function} object--type


@deftp {Type Annotation} @aclass{hash-function}
Type of procedures acting as equality predicates.  The definition of
this type is equivalent to:

@lisp
(define-type <hash-function>
  (lambda (<bottom>) => (<non-negative-fixnum>)))
@end lisp
@end deftp

@c page
@node built-in procedures type-method-retriever
@subsection The @class{type-method-retriever} object-type


@deftp {Type Annotation} @aclass{type-method-retriever}
Type of procedures acting as run--time method retriever for object of a
specified type.  The definition of this type is equivalent to:

@lisp
(define-type <type-method-retriever>
  (lambda (<symbol>) => ((or <false> <procedure>))))
@end lisp
@end deftp

@c page
@node built-in numerics
@section Type of numeric values


@menu
* built-in numerics number::           Type of number values.
* built-in numerics complex::          Type of complex values.
* built-in numerics real-valued::      Type of real-valued values.
* built-in numerics real::             Type of real values.
* built-in numerics rational-valued::  Type of rational-valued values.
* built-in numerics rational::         Type of rational values.
* built-in numerics integer-valued::   Type of integer-valued values.
* built-in numerics integer::          Type of integer values.
* built-in numerics exact-integer::    Type of exact-integer values.
* built-in numerics fixnums::          Type of fixnum values.
* built-in numerics bignums::          Type of bignum values.
* built-in numerics flonums::          Type of flonum values.
* built-in numerics ratnums::          Type of ratnum values.
* built-in numerics compnums::         Type of compnum values.
* built-in numerics cflonums::         Type of cflonum values.
* built-in numerics bytes::            Type of byte values.
* built-in numerics octets::           Type of octet values.
* built-in numerics exactness::        Exactness of numeric values.
* built-in numerics sign::             Sign of numeric values.
@end menu

@c page
@node built-in numerics number
@subsection Type of number values


@deftp {Core Type} @aclass{number}
@deftpx {Parent Type} @aclass{top}
Type of numeric values.
@end deftp


@deftypeop Constructor @class{number} @aclass{number} type-constructor @var{Z}
Validate @var{Z} as number object and return @var{Z} itself.  If @var{Z}
is not a @class{number}: raise and exception.
@end deftypeop


@deftypeop {Type predicate} @class{number} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{number?}.  Return @true{} if @var{obj} is a
@class{number} object, otherwise return @false{}.
@end deftypeop


@deftypeop {Equality predicate} @class{number} @aclass{boolean} equality-predicate @var{this} @bracearg{Z, number}
The equality predicate is @func{=}.
@end deftypeop


@deftypeop {Hash function} @class{number} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{number-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods: predicates


@deftypemethod @class{number} @aclass{boolean} zero? @var{this}
Apply @func{zero?} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{boolean} nan? @var{this}
Apply @func{nan?} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{boolean} finite? @var{this}
@deftypemethodx @class{number} @aclass{boolean} infinite? @var{this}
Apply @func{finite?}, @func{infinite?} to the argument and return its
return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{boolean} odd? @var{this}
@deftypemethodx @class{number} @aclass{boolean} even? @var{this}
Apply @func{odd?}, @func{even?} to the argument and return its return
value.
@end deftypemethod


@c ------------------------------------------------------------------------

@subsubheading Methods: exactness


@deftypemethod @class{number} @aclass{number} exact @var{this}
Apply @func{exact} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} inexact @var{this}
Apply @func{inexact} to the argument and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: complex numbers


@deftypemethod @class{number} @aclass{real} magnitude @var{this}
Apply @func{magnitude} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{real} angle @var{this}
Apply @func{angle} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{real} real-part @var{this}
Apply @func{real-part} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{real} imag-part @var{this}
Apply @func{imag-part} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} complex-conjugate @var{this}
Apply @func{complex-conjugate} to the argument and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: comparison


@deftypemethod @class{number} @aclass{boolean} = @var{this} @bracearg{Z, number} @dots{}
Apply @func{=} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{boolean} != @var{this} @bracearg{Z, number} @dots{}
Apply @func{!=} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: arithmetics


@deftypemethod @class{number} @aclass{number} + @var{this} @bracearg{Z, number} @dots{}
Apply @func{+} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} - @var{this} @bracearg{Z, number} @dots{}
Apply @func{-} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} * @var{this} @bracearg{Z, number} @dots{}
Apply @func{*} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} / @var{this} @bracearg{Z, number} @dots{}
Apply @func{/} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} add1 @var{this}
Apply @func{add1} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} sub1 @var{this}
Apply @func{sub1} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: exponentiation and logarithms


@deftypemethod @class{number} @aclass{number} exp @var{this}
Apply @func{exp} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} log @var{this}
@deftypemethodx @class{number} @aclass{number} log @var{this} @bracearg{Z, number}
Apply @func{log} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} expt @var{this} @bracearg{Z, number}
Apply @func{expt} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} square @var{this}
Apply @func{square} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} cube @var{this}
Apply @func{cube} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} sqrt @var{this}
Apply @func{sqrt} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} cbrt @var{this}
Apply @func{cbrt} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: trigonometric functions


@deftypemethod @class{number} @aclass{number} sin @var{this}
@deftypemethodx @class{number} @aclass{number} cos @var{this}
@deftypemethodx @class{number} @aclass{number} tan @var{this}
Apply @func{sin}, @func{cos}, @func{tan} to the argument and return its
return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} asin @var{this}
@deftypemethodx @class{number} @aclass{number} acos @var{this}
@deftypemethodx @class{number} @aclass{number} atan @var{this}
@deftypemethodx @class{number} @aclass{number} atan @var{this} @bracearg{Z, number}
Apply @func{asin}, @func{acos}, @func{atan} to the argument and return
its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: hyperbolic functions


@deftypemethod @class{number} @aclass{number} sinh @var{this}
@deftypemethodx @class{number} @aclass{number} cosh @var{this}
@deftypemethodx @class{number} @aclass{number} tanh @var{this}
Apply @func{sinh}, @func{cosh}, @func{tanh} to the argument and return
its return value.
@end deftypemethod


@deftypemethod @class{number} @aclass{number} asinh @var{this}
@deftypemethodx @class{number} @aclass{number} acosh @var{this}
@deftypemethodx @class{number} @aclass{number} atanh @var{this}
Apply @func{asinh}, @func{acosh}, @func{atanh} to the argument and
return its return value.
@end deftypemethod

@c page
@node built-in numerics complex
@subsection Type of complex values


@deftp {Core Type} @aclass{complex}
@deftpx {Parent Type} @aclass{number}
Type of complex numbers.
@end deftp


@deftypeop Constructor @class{complex} @aclass{complex} type-constructor @var{re} @var{im}
Apply @func{make-rectangular} to the arguments and return its return
value.
@end deftypeop


@deftypeop {Type predicate} @class{complex} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{complex?}.  Return @true{} if @var{obj} is a
@class{complex} object, otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics real-valued
@subsection Type of real--valued values


@deftp {Core Type} @aclass{real-valued}
@deftpx {Parent Type} @aclass{complex}
Type of real--valued values.
@end deftp


@deftypeop Constructor @class{real-valued} @aclass{real-valued} type-constructor @var{obj}
Validate @var{obj} as object of type @class{real-valued} and return it.
@end deftypeop


@deftypeop {Type predicate} @class{real-valued} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{real-valued?}.  Return @true{} if @var{obj}
is a @class{real-valued} object, otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics real
@subsection Type of real values


@menu
* built-in numerics real base::         The @class{real} type.
* built-in numerics real positive::     The @class{positive-real} type.
* built-in numerics real negative::     The @class{negative-real} type.
* built-in numerics real zero::         The @class{zero-real} type.
* built-in numerics real non-zero::     The @class{non-zero-real} type.
* built-in numerics real non-negative:: The @class{non-negative-real} type.
@end menu

@c page
@node built-in numerics real base
@subsubsection The @class{real} type


@deftp {Core Type} @aclass{real}
@deftpx {Parent Type} @aclass{real-valued}
Type of real values.  There is no constructor.  The type predicate is
@func{real?}.
@end deftp


@deftypeop Constructor @class{real} @aclass{real} type-constructor @var{obj}
Validate @var{obj} as object of type @class{real} and return it.
@end deftypeop


@deftypeop {Type predicate} @class{real} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{real?}.  Return @true{} if @var{obj} is a
@class{real} object, otherwise return @false{}.
@end deftypeop


@deftypeop {Comparison procedure} @class{real} @aclass{fixnum} comparison-procedure @var{this} @bracearg{X, real}
The comparison procedure is @func{compar-real}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods: predicates


@deftypemethod @class{real} @aclass{boolean} positive? @var{this}
@deftypemethodx @class{real} @aclass{boolean} negative? @var{this}
Apply @func{positive?}, @func{negative?} to the argument and return its
return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{boolean} non-positive? @var{this}
@deftypemethodx @class{real} @aclass{boolean} non-negative? @var{this}
Apply @func{non-positive?}, @func{non-negative?} to the argument and
return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: comparison


@deftypemethod @class{real} @aclass{boolean} < @var{this} @braceargo{Z, real} @bracearg{Z, real} @dots{}
Apply @func{<} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{boolean} > @var{this} @braceargo{Z, real} @bracearg{Z, real} @dots{}
Apply @func{>} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{boolean} <= @var{this} @braceargo{Z, real} @bracearg{Z, real} @dots{}
Apply @func{<=} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{boolean} <= @var{this} @braceargo{Z, real} @bracearg{Z, real} @dots{}
Apply @func{<=} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods


@deftypemethod @class{real} @aclass{non-negative-real} abs @var{this}
Apply @func{abs} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{real} numerator @var{this}
Apply @func{numerator} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{real} denominator @var{this}
Apply @func{denominator} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{real} sign @var{this}
Apply @func{sign} to the argument and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: rounding


@deftypemethod @class{real} @aclass{real} floor @var{this}
Apply @func{floor} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{real} ceiling @var{this}
Apply @func{ceiling} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{real} truncate @var{this}
Apply @func{truncate} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{real} round @var{this}
Apply @func{round} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{real} @aclass{real} rationalize @var{this} @bracearg{X, real}
Apply @func{rationalize} to the arguments and return its return value.
@end deftypemethod

@c page
@node built-in numerics real positive
@subsubsection The @class{positive-real} type


@deftp {Core Type} @aclass{positive-real}
Type of positive real values.  Its definition is equivalent to:

@lisp
(define-type <positive-real>
  (or <positive-fixnum> <positive-bignum> <positive-flonum>))
@end lisp
@end deftp

@c page
@node built-in numerics real negative
@subsubsection The @class{negative-real} type


@deftp {Core Type} @aclass{negative-real}
Type of negative real values.  Its definition is equivalent to:

@lisp
(define-type <negative-real>
  (or <negative-fixnum> <negative-bignum> <negative-flonum>))
@end lisp
@end deftp

@c page
@node built-in numerics real zero
@subsubsection The @class{zero-real} type


@deftp {Core Type} @aclass{zero-real}
Type of zero real values.  Its definition is equivalent to:

@lisp
(define-type <zero-real>
  (or <zero-fixnum> <zero-flonum>))
@end lisp
@end deftp

@c page
@node built-in numerics real non-zero
@subsubsection The @class{non-zero-real} type


@deftp {Core Type} @aclass{non-zero-real}
Type of non--zero real values.  Its definition is equivalent to:

@lisp
(define-type <non-zero-real>
  (or <non-zero-fixnum> <bignum> <non-zero-flonum>))
@end lisp
@end deftp

@c page
@node built-in numerics real non-negative
@subsubsection The @class{non-negative-real} type


@deftp {Core Type} @aclass{non-negative-real}
Type of non--negative real values.  Its definition is equivalent to:

@lisp
(define-type <non-negative-real>
  (or <non-negative-fixnum> <positive-bignum> <positive-flonum>))
@end lisp
@end deftp

@c page
@node built-in numerics rational-valued
@subsection Type of rational--valued values


@deftp {Core Type} @aclass{rational-valued}
@deftpx {Parent Type} @aclass{real}
Type of rational--valued values.
@end deftp


@deftypeop Constructor @class{rational-valued} @aclass{rational-valued} type-constructor @var{obj}
Validate @var{obj} as object of type @class{rational-valued} and return it.
@end deftypeop


@deftypeop {Type predicate} @class{rational-valued} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{rational-valued?}.  Return @true{} if
@var{obj} is a @class{rational-valued} object, otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics rational
@subsection Type of rational values


@menu
* built-in numerics rational base::          The @class{rational} type.
* built-in numerics rational exact::         The @class{exact-rational} type.
* built-in numerics rational non-negative::  The @class{non-negative-exact-rational} type.
* built-in numerics rational non-zero::      The @class{non-zero-exact-rational} type.
@end menu

@c page
@node built-in numerics rational base
@subsubsection The @class{rational} type


@deftp {Core Type} @aclass{rational}
@deftpx {Parent Type} @aclass{rational-valued}
Type of rational values.
@end deftp


@deftypeop Constructor @class{rational} @aclass{rational} type-constructor @var{obj}
Validate @var{obj} as object of type @class{rational} and return it.
@end deftypeop


@deftypeop {Type predicate} @class{rational} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{rational?}.  Return @true{} if @var{obj} is
a @class{rational} object, otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics rational exact
@subsubsection The @class{exact-rational} type


@deftp {Core Type} @aclass{exact-rational}
Type of exact rational values.  Its definition is equivalent to:

@lisp
(define-type <exact-rational>
  (or <exact-integer> <ratnum>))
@end lisp
@end deftp

@c page
@node built-in numerics rational non-negative
@subsubsection The @class{non-negative-exact-rational} type


@deftp {Core Type} @aclass{non-negative-exact-rational}
Type of non--negative exact rational values.  Its definition is
equivalent to:

@lisp
(define-type <non-negative-exact-rational>
  (or <non-negative-exact-integer> <positive-ratnum>))
@end lisp
@end deftp

@c page
@node built-in numerics rational non-zero
@subsubsection The @class{non-zero-exact-rational} type


@deftp {Core Type} @aclass{non-zero-exact-rational}
Type of non--zero exact rational values.  Its definition is equivalent
to:

@lisp
(define-type <non-zero-exact-rational>
  (or <non-zero-exact-integer> <ratnum>))
@end lisp
@end deftp

@c page
@node built-in numerics integer-valued
@subsection Type of integer--valued values


@deftp {Core Type} @aclass{integer-valued}
@deftpx {Parent Type} @aclass{rational-valued}
Type of integer--valued values.
@end deftp


@deftypeop Constructor @class{integer-valued} @aclass{integer-valued} type-constructor @var{obj}
Validate @var{obj} as object of type @class{integer-valued} and return
it.
@end deftypeop


@deftypeop {Type predicate} @class{integer-valued} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{integer-valued?}.  Return @true{} if
@var{obj} is a @class{integer-valued} object, otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics integer
@subsection Type of integer values


@deftp {Core Type} @aclass{integer}
@deftpx {Parent Type} @aclass{rational}
Type of integer values.
@end deftp


@deftypeop Constructor @class{integer} @aclass{integer} type-constructor @var{obj}
Validate @var{obj} as object of type @class{integer} and return it.
@end deftypeop


@deftypeop {Type predicate} @class{integer} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{integer?}.  Return @true{} if @var{obj} is a
@class{integer} object, otherwise return @false{}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods


@deftypemethod @class{integer} @aclass{integer} gcd @var{this} @bracearg{X, integer} @dots{}
Apply @func{gcd} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{integer} @aclass{integer} lcm @var{this} @bracearg{X, integer} @dots{}
Apply @func{lcm} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{integer} @aclass{integer} quotient @var{this} @bracearg{X, integer}
Apply @func{quotient} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{integer} @aclass{integer} remainder @var{this} @bracearg{X, integer}
Apply @func{remainder} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{integer} @aclass{integer} quotient+remainder @var{this} @bracearg{X, integer}
Apply @func{quotient+remainder} to the arguments and return its return
values.
@end deftypemethod


@deftypemethod @class{integer} @aclass{integer} modulo @var{this} @bracearg{X, integer}
Apply @func{modulo} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{integer} @aclass{integer} factorial @var{this} @bracearg{X, integer}
Apply @func{factorial} to the argument and return its return value.
@end deftypemethod

@c page
@node built-in numerics exact-integer
@subsection Type of exact--integer values


@menu
* built-in numerics exact-integer base::          The @class{exact-integer} type.
* built-in numerics exact-integer positive::      The @class{positive-exact-integer} type.
* built-in numerics exact-integer negative::      The @class{negative-exact-integer} type.
* built-in numerics exact-integer non-zero::      The @class{non-zero-exact-integer} type.
* built-in numerics exact-integer non-positive::  The @class{non-positive-exact-integer} type.
* built-in numerics exact-integer non-negative::  The @class{non-negative-exact-integer} type.
@end menu

@c page
@node built-in numerics exact-integer base
@subsubsection The @class{exact-integer} type


@deftp {Core Type} @aclass{exact-integer}
@deftpx {Parent Type} @aclass{integer}
Type of exact integers.  There is no constructor.  The type predicate is
@func{exact-integer?}.
@end deftp


@deftypeop Constructor @class{exact-integer} @aclass{exact-integer} type-constructor @var{obj}
Validate @var{obj} as object of type @class{exact-integer} and return
it.
@end deftypeop


@deftypeop {Type predicate} @class{exact-integer} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{exact-integer?}.  Return @true{} if
@var{obj} is a @class{exact-integer} object, otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{exact-integer} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{exact-integer-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods


@deftypemethod @class{exact-integer} @aclass{exact-integer} div @var{this} @bracearg{N, exact-integer}
Apply @func{div} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{exact-integer} @aclass{exact-integer} mod @var{this} @bracearg{N, exact-integer}
Apply @func{mod} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{exact-integer} @aclass{exact-integer} div-and-mod @var{this} @bracearg{N, exact-integer}
Apply @func{div-and-mod} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{exact-integer} @aclass{exact-integer} div0 @var{this} @bracearg{N, exact-integer}
Apply @func{div0} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{exact-integer} @aclass{exact-integer} mod0 @var{this} @bracearg{N, exact-integer}
Apply @func{mod0} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{exact-integer} @aclass{exact-integer} div0-and-mod0 @var{this} @bracearg{N, exact-integer}
Apply @func{div0-and-mod0} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{exact-integer} @aclass{exact-integer} exact-integer-sqrt @var{this} @bracearg{N, exact-integer}
Apply @func{exact-integer-sqrt} to the arguments and return its return
value.
@end deftypemethod

@c page
@node built-in numerics exact-integer positive
@subsubsection The @class{positive-exact-integer} type


@deftp {Core Type} @aclass{positive-exact-integer}
Type of positive exact integers.  Its definition is equivalent to:

@lisp
(define-type <positive-exact-integer>
  (or <positive-fixnum> <positive-bignum>))
@end lisp
@end deftp

@c page
@node built-in numerics exact-integer negative
@subsubsection The @class{negative-exact-integer} type


@deftp {Core Type} @aclass{negative-exact-integer}
Type of negative exact integers.  Its definition is equivalent to:

@lisp
(define-type <negative-exact-integer>
  (or <negative-fixnum> <negative-bignum>))
@end lisp
@end deftp

@c page
@node built-in numerics exact-integer non-zero
@subsubsection The @class{non-zero-exact-integer} type


@deftp {Core Type} @aclass{non-zero-exact-integer}
Type of non--zero exact integers.  Its definition is equivalent to:

@lisp
(define-type <non-zero-exact-integer>
  (or <non-zero-fixnum> <bignum>))
@end lisp
@end deftp

@c page
@node built-in numerics exact-integer non-positive
@subsubsection The @class{non-positive-exact-integer} type


@deftp {Core Type} @aclass{non-positive-exact-integer}
Type of non--positive exact integers.  Its definition is equivalent to:

@lisp
(define-type <non-positive-exact-integer>
  (or <non-positive-fixnum> <negative-bignum>))
@end lisp
@end deftp

@c page
@node built-in numerics exact-integer non-negative
@subsubsection The @class{non-negative-exact-integer} type


@deftp {Core Type} @aclass{non-negative-exact-integer}
Type of non--negative exact integers.  Its definition is equivalent to:

@lisp
(define-type <non-negative-exact-integer>
  (or <non-negative-fixnum> <positive-bignum>))
@end lisp
@end deftp

@c page
@node built-in numerics fixnums
@subsection Type of fixnum values


@menu
* built-in numerics fixnums base::          The @class{fixnum} type.
* built-in numerics fixnums positive::      The @class{positive-fixnum} type.
* built-in numerics fixnums negative::      The @class{negative-fixnum} type.
* built-in numerics fixnums zero::          The @class{zero-fixnum} type.
* built-in numerics fixnums non-positive::  The @class{non-positive-fixnum} type.
* built-in numerics fixnums non-negative::  The @class{non-negative-fixnum} type.
* built-in numerics fixnums non-zero::      The @class{non-zero-fixnum} type.
@end menu

@c page
@node built-in numerics fixnums base
@subsubsection The @class{fixnum} type


@deftp {Core Type} @aclass{fixnum}
@deftpx {Parent Type} @aclass{exact-integer}
Type of fixnum values.
@end deftp


@deftypeop Constructor @class{fixnum} @aclass{fixnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{fixnum} and return it.
@end deftypeop


@deftypeop {Type predicate} @class{fixnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{fixnum?}.  Return @true{} if @var{obj} is a
@class{fixnum} object, otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{fixnum} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{fixnum-hash}.
@end deftypeop

@c page
@node built-in numerics fixnums positive
@subsubsection The @class{positive-fixnum} type


@deftp {Core Type} @aclass{positive-fixnum}
@deftpx {Parent Type} @aclass{fixnum}
Type of positive fixnum values.
@end deftp


@deftypeop Constructor @class{positive-fixnum} @aclass{positive-fixnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{positive-fixnum} and return it.
@end deftypeop


@deftypeop {Type predicate} @class{positive-fixnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{positive-fixnum?}.  Return @true{} if
@var{obj} is a @class{positive-fixnum} object, otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics fixnums negative
@subsubsection The @class{negative-fixnum} type


@deftp {Core Type} @aclass{negative-fixnum}
@deftpx {Parent Type} @aclass{fixnum}
Type of negative fixnum values.
@end deftp


@deftypeop Constructor @class{negative-fixnum} @aclass{negative-fixnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{negative-fixnum} and return
it.
@end deftypeop


@deftypeop {Type predicate} @class{negative-fixnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{negative-fixnum?}.  Return @true{} if
@var{obj} is a @class{negative-fixnum} object, otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics fixnums zero
@subsubsection The @class{zero-fixnum} type


@deftp {Core Type} @aclass{zero-fixnum}
@deftpx {Parent Type} @aclass{fixnum}
Type of the zero fixnum value.
@end deftp


@deftypeop Constructor @class{zero-fixnum} @aclass{zero-fixnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{zero-fixnum} and return it.
@end deftypeop


@deftypeop {Type predicate} @class{zero-fixnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{zero-fixnum?}.  Return @true{} if @var{obj}
is a @class{zero-fixnum} object, otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics fixnums non-positive
@subsubsection The @class{non-positive-fixnum} type


@deftp {Core Type} @aclass{non-negative-fixnum}
Type of non--negative fixnum values.  Its definition is equivalent to:

@lisp
(define-type <non-negative-fixnum>
  (or <zero-fixnum> <positive-fixnum>))
@end lisp
@end deftp

@c page
@node built-in numerics fixnums non-negative
@subsubsection The @class{non-negative-fixnum} type


@deftp {Core Type} @aclass{non-positive-fixnum}
Type of non--positive fixnum values.  Its definition is equivalent to:

@lisp
(define-type <non-positive-fixnum>
  (or <zero-fixnum> <negative-fixnum>))
@end lisp
@end deftp

@c page
@node built-in numerics fixnums non-zero
@subsubsection The @class{non-zero-fixnum} type


@deftp {Core Type} @aclass{non-zero-fixnum}
Type of non--zero fixnum values.  Its definition is equivalent to:

@lisp
(define-type <non-zero-fixnum>
  (or <positive-fixnum> <negative-fixnum>))
@end lisp
@end deftp

@c page
@node built-in numerics bignums
@subsection Type of bignum values


@menu
* built-in numerics bignums base::      The @class{bignum} type.
* built-in numerics bignums positive::  The @class{positive-bignum} type.
* built-in numerics bignums negative::  The @class{negative-bignum} type.
@end menu

@c page
@node built-in numerics bignums base
@subsubsection The @class{bignum} type


@deftp {Core Type} @aclass{bignum}
@deftpx {Parent Type} @aclass{exact-integer}
Type of bignum values.  There is no constructor.  The type predicate is
@func{bignum?}.
@end deftp


@deftypeop Constructor @class{bignum} @aclass{bignum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{bignum} and return it.
@end deftypeop


@deftypeop {Type predicate} @class{bignum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{bignum?}.  Return @true{} if @var{obj} is a
@class{bignum} object, otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{bignum} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{bignum-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods


@deftypemethod @class{bignum} @aclass{bytevector} bytevector @var{this}
Apply @func{bignum->bytevector} to the instance and return its return
value.
@end deftypemethod


@deftypemethod @class{bignum} @aclass{bytevector} odd? @var{this}
Apply @func{odd?} to the instance and return its return value.
@end deftypemethod


@deftypemethod @class{bignum} @aclass{bytevector} even? @var{this}
Apply @func{even?} to the instance and return its return value.
@end deftypemethod

@c page
@node built-in numerics bignums positive
@subsubsection The @class{positive-bignum} type


@deftp {Core Type} @aclass{positive-bignum}
@deftpx {Parent Type} @aclass{bignum}
Type of positive bignum values.
@end deftp


@deftypeop Constructor @class{positive-bignum} @aclass{positive-bignum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{positive-bignum} and return
it.
@end deftypeop


@deftypeop {Type predicate} @class{positive-bignum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{positive-bignum?}.  Return @true{} if
@var{obj} is a @class{positive-bignum} object, otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics bignums negative
@subsubsection The @class{negative-bignum} type


@deftp {Core Type} @aclass{negative-bignum}
@deftpx {Parent Type} @aclass{bignum}
Type of negative bignum values.
@end deftp


@deftypeop Constructor @class{negative-bignum} @aclass{negative-bignum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{negative-bignum} and return
it.
@end deftypeop


@deftypeop {Type predicate} @class{negative-bignum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{negative-bignum?}.  Return @true{} if
@var{obj} is a @class{negative-bignum} object, otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics flonums
@subsection Type of flonum values


@menu
* built-in numerics flonums base::          The @class{flonum} type.
* built-in numerics flonums zero::          The @class{zero-flonum} type.
* built-in numerics flonums positive-zero:: The @class{positive-zero-flonum} type.
* built-in numerics flonums negative-zero:: The @class{negative-zero-flonum} type.
* built-in numerics flonums non-zero::      The @class{non-zero-flonum} type.
* built-in numerics flonums positive::      The @class{positive-flonum} type.
* built-in numerics flonums negative::      The @class{negative-flonum} type.
* built-in numerics flonums non-positive::  The @class{non-positive-flonum} type.
* built-in numerics flonums non-negative::  The @class{non-negative-flonum} type.
@end menu

@c page
@node built-in numerics flonums base
@subsubsection The @class{flonum} type


@deftp {Core Type} @aclass{flonum}
@deftpx {Parent Type} @aclass{real}
Type of flonum values.
@end deftp


@deftypeop Constructor @class{flonum} @aclass{flonum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{flonum}.  Return @var{obj}
itself.
@end deftypeop


@deftypeop {Type predicate} @class{flonum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{flonum?}.  Return @true{} if @var{obj} is an
object of type @class{flonum}; otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{flonum} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{flonum-hash}.
@end deftypeop

@c page
@node built-in numerics flonums zero
@subsubsection The @class{zero-flonum} type


@deftp {Core Type} @aclass{zero-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of zero flonum values: @samp{+0.0} and @samp{-0.0}.
@end deftp


@deftypeop Constructor @class{zero-flonum} @aclass{zero-flonum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{zero-flonum}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{zero-flonum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{zero-flonum?}.  Return @true{} if @var{obj}
is an object of type @class{zero-flonum}; otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics flonums positive-zero
@subsubsection The @class{positive-zero-flonum} type


@deftp {Core Type} @aclass{positive-zero-flonum}
@deftpx {Parent Type} @aclass{zero-flonum}
Type of positive zero flonum values: @samp{+0.0}.
@end deftp


@deftypeop Constructor @class{positive-zero-flonum} @aclass{positive-zero-flonum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{positive-zero-flonum}.
Return @var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{positive-zero-flonum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{positive-zero-flonum?}.  Return @true{} if
@var{obj} is an object of type @class{positive-zero-flonum}; otherwise
return @false{}.
@end deftypeop

@c page
@node built-in numerics flonums negative-zero
@subsubsection The @class{negative-zero-flonum} type


@deftp {Core Type} @aclass{negative-zero-flonum}
@deftpx {Parent Type} @aclass{zero-flonum}
Type of negative zero flonum values: @samp{-0.0}.
@end deftp


@deftypeop Constructor @class{negative-zero-flonum} @aclass{negative-zero-flonum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{negative-zero-flonum}.
Return @var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{negative-zero-flonum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{negative-zero-flonum?}.  Return @true{} if
@var{obj} is an object of type @class{negative-zero-flonum}; otherwise
return @false{}.
@end deftypeop

@c page
@node built-in numerics flonums non-zero
@subsubsection The @class{non-zero-flonum} type


@deftp {Core Type} @aclass{non-zero-flonum}
Type of non--zero flonum values.  The definition is equivalent to:

@lisp
(define-type <non-zero-flonum>
  (or <positive-flonum> <negative-flonum>))
@end lisp
@end deftp

@c page
@node built-in numerics flonums positive
@subsubsection The @class{positive-flonum} type


@deftp {Core Type} @aclass{positive-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of positive flonum values, @strong{excluding} the positive zero
@samp{+0.0}.
@end deftp


@deftypeop Constructor @class{positive-flonum} @aclass{positive-flonum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{positive-flonum}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{positive-flonum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{positive-flonum?}.  Return @true{} if
@var{obj} is an object of type @class{positive-flonum}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics flonums negative
@subsubsection The @class{negative-flonum} type


@deftp {Core Type} @aclass{negative-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of negative flonum values, @strong{excluding} the negative zero
@samp{-0.0}.
@end deftp


@deftypeop Constructor @class{negative-flonum} @aclass{negative-flonum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{negative-flonum}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{negative-flonum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{positive-flonum?}.  Return @true{} if
@var{obj} is an object of type @class{negative-flonum}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics flonums non-positive
@subsubsection The @class{non-positive-flonum} type


@deftp {Core Type} @aclass{non-positive-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of non--positive flonum values.  This type definition is equivalent
to:

@lisp
(define-type <non-positive-flonum>
  (or <negative-flonum> <zero-flonum>))
@end lisp
@end deftp

@c page
@node built-in numerics flonums non-negative
@subsubsection The @class{non-negative-flonum} type


@deftp {Core Type} @aclass{non-negative-flonum}
@deftpx {Parent Type} @aclass{flonum}
Type of non--negative flonum values.  This type definition is equivalent
to:

@lisp
(define-type <non-negative-flonum>
  (or <positive-flonum> <zero-flonum>))
@end lisp
@end deftp

@c page
@node built-in numerics ratnums
@subsection Type of ratnum values


@menu
* built-in numerics ratnums base::      The @class{ratnum} type.
* built-in numerics ratnums positive::  The @class{positive-ratnum} type.
* built-in numerics ratnums negative::  The @class{negative-ratnum} type.
@end menu

@c page
@node built-in numerics ratnums base
@subsubsection The @class{ratnum} type


@deftp {Core Type} @aclass{ratnum}
@deftpx {Parent Type} @aclass{rational}
Type of ratnum values.
@end deftp


@deftypeop Constructor @class{ratnum} @aclass{ratnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{ratnum}.  Return @var{obj}
itself.
@end deftypeop


@deftypeop {Type predicate} @class{ratnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{ratnum?}.  Return @true{} if @var{obj} is an
object of type @class{ratnum}; otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{ratnum} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{ratnum-hash}.
@end deftypeop

@c page
@node built-in numerics ratnums positive
@subsubsection The @class{positive-ratnum} type


@deftp {Core Type} @aclass{positive-ratnum}
@deftpx {Parent Type} @aclass{ratnum}
Type of positive ratnum values.
@end deftp


@deftypeop Constructor @class{positive-ratnum} @aclass{positive-ratnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{positive-ratnum}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{positive-ratnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{positive-ratnum?}.  Return @true{} if
@var{obj} is an object of type @class{positive-ratnum}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics ratnums negative
@subsubsection The @class{negative-ratnum} type


@deftp {Core Type} @aclass{negative-ratnum}
@deftpx {Parent Type} @aclass{ratnum}
Type of negative ratnum values.
@end deftp


@deftypeop Constructor @class{negative-ratnum} @aclass{negative-ratnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{negative-ratnum}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{negative-ratnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{negative-ratnum?}.  Return @true{} if
@var{obj} is an object of type @class{negative-ratnum}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics compnums
@subsection Type of compnum values


@menu
* built-in numerics compnums base::     The @class{compnum} type.
* built-in numerics compnums exact::    The @class{exact-compnum} type.
* built-in numerics compnums inexact::  The @class{inexact-compnum} type.
* built-in numerics compnums zero::     The @class{zero-compnum} type.
* built-in numerics compnums non-zero-inexact::  The @class{non-zero-inexact-compnum} type.
* built-in numerics compnums non-zero:: The @class{non-zero-compnum} type.
@end menu

@c page
@node built-in numerics compnums base
@subsubsection The @class{compnum} type


@deftp {Core Type} @aclass{compnum}
@deftpx {Parent Type} @aclass{complex}
Type of compnum values.
@end deftp


@deftypeop Constructor @class{compnum} @aclass{compnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{compnum}.  Return @var{obj}
itself.
@end deftypeop


@deftypeop {Type predicate} @class{compnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{compnum?}.  Return @true{} if @var{obj} is
an object of type @class{compnum}; otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{compnum} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{compnum-hash}.
@end deftypeop

@c page
@node built-in numerics compnums exact
@subsubsection The @class{exact-compnum} type


@deftp {Core Type} @aclass{exact-compnum}
@deftpx {Parent Type} @aclass{compnum}
Type of compnum values having exact real and imaginary parts.

Remembering that a compnum with exact zero as imaginary part is
converted to a real number by the Scheme reader and the function
@func{make-rectangular}:

@lisp
1+0i                            @result{} 1
1.0+0i                          @result{} 1.0
(make-rectangular 1 0)          @result{} 1
(make-rectangular 1.0 0)        @result{} 1.0
@end lisp

@noindent
it follows that a value of type @class{exact-compnum} @strong{cannot} be
zero.
@end deftp


@deftypeop Constructor @class{exact-compnum} @aclass{exact-compnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{exact-compnum}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{exact-compnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{exact-compnum?}.  Return @true{} if
@var{obj} is an object of type @class{exact-compnum}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics compnums inexact
@subsubsection The @class{inexact-compnum} type


@deftp {Core Type} @aclass{inexact-compnum}
@deftpx {Parent Type} @aclass{compnum}
Type of compnum values having inexact real or imaginary parts.

@quotation
@strong{NOTE} We need to remember that if a value is a compnum: only one
among the real and imaginary parts is inexact.  If both are inexact: it
is not a compnum, it is a cflonum.
@end quotation
@end deftp


@deftypeop Constructor @class{inexact-compnum} @aclass{inexact-compnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{inexact-compnum}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{inexact-compnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{inexact-compnum?}.  Return @true{} if
@var{obj} is an object of type @class{inexact-compnum}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics compnums zero
@subsubsection The @class{zero-compnum} type


@deftp {Core Type} @aclass{zero-compnum}
@deftpx {Parent Type} @aclass{inexact-compnum}
Type of compnum values having both the real part and imaginary part
equal to zero.

Remembering that a compnum with exact zero as imaginary part is
converted to a real number by the Scheme reader and the function
@func{make-rectangular}:

@lisp
1+0i                            @result{} 1
1.0+0i                          @result{} 1.0
(make-rectangular 1 0)          @result{} 1
(make-rectangular 1.0 0)        @result{} 1.0
@end lisp

@noindent
the compnums of type @class{zero-compnum} are @samp{0+0.0i} and
@samp{0-0.0i} with the imaginary part always inexact.

@quotation
@strong{NOTE} We need to remember that if a value is a compnum: only one
among the real and imaginary parts is inexact.  If both are inexact: it
is not a compnum, it is a cflonum.
@end quotation
@end deftp


@deftypeop Constructor @class{zero-compnum} @aclass{zero-compnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{zero-compnum}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{zero-compnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{zero-compnum?}.  Return @true{} if @var{obj}
is an object of type @class{zero-compnum}; otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics compnums non-zero-inexact
@subsubsection The @class{non-zero-inexact-compnum} type


@deftp {Core Type} @aclass{non-zero-inexact-compnum}
@deftpx {Parent Type} @aclass{inexact-compnum}
Type of inexact compnum values having either the real part or imaginary
part different from zero.
@end deftp


@deftypeop Constructor @class{non-zero-inexact-compnum} @aclass{non-zero-inexact-compnum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{non-zero-inexact-compnum}.
Return @var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{non-zero-inexact-compnum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{non-zero-inexact-compnum?}.  Return @true{}
if @var{obj} is an object of type @class{non-zero-inexact-compnum};
otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics compnums non-zero
@subsubsection The @class{non-zero-compnum} type


@deftp {Core Type} @aclass{non-zero-compnum}
Type of compnum values having either the real part or imaginary part
different from zero.  Its definition is equivalent to:

@lisp
(define-type <non-zero-compnum>
  (or <exact-compnum> <non-zero-inexact-compnum>))
@end lisp
@end deftp

@c page
@node built-in numerics cflonums
@subsection Type of cflonum values


@menu
* built-in numerics cflonums base::     The @class{cflonum} type.
* built-in numerics cflonums zero::     The @class{zero-cflonum} type.
* built-in numerics cflonums non-zero:: The @class{non-zero-cflonum} type.
@end menu

@c page
@node built-in numerics cflonums base
@subsubsection The @class{cflonum} type


@deftp {Core Type} @aclass{cflonum}
@deftpx {Parent Type} @aclass{complex}
Type of cflonum values.
@end deftp


@deftypeop Constructor @class{cflonum} @aclass{cflonum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{cflonum}.  Return @var{obj}
itself.
@end deftypeop


@deftypeop {Type predicate} @class{cflonum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{cflonum?}.  Return @true{} if @var{obj} is
an object of type @class{cflonum}; otherwise return @false{}.
@end deftypeop


@deftypeop {Hash function} @class{cflonum} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{cflonum-hash}.
@end deftypeop

@c page
@node built-in numerics cflonums zero
@subsubsection The @class{zero-cflonum} type


@deftp {Core Type} @aclass{zero-cflonum}
@deftpx {Parent Type} @aclass{cflonum}
Type of cflonum values having both the real part and imaginary part
equal to zero.  Such values are the following:

@example
+0.0+0.0i       +0.0-0.0i
-0.0+0.0i       -0.0-0.0i
@end example
@end deftp


@deftypeop Constructor @class{zero-cflonum} @aclass{zero-cflonum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{zero-cflonum}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{zero-cflonum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{zero-cflonum?}.  Return @true{} if @var{obj}
is an object of type @class{zero-cflonum}; otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics cflonums non-zero
@subsubsection The @class{non-zero-cflonum} type


@deftp {Core Type} @aclass{non-zero-cflonum}
@deftpx {Parent Type} @aclass{cflonum}
Type of cflonum values having either the real part or imaginary part
different from zero.
@end deftp


@deftypeop Constructor @class{non-zero-cflonum} @aclass{non-zero-cflonum} type-constructor @var{obj}
Validate @var{obj} as object of type @class{non-zero-cflonum}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{non-zero-cflonum} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{non-zero-cflonum?}.  Return @true{} if
@var{obj} is an object of type @class{non-zero-cflonum}; otherwise
return @false{}.
@end deftypeop

@c page
@node built-in numerics bytes
@subsection The @class{byte} type


@menu
* built-in numerics bytes base::          The @class{byte} type.
* built-in numerics bytes zero::          The @class{zero-byte} type.
* built-in numerics bytes positive::      The @class{positive-byte} type.
* built-in numerics bytes negative::      The @class{negative-byte} type.
* built-in numerics bytes non-positive::  The @class{non-positive-byte} type.
* built-in numerics bytes non-negative::  The @class{non-negative-byte} type.
@end menu

@c page
@node built-in numerics bytes base
@subsubsection The @class{byte} type


@deftp {Label Type} @class{byte}
@deftpx {Parent Type} @aclass{fixnum}
Type of byte values.  A ``byte'' is a fixnum in the range @math{[-128,
127]}.
@end deftp


@deftypeop Constructor @class{byte} @aclass{byte} type-constructor @var{obj}
Validate @var{obj} as object of type @class{byte}.  Return @var{obj}
itself.
@end deftypeop


@deftypeop {Type predicate} @class{byte} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{byte-fixnum?}.  Return @true{} if @var{obj}
is an object of type @class{byte}; otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics bytes zero
@subsubsection The @class{zero-byte} type


@deftp {Label Type} @class{zero-byte}
@deftpx {Parent Type} @aclass{byte}
Type of zero byte values.
@end deftp


@deftypeop Constructor @class{zero-byte} @aclass{zero-byte} type-constructor @var{obj}
Validate @var{obj} as object of type @class{zero-byte}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{zero-byte} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{zero-byte-fixnum?}.  Return @true{} if
@var{obj} is an object of type @class{zero-byte}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics bytes positive
@subsubsection The @class{positive-byte} type


@deftp {Label Type} @class{positive-byte}
@deftpx {Parent Type} @aclass{byte}
Type of positive byte values.
@end deftp


@deftypeop Constructor @class{positive-byte} @aclass{positive-byte} type-constructor @var{obj}
Validate @var{obj} as object of type @class{positive-byte}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{positive-byte} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{positive-byte-fixnum?}.  Return @true{} if
@var{obj} is an object of type @class{positive-byte}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics bytes negative
@subsubsection The @class{negative-byte} type


@deftp {Label Type} @class{negative-byte}
@deftpx {Parent Type} @aclass{byte}
Type of negative byte values.
@end deftp


@deftypeop Constructor @class{negative-byte} @aclass{negative-byte} type-constructor @var{obj}
Validate @var{obj} as object of type @class{negative-byte}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{negative-byte} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{zero-byte-fixnum?}.  Return @true{} if
@var{obj} is an object of type @class{negative-byte}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics bytes non-positive
@subsubsection The @class{non-positive-byte} type


@deftp {Core Type} @class{non-positive-byte}
Type of non--positive byte values.  Its definition is equivalent to:

@lisp
(define-type <non-positive-byte>
  (or <zero-byte> <negative-byte>))
@end lisp
@end deftp

@c page
@node built-in numerics bytes non-negative
@subsubsection The @class{non-negative-byte} type


@deftp {Core Type} @class{non-negative-byte}
Type of non--negative byte values.  Its definition is equivalent to:

@lisp
(define-type <non-negative-byte>
  (or <zero-byte> <positive-byte>))
@end lisp
@end deftp

@c page
@node built-in numerics octets
@subsection The @class{octet} type


@menu
* built-in numerics octets base::       The @class{octet} type.
* built-in numerics octets zero::       The @class{zero-octet} type.
* built-in numerics octets positive::   The @class{positive-octet} type.
@end menu

@c page
@node built-in numerics octets base
@subsubsection The @class{octet} type


@deftp {Label Type} @class{octet}
@deftpx {Parent Type} @aclass{non-negative-fixnum}
Type of octet values.  An ``octet'' is a fixnum in the range @math{[0,
255]}.
@end deftp


@deftypeop Constructor @class{octet} @aclass{octet} type-constructor @var{obj}
Validate @var{obj} as object of type @class{octet}.  Return @var{obj}
itself.
@end deftypeop


@deftypeop {Type predicate} @class{octet} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{octet-fixnum?}.  Return @true{} if @var{obj}
is an object of type @class{octet}; otherwise return @false{}.
@end deftypeop

@c page
@node built-in numerics octets zero
@subsubsection The @class{zero-octet} type


@deftp {Label Type} @class{zero-octet}
@deftpx {Parent Type} @aclass{octet}
Type of zero octet values.
@end deftp


@deftypeop Constructor @class{zero-octet} @aclass{zero-octet} type-constructor @var{obj}
Validate @var{obj} as object of type @class{zero-octet}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{zero-octet} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{zero-octet-fixnum?}.  Return @true{} if
@var{obj} is an object of type @class{zero-octet}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics octets positive
@subsubsection The @class{positive-octet} type


@deftp {Label Type} @class{positive-octet}
@deftpx {Parent Type} @aclass{non-negative-fixnum}
Type of positive octet values.
@end deftp


@deftypeop Constructor @class{positive-octet} @aclass{positive-octet} type-constructor @var{obj}
Validate @var{obj} as object of type @class{positive-octet}.  Return
@var{obj} itself.
@end deftypeop


@deftypeop {Type predicate} @class{positive-octet} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{positive-octet-fixnum?}.  Return @true{} if
@var{obj} is an object of type @class{positive-octet}; otherwise return
@false{}.
@end deftypeop

@c page
@node built-in numerics exactness
@subsection Exactness of values


@deftp {Core Type} @class{exact}
Type of exact numeric values.  Its definition is equivalent to:

@lisp
(define-type <exact>
  (or <exact-rational> <exact-compnum>))
@end lisp
@end deftp


@deftp {Core Type} @class{inexact}
Type of inexact numeric values.  Its definition is equivalent to:

@lisp
(define-type <inexact>
  (or <flonum> <cflonum> <inexact-compnum>))
@end lisp
@end deftp

@c page
@node built-in numerics sign
@subsection Sign of numeric values


@deftp {Core Type} @class{positive}
Type of positive numeric values.  Its definition is equivalent to:

@lisp
(define-type <positive>
  (or <positive-fixnum> <positive-bignum>
      <positive-ratnum> <positive-flonum>))
@end lisp
@end deftp


@deftp {Core Type} @class{negative}
Type of negative numeric values.  Its definition is equivalent to:

@lisp
(define-type <negative>
  (or <negative-fixnum> <negative-bignum>
      <negative-ratnum> <negative-flonum>))
@end lisp
@end deftp


@deftp {Core Type} @class{non-negative}
Type of non--negative numeric values.  Its definition is equivalent to:

@lisp
(define-type <non-negative>
  (or <non-negative-fixnum> <positive-bignum> <positive-ratnum>
      <positive-flonum> <positive-zero-flonum>))
@end lisp
@end deftp


@deftp {Core Type} @class{non-positive}
Type of non--positive numeric values.  Its definition is equivalent to:

@lisp
(define-type <non-positive>
  (or <non-positive-fixnum> <negative-bignum> <negative-ratnum>
      <negative-flonum> <negative-zero-flonum>))
@end lisp
@end deftp


@deftp {Core Type} @class{zero}
Type of zero numeric values.  Its definition is equivalent to:

@lisp
(define-type <zero>
  (or <zero-fixnum>  <zero-flonum>
      <zero-compnum> <zero-cflonum>))
@end lisp
@end deftp

@c page
@node built-in strings
@section Type of string values


@menu
* built-in strings base::         Base string type.
* built-in strings empty::        Empty string type.
* built-in strings non-empty::    Non-empty string type.
@end menu

@c page
@node built-in strings base
@subsection Base string type


@deftp {Core Type} @class{string}
@deftpx {Parent Type} @aclass{top}
Type of string values.
@end deftp


@deftypeop Constructor @class{string} @aclass{string} type-constructor @bracearg{ch, char} @dots{}
The constructor is @func{string}.
@end deftypeop


@deftypeop {Type predicate} @class{string} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{string?}.  Return @true{} if @var{obj} is a
string object; otherwise return @false{}.
@end deftypeop


@deftypeop {Equality predicate} @class{string} @aclass{boolean} equality-predicate @var{this} @bracearg{str, string}
The equality predicate is @func{string=?}.
@end deftypeop


@deftypeop {Comparison procedure} @class{string} @aclass{fixnum} comparison-procedure @var{this} @bracearg{str, string}
The comparison procedure is @func{compar-string}.
@end deftypeop


@deftypeop {Hash function} @class{string} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{string-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Inspection


@deftypemethod @class{string} @aclass{boolean} empty? @var{this}
Apply @func{string-empty?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} length @var{this}
Apply @func{string-length} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} for-each @var{this} @var{func} @var{str} @dots{}
Apply @func{string-for-each} to the function @var{func}, the instance
and the arguments.  Example:

@lisp
(.for-each "ciao" display)
@end lisp
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Constructors


@deftypemethod @aclass{string} copy @var{this}
Apply @func{string-copy} to the instance and return its return value.
@end deftypemethod


@deftypemethod @aclass{string} append @var{this} @bracearg{str, string} @dots{}
Apply @func{string-append} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators


@deftypemethod @aclass{string} fill! @var{this} @var{char}
Apply @func{string-fill!} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Encoding inspection


@deftypemethod @aclass{string} ascii-encoded? @var{this}
Apply @func{ascii-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} latin1-encoded? @var{this}
Apply @func{latin1-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} octets-encoded? @var{this}
Apply @func{octets-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} uri-encoded @var{this}
Apply @func{uri-encoded-string?} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} pencent-encoded? @var{this}
Apply @func{percent-encoded-string?} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Comparison


@deftypemethod @aclass{string} = @var{this} @var{str} @dots{}
@deftypemethodx @aclass{string} != @var{this} @var{str} @dots{}
@deftypemethodx @aclass{string} < @var{this} @var{str} @dots{}
@deftypemethodx @aclass{string} > @var{this} @var{str} @dots{}
@deftypemethodx @aclass{string} <= @var{this} @var{str} @dots{}
@deftypemethodx @aclass{string} >= @var{this} @var{str} @dots{}
Apply @func{string=?}, @func{string!=?}, @func{string<?},
@func{string>?}, @func{string<=?}, @func{string>=?} to the instance and
the arguments and return its return value.
@end deftypemethod


@deftypemethod @aclass{string} ci= @var{this} @var{str} @dots{}
@deftypemethodx @aclass{string} ci< @var{this} @var{str} @dots{}
@deftypemethodx @aclass{string} ci> @var{this} @var{str} @dots{}
@deftypemethodx @aclass{string} ci<= @var{this} @var{str} @dots{}
@deftypemethodx @aclass{string} ci>= @var{this} @var{str} @dots{}
Apply @func{string-ci=?}, @func{string-ci<?}, @func{string-ci>?},
@func{string-ci<=?}, @func{string-ci>=?}, to the instance and the
arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Case handling


@deftypemethod @aclass{string} titlecase @var{this}
Apply @func{string-titlecase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} upcase @var{this}
Apply @func{string-upcase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} downcase @var{this}
Apply @func{string-downcase} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} foldcase @var{this}
Apply @func{string-foldcase} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Normalisation


@deftypemethod @aclass{string} normalize-nfc @var{this}
Apply @func{string-normalize-nfc} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfd @var{this}
Apply @func{string-normalize-nfd} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfkc @var{this}
Apply @func{string-normalize-nfkc} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} normalize-nfkd @var{this}
Apply @func{string-normalize-nfkd} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Conversion


@deftypemethod @aclass{string} flonum @var{this}
Apply @func{string->flonum} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} number @var{this}
@deftypemethodx @aclass{string} number @var{this} @var{radix}
Apply @func{string->number} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} utf8 @var{this}
Apply @func{string->utf8} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16 @var{this}
@deftypemethodx @aclass{string} utf16 @var{this} @var{endianness}
Apply @func{string->utf16} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} utf16be @var{this}
Apply @func{string->utf16be} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16le @var{this}
Apply @func{string->utf16le} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf16n @var{this}
Apply @func{string->utf16n} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} utf32 @var{this}
@deftypemethodx @aclass{string} utf32 @var{this} @var{endianness}
Apply @func{string->utf32} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} bytevector @var{this}
@deftypemethodx @aclass{string} bytevector @var{this} @var{transcoder}
Apply @func{string->bytevector} to the instance and the argument.
@end deftypemethod


@deftypemethod @aclass{string} ascii @var{this}
Apply @func{string->ascii} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} latin1 @var{this}
Apply @func{string->latin1} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} octets @var{this}
Apply @func{string->octets} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} percent-encoding @var{this}
Apply @func{string->percent-encoding} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} uri-encoding @var{this}
Apply @func{string->uri-encoding} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} base64->bytevector @var{this}
Apply @func{string-base64->bytevector} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} hex->bytevector @var{this}
Apply @func{string-hex->bytevector} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} symbol @var{this}
Apply @func{string->symbol} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} keyword @var{this}
Apply @func{string->keyword} to the instance.
@end deftypemethod


@deftypemethod @aclass{string} list @var{this}
Apply @func{string->list} to the instance.
@end deftypemethod

@c page
@node built-in strings empty
@subsection Empty string type


@deftp {Core Type} @aclass{empty-string}
@deftpx {Parent Type} @aclass{string}
Type of empty string values.
@end deftp


@deftypeop Constructor @class{empty-string} @aclass{empty-string} type-constructor
Build and return an empty string.
@end deftypeop


@deftypeop {Type predicate} @class{empty-string} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{empty-string?}.  Return @true{} if @var{obj}
is a @class{empty-string} object; otherwise return @false{}.
@end deftypeop

@c page
@node built-in strings non-empty
@subsection Non--empty string type


@deftp {Core Type} @aclass{nestring}
@deftpx {Parent Type} @aclass{string}
Type of non--empty string values.
@end deftp


@deftypeop Constructor @class{nestring} @aclass{nestring} type-constructor @braceargo{ch, char} @bracearg{ch, char} @dots{}
Build and return a non--empty string.
@end deftypeop


@deftypeop {Type predicate} @class{nestring} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{empty-string?}.  Return @true{} if @var{obj}
is a @class{nestring} object; otherwise return @false{}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators


@deftypemethod @class{nestring} @aclass{char} ref @var{this} @bracearg{idx, non-negative-fixnum}
Apply @func{string-ref} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{nestring} @aclass{void} set! @var{this} @bracearg{idx, non-negative-fixnum} @bracearg{ch, char}
Apply @func{string-set!} to the instance and the arguments.
@end deftypemethod

@c page
@node built-in vectors
@section Type of vector values


@menu
* built-in vectors base::         Base vector type.
* built-in vectors empty::        Empty vector type.
* built-in vectors non-empty::    Non-empty vector type.
@end menu

@c page
@node built-in vectors base
@subsection Base vector type


@deftp {Core Type} @aclass{vector}
@deftpx {Parent Type} @aclass{top}
Type of vector values.
@end deftp


@deftypeop Constructor @class{vector} @aclass{vector} type-constructor @var{obj} @dots{}
The constructor is @func{vector}.
@end deftypeop


@deftypeop {Type predicate} @class{vector} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{vector?}.  Return @true{} if @var{obj} is a
vector object; otherwise return @false{}.
@end deftypeop


@deftypeop {Equality predicate} @class{vector} @aclass{boolean} equality-predicate @var{this} @bracearg{vec, vector}
The equality predicate is @func{equal?}.
@end deftypeop


@deftypeop {Hash function} @class{vector} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{vector-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Inspection


@deftypemethod @class{vector} @aclass{non-negative-fixnum} length @var{this}
Apply @func{vector-length} to the instance.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators

@deftypemethod @class{vector} @aclass{void} fill! @var{this} @var{obj}
Apply @func{vector-fill!} to the instance and the argument.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Other constructors


@deftypemethod @class{vector} @aclass{vector} subvector @var{this} @var{begin} @var{end}
Apply @func{subvector} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{vector} append @var{this} @var{vec} @dots{}
Apply @func{vector-append} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{vector} resize @var{this} @var{new-length}
@deftypemethodx @class{vector} @aclass{vector} resize @var{this} @var{new-length} @var{fill}
Apply @func{vector-resize} to the instance and the arguments.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Iteration and searching


@deftypemethod @class{vector} @aclass{vector} map @var{this} @var{proc} @var{vec} @dots{}
Apply @func{vector-map} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{void} for-each @var{this} @var{proc} @var{vec} @dots{}
Apply @func{vector-for-each} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} for-all @var{this} @var{proc} @var{vec} @dots{}
Apply @func{vector-for-all} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} exists @var{this} @var{proc} @var{vec} @dots{}
Apply @func{vector-exists} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} find @var{this} @var{proc}
Apply @func{vector-find} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} fold-left @var{this} @var{proc} @var{knil} @var{vec} @dots{}
Apply @func{vector-fold-left} to the instance and the arguments.
@end deftypemethod


@deftypemethod @class{vector} @aclass{top} fold-right @var{this} @var{proc} @var{knil} @var{vec} @dots{}
Apply @func{vector-fold-right} to the instance and the arguments.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Sorting


@deftypemethod @class{vector} @aclass{vector} sort @var{this} @var{proc}
@deftypemethodx @class{vector} @aclass{vector} sort! @var{this} @var{proc}
Apply @func{vector-sort} or @func{vector-sort!} to the instance and the
argument.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Conversion


@deftypemethod @class{vector} @aclass{list} list @var{this}
Apply @func{vector->list} to the instance.
@end deftypemethod

@c page
@node built-in vectors empty
@subsection Empty vector type


@deftp {Core Type} @aclass{empty-vector}
@deftpx {Parent Type} @aclass{vector}
Type of empty vector values.
@end deftp


@deftypeop Constructor @class{empty-vector} @aclass{empty-vector} type-constructor
Return an empty vector.
@end deftypeop


@deftypeop {Type predicate} @class{empty-vector} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{empty-vector?}.  Return @true{} if @var{obj}
is a @class{empty-vector} object; otherwise return @false{}.
@end deftypeop

@c page
@node built-in vectors non-empty
@subsection Non--empty vector type


@deftp {Core Type} @aclass{nevector}
@deftpx {Parent Type} @aclass{vector}
Type of non--empty vector values.
@end deftp


@deftypeop Constructor @class{nevector} @aclass{nevector} type-constructor @varo{obj} @var{obj} @dots{}
Return a non--empty vector.
@end deftypeop


@deftypeop {Type predicate} @class{nevector} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{nevector?}.  Return @true{} if @var{obj} is
a @class{nevector} object; otherwise return @false{}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators

@deftypemethod @class{nevector} @aclass{top} ref @var{this} @bracearg{idx, non-negative-fixnum}
Apply @func{vector-ref} to the instance and the argument.
@end deftypemethod


@deftypemethod @class{nevector} @aclass{void} set! @var{this} @bracearg{idx, non-negative-fixnum} @var{obj}
Apply @func{vector-set!} to the instance and the arguments.
@end deftypemethod

@c page
@node built-in lists
@section Type of list objects


@menu
* built-in lists base::       Base type of list objects.
* built-in lists null::       Type of empty lists.
* built-in lists non-empty::  Type of non-empty list objects.
@end menu

@c page
@node built-in lists base
@subsection Base type of list objects


@deftp {Core Type} @aclass{list}
@deftpx {Parent Type} @aclass{top}
Type of lists, whatever their structure.  The fact that a list structure
is non--empty, non--circular, proper or improper must be checked at
run--time.
@end deftp


@deftypeop Constructor @class{list} @aclass{list} type-constructor @var{obj} @dots{}
The constructor is @func{list}.  Return a new list having the given
@var{obj} arguments as items.
@end deftypeop


@deftypeop {Type predicate} @class{list} @aclass{list} type-predicate @var{obj}
The type predicate is @func{list?}.  Return @true{} if @var{obj} is null
or a proper list object; otherwise return @false{}.
@end deftypeop


@deftypeop {Equality predicate} @class{list} @aclass{boolean} equality-predicate @var{this}
The equality predicate is @func{equal?}.
@end deftypeop


@deftypeop {Hash function} @class{list} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{list-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods: predicates


@deftypemethod @class{list} @aclass{boolean} circular? @var{this}
Apply @func{circular-list?} to the argument and return its return value.
@end deftypemethod


@deftypemethod @class{list} @aclass{boolean} single-item? @var{this}
Apply @func{list-of-single-item?} to the argument and return its return
value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: constructors


@deftypemethod @class{list} @aclass{list} append @var{this} @bracearg{L, list} @dots{}
Apply @func{append} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{list} @aclass{list} reverse @var{this}
Apply @func{reverse} to the arguments and return its return value.
@end deftypemethod

@c page
@node built-in lists null
@subsection Type of empty lists


@deftp {Core Type} @aclass{null}
@deftpx {Parent Type} @aclass{list}
Type of the null object.

The type @class{null} is special in that it is considered sub--type of
both the type @class{list} and the types defined with the annotations
@code{(list-of @meta{type})}.  Notice that types defined with the
annotations @code{(list @metao{type} @meta{type} ...)} are @strong{not}
super--types of @class{null}, because, by definition, they contain at
list one item.
@end deftp


@deftypeop Constructor @class{null} @aclass{null} type-constructor
Return the null object.
@end deftypeop


@deftypeop {Type predicate} @class{null} @aclass{null} type-predicate @var{obj}
The type predicate is @func{null?}.  Return @true{} if @var{obj} is the
null object; otherwise return @false{}.
@end deftypeop

@c page
@node built-in lists non-empty
@subsection Type of non--empty list objects


@deftp {Core Type} @aclass{nelist}
@deftpx {Parent Type} @aclass{list}
Type of non--empty lists, whatever their structure.  The fact that a
list structure is non--circular, proper or improper must be checked at
run--time.
@end deftp


@deftypeop Constructor @class{nelist} @aclass{nelist} type-constructor @var{obj} @dots{}
Return a new non--empty list having the given @var{obj} arguments as
items.
@end deftypeop


@deftypeop {Type predicate} @class{nelist} @aclass{nelist} type-predicate @var{obj}
The type predicate is @func{nelist?}.  Return @true{} if @var{obj} is a
proper non--empty list object; otherwise return @false{}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods: accessors


@deftypemethod @class{nelist} @aclass{top} car @var{this}
Apply @func{car} to the type instance.
@end deftypemethod


@deftypemethod @class{nelist} @aclass{top} cdr @var{this}
Apply @func{cdr} to the type instance.
@end deftypemethod


@deftypemethod @class{nelist} @aclass{pair} last-pair @var{this}
Apply @func{last-pair} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{list} @aclass{list} list-tail @var{this} @bracearg{idx, non-negative-exact-integer}
Apply @func{list-tail} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{list} @aclass{list} ref @var{this} @bracearg{idx, non-negative-exact-integer}
Apply @func{list-ref} to the arguments and return its return value.
@end deftypemethod

@c page
@node built-in pairs
@section Type of pair objects


@menu
* built-in pairs base::         Type of pair objects.
* built-in pairs weak::         Type of weak pair objects.
* built-in pairs immutable::    Type of immutable pair objects.
@end menu

@c page
@node built-in pairs base
@subsection Type of pair objects


@deftp {Core Type} @aclass{pair}
@deftpx {Parent Type} @aclass{top}
Type of pair objects.
@end deftp


@deftypeop Constructor @class{pair} @aclass{pair} type-constructor @var{A} @var{D}
The constructor is @func{cons}.  Return a new pair having @var{A} and
@var{D} as car and cdr.
@end deftypeop


@deftypeop {Type predicate} @class{pair} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{pair?}.  Return @true{} if @var{obj} is a
pair object; otherwise return @false{}.
@end deftypeop


@deftypeop {Equality predicate} @class{pair} @aclass{boolean} equality-predicate @var{this} @bracearg{P, pair}
The equality predicate is @func{equal?}.
@end deftypeop


@deftypeop {Hash function} @class{pair} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{pair-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods: accessors


@deftypemethod @class{pair} @aclass{top} car @var{this}
Apply @func{car} to the type instance.
@end deftypemethod


@deftypemethod @class{pair} @aclass{top} cdr @var{this}
Apply @func{cdr} to the type instance.
@end deftypemethod

@c page
@node built-in pairs weak
@subsection Type of weak pair objects


@deftp {Label Type} @aclass{weak-pair}
@deftpx {Parent Type} @aclass{pair}
Type of weak pair objects.
@end deftp


@deftypeop Constructor @class{weak-pair} @aclass{weak-pair} type-constructor @var{A} @var{D}
The constructor is @func{weak-cons}.  Return a new weak pair having
@var{A} and @var{D} as car and cdr.
@end deftypeop


@deftypeop {Type predicate} @class{weak-pair} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{weak-pair?}.  Return @true{} if @var{obj} is
an immutable pair object; otherwise return @false{}.
@end deftypeop

@c page
@node built-in pairs immutable
@subsection Type of immutable pair objects


@deftp {Core Type} @aclass{ipair}
@deftpx {Parent Type} @aclass{struct}
Type of immutable pair objects.
@end deftp


@deftypeop Constructor @class{ipair} @aclass{ipair} type-constructor @var{A} @var{D}
The constructor is @func{ipair}.  Return a new immutable pair having
@var{A} and @var{D} as car and cdr.
@end deftypeop


@deftypeop {Type predicate} @class{ipair} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{ipair?}.  Return @true{} if @var{obj} is an
immutable pair object; otherwise return @false{}.
@end deftypeop


@deftypeop {Equality predicate} @class{ipair} @aclass{boolean} equality-predicate @var{this} @bracearg{P, ipair}
The equality predicate is @func{equal?}.
@end deftypeop


@deftypeop {Hash function} @class{ipair} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{ipair-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods: accessors


@deftypemethod @class{ipair} @aclass{top} car @var{this}
Apply @func{icar} to the type instance.
@end deftypemethod


@deftypemethod @class{ipair} @aclass{top} cdr @var{this}
Apply @func{icdr} to the type instance.
@end deftypemethod

@c page
@node built-in bytevectors
@section Type of bytevector objects


@menu
* built-in bytevectors base::       The @class{bytevector} type.
* built-in bytevectors empty::      The @class{empty-bytevector} type.
* built-in bytevectors non-empty::  The @class{nebytevector} type.
@end menu

@c page
@node built-in bytevectors base
@subsection The @class{bytevector} type


@deftp {Core Type} @aclass{bytevector}
@deftpx {Parent Type} @aclass{top}
Type of bytevector objects.
@end deftp


@deftypeop Constructor @class{bytevector} @aclass{bytevector} type-constructor @bracearg{len, non-negative-fixnum}
@deftypeopx Constructor @class{bytevector} @aclass{bytevector} type-constructor @bracearg{len, non-negative-fixnum} @bracearg{fill, fixnum}
The constructor is @func{make-bytevector}.
@end deftypeop


@deftypeop {Type predicate} @class{bytevector} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{bytevector?}.
@end deftypeop


@deftypeop {Equality predicate} @class{bytevector} @aclass{boolean} equality-predicate @var{this} @bracearg{bv, bytevector}
The equality predicate is @func{bytevector=?}.
@end deftypeop


@deftypeop {Hash function} @class{bytevector} @aclass{non-negative-fixnum} hash-function @var{this}
The hash function is @func{bytevector-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods


@deftypemethod @class{bytevector} @aclass{non-negative-fixnum} length @var{this}
Apply @func{bytevector-length} to the instance and return its return
value.
@end deftypemethod


@deftypemethod @aclass{bytevector} = @var{this} @bracearg{bv, bytevector} @dots{}
@deftypemethodx @aclass{bytevector} != @var{this} @bracearg{bv, bytevector} @dots{}
Apply @func{bytevector=?}, @func{bytevector!=?} to the instance and the
arguments and return its return value.
@end deftypemethod

@c page
@node built-in bytevectors empty
@subsection The @class{empty-bytevector} type


@deftp {Core Type} @aclass{empty-bytevector}
@deftpx {Parent Type} @aclass{bytevector}
Type of empty bytevector objects.
@end deftp


@deftypeop Constructor @class{empty-bytevector} @aclass{empty-bytevector} type-constructor
Return an empty bytevector object.
@end deftypeop


@deftypeop {Type predicate} @class{empty-bytevector} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{empty-bytevector?}.
@end deftypeop

@c page
@node built-in bytevectors non-empty
@subsection The @class{nebytevector} type


@deftp {Core Type} @aclass{nebytevector}
@deftpx {Parent Type} @aclass{bytevector}
Type of non--empty bytevector objects.
@end deftp


@deftypeop Constructor @class{nebytevector} @aclass{nebytevector} type-constructor @bracearg{len, positive-fixnum}
@deftypeopx Constructor @class{nebytevector} @aclass{nebytevector} type-constructor @bracearg{len, positive-fixnum} @bracearg{fill, fixnum}
Return a non--empty bytevector object.
@end deftypeop


@deftypeop {Type predicate} @class{nebytevector} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{nebytevector?}.
@end deftypeop

@c page
@node built-in hashtables
@section Type of hashtable objects


@menu
* built-in hashtables base::    The @class{hashtable} type.
* built-in hashtables eq::      The @class{hashtable-eq} type.
* built-in hashtables eqv::     The @class{hashtable-eqv} type.
* built-in hashtables equiv::   The @class{hashtable-equiv} type.
@end menu

@c page
@node built-in hashtables base
@subsection The @class{hashtable} type


@deftp {Core Type} @aclass{hashtable}
@deftpx {Parent Type} @aclass{top}
Base type for hashtable objects.
@end deftp


@deftypeop Constructor @class{hashtable} @aclass{hashtable} type-constructor @var{table}
Validate @var{table} as hashtable object and return it.
@end deftypeop


@deftypeop {Type predicate} @class{hashtable} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{hashtable?}.
@end deftypeop

@c page
@node built-in hashtables eq
@subsection The @class{hashtable-eq} type


@deftp {Core Type} @aclass{hashtable-eq}
@deftpx {Parent Type} @aclass{hashtable}
Type of @func{eq?} hashtables.
@end deftp


@deftypeop Constructor @class{hashtable-eq} @aclass{hashtable-eq} type-constructor
@deftypeopx Constructor @class{hashtable-eq} @aclass{hashtable-eq} type-constructor @var{k}
The constructor if @func{make-eq-hashtable}.
@end deftypeop


@deftypeop {Type predicate} @class{hashtable-eq} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{hashtable-eq?}.
@end deftypeop

@c page
@node built-in hashtables eqv
@subsection The @class{hashtable-eqv} type


@deftp {Core Type} @aclass{hashtable-eqv}
@deftpx {Parent Type} @aclass{hashtable}
Type of @func{eqv?} hashtables.
@end deftp


@deftypeop Constructor @class{hashtable-eqv} @aclass{hashtable-eqv} type-constructor
@deftypeopx Constructor @class{hashtable-eqv} @aclass{hashtable-eqv} type-constructor @var{k}
The constructor if @func{make-eqv-hashtable}.
@end deftypeop


@deftypeop {Type predicate} @class{hashtable-eqv} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{hashtable-eqv?}.
@end deftypeop

@c page
@node built-in hashtables equiv
@subsection The @class{hashtable-equiv} type


@deftp {Core Type} @aclass{hashtable-equiv}
@deftpx {Parent Type} @aclass{hashtable}
Type of @func{equal?} hashtables.
@end deftp


@deftypeop Constructor @class{hashtable-equiv} @aclass{hashtable-equiv} type-constructor @var{hash-function} @var{equiv}
@deftypeopx Constructor @class{hashtable-equiv} @aclass{hashtable-equiv} type-constructor @var{hash-function} @var{equiv} @var{k}
The constructor if @func{make-hashtable}.
@end deftypeop


@deftypeop {Type predicate} @class{hashtable-equiv} @aclass{boolean} type-predicate @var{obj}
The type predicate is @func{hashtable-equiv?}.
@end deftypeop

@c page
@node built-in structs
@section Type of struct objects


@menu
* built-in structs base::       The @class{struct} type.
* built-in structs std::        The @class{struct-type-descriptor} type.
@end menu

@c page
@node built-in structs base
@subsection The @class{struct} type


@deftp {Core Type} @aclass{struct}
@deftpx {Parent Type} @aclass{top}
Type of struct objects.  There is no constructor.  The type predicate is
@func{struct?}.
@end deftp


@deftypeop Constructor @class{struct} @aclass{struct} type-constructor @var{stru}
Validate @var{stru} as struct object and return it.
@end deftypeop


@deftypeop {Type predicate} @class{struct} @class{boolean} type-predicate @var{obj}
The type predicate is @func{struct?}.
@end deftypeop


@deftypeop {Equality predicate} @class{struct} @class{boolean} equality-predicate @var{this} @bracearg{stru, struct}
The equality predicate is @func{struct=?}.
@end deftypeop


@deftypeop {Hash function} @class{struct} @class{non-negative-fixnum} hash-function @var{this}
The hash function is @func{struct-hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Methods: inspection


@deftypemethod @class{struct} @class{struct-type-descriptor} std @var{this}
Apply @func{struct-std} to the instance and return its return value.
@end deftypemethod


@deftypemethod @class{struct} @class{nestring} name @var{this}
Apply @func{struct-name} to the instance and return its return value.
@end deftypemethod


@deftypemethod @class{struct} @class{non-negative-fixnum} length @var{this}
Apply @func{struct-length} to the instance and return its return value.
@end deftypemethod


@deftypemethod @class{struct} {(list-of @aclass{symbol})} field-names @var{this}
Apply @func{struct-field-names} to the instance and return its return value.
@end deftypemethod


@deftypemethod @class{struct} @aclass{type-printer} printer @var{this}
Apply @func{struct-printer} to the instance and return its return value.
@end deftypemethod


@deftypemethod @class{struct} @aclass{type-destructor} destructor @var{this}
Apply @func{struct-destructor} to the instance and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: comparison


@deftypemethod @class{struct} @class{boolean} = @var{this} @bracearg{stru, struct}
Apply @func{struct=?} to the arguments and return its return value.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Methods: accessors and mutators


@deftypemethod @class{struct} @class{top} ref @var{this} @bracearg{idx, non-negative-fixnum}
Apply @func{struct-ref} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{struct} @class{void} set! @var{this} @bracearg{idx, non-negative-fixnum} @var{obj}
Apply @func{struct-set!} to the arguments and return its return value.
@end deftypemethod


@deftypemethod @class{struct} @class{void} reset @var{this}
Apply @func{struct-reset!} to the arguments and return its return value.
@end deftypemethod

@c page
@node built-in structs std
@subsection The @class{struct-type-descriptor} type


@deftp {Core Type} @aclass{struct-type-descriptor}
@deftpx {Parent Type} @aclass{struct}
Type of struct--type descriptor objects.
@end deftp


@deftypeop Constructor @class{struct-type-descriptor} @aclass{struct-type-descriptor} type-constructor @var{name} @var{fields}
@deftypeopx Constructor @class{struct-type-descriptor} @aclass{struct-type-descriptor} type-constructor @var{name} @var{fields} @var{uid}
The constructor if @func{make-struct-type}.
@end deftypeop


@deftypeop {Type predicate} @class{struct-type-descriptor} @class{boolean} type-predicate @var{obj}
The type predicate is @func{struct-type-descriptor?}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading methods


@deftypemethod @class{struct-type-descriptor} @aclass{string} name @var{this}
Apply @func{struct-type-name} to the instance and return its return
value.
@end deftypemethod


@deftypemethod @class{struct-type-descriptor} @aclass{symbol} uid @var{this}
Apply @func{struct-type-symbol} to the instance and return its return
value.
@end deftypemethod


@deftypemethod @class{struct-type-descriptor} {(list-of @aclass{symbol})} field-names @var{this}
Apply @func{struct-type-field-names} to the instance and return its
return value.
@end deftypemethod


@deftypemethod @class{struct-type-descriptor} @aclass{procedure} constructor @var{this}
Apply @func{struct-type-constructor} to the instance and return its
return value.
@end deftypemethod


@deftypemethod @class{struct-type-descriptor} @aclass{type-predicate} predicate @var{this}
Apply @func{struct-type-predicate} to the instance and return its return
value.
@end deftypemethod


@deftypemethod @class{struct-type-descriptor} @aclass{type-printer} printer @var{this}
Apply @func{struct-type-printer} to the instance and return its return
value.
@end deftypemethod


@deftypemethod @class{struct-type-descriptor} @aclass{type-destructor} destructor @var{this}
Apply @func{struct-type-destructor} to the instance and return its
return value.
@end deftypemethod


@deftypemethod @class{struct-type-descriptor} @aclass{procedure} field-accessor @var{this} @bracearg{idx, non-negative-fixnum}
@deftypemethodx @class{struct-type-descriptor} @aclass{procedure} field-accessor @var{this} @bracearg{name, symbol}
Apply @func{struct-type-field-accessor} to the instance and return its
return value.
@end deftypemethod


@deftypemethod @class{struct-type-descriptor} @aclass{procedure} field-mutator @var{this} @bracearg{idx, non-negative-fixnum}
@deftypemethodx @class{struct-type-descriptor} @aclass{procedure} field-mutator @var{this} @bracearg{name, symbol}
Apply @func{struct-type-field-mutator} to the instance and return its
return value.
@end deftypemethod


@deftypemethod @class{struct-type-descriptor} @aclass{procedure} field-method @var{this} @bracearg{idx, non-negative-fixnum}
@deftypemethodx @class{struct-type-descriptor} @aclass{procedure} field-method @var{this} @bracearg{name, symbol}
Apply @func{struct-type-field-method} to the instance and return its
return value.
@end deftypemethod

@c page
@node built-in records
@section Type of record objects


@deftp {Core Type} @aclass{record}
@deftpx {Parent Type} @aclass{struct}
Type of record objects.  There is no constructor.  The type predicate is
@func{record?}.
@end deftp


@deftp {Core Type} @aclass{record-type-descriptor}
@deftpx {Parent Type} @aclass{struct}
Type of record--type descriptor objects.  The constructor is
@func{make-record-type-descriptor}.  The type predicate is
@func{record-type-descriptor?}.
@end deftp


@deftp {Core Type} @aclass{record-constructor-descriptor}
@deftpx {Parent Type} @aclass{struct}
Type of record--constructor descriptor objects.  The constructor is
@func{make-record-constructor-descriptor}.  The type predicate is
@func{record-constructor-descriptor?}.
@end deftp

@c page
@node built-in conditions
@section Type of condition objects


@deftp {Core Type} @aclass{condition}
@deftpx {Parent Type} @aclass{record}
Type of condition objects.  There is no constructor.  The type predicate
is @func{condition?}.
@end deftp


@deftp {Core Type} @aclass{compound-condition}
@deftpx {Parent Type} @aclass{condition}
Type of compound condition objects.  The constructor is
@func{condition}.  The type predicate is @func{compound-condition?}.
@end deftp


@defmethod @class{condition} print
@defmethodx @class{compound-condition} print
Apply @func{print-condition} to the instance.
@end defmethod

@c page
@node built-in ports
@section Types of input/output ports


@menu
* built-in ports base::            Base port types.
* built-in ports textual in::      Textual input port types.
* built-in ports textual out::     Textual output port types.
* built-in ports textual in/out::  Textual input/output port types.
* built-in ports binary in::       Binary input port types.
* built-in ports binary out::      Binary output port types.
* built-in ports binary in/out::   Binary input/output port types.
@end menu

@c page
@node built-in ports base
@subsection Base port types


@deftp {Core Type} @aclass{port}
@deftpx {Parent Type} @aclass{top}
Base type for input, output and input/output ports.  There is no
constructor.  The type predicate is @func{port?}.
@end deftp


@deftp {Core Type} @aclass{input-port}
@deftpx {Parent Type} @aclass{port}
Base type for input ports.  There is no constructor.  The type predicate
is @func{input-port?}.
@end deftp


@deftp {Core Type} @aclass{output-port}
@deftpx {Parent Type} @aclass{port}
Base type for output ports.  There is no constructor.  The type
predicate is @func{output-port?}.
@end deftp


@deftp {Core Type} @aclass{input/output-port}
@deftpx {Parent Type} @aclass{port}
Base type for input/output ports.  There is no constructor.  The type
predicate is @func{input/output-port?}.
@end deftp


@deftp {Core Type} @aclass{textual-port}
Type of textual ports.  Its definition is equivalent to:

@lisp
(define-type <textual-port>
  (or <textual-input-port>
      <textual-output-port>
      <textual-input/output-port>))
@end lisp
@end deftp


@deftp {Core Type} @aclass{binary-port}
Type of binary ports.  Its definition is equivalent to:

@lisp
(define-type <binary-port>
  (or <textual-input-port>
      <textual-output-port>
      <textual-input/output-port>))
@end lisp
@end deftp

@c page
@node built-in ports textual in
@subsection Textual input port types


@deftp {Core Type} @aclass{textual-input-only-port}
@deftpx {Parent Type} @aclass{input-port}
Type of textual--only input ports.  There is no constructor.  The type
predicate is @func{textual-input-only-port?}.
@end deftp


@deftp {Label Type} @aclass{textual-input-port}
Type of textual input ports.  The type predicate is
@func{textual-input-port?}.  This label--type has the following type
annotation as parent:

@lisp
(or <textual-input-only-port>
    <textual-input/output-port>)
@end lisp
@end deftp

@c page
@node built-in ports textual out
@subsection Textual output port types


@deftp {Core Type} @aclass{textual-output-only-port}
@deftpx {Parent Type} @aclass{output-port}
Type of textual output port.  There is no constructor.  The type
predicate is @func{textual-output-port?}.
@end deftp


@deftp {Label Type} @aclass{textual-output-port}
Type of textual output ports.  The type predicate is
@func{textual-output-port?}.  This label--type has the following type
annotation as parent:

@lisp
(or <textual-output-only-port>
    <textual-input/output-port>)
@end lisp
@end deftp

@c page
@node built-in ports textual in/out
@subsection Textual input/output port types


@deftp {Core Type} @aclass{textual-input/output-port}
@deftpx {Parent Type} @aclass{input/output-port}
Type of textual input/output ports.  There is no constructor.  The type
predicate is @func{textual-input/output-port?}.
@end deftp

@c page
@node built-in ports binary in
@subsection Binary input port types


@deftp {Core Type} @aclass{binary-input-only-port}
@deftpx {Parent Type} @aclass{input-port}
Type of binary input ports.  There is no constructor.  The type
predicate is @func{binary-input-port?}.
@end deftp


@deftp {Label Type} @aclass{binary-input-port}
Type of binary input ports.  The type predicate is
@func{binary-input-port?}.  This label--type has the following type
annotation as parent:

@lisp
(or <binary-input-only-port>
    <binary-input/output-port>)
@end lisp
@end deftp

@c page
@node built-in ports binary out
@subsection Binary output port types


@deftp {Core Type} @aclass{binary-output-only-port}
@deftpx {Parent Type} @aclass{output-port}
Type of binary output ports.  There is no constructor.  The type
predicate is @func{binary-output-port?}.
@end deftp


@deftp {Label Type} @aclass{binary-output-port}
Type of binary output ports.  The type predicate is
@func{binary-output-port?}.  This label--type has the following type
annotation as parent:

@lisp
(or <binary-output-only-port>
    <binary-input/output-port>)
@end lisp
@end deftp

@c page
@node built-in ports binary in/out
@subsection Binary input/output port types


@deftp {Core Type} @aclass{binary-input/output-port}
@deftpx {Parent Type} @aclass{input/output-port}
Type of binary input/output ports.  There is no constructor.  The type
predicate is @func{binary-input/output-port?}.
@end deftp

@c page
@node built-in sentinel
@section Type of sentinel object


@deftp {Built-in Type} @aclass{sentinel}
@deftpx {Parent Type} @aclass{struct}
Type of the sentinel object (@vicarepxref{iklib sentinel, The sentinel
object}).
@end deftp


@defop Constructor @class{sentinel} new @aclass{sentinel}
The constructor is @func{sentinel}.  Return the sentinel object.
@end defop


@defop {Type predicate} @class{sentinel} is-a? @var{obj} @aclass{sentinel}
The type predicate is @func{sentinel?}.  Return @true{} if @var{obj} is
the sentinel object; otherwise return @false{}.
@end defop

@c page
@node built-in time
@section Type of time objects


@menu
* built-in time time::          Time spans object-type.
* built-in time epoch::         Time spans since the Epoch.
@end menu

@c page
@node built-in time time
@subsection Time spans object-type


@deftp {Built-in Type} @aclass{time}
@deftpx {Parent Type} @aclass{record}
Type name of time objects.  It can represent both absolute times
(typically elapsed times since the Epoch) and positive and negative time
spans relative to an arbitrary origin.  The internal time representation
has nanosecond resolution and it is immutable.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Operations


@deftypeop Constructor @aclass{time} @aclass{time} constructor @bracearg{seconds, exact-integer} @bracearg{nanoseconds, exact-integer}
@deftypeopx Constructor @aclass{time} @aclass{time} constructor @bracearg{megaseconds, exact-integer} @bracearg{seconds, exact-integer} @bracearg{nanoseconds, exact-integer}
Build and return a new @class{time} object.  If @var{nanoseconds}
exceeds @code{#e1e9} its value is normalised and the excess added to
@var{seconds}.  If @var{seconds} exceeds @code{#e1e6} its value is
normalised and the excess added to @var{megaseconds}.
@end deftypeop


@deftypeop {Type predicate} @aclass{time} @aclass{boolean} type-predicate @var{obj}
Return @true{} if @var{obj} is a @class{time} object; otherwise return
@false{}.
@end deftypeop


@deftypeop {Equality predicate} @aclass{time} @aclass{boolean} equality-predicate @var{this} @bracearg{T, time}
Return @true{} if the @class{time} objects are true, otherwise return
@false{}.  This equality predicate is used by @func{equal?}.
@end deftypeop


@deftypeop {Comparison procedure} @aclass{time} @aclass{fixnum} comparison-procedure @var{this} @bracearg{T, time}
Return @code{-1} if @vari{T} is less than @varii{T}; return @code{0} if
@vari{T} is equal to @varii{T}; return @code{+1} if @vari{T} is greater
than @varii{T}.
@end deftypeop


@deftypeop {Hash function} @aclass{time} @aclass{fixnum} hash-function @var{this}
Return a non--negative fixnum representing the hash value for @var{T}.
This hash function is used by the syntax @syntax{hash}.
@end deftypeop

@c ------------------------------------------------------------------------

@subsubheading Accessors


@deftypemethod @aclass{time} @aclass{exact-integer} seconds @var{this}
The number of seconds in the represented time span.
@end deftypemethod


@deftypemethod @aclass{time} @aclass{fixnum} nanoseconds @var{this}
The number of nanoseconds in the represented time span.
@end deftypemethod


@deftypemethod @aclass{time} @aclass{ratnum} ratnum @var{this}
@deftypemethodx @aclass{time} @aclass{flonum} flonum @var{this}
Return a real number representing the time in seconds.  This single
number is built from seconds and nanoseconds.
@end deftypemethod

@c ------------------------------------------------------------------------

@subsubheading Arithmetics


@deftypemethod @aclass{time} @aclass{time} + @var{this} @bracearg{T, time} @dots{}
Compute the addition between time objects: @code{@var{this} + @var{T} +
...} and return a time object representing it.
@end deftypemethod


@deftypemethod @aclass{time} @aclass{time} - @var{this} @bracearg{T, time} @dots{}
When only the instance @var{this} is given: return the negation of the
time object.  When additional arguments @var{T} are given, compute the
difference between time objects: @code{@var{this} - (@var{T} + ...)}
and return a time object representing it.
@end deftypemethod

@c ------------------------------------------------------------

@subsubheading Time comparison


@deftypemethod @aclass{time} @aclass{boolean} = @var{this} @bracearg{T, time} @dots{}
Return @true{} if the time objects are equal, else return @false{}.
@end deftypemethod


@deftypemethod @aclass{time} @aclass{boolean} != @var{this} @bracearg{T, time} @dots{}
Return @true{} if the arguments are all different: no two arguments are
equal; otherwise return @false{}.  When @var{this} is the only argument:
return @false{}.
@end deftypemethod


@deftypemethod @aclass{time} @aclass{boolean} < @var{this} @bracearg{T, time} @dots{}
Return @true{} if the time objects are monotonically increasing; else
return @false{}.
@end deftypemethod


@deftypemethod @aclass{time} @aclass{boolean} <= @var{this} @bracearg{T, time} @dots{}
Return @true{} if the time objects are monotonically non--decreasing;
else return @false{}.
@end deftypemethod


@deftypemethod @aclass{time} @aclass{boolean} > @var{this} @bracearg{T, time} @dots{}
Return @true{} if the time objects are monotonically decreasing; else
return @false{}.
@end deftypemethod


@deftypemethod @aclass{time} @aclass{boolean} >= @var{this} @bracearg{T, time} @dots{}
Return @true{} if the time objects are monotonically non--increasing;
else return @false{}.
@end deftypemethod


@deftypemethod @aclass{time} @aclass{boolean} max @var{this} @bracearg{T, time} @dots{}
@deftypemethodx @aclass{time} @aclass{boolean} min @var{this} @bracearg{T, time} @dots{}
Return the maximum or minimum between the arguments.
@end deftypemethod

@c page
@node built-in time epoch
@subsection Time spans since the Epoch


@deftp {Built-in Type} @aclass{epoch-time}
@deftpx {Parent Type} @aclass{time}
Type name of time objects representing the time elapsed since the Epoch.
The time is internally represented with nanosecond resolution.

Objects of this type representing the current time are returned by the
function @func{epoch-time} and built using the @posix{} function
@cfunc{clock_gettime} with the argument @code{CLOCK_REALTIME};
@manpage{clock_gettime, Clock and time functions}.
@end deftp


@deftypeop Constructor @aclass{epoch-time} @aclass{epoch-time} constructor @bracearg{seconds, exact-integer} @bracearg{nanoseconds, fixnum}
Build and return a new @class{epoch-time} object.  The arguments are
normalised as explained for the constructor of @class{time}.
@end deftypeop


@deftypeop {Type predicate} @aclass{epoch-time} @aclass{boolean} type-predicate @var{obj}
Return @true{} if @var{obj} is a @class{epoch-time} object; otherwise
return @false{}.
@end deftypeop


@deftypemethod @aclass{epoch-time} @aclass{epoch-time} + @var{this} @bracearg{T, time}
Add @var{T} to @var{this} and return the result.
@end deftypemethod


@deftypemethod @aclass{epoch-time} @aclass{epoch-time} - @var{this} @bracearg{T, time}
Subtract @var{T} from @var{this} and return the result.
@end deftypemethod

@c page
@node built-in misc
@section Miscellaneous built-in types


@deftp {Built--In Type} @class{&who-value}
The type of the field in the built--in condition object type
@condition{who}.  Its definition is equivalent to:

@lisp
(define-type <&who-value>
  (or <false> <symbol> <string>))
@end lisp
@end deftp


@deftp {Built--In Type} @class{file-descriptor}
The type of file descriptor values.  Its definition is equivalent to:

@lisp
(define-type <file-descriptor>
  <non-negative-fixnum>)
@end lisp
@end deftp

@c page
@node methods
@chapter Methods and virtual methods


@cindex Methods
@cindex Concrete methods
@cindex Virtual methods
@cindex Sealing methods
@cindex @clause{method}, record--type definition clause
@cindex @clause{method}, label--type definition clause
@cindex @clause{method}, interface--type definition clause
@cindex @clause{method}, mixin definition clause
@cindex @clause{virtual-method}, record--type definition clause
@cindex @clause{virtual-method}, mixin definition clause
@cindex @clause{seal-method}, record--type definition clause
@cindex @clause{seal-method}, mixin definition clause


Methods are possibly overloaded typed functions whose syntactic binding
resides in a namespace reserved to an object--type and that are
accessible only through an instance of such object--type.

The syntactic bindings @clause{method}, @clause{virtual-method} and
@clause{seal-method} are used as clause keywords in uses of
@syntax{define-record-type} to define methods and virtual methods for a
record--type; they can be used any number of times in the same
@syntax{define-record-type} macro use.

The clause @clause{method} is also accepted by
@syntax{define-label-type}, @syntax{define-interface-type} and
@syntax{define-mixin-type}.

The clauses @clause{virtual-method} and @clause{seal-method} are also
accepted by @syntax{define-mixin-type}.

@menu
* methods concrete::      Concrete methods.
* methods virtual::       Virtual methods.
* methods sealing::       Sealing methods.
* methods calling::       Calling object-type methods.
@end menu

@c page
@node methods concrete
@section Concrete methods


We can think of @clause{method} as acting like @syntax{define/checked}
with regard to the syntax of arguments to function; the first argument
to a method is the record itself, but it is implicit: we can access it
using the fluid syntax @syntax{this}.  For example, using the procedural
coding style:

@lisp
(define-record-type <duo>
  (strip-angular-parentheses)
  (fields one two)
  (method (sum-them)
    (+ (duo-one this)
       (duo-two this)))
  (method (mul-them)
    (* (duo-one this)
       (duo-two this))))

(define O
  (make-duo 1 2))

(method-call sum-them O)        @result{} 3
@end lisp

@noindent
and using the object--oriented syntax style:

@lisp
(define-record-type <duo>
  (fields one two)
  (method (sum-them)
    (+ (.one this)
       (.two this)))
  (method (mul-them)
    (* (.one this)
       (.two this))))

(define O
  (new <duo> 1 2))

(.sum-them O)   @result{} 3
@end lisp

The syntax @syntax{method-call} searches for a record--type's methods by
using @func{eq?} to search for the method's name, as symbol, in the
record--type's internal table of methods (it does @strong{not} use the
syntactic identifiers with @func{free-identifier=?}).  @ref{methods
calling, Calling object--type methods}.

@menu
* methods concrete overloaded::  Overloaded methods.
* methods concrete fields::      Field methods.
* methods concrete override::    Overriding methods.
@end menu

@c page
@node methods concrete overloaded
@subsection Overloaded methods


The clause @clause{method} allows the definition of overloaded
functions, with multiple function specialisations associated to the same
method name.  Example:

@lisp
(define-record-type <alpha>
  (fields a b)

  (method (@{doit <list>@} @{A <fixnum>@})
    (list (.a this) (.b this) 'fixnum A))

  (method (@{doit <list>@} @{A <symbol>@})
    (list (.a this) (.b this) 'symbol A))

  (method (@{doit <list>@} @{A <number>@} @{B <number>@})
    (list (.a this) (.b this) 'numbers A B)))

(define O
  (new <alpha> 1 2))

(.doit O 123)           @result{} (1 2 fixnum 123)
(.doit O 'ciao)         @result{} (1 2 symbol ciao)
(.doit O 3 4)           @result{} (1 2 numbers 3 4)
@end lisp

@noindent
we can think of the methods defined above as expanding to the following
definitions:

@lisp
(define/overload (@{doit <list>@} @{subject <alpha>@}
                      @{A <fixnum>@})
  (fluid-let-syntax ((this (make-synonym-transformer #'subject)))
    (list (.a this) (.b this) 'fixnum A)))

(define/overload (@{doit <list>@} @{subject <alpha>@}
                      @{A <symbol>@})
  (fluid-let-syntax ((this (make-synonym-transformer #'subject)))
    (list (.a this) (.b this) 'symbol A)))

(define/overload (@{doit <list>@} @{subject <alpha>@}
                      @{A <number>@} @{B <number>@})
  (fluid-let-syntax ((this (make-synonym-transformer #'subject)))
    (list (.a this) (.b this) 'numbers A B)))
@end lisp

@noindent
where @var{subject} is a non--accessible identifier.

@c page
@node methods concrete fields
@subsection Field methods


When methods are defined for record-types: method names cannot be equal
to field names; field accessors and mutators are accessible as methods
automatically, with a method name equal to the field name.  The syntax
of @syntax{method-call} is:

@example
(method-call @meta{name} @meta{subject-expr} @meta{arg} ...)
@end example

@noindent
when there are no @meta{arg} operand the syntax is compatible with a
field accessor call; when there is a single @meta{arg} operand the
syntax is compatible with a field mutator call.

So we can access and mutate fields as follows:

@lisp
(define-record-type <alpha>
  (fields (mutable a)))

(define O
  (new <alpha> 1))

(.a O)          @result{} 1
(.a O 2)
(.a O)          @result{} 2
@end lisp

@c page
@node methods concrete override
@subsection Overriding methods


When a hierarchy of record--types is defined: the sub--types can
override the super--type's concrete methods by defining methods with the
same name.  Example:

@lisp
(define-record-type <super>
  (method (doit)
    1))

(define-record-type <sub>
  (parent <super>)
  (method (doit)
    2))

(define (super-fun @{O <super>@})
  (.doit O))

(define (sub-fun   @{O <sub>@})
  (.doit O))

(define O
  (new <sub>))

(super-fun O)   @result{} 1
(sub-fun   O)   @result{} 2
@end lisp

The method of the super--type is still accessible if we ``see'' the
object instance through the super--type's type specification.

The sub--type's method is in no way limited by the super--type's method:
the two methods are allowed to have completely different type
signatures.

@c page
@node methods virtual
@section Virtual methods


The clause @clause{virtual-method} allows the definition of virtual
methods associated to a record--type.  Virtual methods work almost like
concrete methods, but the rules of overriding are different: with
virtual methods we request run--time dynamic dispatching, to have the
methods of the sub--types take precedence over the methods of the
super--types.

@quotation
@strong{NOTE} Virtual methods must have an implementation, there are no
abstract methods.
@end quotation

Example:

@lisp
(define-record-type <super>
  (virtual-method (doit)
    1))

(define-record-type <sub>
  (parent <super>)
  (method (doit)
    2))

(define (super-fun @{O <super>@})
  (.doit O))

(define (sub-fun   @{O <sub>@})
  (.doit O))

(define O
  (new <sub>))

(super-fun O)   @result{} 2
(sub-fun   O)   @result{} 2
@end lisp

@noindent
we see that even though the function @func{super-fun} accesses the
instance of @class{sub} with the type specification @class{super}, the
actually called method is the one defined by @class{sub}.

The overriding method's type signature must be a sub--type of the
overridden method's type signature.  For example, the following
definitions are fine:

@lisp
(define-record-type <super>
  (fields value)
  (virtual-method (@{doit <number>@} @{S <nestring>@})
    (.value this)))

(define-record-type <sub>
  (parent <super>)
  (virtual-method (@{doit <fixnum>@} @{S <string>@})
    (.value this)))
@end lisp

@noindent
because:

@lisp
(type-annotation-super-and-sub?
   (lambda (<nestring>) => (<number>))
   (lambda (<string>)   => (<fixnum>)))
@result{} #t
@end lisp

@noindent
while the following definitions will cause a syntax violation exception
at expand--time:

@lisp
(define-record-type <super>
  (fields value)
  (virtual-method (@{doit <number>@} @{S <nestring>@})
    (.value this)))

(define-record-type <sub>
  (parent <super>)
  (virtual-method (@{doit <fixnum>@} @{S <vector>@})
    (.value this)))
@end lisp

@noindent
because:

@lisp
(type-annotation-super-and-sub?
   (lambda (<nestring>) => (<number>))
   (lambda (<string>)   => (<vector>)))
@result{} #f
@end lisp

Once a method has been defined as virtual in a super--type, it does not
matter if the sub--type makes use of @clause{method},
@clause{virtual-method} or @clause{seal-method}: all these clauses will
override the super--type's method if they use the same name.  Example:

@lisp
(define-record-type <super>
  (virtual-method (darkness)
    1)
  (virtual-method (light)
    2))

(define-record-type <sub>
  (parent <super>)
  (method (darkness)
    11)
  (virtual-method (light)
    22))

(define @{P <super>@}
  (new <sub>))

(.darkness P)   @result{} 11
(.light    P)   @result{} 22
@end lisp

Notice that it is not possible to define a sub--type having a field with
the same name of a super--type's virtual method; the following
definitions will cause an expand--time exception:

@lisp
(define-record-type <super>
  (method (doit)
    1))

(define-record-type <sub>
  (parent <super>)
  (fields doit))
@error{} &syntax
@end lisp

The clause @clause{seal-method} seals a method name so that the
sub--types can no more use it; it does not matter if the super--types
actually use it or not.

@c page
@node methods sealing
@section Sealing methods


It happens that we want to define virtual methods in a super--type,
override them in a sub--type and then forbid further overriding in the
sub--types of the sub-type.  This is possible with sealing methods.

The clause @clause{seal-method} allows the definition of methods
associated to a record--type that might override the super--type's
methods, but that forbid the sub--types from overriding them.  For
everything else: sealing methods work like concrete methods.

In the following example everything works as usual, with @class{sub}
overriding the implementation of @func{doit} in @class{super}:

@lisp
(define-record-type <super>
  (virtual-method (doit)
    1))

(define-record-type <sub>
  (parent <super>)
  (seal-method (doit)
    2))

(define (super-fun @{O <super>@})
  (.doit O))

(define (sub-fun   @{O <sub>@})
  (.doit O))

(define O
  (new <sub>))

(super-fun O)   @result{} 2
(sub-fun   O)   @result{} 2
@end lisp

@noindent
but adding the following definition will cause an expand--time
exception, because sub--types of @class{sub} are forbidden from having a
method named @func{doit}:

@lisp
(define-record-type <sub-sub>
  (parent <sub>)
  (method (doit)
    3))
@error{} &syntax
@end lisp

@noindent
the following definition will also cause an expand--time exception,
because sub--types of @class{sub} are forbidden from having a field
named @func{doit}:

@lisp
(define-record-type <sub-sub>
  (parent <sub>)
  (fields doit))
@error{} &syntax
@end lisp

@c page
@node methods calling
@section Calling object-type methods


The following keyword syntactic bindings are involved in the definition
and use of methods: @clause{method}, @clause{virtual-method},
@clause{seal-method}, @syntax{method-call}.  In addition the function
@func{method-call-late-binding} performs a method call with ``late
binding'' (run--time dispatching).

The keyword @clause{method} is used in @syntax{define-record-type} to
define methods for a record--type (@vicarepxref{iklib records defs
methods, Record--type methods}).  For example:

@lisp
(define-record-type duo
  (fields one two)
  (method (sum-them)
    (+ (duo-one this)
       (duo-two this)))
  (method (mul-them)
    (* (duo-one this)
       (duo-two this))))
@end lisp

@noindent
the syntax @syntax{method-call} is then used to call a record's methods:

@lisp
(define @{O duo@}
  (new duo 3 5))

(method-call sum-them O)        @result{} 8
(method-call mul-them O)        @result{} 15
@end lisp

When defining a record or struct: @value{PRJNAME} automatically adds a
method to the methods table, for each field, with the same name of the
field.  When the field is mutable: if the method is called with one
argument, it behaves as a field accessor; if the method is called with
two arguments, it behaves as a field mutator.  When the field is
immutable: the method can be called with one argument only.  Example:

@lisp
(define-record-type duo
  (fields (immutable one)
          (mutable   two)))

(define @{O duo@}
  (new duo 1 2))

(method-call one O)     @result{} 1
(method-call one O 123) @error{} &syntax
(method-call two O)     @result{} 2
(method-call two O 9)
(method-call two O)     @result{} 9
@end lisp

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn Syntax method-call @meta{name} @meta{subject-expr} @meta{arg} @dots{}
Apply an object--type's method to the return value of
@meta{subject-expr} and the optional arguments @meta{arg}.

@meta{name} must be a symbol representing a method or field name.
@meta{subject-expr} must be a Scheme expression which, expanded and
evaluated at run--time, returns a single value.  Each @meta{arg} must be
a Scheme expression which, expanded and evaluated at run--time, returns
a single value.

When possible, @syntax{method-call} determines at expand--time the type
of the expression @meta{subject-expr} and searches for a method with
equal name, according to @func{eq?}.  If the method is found, the
syntactic identifier to which the implementation procedure is bound is
inserted in the macro expansion:

@lisp
(@meta{procedure} @meta{subject-expr} @meta{arg} ...)
@end lisp

@noindent
If the object--type of @meta{subject-expr} has no matching method: its
super--type is inspected, then the super--type of the super--type and so
on.  If no method is found in the types hierarchy: an exception is
raised.

@syntax{method-call} is able to retrieve the type of its second argument
at expand--time only when the typed language is enabled.  If
@syntax{method-call} cannot determine the type of @meta{subject-expr} at
expand--time, the macro use is expanded to:

@lisp
(method-call-late-binding (quote @meta{name}) #f
                          @meta{subject-expr} @meta{arg} ...)
@end lisp

@noindent
and the function @func{method-call-late-binding} attempts to determine a
suitable method at run--time.
@end deffn


@defun method-call-late-binding @var{name} @var{td} @var{subject} @var{arg} @dots{}
Apply an object--type's method to @var{subject} and the optional
arguments @meta{arg}.  Return the application results.

The argument @var{name} must be a symbol representing a method or field
name.  The argument @var{subject} must be a Scheme object implementing a
set of methods.  The optional @meta{arg} arguments can be any value.

The argument @var{td} must be @false{} or a predetermined type
descriptor for @var{subject}; this argument is usually @false{}.

This function attempts to determine the type of @var{subject} at
run--time and searches the object--type's table of methods, if any, for
a method whose name equals @var{name} according to @func{eq?}.  If a
method is found, its implementation procedure is retrieved and applied
to @var{subject} and the @var{arg} values.

If the object--type of @var{subject} has no matching method: its
super--type is inspected, then the super--type of the super--type and so
on.  If no method is found in the type's hierarchy: an exception is
raised.

Usually we do not need to call this function explicitly; however, it is
useful for debugging purposes.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Dot notation

When the Scheme reader's textual input port is configured in
@samp{#!vicare} mode: if a list starts with a symbol; the name of the
symbol is a string of length at least @math{2}; the first character of
the string is a dot; the second character of the string is @strong{not}
a dot, then a @syntax{method-call} symbol is inserted and the symbol
stripped of the dot.

We can try it at the @repl{}:

@example
vicare> '(.ciao)
$1 = (method-call ciao)
@end example

Notice that @rnrs{6} forbids symbols starting with a dot, with the
exception of the ellipsis; so this transformation does not influence the
other reader operations.

We can use this notation to call an object--type's methods as in the
following program:

@lisp
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))

  (define-record-type duo
    (fields one two)

    (method (sum-them)
      (+ (.one this) (.two this)))

    (method (mul-them)
      (* (.one this) (.two this)))

    (method (display port)
      (display this port)))

  (define @{O duo@}
    (new duo 3 4))

  (pretty-print (.sum-them O)
                (current-error-port))

  (pretty-print (.mul-them O)
                (current-error-port))

  (.display O (current-error-port))
  (newline (current-error-port))

  #| end of program |# )
@end lisp

@c page
@node protlev
@chapter Protection levels


@cindex Protection levels for record--type's members
@cindex Record--types, protection levels for members


When the typed language is enabled, record--type definitions support
protection levels for fields and methods.  Protection levels limit the
way fields and methods can be used both from other types in the
record--type hierarchy and from outside a record--type's definition.

Three protection levels are supported: @clause{public},
@clause{protected} and @clause{private}; they are loosely modeled after
the ones defined in the C++ language.

The following syntactic bindings are exported by the library
@library{vicare}.


@deffn {Auxiliary Syntax} public
Select the @clause{public} protection level for the associated fields
and methods.  When a member of record--type @class{T} is given the
@clause{public} protection level: sub--types of @class{T} can access it;
instances of @class{T} can access it from outside methods.

When no protection level is specified for a member in a record--type
definition: the protection level defaults to @clause{public}.
@end deffn


@deffn {Auxiliary Syntax} protected
Select the @clause{protected} protection level for the associated fields
and methods.  When a member of record--type @class{T} is given the
@clause{protected} protection level: sub--types of @class{T} can access
it; instances of @class{T} cannot access it from outside methods.
@end deffn


@deffn {Auxiliary Syntax} private
Select the @clause{private} protection level for the associated fields
and methods.  When a member of record--type @class{T} is given the
@clause{private} protection level: sub--types of @class{T} cannot access
it; instances of @class{T} cannot access it from outside methods.
@end deffn

@float Table
@multitable {Members of the same type} {public} {protected} {private}
@headitem Access @tab public @tab protected @tab private
@item Members of the same type
@tab yes
@tab yes
@tab yes
@item Members of sub--type
@tab yes
@tab yes
@tab no
@item Not members
@tab yes
@tab no
@tab no
@end multitable
@caption{Summary of protection levels.}
@end float

The protection level keywords can be used either as ``enclosing
syntaxes'' as in:

@lisp
(define-record-type <duo>
  (public
    (fields one two)
    (method (add)
      (+ (.one this) (.two this)))))
@end lisp

@noindent
or as ``attribute syntaxes'' as in:

@lisp
(define-record-type <duo>
  (fields public one two)
  (method public (add)
    (+ (.one this) (.two this))))
@end lisp

The only clauses that can be put in an enclosing syntax and that accept
an attribute syntax are: @clause{fields}, @clause{method},
@clause{virtual-method}, @clause{seal-method}.

@c ------------------------------------------------------------------------

@subsubheading Usage and limitations by examples

The protection levels limit the access to members from outside a
method's body:

@lisp
(define-record-type <blue>
  (method public    (pub)  1)
  (method protected (pro)  2)
  (method private   (pri)  3))

(define O
  (new <blue>))

(.pub O)        @result{} 1
(.pro O)        @error{} not a public method
(.pri O)        @error{} not a public method
@end lisp

When super--type's members are @clause{public}, everything works as
usual:

@lisp
(define-record-type <blue>
  (fields public light))

(define-record-type <dark-blue>
  (parent <blue>)
  (method public (doit)
    (.light this)))

(define O
  (new <dark-blue> 1))

(define @{X <blue>@}
  O)

(.doit  O)      @result{} 1
(.light X)      @result{} 1
@end lisp

When super--type's members are @clause{protected}, we can access them
from the super--type's methods and from the sub--type's methods:

@lisp
(define-record-type <blue>
  (fields protected light)
  (method public (doit)
    (.light this)))

(define-record-type <dark-blue>
  (parent <blue>)
  (method public (doit)
    (.light this)))

(define O
  (new <dark-blue> 1))

(.doit O)       @result{} 1

(define @{X <blue>@}
  O)

(.light X)      @error{} not a public method
(.doit  X)      @result{} 1
@end lisp

When super--type's members are @clause{private}, we can access them from
the super--type's methods only:

@lisp
(define-record-type <blue>
  (fields private light)
  (method public (doit)
    (.light this)))

(define X
  (new <blue> 1))

(.light X)      @error{} not a public method
(.doit  X)      @result{} 1

(define-record-type <dark-blue>
  (parent <blue>)
  (method public (doit)
    (.light this)))     @error{} not a public or protected method
@end lisp

It is not an error to define a private virtual method, but such method
cannot be overridden by the sub--types:

@lisp
(define-record-type <blue>
  (virtual-method private (doit) 1))

(define-record-type <dark-blue>
  (parent <blue>)
  (method (doit) 2))    @error{} cannot override private method
@end lisp

Virtual methods overriding and sealing is possible only among methods of
the same protection level:

@lisp
(define-record-type <blue>
  (protected
    (virtual-method (over)
      'over-blue))
  (method (doit)
    (.over this)))

(define-record-type <dark-blue>
  (parent <blue>)
  (protected
    (method (over)
      'over-dark-blue)))

(define O
  (new <dark-blue>))

(define (fun @{X <blue>@})
  (.doit X))

(fun O)         @result{} over-dark-blue
@end lisp

@c page
@node mixins
@chapter Sharing object--type definition clauses


@cindex Library @library{vicare language-extensions mixins}
@cindex @library{vicare language-extensions mixins}, library


@dfn{Mixins} are a way to add definition clauses to record--types and
labels.  Interfaces are implemented half in the boot image and half in
the library @library{vicare language-extensions mixins}.

Let's consider this situation:

@lisp
(define-record-type <alpha>
  (fields a))

(define-record-type <beta>
  (fields b))

(define-record-type <delta>
  (parent <alpha>)
  (fields v)
  (method (doit)
    (+ 1 (.v this))))

(define-record-type <gamma>
  (parent <beta>)
  (fields v)
  (method (doit)
    (+ 1 (.v this))))
@end lisp

@noindent
the definitions of @class{delta} and @class{gamma} share some clauses;
both of them already have a parent type and multiple inheritance is not
supported by @value{PRJNAME}.  Is it possible to write the shared
clauses only once and attach them to the record--type definitions?  Yes,
with mixins.  The example above is equivalent to the following:

@lisp
(define-record-type <alpha>
  (field a))

(define-record-type <beta>
  (field b))

(define-mixin-type <stuff>
  (field v)
  (method (doit)
    (+ 1 (.v this))))

(define-record-type <delta>
  (parent <alpha>)
  (mixins <stuff>))

(define-record-type <gamma>
  (parent <beta>)
  (mixins <stuff>))
@end lisp

@noindent
the syntax use of @syntax{define-mixin-type} associates a set of clauses to
the identifier @class{stuff}; when the @clause{mixins} clause is used in
the body of a record--type definition:

@enumerate
@item
The clauses associated to the selected mixin identifier are retrieved as
syntax object.

@item
All the instances of the identifier @class{stuff} are substituted with
the identifier of the enclosing record--type; @class{delta} and
@class{gamma} in the example.

@item
The resulting clauses are added to the enclosing definition.
@end enumerate


@deffn {Auxiliary Syntax} mixins @meta{mixin-name} @dots{}
Compose the enclosing record--type, label or mixin definition with the
given list of mixins.  This clause can be used multiple times.  This
syntactic binding is exported by the library @library{vicare}.

The syntactic identifiers @meta{mixin-name} are used to reference the
mixins to be imported.  The clauses are included in the same order in
which the @meta{mixin-name} identifiers are present in the
@clause{mixins} clause and in the same place in which the
@clause{mixins} clause is present in the enclosing definition.

It is a syntax violation if a mixin identifier name is not already
associated to a set of clauses at the time the receiving definition is
expanded.
@end deffn


@deffn Syntax define-mixin-type @meta{mixin-name} @metao{clause} @meta{clause} ...
Associate a set of mixin clauses to the identifier @meta{mixin-name},
which can be later referenced by a @clause{mixins} clause in the body of
a class or label definition.  This syntactic binding is exported by the
library @library{vicare language-extensions mixins}.

The @clause{mixins} clause can be used in the body of a mixin
definition; the result is that the clauses of the imported mixins are
added to the enclosing mixin definition.

The following clauses are accepted in the body of a
@syntax{define-mixin-type}:

@lisp
define-type-descriptors strip-angular-parentheses
nongenerative sealed opaque protocol super-protocol fields
method virtual-method seal-method
custom-printer type-predicate equality-predicate
comparison-procedure hash-function
public protected private
implements
@end lisp
@end deffn

@c page
@node interfaces
@chapter Interface types


@cindex Library @library{vicare language-extensions interfaces}
@cindex @library{vicare language-extensions interfaces}, library


The @dfn{interfaces} are a mechanism to verify, at expand--time, that
instances of an object--type can be used in a generic expression,
because they implement all the needed methods and such methods can be
called at run--time through dynamic dispatching.

Interfaces are implemented half in the boot image and half in the
library @library{vicare language-extensions interfaces}.

@menu
* interfaces intro::      Introduction to interfaces.
* interfaces defs::       Defining interfaces.
* interfaces descr::      Interfaces type descriptors.
* interfaces examples::   Interfaces by examples.
@end menu

@c page
@node interfaces intro
@section Introduction to interfaces


Let's consider this code:

@lisp
(define-record-type <a-vector>
  (fields @{vec <nevector>@})
  (method (@{first <top>@})
    (vector-ref (.vec this) 0)))

(define-record-type <a-string>
  (fields @{vec <nestring>@})
  (method (@{first <top>@})
    (string-ref (.vec this) 0)))

(define-record-type <a-list>
  (fields @{vec <nelist>@})
  (method (@{first <top>@})
    (car (.vec this))))

(define (fun O)
  (.first O))

(fun (new <a-vector> '#(1 2 3)))        @result{} 1
(fun (new <a-string> "ABC"))            @result{} #\A
(fun (new <a-list> '(a b c)))           @result{} a
@end lisp

@noindent
everything works fine in the function @func{fun} because all of
@class{a-vector}, @class{a-string} and @class{a-list} implement the
method @samp{first}.  The code @code{(.first O)} expands into a call to
@func{method-call-late-binding}, which, at run--time, finds the method
implementation functions in the type descriptors of @class{a-vector},
@class{a-string} and @class{a-list}.

Fine, but the code is not type--checked at expand--time.  Enter
interfaces.  Let's modify the code as follows:

@lisp
(define-interface-type <Sequence>
  (method-prototype first
    (lambda () => (<top>))))

(define-record-type <a-vector>
  (implements <Sequence>)
  (fields @{vec <nevector>@})
  (method (@{first <top>@})
    (vector-ref (.vec this) 0)))

(define-record-type <a-string>
  (implements <Sequence>)
  (fields @{vec <nestring>@})
  (method (@{first <top>@})
    (string-ref (.vec this) 0)))

(define-record-type <a-list>
  (implements <Sequence>)
  (fields @{vec <nelist>@})
  (method (@{first <top>@})
    (car (.vec this))))

(define (fun @{O <Sequence>@})
  (.first O))

(fun (new <a-vector> '#(1 2 3)))        @result{} 1
(fun (new <a-string> "ABC"))            @result{} #\A
(fun (new <a-list> '(a b c)))           @result{} a
@end lisp

@noindent
everything works almost as before, but the record--type definition
clause @code{(implements <Sequence>)} causes the expander to validate,
at expand-time, that the record--types actually implement a method
@code{first} with the correct type signature.

Also, the function application @code{(fun @meta{operand})} is validated
at expand--time to verify that the type of @meta{operand} is an
object--type that implements @class{Sequence}.  Such validation can
happen @strong{only} if the expander is able to determine the type of
@meta{operand}; this validation cannot happen at run--time, so, for
example, it is impossible for label types to implement interfaces.

@c page
@node interfaces defs
@section Defining interfaces


The following syntactic bindings are exported by the library
@library{vicare language-extensions interfaces}.


@deffn Syntax define-interface-type @meta{name} @meta{clause} @dots{}
@deffnx {Auxiliary Syntax} nongenerative
@deffnx {Auxiliary Syntax} parent
@deffnx {Auxiliary Syntax} implements
@deffnx {Auxiliary Syntax} method-prototype
@deffnx {Auxiliary Syntax} method
Define a new interface--type bound to the syntactic identifier
@meta{name}.  The syntactic bindings @clause{nongenerative},
@clause{parent}, @clause{implements}, @clause{method} are the same ones
exported by @library{vicare} and are reexported by the library
@library{vicare language-extensions interfaces}.

Interfaces cannot be instantiated: attempting to do it will raise an
expand--time exception.

A use of the clause @clause{nongenerative} must have one of the formats:

@lisp
(nongenerative)
(nongenerative @meta{uid})
@end lisp

@noindent
when used it causes the interface--type to be non--generative.  This
concept is the same as for record--types, so usually we do want to
define non--generative interface--types.

A use of the clause @clause{parent} must have the format:

@lisp
(parent @meta{parent-name})
@end lisp

@noindent
and causes the new interface--type to become a sub--type of
@meta{parent-name}, which must be a syntactic identifier representing
the name of an already defined interface--type.  An object--type
implementing the interface @meta{name} must also implement all the
methods required by the interface @meta{parent-name}.

A use of the clause @clause{implements} must have format:

@lisp
(implements @meta{iface-name} ...)
@end lisp

@noindent
and declares that an object--type implementing the interface--type
@meta{name} also implements all the methods in the interface--types
@meta{iface-name}.  The definition of @meta{name} must include a
@clause{method-prototype} clause for each method required by the
interfaces @meta{iface-name}, with matching type signatures.

A use of the clause @clause{method-prototype} must have format:

@lisp
(method-prototype @meta{method-name} @meta{signature})
@end lisp

@noindent
where @meta{method-name} is an identifier representing the name of the
method and @meta{signature} is a @syntax{lambda} or @syntax{case-lambda}
type annotation representing the type signature of the method.  Any
object--type that implements an interface, must implement all the
methods with signatures that are sub--types of the method prototypes.

A use of the clause @clause{method} must have format:

@lisp
(method (@meta{who} . @meta{typed-formals})
  . @meta{body})

(method ((brace @meta{who} . @meta{rv-types}) . @meta{typed-formals})
  . @meta{body})
@end lisp

@noindent
which is the same syntax for @syntax{define-record-type}.  The clause
@clause{method} defines a required method prototype which also has a
default implementation.  An object--type implementing the interface
@meta{name} is allowed not to implement a method matching an interface
prototype with default implementation.
@end deffn

@c page
@node interfaces descr
@section Interfaces type descriptors


Interfaces have run--time type descriptors, accessible through the
@syntax{type-descriptor} syntax, @ref{descriptors other interface,
Interface type descriptors}.  Example:

@lisp
(import (prefix (vicare system type-descriptors)
                td::))

(define-interface-type <Stuff>
  (method-prototype red
    (lambda () => (<top>)))
  (method (blue)
    2))

(define itd
  (type-descriptor <Stuff>))

(td::interface-type-descr? itd)
@result{} #t

(td::interface-type-descr.type-name itd)
@result{} <Stuff>
@end lisp

@c page
@node interfaces examples
@section Interfaces by examples


Let's illustrate the features and limitations of interface--types by
examples.

Whenever an interface inherits from another interface, it obviously
becomes its sub--type:

@lisp
(define-interface-type <IParent>
  (method-prototype doit
    (lambda (<number>) => (<string>))))

(define-interface-type <IChild>
  (parent <IParent>))

(type-annotation-super-and-sub? <IParent> <IChild>) @result{} #t
(type-annotation-super-and-sub? <IChild> <IParent>) @result{} #f
@end lisp

An interface can implement another interface; the implementer must
declare a matching method prototype for every method prototype of the
implemented.  The method prototype of the implementer must be a
sub--type of the method prototype of the implemented.  Given that:

@lisp
(type-annotation-super-and-sub?
  (lambda (<nestring>) => (<number>))
  (lambda (<string>)   => (<fixnum>)))
@result{} #t
@end lisp

@noindent
we can define:

@lisp
(define-interface-type <IOne>
  (method-prototype doit
    (lambda (<nestring>) => (<number>))))

(define-interface-type <ITwo>
  (implements <IOne>)
  (method-prototype doit
    (lambda (<string>) => (<fixnum>))))

(type-annotation-super-and-sub? <IOne> <ITwo>) @result{} #t
(type-annotation-super-and-sub? <ITwo> <IOne>) @result{} #f
@end lisp

An interface can inherit method prototypes from another interface and
use those to implement another interface:

@lisp
(define-interface-type <I>
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-interface-type <A>
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-interface-type <B>
  (parent <A>)
  (implements <I>))

(type-annotation-super-and-sub? <I> <A>) @result{} #f
(type-annotation-super-and-sub? <I> <B>) @result{} #t
(type-annotation-super-and-sub? <A> <I>) @result{} #f
(type-annotation-super-and-sub? <B> <I>) @result{} #f
@end lisp

If the interface @class{ISub} inherits from @class{ISuper}, to implement
@class{ISub} the interface @class{A} has to declare a method for every
method in @class{ISub} and @class{ISuper}:

@lisp
(define-interface-type <ISuper>
  (method-prototype super-doit
    (lambda (<string>) => (<number>))))

(define-interface-type <ISub>
  (parent <ISuper>)
  (method-prototype sub-doit
    (lambda (<string>) => (<fixnum>))))

(define-interface-type <A>
  (implements <ISub>)
  (method-prototype super-doit
    (lambda (<string>) => (<number>)))
  (method-prototype sub-doit
    (lambda (<string>) => (<fixnum>))))

(type-annotation-super-and-sub? <ISuper> <A>) @result{} #t
(type-annotation-super-and-sub? <ISub>   <A>) @result{} #t
(type-annotation-super-and-sub? <A> <ISuper>) @result{} #f
(type-annotation-super-and-sub? <A> <ISub>)   @result{} #f
@end lisp

Interface @class{B} implements interface @class{A}; interface @class{C}
implements interface @class{B}; automatically, interface @class{C}
implements interface @class{A}:

@lisp
(define-interface-type <A>
  (method-prototype red         (lambda () => (<fixnum>))))

(define-interface-type <B>
  (implements <A>)
  (method-prototype red         (lambda () => (<fixnum>)))
  (method-prototype blue        (lambda () => (<symbol>))))

(define-interface-type <C>
  (implements <B>)
  (method-prototype red         (lambda () => (<fixnum>)))
  (method-prototype blue        (lambda () => (<symbol>))))

(type-annotation-super-and-sub? <A> <B>) @result{} #t
(type-annotation-super-and-sub? <A> <C>) @result{} #t
(type-annotation-super-and-sub? <B> <A>) @result{} #f
(type-annotation-super-and-sub? <B> <C>) @result{} #t
(type-annotation-super-and-sub? <C> <A>) @result{} #f
(type-annotation-super-and-sub? <C> <B>) @result{} #f
@end lisp

An interface that inherits from another interface can ``extend'' its
method prototypes with additional signatures.  The interface
@class{IThree} implements the interfaces @class{IOne} and @class{ITwo}.
@class{IThree} implements the ``composite'' method from @class{IOne} and
@class{ITwo} with multiple @clause{method-prototype} clauses:

@lisp
;;
;;                 <IOne>
;;                    ^
;;                    |
;;   <IThree> +++> <ITwo>
;;
(define-interface-type <IOne>
  (method-prototype doit
    (lambda (<fixnum>) => (<string>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype doit
    (lambda (<flonum>) => (<string>))))

(define-interface-type <IThree>
  (implements <ITwo>)
  (method-prototype doit (lambda (<fixnum>) => (<string>)))
  (method-prototype doit (lambda (<flonum>) => (<string>))))

(type-annotation-super-and-sub? <IOne>   <IThree>) @result{} #t
(type-annotation-super-and-sub? <IOne>   <ITwo>)   @result{} #t
(type-annotation-super-and-sub? <ITwo>   <IThree>) @result{} #t
(type-annotation-super-and-sub? <IThree> <IOne>)   @result{} #f
(type-annotation-super-and-sub? <ITwo>   <IOne>)   @result{} #f
(type-annotation-super-and-sub? <IThree> <ITwo>)   @result{} #f
@end lisp

@noindent
the same as above, but with a single @clause{method-prototype} clause:

@lisp
(define-interface-type <IOne>
  (method-prototype doit
    (lambda (<fixnum>) => (<string>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype doit
    (lambda (<flonum>) => (<string>))))

(define-interface-type <IThree>
  (implements <ITwo>)
  (method-prototype doit
    (case-lambda
      ((<fixnum>) => (<string>))
      ((<flonum>) => (<string>)))))
@end lisp

A record--type can implement an interface by defining a concrete method
for every method prototype:

@lisp
(define-interface-type <IOne>
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-record-type <blue>
  (implements <IOne>)
  (method (@{doit <number>@} @{S <string>@})
    1))

(type-annotation-super-and-sub? <IOne> <blue>) @result{} #t
(type-annotation-super-and-sub? <blue> <IOne>) @result{} #f
@end lisp

A record--type can inherit from another record--type and use its
parent's methods to implement an interface:

@lisp
(define-interface-type <I>
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-record-type <A>
  (method (@{doit <number>@} @{S <string>@})
    1))

(define-record-type <B>
  (parent <A>)
  (implements <I>))

(type-annotation-super-and-sub? <I> <A>) @result{} #f
(type-annotation-super-and-sub? <I> <B>) @result{} #t
(type-annotation-super-and-sub? <A> <I>) @result{} #f
(type-annotation-super-and-sub? <B> <I>) @result{} #f
@end lisp

A record--type must implement a method for every method prototype in the
interface and its parents:

@lisp
(define-interface-type <ISuper>
  (method-prototype super-doit
    (lambda (<string>) => (<number>))))

(define-interface-type <ISub>
  (parent <ISuper>)
  (method-prototype sub-doit
    (lambda (<string>) => (<fixnum>))))

(define-record-type <A>
  (implements <ISub>)
  (method (@{super-doit <number>@} @{S <string>@})
    1)
  (method (@{sub-doit <fixnum>@} @{S <string>@})
    1))

(type-annotation-super-and-sub? <ISuper> <A>) @result{} #t
(type-annotation-super-and-sub? <ISub>   <A>) @result{} #t
(type-annotation-super-and-sub? <A> <ISuper>) @result{} #f
(type-annotation-super-and-sub? <A> <ISub>)   @result{} #f
@end lisp

The record--type @class{C} implements interface @class{B}; the interface
@class{B} implements interface @class{A}; automatically, @class{C}
implements @class{A}:

@lisp
(define-interface-type <A>
  (method-prototype red
    (lambda () => (<fixnum>))))

(define-interface-type <B>
  (implements <A>)
  (method-prototype red
    (lambda () => (<fixnum>)))
  (method-prototype blue
    (lambda () => (<symbol>))))

(define-record-type <C>
  (implements <B>)
  (method (@{red  <fixnum>@})
    1)
  (method (@{blue <symbol>@})
    'ciao))

(type-annotation-super-and-sub? <A> <B>) @result{} #t
(type-annotation-super-and-sub? <A> <C>) @result{} #t
(type-annotation-super-and-sub? <B> <A>) @result{} #f
(type-annotation-super-and-sub? <B> <C>) @result{} #t
(type-annotation-super-and-sub? <C> <A>) @result{} #f
(type-annotation-super-and-sub? <C> <B>) @result{} #f
@end lisp

The record--type @class{dark-blue} inherits from @class{blue} the
implementation of the interfaces @class{IOne} and @class{ITwo}:

@lisp
;;
;;               <IOne>
;;                  ^
;;                  |
;;   <blue> +++> <ITwo>
;;     ^
;;     |
;;   <dark-blue>

(define-interface-type <IOne>
  (method-prototype ione-doit
    (lambda () => (<number>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype itwo-doit
    (lambda () => (<symbol>))))

(define-record-type <blue>
  (implements <ITwo>)
  (fields val)
  (method (@{ione-doit <number>@})
    (+ 10 (.val this)))
  (method (@{itwo-doit <symbol>@})
    'ciao))

(define-record-type <dark-blue>
  (parent <blue>))

(define (fun-1 @{O <IOne>@})
  (.ione-doit O))

(define (fun-2 @{O <ITwo>@})
  (vector (.ione-doit O)
          (.itwo-doit O)))

(define O
  (new <dark-blue> 1))

(fun-1 O)       @result{} 11
(fun-2 O)       @result{} #(11 ciao)
@end lisp

The record--type @class{dark-blue} implements the interface @class{ITwo}
and inherits from @class{blue} the implementation of the interface
@class{IOne}:

@lisp
;;   <blue> +++> <IOne>
;;     ^
;;     |
;;   <dark-blue> +++> <ITwo>

(define-interface-type <IOne>
  (method-prototype ione-doit
    (lambda () => (<number>))))

(define-interface-type <ITwo>
  (method-prototype itwo-doit
    (lambda () => (<symbol>))))

(define-record-type <blue>
  (implements <IOne>)
  (fields val)
  (method (@{ione-doit <number>@})
    (+ 10 (.val this))))

(define-record-type <dark-blue>
  (parent <blue>)
  (implements <ITwo>)
  (method (@{itwo-doit <symbol>@})
    'ciao))

(define (fun-1 @{O <IOne>@})
  (.ione-doit O))

(define (fun-2 @{O <ITwo>@})
  (.itwo-doit O))

(define O
  (new <dark-blue> 1))

(fun-1 O)       @result{} 11
(fun-2 O)       @result{} ciao
@end lisp

The record--type @class{blue} implements the interface @class{ITwo}, its
parent @class{IOne}, and automatically the interface @class{IThree}
implemented by @class{IOne}:

@lisp
;;               <IOne> +++> <IThree>
;;                  ^
;;                  |
;;   <blue> +++> <ITwo>

(define-interface-type <IThree>
  (method-prototype ithree-doit
    (lambda () => (<string>))))

(define-interface-type <IOne>
  (implements <IThree>)
  (method-prototype ione-doit
    (lambda () => (<number>)))
  (method-prototype ithree-doit
    (lambda () => (<string>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype itwo-doit
    (lambda () => (<symbol>))))

(define-record-type <blue>
  (implements <ITwo>)
  (fields val)
  (method (@{ione-doit <number>@})
    (+ 10 (.val this)))
  (method (@{itwo-doit <symbol>@})
    'ciao)
  (method (@{ithree-doit <string>@})
    "hello"))

(define (fun-1 @{O <IOne>@})
  (vector (.ione-doit O)
          (.ithree-doit O)))

(define (fun-2 @{O <ITwo>@})
  (vector (.ione-doit O)
          (.itwo-doit O)
          (.ithree-doit O)))

(define (fun-3 @{O <IThree>@})
  (.ithree-doit O))

(define O
  (new <blue> 1))

(fun-1 O)       @result{} #(11 "hello")
(fun-2 O)       @result{} #(11 ciao "hello")
(fun-3 O)       @result{} "hello"
@end lisp

Two record--types in a hierarchy both implement the same interface:

@lisp
(define-interface-type <Arith>
  (method-prototype add
    (lambda () => (<number>))))

(define-record-type <duo>
  (implements <Arith>)
  (fields one two)
  (method (@{add <number>@})
    (+ (.one this) (.two this))))

(define-record-type <trio>
  (parent <duo>)
  (implements <Arith>)
  (fields three)
  (method (@{add <number>@})
    (+ (.one this) (.two this) (.three this))))

(define (fun @{O <Arith>@})
  (.add O))

(fun (new <duo>  1 2))          @result{} 3
(fun (new <trio> 1 2 3))        @result{} 6
@end lisp

The record--type @class{duo} implements the interface @class{Stringer}
which has a default method @code{to-string}:

@lisp
(define-interface-type <Stringer>
  (method (to-string)
    (with-output-to-string
      (lambda ()
        (display this)))))

(define-record-type <duo>
  (implements <Stringer>)
  (fields one two)
  (custom-printer
    (lambda (@{this <duo>@} port sub-printer)
      (display "#[duo "    port)
      (display (.one this) port)
      (display #\space     port)
      (display (.two this) port)
      (display #\]         port))))

(define (fun @{O <Stringer>@})
  (.to-string O))

(fun (new <duo> 1 2))   @result{} "#[duo 1 2]"
@end lisp

The record--type @class{duo} implements the interface @class{Stringer}
which has a default method @code{to-string}; @class{duo} implements the
method by itself:

@lisp
(define-interface-type <Stringer>
  (method (@{to-string <string>@})
    (with-output-to-string
      (lambda ()
        (display this)))))

(define-record-type <duo>
  (implements <Stringer>)
  (fields one two)
  (method (@{to-string <string>@})
    (with-output-to-string
      (lambda ()
        (display "#[duo ")
        (display (.one this))
        (display #\space)
        (display (.two this))
        (display #\])))))

(define (fun @{O <Stringer>@})
  (.to-string O))

(fun (new <duo> 1 2))   @result{} "#[duo 1 2]"
@end lisp

Default methods have a limitation: they cannot extend other methods.
The following definitions will raise an expand--time exception:

@lisp
(define-interface-type <IOne>
  (method (@{doit <number>@})
    1))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method-prototype doit
    (lambda (<string>) => (<number>))))
@end lisp

@noindent
because we cannot extend the default method @code{doit} in @class{IOne}
with a method prototype in @class{ITwo}.  The following definitions will
raise an expand--time exception:

@lisp
(define-interface-type <IOne>
  (method-prototype doit
    (lambda (<string>) => (<number>))))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method (@{doit <number>@})
    1))
@end lisp

@noindent
because we cannot extend the method prototype @code{doit} in
@class{IOne} with a default method in @class{ITwo}.  The following
definitions will raise an expand--time exception:

@lisp
(define-interface-type <IOne>
  (method (@{doit <number>@})
    1))

(define-interface-type <ITwo>
  (parent <IOne>)
  (method (@{doit <number>@} @{S <string>@})
    2))
@end lisp

@noindent
because we cannot extend the default method @code{doit} in @class{IOne}
with the default method @code{doit} in @class{ITwo}.

Here we use an ``instantiable body'' to define a ``generic'' interface--type:

@lisp
(import (vicare language-extensions instantiable-bodies))

(define-instantiable-body define-iface-arith
  (define-interface-type <Iface>
    (method-prototype add
      (lambda () => (<type-name>)))))

(begin
  (define-iface-arith
    ((<Iface>             <NumberArith>)
     (<type-name>         <number>)))
  (define (nfun @{O <NumberArith>@})
    (.add O)))

(begin
  (define-iface-arith
    ((<Iface>             <StringArith>)
     (<type-name>         <string>)))
  (define (sfun @{O <StringArith>@})
    (.add O)))

(define-record-type <duo>
  (implements <NumberArith>)
  (fields one two)
  (method (@{add <number>@})
    (+ (.one this) (.two this))))

(define-record-type <string-duo>
  (implements <StringArith>)
  (fields one two)
  (method (@{add <string>@})
    (string-append (.one this) (.two this))))

(nfun (new <duo> 1 2))                  @result{} 3
(sfun (new <string-duo> "hel" "lo"))    @result{} "hello"
@end lisp

@c page
@node labels
@chapter Sub--typing with labels


@cindex Library @library{vicare language-extensions labels}
@cindex @library{vicare language-extensions labels}, library


@dfn{Labels} are types built on top of other types: we put label--types
on values of a parent type to handle them locally in a special way.
There are two kinds of labels:

@itemize
@item
Labels without custom type predicate.  They are synonyms of their parent
type and add methods to it.  A value matches the label--type if it
matches the parent type.

@item
Labels with custom type predicate.  A value matches the label--type if
it satisfies the label's type predicate; it is possible to establish
when a value matches the label--type only at run--time.
@end itemize

The following syntactic bindings are exported by the library
@library{vicare language-extensions labels}.  All the auxiliary syntaxes
are exported by the library @library{vicare} and reexported by the
library @library{vicare language-extensions labels}.


@deffn Syntax define-label-type @meta{type-name} @meta{clause} @dots{}
@deffnx {Auxiliary Syntax} nongenerative
@deffnx {Auxiliary Syntax} parent
@deffnx {Auxiliary Syntax} constructor
@deffnx {Auxiliary Syntax} destructor
@deffnx {Auxiliary Syntax} type-predicate
@deffnx {Auxiliary Syntax} equality-predicate
@deffnx {Auxiliary Syntax} comparison-procedure
@deffnx {Auxiliary Syntax} hash-function
@deffnx {Auxiliary Syntax} method
@deffnx {Auxiliary Syntax} mixins
Define a new label type.  @meta{type-name} must be a syntactic
identifier representing the label name.

The clause @clause{parent} is mandatory and its single argument must be
a type annotation.

The following clauses can be used in the same way they are used in
@syntax{define-record-type}:

@lisp
parent type-predicate
equality-predicate comparison-procedure hash-function
method mixins
@end lisp

@noindent
notice that labels @strong{cannot} implement interfaces.

The clause @clause{constructor} may appear zero, one or more times;
these clauses define a constructor function to be used with the syntax
@syntax{new}.  The @clause{constructor} clause has a syntax similar to
@syntax{lambda/checked}; it must have the format:

@lisp
(constructor @meta{typed-formals} @metao{body} @meta{body} ...)
@end lisp

@noindent
@meta{typed-formals} must @strong{not} specify a return value: the
constructor returns a single value of type @var{type-name}, and its
specification is automatically generated.

The clause @clause{destructor} may appear zero or one time; this clause
defines a destructor function to be used with the syntax
@syntax{delete}; this destructor is @strong{not} used by the garbage
collector.  The @clause{destructor} clause has a syntax similar to
@syntax{lambda}; it must have the format:

@lisp
(destructor @meta{formals} @metao{body} @meta{body} ...)
@end lisp

@noindent
where @meta{formals} must specify a single argument of type
@meta{type-name}.  @meta{formals} must @strong{not} specify a return
value: the destructor should return unspecified values.

The optional clause @clause{nongenerative} must be used with a single
argument being a symbol representing a @uid{} associated with the label
type; such symbol is used by @syntax{type-unique-identifiers} and so it
allows multimethods to use label types.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Examples of simple labels

The following example defines a label @class{String} that is just a
synonym for @class{string}:

@lisp
(define-label-type <String>
  (parent <string>))

(define @{O <String>@}
  "ciao")

(.length O)     @result{} 4
(hash    O)     @expansion{} (string-hash O)
@end lisp

The following example defines a label to represent fixnums returned by
comparison procedures (@samp{-1}, @samp{0}, @samp{+1}):

@lisp
(define-label-type <comparison-fixnum>
  (parent (or <non-negative-fixnum> <negative-fixnum>))
  (type-predicate
    (lambda (@{parent-pred <type-predicate>@})
      (lambda (obj)
        (and (parent-pred obj)
             (fx<=? obj +1)
             (fx>=? obj -1))))))

(is-a? +1 <comparison-fixnum>)  @result{} #t
(is-a? -1 <comparison-fixnum>)  @result{} #t
(is-a?  0 <comparison-fixnum>)  @result{} #t

(is-a? +2 <comparison-fixnum>)  @result{} #f
(is-a? -2 <comparison-fixnum>)  @result{} #f
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Examples of hash function

Now let's define a custom hash function (we ignore the parent hash
function that gets passed as @var{parent-hash} argument):

@lisp
(define-label-type <String>
  (parent <string>)
  (hash-function
    (lambda (parent-hash)
      (lambda (S)
        (if (string-empty? S)
            0
          (char-hash (string-ref S 0)))))))

(define @{O <String>@}
  "ciao")

(hash O)     @equiv{} (char-hash #\c)
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Examples of methods

Let's define a label with a method to increment a fixnum.

@lisp
(define-label-type <fx>
  (parent <fixnum>)
  (method (incr)
    (fxadd1 this)))

(define @{O <fx>@}
  10)

(.incr O)       @result{} 11
@end lisp

Now let's define a method for adding prefixes and suffixes:

@lisp
(define-label-type <String>
  (parent <string>)
  (method (@{append <String>@} @{suff <String>@})
    (string-append this suff))
  (method (@{append <String>@} @{pref <String>@} @{suff <String>@})
    (string-append pref this suff)))

(define @{O <String>@}
  "ciao")

(.append O "-suff")             @result{} "ciao-suff"
(.append O "pref-" "-suff")     @result{} "pref-ciao-suff"

(.length (.append O "pref-" "-suff"))
@result{} 14
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Defining a constructor function

In the following example:

@lisp
(define-label-type <vec>
  (parent <nevector>)
  (constructor (a b)
    (vector a b))
  (constructor (a b c)
    (vector a b c)))

(new <vec> 1 2)         @result{} #(1 2)
(new <vec> 1 2 3)       @result{} #(1 2 3)
@end lisp

@noindent
we can think of the @clause{constructor} clauses as generating the
following functions definition:

@lisp
(define/overload (@{<vec>-constructor <vec>@} a b)
  (vector a b))

(define/overload (@{<vec>-constructor <vec>@} a b c)
  (vector a b c))
@end lisp

@noindent
notice that a type signature for the return value has been automatically
inserted.

@c ------------------------------------------------------------------------

@subsubheading Defining a destructor function

Here we define a bogus destructor function:

@lisp
(define-label-type <vec>
  (parent <vector>)
  (destructor (@{O <vec>@})
    `(deleted ,O)))

(define @{O <vec>@}
  '#(1 2))

(delete O)      @result{} (deleted #(1 2))
@end lisp

@noindent
we can think of the @clause{destructor} clauses as generating the
following function definition:

@lisp
(define (<vec>-destructor @{O <vec>@})
  `(deleted ,O))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Example of mixin

Here we show how to include mixin clauses in a label definition:

@lisp
(define-mixin-type <stuff>
  (method (pussy)
    (list 'pussy (.name this))))

(define-label-type <peluche>
  (parent (list <symbol>))
  (method (name)
    (car this))
  (mixins <stuff>))

(define @{O <peluche>@}
  '(cat))

(.name  O)      @result{} cat
(.pussy O)      @result{} (pussy cat)
@end lisp

@c page
@node friends
@chapter Friend functions


@cindex Friend functions
@cindex Record--types, friend functions


Friend functions are used to access private, public and protected
members of a record--type from outside of the record--type's methods.


@deffn Syntax define/friend (@meta{typed-who} (brace @meta{subject} @meta{type}) . @meta{formals}) . @meta{body}
Define a function like @syntax{define/checked} would do, but give
private access to the members of the record--type @meta{type} for the
argument @meta{subject}.

The new function is not a member of the record--type, so it does not
influence the compliance of the record--type with interface types.
@end deffn


Usage example:

@lisp
(define-record-type <duo>
  (private
    (fields one two)))

(define/friend (@{add <number>@} @{O <duo>@})
  (+ (.one O) (.two O)))

(define O
  (new <duo> 1 2))

(add O)  @result{} 3
@end lisp

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references



@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c End:
