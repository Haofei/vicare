@node restarts
@section Signaling conditions and restarts


@cindex Library @library{vicare language-extensions conditions-and-restarts}
@cindex @library{vicare language-extensions conditions-and-restarts}, library


The library @library{vicare language-extensions conditions-and-restarts}
implements Scheme--flavoured Common Lisp's condition handlers and
restart handlers.

Not everything defined by Common Lisp is implemented:

@itemize
@item
There is no integration with the debugger.

@item
Some facilities are not implemented.  Among the missing ones:
@syntax{restart-bind}, @syntax{with-simple-restart},
@func{muffle-warning}.
@end itemize

To understand what is going on here, we should read Common Lisp's Hyper
Spec, Chapter 9.1 ``Condition System
Concepts''@footnote{@url{http:/@//@/www.cs.cmu.edu/@/Groups/@/AI/@/html/@/hyperspec/@/HyperSpec/@/Body/@/sec_9-1.htm}}.

@menu
* restarts signal::             Signaling conditions.
* restarts handler-case::       Catching signalled conditions.
* restarts ignore-errors::      Ignoring signalled conditions of
                                type @condition{error}.
* restarts handler-bind::       Handling signalled conditions.
* restarts restart-case::       Installing restart handlers.
* restarts assoc::              Associating restarts to conditions.
* restarts invoke::             Finding and invoking restarts.
* restarts func::               Standardised restart functions.
* restarts errors::             Detecting errors in the conditions
                                and restarts mechanism.
@end menu

@c page
@node restarts signal
@subsection Signaling conditions


@defun signal @var{cnd}
Signal a condition by raising it with @func{raise-continuable}.  Perform
what is needed to handle the restarts protocol.  @var{cnd} must be a
condition object (simple or compound).

As defined by Common Lisp: @func{signal} should return if no handler
accepting the condition is found; in this implementation this normal
return will @strong{not} happen by default.  To implement such behaviour
we have to wrap the whole code in a form like this:

@example
(with-return-to-signal-on-unhandled-exception
  @metao{body} @meta{body} @dots{})
@end example
@end defun


@deffn Syntax with-return-to-signal-on-unhandled-exception @metao{body} @meta{body} @dots{}
Do what is needed to allow @func{signal} to just return if all the
installed condition handlers decline to handle the signalled condition.
@end deffn

@c page
@node restarts handler-case
@subsection Catching signalled conditions


@deffn Syntax handler-case (@meta{clause} @dots{}) @metao{body} @meta{body} @dots{}
Evaluate body forms in a dynamic environment in which new exception
handlers are installed; it is capable of handling exceptions raised with
@func{raise}, @func{raise-continuable} and @func{signal}.  Basically
behave like @rnrs{6}'s @syntax{guard} syntax.

The arguments @meta{clause} must have one of the following syntaxes:

@example
(@meta{typespec} @meta{condition-handler})
(:no-error @meta{no-error-handler})
@end example

Every @meta{typespec} is meant to be an identifier or a non--empty
proper list of identifiers, each usable as second argument to
@syntax{condition-is-a?}.

Every @meta{condition-handler} must be an expression evaluating to a
procedure accepting a condition object as single argument; the condition
object can be simple or compound.

In the no--error clause: @code{:no-error} must be the actual symbol;
@meta{no-error-handler} must be an expression evaluating to a procedure.
The optional @code{:no-error} clause can be present only if it is the
last one.

If the body performs a normal return:

@itemize
@item
If the @code{:no-error} clause is missing: the values returned by the
body become the values returned by @syntax{handler-case}.

@item
If the @code{:no-error} clause is present: the procedure
@meta{no-error-handler} is applied to the returned values; the return
values of such application become the return values of
@syntax{handler-case}.
@end itemize

If an exception is raised (in Common Lisp jargon: a condition is
signalled): a condition handler matching the raised object is searched in
the sequence of clauses, left--to--right:

@itemize
@item
If a clause matches: the dynamic extent of the body is terminated, the
@meta{condition-handler} is applied to the raised object and the return
values of such application become the return values of
@syntax{handler-case}.

@item
If no clause matches: the raised object is re--raised with
@func{raise-continuable}.
@end itemize
@end deffn

@c page
@node restarts ignore-errors
@subsection Ignoring signalled conditions of type @condition{error}


@deffn Syntax ignore-errors @metao{body} @meta{body} @dots{}
Install a handler for conditions of type @condition{error}, then
evaluate the body forms; the handler is installed using
@syntax{handler-case}.  If the body performs a normal return: its return
values become the return values of @syntax{ignore-errors}.  If the body
signals a condition of type @condition{error}: two values are returned,
@false{} and the signalled condition object.
@end deffn

@c page
@node restarts handler-bind
@subsection Handling signalled conditions


@deffn Syntax handler-bind (@meta{clause} @dots{}) @metao{body} @meta{body} @dots{}
Evaluate body forms in a dynamic environment in which new exception
handlers are installed; it is capable of handling exceptions raised with
@func{raise}, @func{raise-continuable} and @func{signal}.  Not quite
like @rnrs{6}'s @syntax{with-exception-handler} syntax, but similar.

The arguments @meta{clause} must have the following syntax:

@example
(@meta{typespec} @meta{condition-handler})
@end example

Every @meta{typespec} is meant to be an identifier or a non--empty
proper list of identifiers, each usable as second argument to
@syntax{condition-is-a?}.

Every @meta{condition-handler} must be an expression evaluating to a
procedure accepting a condition object as single argument; the condition
object can be simple or compound.

If the body performs a normal return: the values returned by the body
become the values returned by @syntax{handler-bind}.

If an exception is raised (in Common Lisp jargon: a condition is
signalled): a condition handler matching the raised object is searched
in the sequence of clauses, left--to--right:

@itemize
@item
If a clause matches: its @meta{condition-handler} is applied to the
raised object.

@item
If no clause matches: the raised object is re--raised with
@func{raise-continuable}.
@end itemize

The handlers are called with a continuation whose dynamic environment is
that of the call to @func{raise}, @func{raise-continuable} or
@func{signal} that raised the exception; except that the current
exception handler is the one that was in place when
@syntax{handler-bind} was evaluated.

When a condition handler is applied to the raised condition object:

@itemize
@item
If it accepts to handle the condition: it must perform a non--local
exit, for example by invoking a restart.

@item
If it declines to handle the condition: it must perform a normal return;
in this case the returned values are discarded and the originally raised
object is re--raised using @func{raise-continuable}.
@end itemize
@end deffn

@c page
@node restarts restart-case
@subsection Installing restart handlers


@deffn Syntax restart-case @meta{body} (@meta{clause} @dots{})
Install restart handlers in the current dynamic environment, then
evaluate the body form.

The arguments @meta{clause} must have the following syntax:

@example
(@meta{restart-name} @meta{restart-handler})
@end example

Every @meta{restart-name} must be a symbol representing the name of a
restart; the same @meta{restart-name} can be used in nested uses of
@syntax{restart-case}.

Every @meta{restart-handler} must be an expression evaluating to a
procedure accepting a non--constrained number of arguments.  The return
values of @meta{restart-handler} become the return values of
@syntax{restart-case}.  The @meta{restart-handler} is evaluated in the
dynamic environment of the call to @func{invoke-restart} that invoked
the restart.

As special case, if @meta{body} is:

@example
(signal @meta{expr})
@end example

@noindent
the installed restarts are associated to the condition object returned
by the evaluation of @meta{expr}.
@end deffn

@c page
@node restarts assoc
@subsection Associating restarts to conditions


@deffn Syntax with-condition-restarts @meta{condition-form} @meta{restarts-form} @metao{body} @meta{body} @dots{}
Evaluate body forms in a dynamic environment in which some restart
objects are associated to a condition object; in some special case it is
implicitly used by @syntax{restart-case}.  If the body performs a normal
return: the body return values become the return values of
@syntax{with-condition-restarts}.

This is the sequence of operations:

@enumerate
@item
The expression @meta{condition-form} is evaluated: its single return
value must be a condition object, simple or compound.

@item
The expression @meta{restarts-form} is evaluated: its single return
value must be a list of restart objects, for example returned by
@func{find-restart}.

@item
In the dynamic environment: every simple condition object returned by
@meta{condition-form} is associated to every restart object returned by
@meta{restarts-form}.

@item
The body is evaluated.
@end enumerate
@end deffn

@c page
@node restarts invoke
@subsection Finding and invoking restarts


@defun find-restart @var{name}
@defunx find-restart @var{name} @var{cnd}
Search the current dynamic environment for the innermost restart handler
associated to @var{name}, which must be a symbol.  If a handler is
found: return its restart object; otherwise return @false{}.

When the optional argument @var{cnd} is used and @var{cnd} is a
condition object (simple or compound): among the installed restarts,
return only the innermost that is @strong{not} associated to the
condition object @var{cnd}.  When the optional argument @var{cnd} is
used and @var{cnd} is @false{}: behave as if @var{cnd} was not used.
@end defun


@defun invoke-restart @var{restart-designator} . @var{rest}
Given a restart designator: search the associated handler in the current
dynamic environment and apply it to the given @var{rest} arguments.
Return the return values of such application, if the called function
returns.

@var{restart-designator} can be either a symbol representing the name of
the restart or the restart object itself (as returned by
@func{find-restart}).

If @var{restart-designator} is a symbol and no matching restart is
found: an exception is raised with condition object of type
@condition{undefined-restart-error}.
@end defun


@defun compute-restarts
Return a list of symbols representing the names of the restars currently
installed in the dynamic environment.  The list is ordered: the
innermost restarts come first, the outermost restarts come last.
@end defun

@c page
@node restarts func
@subsection Standardised restart functions


@defun use-value @var{obj}
@defunx use-value @var{obj} @var{cnd}
If a restart named @code{use-value} is installed in the dynamic
environment: apply its handler to @var{obj}; otherwise return @false{}
(without performing a non--local exit).

If the optional argument @var{cnd} is a condition object: select the
innermost matching restart that is @strong{not} associated with such
condition object.  If @var{cnd} is missing or @false{}: just select the
innermost installed restart.
@end defun


@defun store-value @var{obj}
@defunx store-value @var{obj} @var{cnd}
If a restart named @code{store-value} is installed in the dynamic
environment: apply its handler to @var{obj}; otherwise return @false{}
(without performing a non--local exit).

If the optional argument @var{cnd} is a condition object: select the
innermost matching restart that is @strong{not} associated with such
condition object.  If @var{cnd} is missing or @false{}: just select the
innermost installed restart.
@end defun


@defun continue-restart
@defunx continue-restart @var{cnd}
If a restart named @code{continue} is installed in the dynamic
environment: call its handler with no arguments; otherwise return
@false{} (without performing a non--local exit).

If the optional argument @var{cnd} is a condition object: select the
innermost matching restart that is @strong{not} associated with such
condition object.  If @var{cnd} is missing or @false{}: just select the
innermost installed restart.

@quotation
@strong{NOTE} Under Common Lisp: this is simply called @func{continue};
under @value{PRJNAME} @func{continue} is already bound.
@end quotation
@end defun


@defun abort-restart
@defunx abort-restart @var{cnd}
If a restart named @code{abort} is installed in the dynamic environment:
call its handler with no arguments; otherwise return @false{} (without
performing a non--local exit).

If the optional argument @var{cnd} is a condition object: select the
innermost matching restart that is @strong{not} associated with such
condition object.  If @var{cnd} is missing or @false{}: just select the
innermost installed restart.

@quotation
@strong{NOTE} Under Common Lisp: this is simply called @func{abort};
this is quite a common action, so it is left unbound.
@end quotation
@end defun

@c page
@node restarts errors
@subsection Detecting errors in the conditions and restarts mechanism


@unnumberedsubsec Base condition type

@deftp {Condition Type} &restarts-error
Base type of all the error conditions associated to the restarts
mechanism.
@end deftp


@defun make-restarts-error
Build and return a condition object of type @condition{restarts-error}.
@end defun


@defun restarts-error-condition? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{restarts-error}; otherwise return @false{}.
@end defun

@c ------------------------------------------------------------------------

@unnumberedsubsec Control error condition type

@deftp {Condition Type} &restarts-control-error
Type of error conditions associated to the restarts mechanism.  It is
derived from @condition{restarts-error}.
@end deftp


@defun make-restarts-control-error
Build and return a condition object of type
@condition{restarts-control-error}.
@end defun


@defun restarts-control-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{restarts-control-error}; otherwise return @false{}.
@end defun


@defun signal-restarts-control-error @var{who} @var{message} @var{irritant} @dots{}
Build a compound condition object with components:
@condition{restarts-control-error}, @condition{who} @condition{message}
@condition{irritants} and raise it using @func{signal}.
@end defun

@c ------------------------------------------------------------------------

@unnumberedsubsec Undefined restart error condition type

@deftp {Condition Type} &undefined-restart-error
Type of the error conditions raise when attempting to invoke an
undefined restart.  It is derived from
@condition{restarts-control-error}.
@end deftp


@defun make-undefined-restart-error
Build and return a condition object of type
@condition{undefined-restart-error}.
@end defun


@defun undefined-restart-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{undefined-restart-error}; otherwise return @false{}.
@end defun


@defun signal-undefined-restart-error @var{who} @var{message} @var{irritant} @dots{}
Build a compound condition object with components:
@condition{undefined-restart-error}, @condition{who} @condition{message}
@condition{irritants} and raise it using @func{signal}.
@end defun


@c Local Variables:
@c mode: texinfo
@c TeX-master: "vicare-libs"
@c End:
