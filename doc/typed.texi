@node typed
@chapter Experimental typed language


@value{PRJNAME}'s expander implements an extension to the language
defined by @rnrs{6} that allows the definition of typed bindings;

@quotation
@strong{NOTE} Typed language support is currently experimental.
@end quotation

@menu
* typed concepts::              Typed language concepts.
* typed parsers::               Parsing tagged syntaxes.
* typed object specs::          Object type specification.
@end menu

@c page
@node typed concepts
@section Typed language concepts


@subsubheading Tag identifiers

A @dfn{tag identifier} is a bound identifier whose syntactic binding
label gensym has a specific entry in its property list; such entry has
an instance of @code{object-type-spec} as value.  Tag identifiers must
be bound (otherwise they do not have a syntactic binding label), but it
does not matter to what they are bound.  Typical examples of tag
identifiers are:

@itemize
@item
Struct type identifiers defined by @func{define-struct}; they are
automatically made tag identifiers by @value{PRJNAME}.

@item
@rnrs{6} record type identifiers defined by @func{define-record-type};
they are automatically made tag identifiers by @value{PRJNAME}.

@item
A set of non--core macro identifiers (whose implementation is integrated
in the expander) are exported by the library @library{vicare expander
tags} to be the tags of built--in @value{PRJNAME} objects.  Some of them
are: @class{fixnum}, @class{string}, @class{vector},
@class{textual-input-port}.
@end itemize

We can easily create a tag identifier as:

@example
(import (vicare)
  (vicare expander tags)
  (for (prefix (vicare expander object-type-specs) typ.)
    expand))

(define-syntax <my-tag>
  (let ()
    (set-identifier-tag! #'<my-tag>
      (make-object-type-spec #'<my-tag> #'<top> ...))
    (lambda (x) #f)))
@end example

@noindent
where @class{my-tag} is a tag identifier and @class{top} is its parent
tag.  Tag identifiers are organised in a tree hierarchy, with subtags
inheriting properties of supertags; by convention, @class{top} is the
parent of all the tag identifiers, the root of the tree.

@c ------------------------------------------------------------

@subsubheading Tagged binding

A @dfn{tagged binding} is a bound identifier whose syntactic binding
label gensym has a specific entry in its property list; such entry has a
tag identifier as value.  Tagged identifiers must be bound (otherwise
they do not have a syntactic binding label).  Tagged bindings are
created by the built--in binding syntaxes @func{lambda}, @func{define},
@func{let}, @func{letrec}, @func{let-values}, etc.

An example of tagged binding creation follows:

@example
#!vicare
(import (vicare)
  (vicare expander tags))

(define @{O <fixnum>@}
  123)
@end example

@noindent
the identifier @code{O} is a tagged identifier with tag identifier
@class{fixnum}; the braces are used to tag the first identifier with the
second identifier.  At the time the tagged binding is created: the tag
identifier must already be a tag identifier.

@c page
@node typed parsers
@section Parsing tagged syntaxes


The library @library{vicare expander object-type-specs} exports
functions to validate and parse syntax objects representing tagged and
untagged bindings.

@quotation
@strong{NOTE} To make the examples simpler: the return value of the
functions is represented by syntax objects that are @func{syntax=?} to
the returned values and written with the reader syntax.  For example,
when the return values are the syntax objects:

@example
#<syntax expr=X> #<syntax expr=<fixnum>>
@end example

@noindent
they are represented as:

@example
#'X #'<fixnum>
@end example
@end quotation

@menu
* typed parsers predicates::    Syntax predicates.
* typed parsers ids::           Parsing standalone bindings.
* typed parsers lists::         Parsing proper lists of bindings.
* typed parsers formals::       Parsing tagged formals.
* typed parsers callable::      Parsing tagged callable signatures.
@end menu

@c page
@node typed parsers predicates
@subsection Syntax predicates


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun standard-formals-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing @rnrs{6}
standard @func{lambda} and @func{let-values} formals; otherwise return
@false{}.  The return value is true if @var{stx} is a proper or improper
list of identifiers, with null and a standalone identifier being
acceptable.
@end defun


@defun formal-tags-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing the tag
signature of a tagged formals syntax; otherwise return @false{}.  The
return value is true if @var{stx} is a proper or improper list of tag
identifiers, with null and a standalone tag identifier being acceptable.
@end defun


@defun return-values-tags-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing the tag
signature of return values from a callable signature; otherwise return
@false{}.  The return value is @true{} if @var{stx} is @false{} or null
or a proper list of tag identifiers.
@end defun

@c page
@node typed parsers ids
@subsection Parsing standalone identifiers


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun tagged-identifier-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing a tagged or
untagged identifier, otherwise return @false{}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.tagged-identifier-syntax? #'(brace X <fixnum>)) @result{} #t
(typ.tagged-identifier-syntax? #'@{X <fixnum>@})       @result{} #t
(typ.tagged-identifier-syntax? #'X)                  @result{} #t
(typ.tagged-identifier-syntax? 123)                  @result{} #f
@end example
@end defun


@defun parse-tagged-identifier-syntax @var{stx}
If @var{stx} is a tagged or untagged identifier, return 2 values: the
identifier representing the binding name and the identifier representing
the tag; otherwise raise an exception with condition type
@condition{syntax}.  When no tag is present: the tag identifier defaults
to @class{top}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.parse-tagged-identifier-syntax #'(brace X <fixnum>))
@result{} #'X #'<fixnum>

(typ.parse-tagged-identifier-syntax #'@{X <fixnum>@})
@result{} #'X #'<fixnum>

(typ.parse-tagged-identifier-syntax #'X)
@result{} #'X #'<top>

(receive (id tag)
    (typ.parse-tagged-identifier-syntax #'@{X <fixnum>@})
  (free-identifier=? id  #'X)           @result{} #t
  (free-identifier=? tag #'<fixnum>))   @result{} #t
@end example
@end defun

@c page
@node typed parsers lists
@subsection Parsing proper lists of bindings


Lists of tagged bindings are often used in binding syntaxes like
@func{let}, @func{do} and similar.  For example, when expanding the
syntax:

@example
#!vicare
(let ((@{a <fixnum>@} 1)
      (@{b <string>@} "b")
      (c            #t))
  . ?body)
@end example

@noindent
a list of tagged bindings is extracted:

@example
(#'(brace a <fixnum>) #'(brace b <string>) #'c)
@end example

@noindent
and parsed to yield the identifiers and the tags:

@example
(#'a #'b #'c) (#'<fixnum> #'<string> #'<top>)
@end example

The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun list-of-tagged-bindings? @var{stx}
Return @true{} if @var{stx} is a syntax object representing a proper
list of tagged or untagged identifiers, otherwise return @false{}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@}
                                 @{b <string>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@}
                                 @{b <string>@}
                                 @{c <vector>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(a))
@result{} #t

(typ.list-of-tagged-bindings? #'(a b))
@result{} #t

(typ.list-of-tagged-bindings? #'(a b c))
@result{} #t

(typ.list-of-tagged-bindings? #'(a @{b <string>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@} b))
@result{} #t

(typ.list-of-tagged-bindings? #'(a
                                 @{b <string>@}
                                 @{c <vector>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@}
                                 b
                                 @{c <vector>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@}
                                 @{b <string>@}
                                 c))
@result{} #t
@end example
@end defun


@defun parse-list-of-tagged-bindings @var{stx}
@defunx parse-list-of-tagged-bindings @var{stx} @var{input-form-stx}
Assume @var{stx} is a syntax object representing a proper list of
possibly tagged binding identifiers; parse the list and, when
successful, return 2 values: a list of identifiers representing the
binding identifiers, a list of identifiers representing the type tags;
@class{top} is used when no tag is present.  If an error occurs raise an
exception with condition object type @condition{syntax}.

The identifiers must be distinct according to @func{bound-identifier=?}.

The optional argument @var{input-form-stx} is meant to be a syntax
object representing the form from which @var{stx} was extracted; it is
used as @code{form} field when raising a syntax violation.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@}))
@result{} (#'a) (#'<fixnum>)

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@}
                                      @{b <string>@}))
@result{} (#'a #'b) (#'<fixnum> #'<string>)

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<fixnum> #'<string> #'<vector>)

(typ.parse-list-of-tagged-bindings #'(a))
@result{} (#'a) (#'<top>)

(typ.parse-list-of-tagged-bindings #'(a b))
@result{} (#'a #'b) (#'<top> #'<top>)

(typ.parse-list-of-tagged-bindings #'(a b c))
@result{} (#'a #'b #'c) (#'<top> #'<top> #'<top>)

(typ.parse-list-of-tagged-bindings #'(a @{b <string>@}))
@result{} (#'a #'b) (#'<top> #'<string>)

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@} b))
@result{} (#'a #'b) (#'<fixnum> #'<top>)

(typ.parse-list-of-tagged-bindings #'(a
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<top> #'<string> #'<vector>)

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@}
                                      b
                                      @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<fixnum> #'<top> #'<vector>)

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      c))
@result{} (#'a #'b #'c) (#'<fixnum> #'<string> #'<top>)
@end example
@end defun

@c page
@node typed parsers formals
@subsection Parsing tagged formals


Tagged formals syntax is used by @func{let-values}, @func{let*-values},
@func{define-values} and similar syntaxes; it is @strong{not} used by
@func{lambda} and related syntaxes.

To describe the supported syntax for tagged formals we use the
conventions: @meta{id}, @meta{rest-id} and @meta{args-id} are argument
identifiers; @meta{arg-tag}, @meta{rest-tag} and @meta{args-tag} are tag
identifiers.  The predicate and parser functions for tagged formals
accept the following standard @rnrs{6} formals formats:

@example
@meta{args-id}
(@meta{id} ...)
(@metao{id} @meta{id} ... . @meta{rest-id})
@end example

@noindent
and in addition the following tagged formals:

@example
(brace @meta{args-id} @meta{args-tag})
(@meta{arg} ...)
(@metao{arg} @meta{arg} ... . @meta{rest-arg})
@end example

@noindent
where @meta{arg} is a tagged identifier with one of the formats:

@example
@meta{arg-id}
(brace @meta{arg-id} @meta{arg-tag})
@end example

@noindent
the identifier @func{brace} is the syntax binding exported by
@library{vicare}.

@noindent
the binding identifiers must be distinct according to
@func{bound-identifier=?}.

The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun tagged-formals-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing a tagged
formals syntax; otherwise return @false{}.  @var{stx} is a tagged
formals syntax if it is a proper or improper list of tagged identifiers,
wich null and a standalone tagged identifier being acceptable.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.tagged-formals-syntax? #'(@{a <fixnum>@}
                               @{b <string>@}))
@result{} #t

(typ.tagged-formals-syntax? #'(@{a <fixnum>@}
                               @{b <string>@}
                               @{c <vector>@}))
@result{} #t

;;; untagged

(typ.tagged-formals-syntax? #'(a))
@result{} #t

(typ.tagged-formals-syntax? #'(a b))
@result{} #t

(typ.tagged-formals-syntax? #'(a b c))
@result{} #t

;;; mixed tagged and untagged

(typ.tagged-formals-syntax? #'(a
                               @{b <string>@}))
@result{} #t

(typ.tagged-formals-syntax? #'(@{a <fixnum>@}
                               b))
@result{} #t

(typ.tagged-formals-syntax? #'(a
                               @{b <string>@}
                               @{c <vector>@}))
@result{} #t

(typ.tagged-formals-syntax? #'(@{a <fixnum>@}
                               b
                               @{c <vector>@}))
@result{} #t

(typ.tagged-formals-syntax? #'(@{a <fixnum>@}
                               @{b <string>@}
                               c)
@result{} #t

;;; args argument

(typ.tagged-formals-syntax? #'@{args <fixnums>@})
@result{} #t

(typ.tagged-formals-syntax? #'args)
@result{} #t

;;; rest argument

(typ.tagged-formals-syntax?
    #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-formals-syntax?
    #'(@{a <fixnum>@} . rest))
@result{} #t

(typ.tagged-formals-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-formals-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} #t
@end example
@end defun


@defun parse-tagged-formals-syntax @var{stx}
@defunx parse-tagged-formals-syntax @var{stx} @var{input-form-stx}
Given a syntax object @var{stx} representing tagged formals: parse it
and split formals from tags.  If successful return 2 values: a proper or
improper list of identifiers representing the standard formals; an
instance of @objtype{formals-signature} holding the tag identifiers.  If
an error occurs raise an exception with condition object type
@condition{syntax}.

The optional argument @var{input-form-stx} is meant to be a syntax
object representing the form from which @var{stx} was extracted; it is
used as @code{form} field when raising a syntax violation.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(define (split stx)
  (receive (standard-formals signature)
      (typ.parse-tagged-formals-syntax stx)
    (values standard-formals (formals-signature-tags signature))))

(split #'(@{a <fixnum>@} @{b <string>@}))
@result{} (#'a #'b) (#'<fixnum> #'<string>)

(split #'(@{a <fixnum>@} @{b <string>@} @{c <vector>@}))
@result{} (a b c) (<fixnum> <string> <vector>))

;;; untagged

(split #'(a))
@result{} (#'a) (#'<top>)

(split #'(a b))
@result{} (#'a #'b) (#'<top> #'<top>)

(split #'(a b c))
@result{} (#'a #'b #'c) (#'<top> #'<top> #'<top>)

;;; mixed tagged and untagged

(split #'(a @{b <string>@}))
@result{} (#'a #'b) (#'<top> #'<string>)

(split #'(@{a <fixnum>@} b))
@result{} (#'a #'b) (#'<fixnum> #'<top>)

(split #'(a @{b <string>@} @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<top> #'<string> #'<vector>)

(split #'(@{a <fixnum>@} b @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<fixnum> #'<top> #'<vector>)

(split #'(@{a <fixnum>@} @{b <string>@} c))
@result{} (#'a #'b #'c) (#'<fixnum> #'<string> #'<top>)

;;; args argument

(split #'@{args <fixnums>@})
@result{} #'args (. #'<fixnums>)

(split #'args)
@result{} #'args (. #'<top>)

;;; rest argument

(split #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} (#'a . #'rest) (#'<fixnum> . #'<fixnums>)

(split #'(@{a <fixnum>@} . rest))
@result{} (#'a . #'rest) (#'<fixnum> . #'<top>)

(split #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} (#'a #'b . #'rest) (#'<fixnum> #'<string> . #'<fixnums>)

(split #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} (#'a #'b . #'rest) (#'<fixnum> #'<string> . #'<top>)
@end example
@end defun

@c page
@node typed parsers callable
@subsection Parsing tagged callable signatures


Callable signatures syntax is used by @func{lambda} and similar
syntaxes.

To describe the supported syntax for callable signatures we use the
conventions: @meta{id}, @meta{rest-id} and @meta{args-id} are argument
identifiers; @meta{arg-tag}, @meta{rest-tag}, @meta{args-tag} and
@meta{rv-tag} are tag identifiers.  The predicate and parser functions
for callable signatures accept the following standard @rnrs{6} formals
formats:

@example
@meta{args-id}
(@meta{id} ...)
(@metao{id} @meta{id} ... . @meta{rest-id})
@end example

@noindent
and in addition the following tagged formals:

@example
(brace @meta{args-id} @meta{args-tag})
(@meta{arg} ...)
(@metao{arg} @meta{arg} ... . @meta{rest-arg})
((brace _ @meta{rv-tag} ...) @meta{arg} ...)
((brace _ @meta{rv-tag} ...) @meta{arg} ... . @meta{rest-arg})
@end example

@noindent
where @meta{arg} is a tagged argument with one of the formats:

@example
@meta{arg-id}
(brace @meta{arg-id} @meta{arg-tag})
@end example

@noindent
the identifiers @func{brace} and @func{_} are the syntax bindings
exported by @library{vicare}; the first item with identifier @func{_} is
a special syntax that allows to specify the number and tags of the
@func{lambda} return values.

The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun tagged-callable-spec-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing valid tagged
callable signature syntax; otherwise return @false{}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.tagged-callable-spec-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} #t

;;; untagged

(typ.tagged-callable-spec-syntax? #'(a))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(a b))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(a b c))
@result{} #t

;;; mixed tagged and untagged

(typ.tagged-callable-spec-syntax? #'(a
                                      @{b <string>@}))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(@{a <fixnum>@}
                                      b))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(a
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(@{a <fixnum>@}
                                      b
                                      @{c <vector>@}))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      c)
@result{} #t

;;; args argument

(typ.tagged-callable-spec-syntax? #'@{args <fixnums>@})
@result{} #t

(typ.tagged-callable-spec-syntax? #'args)
@result{} #t

;;; rest argument

(typ.tagged-callable-spec-syntax?
    #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{a <fixnum>@} . rest))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} #t

;;; return values tagging

(typ.tagged-callable-spec-syntax? #'(@{_ <fixnum>@} a b))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{_ <fixnum>@} @{a <flonum>@} @{b <string>@}))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{_ <fixnum> <flonum>@} @{a <vector>@} @{b <string>@}))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{_ <fixnum> <flonum>@} . @{args <fixnums>@}))
@result{} #t
@end example
@end defun


@defun parse-tagged-callable-spec-syntax @var{stx}
@defunx parse-tagged-callable-spec-syntax @var{stx} @var{input-form-stx}
Given a syntax object @var{stx} representing tagged callable signature
syntax: parse it and split formals from tags.  If successful return 2
values: a proper or improper list of identifiers representing the
standard formals; an instance of @objtype{callable-signature}.  If an
error occurs: raise an exception with condition object type
@condition{syntax}.

The optional argument @var{input-form-stx} is meant to be a syntax
object representing the form from which @var{stx} was extracted; it is
used as @code{form} field when raising a syntax violation.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(define (split input)
  (let-values (((standard-formals-stx callable)
                (typ.parse-tagged-callable-spec-syntax input)))
    (define formals-tags
      (typ.callable-signature-formals-tags callable))
    (define rv-tags
      (typ.callable-signature-return-values-tags callable))
    (values standard-formals-stx rv-tags formals-tags)))

(split #'(@{a <fixnum>@} @{b <string>@}))
@result{} (#'a #'b) #f (#'<fixnum> #'<string>)

(split #'(@{a <fixnum>@} @{b <string>@} @{c <vector>@}))
@result{} #'(a b c) #f (#'<fixnum> #'<string> #'<vector>)

;;; untagged

(split #'(a))
@result{} (#'a) #f (#'<top>)

(split #'(a b))
@result{} (#'a #'b) #f (#'<top> #'<top>)

(split #'(a b c))
@result{} (#'a #'b #'c) #f (#'<top> #'<top> #'<top>)

;;; mixed tagged and untagged

(split #'(a @{b <string>@}))
@result{} (#'a #'b) #f (#'<top> #'<string>)

(split #'(@{a <fixnum>@} b))
@result{} (#'a #'b) #f (#'<fixnum> #'<top>)

(split #'(a @{b <string>@} @{c <vector>@}))
@result{} (#'a #'b #'c) #f (#'<top> #'<string> #'<vector>)

(split #'(@{a <fixnum>@} b @{c <vector>@}))
@result{} (#'a #'b #'c) #f (#'<fixnum> #'<top> #'<vector>)

(split #'(@{a <fixnum>@} @{b <string>@} c))
@result{} (#'a #'b #'c) #f (#'<fixnum> #'<string> #'<top>)

;;; args argument

(split #'@{args <fixnums>@})
@result{} #'args #f #'<fixnums>

(split #'args)
@result{} #'args #f #'<top>

;;; rest argument

(split #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} (#'a . #'rest) #f (#'<fixnum> . #'<fixnums>)

(split #'(@{a <fixnum>@} . rest))
@result{} (#'a . #'rest) #f (#'<fixnum> . #'<top>)

(split #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} (#'a #'b . #'rest) #f (#'<fixnum> #'<string> . #'<fixnums>)

(split #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} (#'a #'b . #'rest) #f (#'<fixnum> #'<string> . #'<top>)

;;; return values tagging

(split #'(@{_@} a b))
@result{} (#'a #'b) () (#'<top> #'<top>)

(split #'(@{_ <fixnum>@} a b))
@result{} (#'a #'b) (#'<fixnum>) (#'<top> #'<top>)

(split #'(@{_ <fixnum>@} @{a <flonum>@} @{b <string>@}))
@result{} (#'a #'b) (#'<fixnum>) (#'<flonum> #'<string>)

(split #'(@{_ <fixnum> <flonum>@} @{a <vector>@} @{b <string>@}))
@result{} (#'a #'b) (#'<fixnum> #'<flonum>) (#'<vector> #'<string>)

(split #'(@{_ <fixnum> <flonum>@} . @{args <fixnums>@}))
@result{} #'args (#'<fixnum> #'<flonum>) #'<fixnums>
@end example
@end defun

@c page
@node typed object specs
@section Object type specification


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@deftp {Struct Type} object-type-spec
Type of structs representing the object type to which expressions in
syntax objects will evaluate; all the Scheme objects are meant to be
representable with this type specification.  It has the following
fields:

@table @code
@item type-id
A bound identifier representing the name of this type; what matters is
that it is bound, not what it is bound to.  This identifier has this
very instance in its syntactic binding property list.

@item pred-id
An identifier bound to the type predicate.

@item accessor-maker
@false{} or an accessor maker procedure accepting 2 arguments and
returning 1 value.

@itemize
@item
The arguments are: an identifier representing a slot name; a boolean,
true if the requested accessor is safe, false if it is unsafe.

@item
The return value is a syntax object evaluating to a slot accessor, or
false if this @objtype{object-type-spec} does not provide an accessor
for the selected slot.
@end itemize

If the slot name is invalid for some reason (for example the slot is
hidden): the proceure must raise an exception.  If this
@objtype{object-type-spec} does not implement the selected slot: the
return value must be @false{} and the slot will be searched in the
parent @objtype{object-type-spec}, if any.

@item mutator-maker
@false{} or a mutator maker procedure accepting 2 arguments and
returning 1 value.

@itemize
@item
The arguments are: an identifier representing a slot name; a boolean,
true if the requested mutator is safe, false if it is unsafe.

@item
The return value is a syntax object evaluating to a slot mutator, or
false if this @objtype{object-type-spec} does not provide a mutator for
the selected slot.
@end itemize

If the slot name is invalid for some reason (for example the slot is
immutable): the proceure must raise an exception.  If this
@objtype{object-type-spec} does not implement the selected slot: the
return value must be false and the slot will be searched in the parent
@objtype{object-type-spec}, if any.

@item dispatcher
False or a dispatcher procedure accepting a single argument and
returning a single value, and acting like a macro transformer.

The argument must be a syntax object representing with the format:

@example
(@meta{var} @metao{arg} @meta{arg} ...)
@end example

@noindent
where @meta{var} is an expression evaluating to a single object whose
type is described by this structure.  The return value must be a syntax
object representing the output form: an expression to be further
expanded.

@item parent-spec
@false{} or an instance of @objtype{object-type-spec} describing the
parent of this type.
@end table
@end deftp


@defun make-object-type-spec @var{type-id} @var{pred-id}
@defunx make-object-type-spec @var{type-id} @var{pred-id} @var{accessor-maker} @var{mutator-maker} @var{dispatcher} @var{parent-id}
Build and return a new instance of @objtype{object-type-spec}.
@end defun


@defun object-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{object-type-spec}, otherwise return @false{}.
@end defun

@c end of file
