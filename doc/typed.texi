@node typed
@chapter Experimental typed language


@value{PRJNAME}'s expander implements an extension to the language
defined by @rnrs{6} that allows the definition of typed bindings;

@quotation
@strong{NOTE} Typed language support is currently experimental.
@end quotation

@menu
* typed parsers::               Parsing tagged syntaxes.
@end menu

@c page
@node typed parsers
@section Parsing tagged syntaxes


@menu
* typed parsers bindings::      Parsing tagged and untagged bindings.
@end menu

@c page
@node typed parsers bindings
@subsection Parsing tagged and untagged bindings


The library @library{vicare expander object-type-specs} exports
functions to validate and parse syntax objects representing tagged and
untagged bindings.

@quotation
@strong{NOTE} To make the examples simpler: the return value of the
functions is represented by syntax objects that are @func{syntax=?} to
the returned values.  For example, when the return values are the syntax
objects:

@example
#<syntax expr=X> #<syntax expr=<fixnum>>
@end example

@noindent
they are represented as:

@example
#'X #'<fixnum>
@end example
@end quotation

@menu
* typed parsers bindings ids::      Parsing standalone bindings.
* typed parsers bindings lists::    Parsing proper lists of bindings.
* typed parsers bindings lambda::   Parsing @func{lambda} formals.
* typed parsers bindings values::   Parsing values formals.
@end menu

@c page
@node typed parsers bindings ids
@subsubsection Parsing standalone identifiers


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun tagged-identifier-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing a tagged or
untagged identifier, otherwise return @false{}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.tagged-identifier-syntax? #'(brace X <fixnum>)) @result{} #t
(typ.tagged-identifier-syntax? #'@{X <fixnum>@})       @result{} #t
(typ.tagged-identifier-syntax? #'X)                  @result{} #t
(typ.tagged-identifier-syntax? 123)                  @result{} #f
@end example
@end defun


@defun parse-tagged-identifier-syntax @var{stx}
If @var{stx} is a tagged or untagged identifier, return 2 values: the
identifier representing the binding name and the identifier representing
the tag; otherwise raise an exception.  When no tag is present: the tag
identifier defaults to @class{top}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.parse-tagged-identifier-syntax #'(brace X <fixnum>))
@result{} #'X #'<fixnum>

(typ.parse-tagged-identifier-syntax #'@{X <fixnum>@})
@result{} #'X #'<fixnum>

(typ.parse-tagged-identifier-syntax #'X)
@result{} #'X #'<top>

(receive (id tag)
    (typ.parse-tagged-identifier-syntax #'@{X <fixnum>@})
  (free-identifier=? id  #'X)           @result{} #t
  (free-identifier=? tag #'<fixnum>))   @result{} #t
@end example
@end defun

@c page
@node typed parsers bindings lists
@subsubsection Parsing proper lists of bindings


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun tagged-bindings-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing a proper
list of tagged or untagged identifier, otherwise return @false{}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.tagged-bindings-syntax? #'(@{a <fixnum>@}))
@result{} #t

(typ.tagged-bindings-syntax? #'(@{a <fixnum>@}
                                @{b <string>@}))
@result{} #t

(typ.tagged-bindings-syntax? #'(@{a <fixnum>@}
                                @{b <string>@}
                                @{c <vector>@}))
@result{} #t

(typ.tagged-bindings-syntax? #'(a))
@result{} #t

(typ.tagged-bindings-syntax? #'(a b))
@result{} #t

(typ.tagged-bindings-syntax? #'(a b c))
@result{} #t

(typ.tagged-bindings-syntax? #'(a @{b <string>@}))
@result{} #t

(typ.tagged-bindings-syntax? #'(@{a <fixnum>@} b))
@result{} #t

(typ.tagged-bindings-syntax? #'(a
                                @{b <string>@}
                                @{c <vector>@}))
@result{} #t

(typ.tagged-bindings-syntax? #'(@{a <fixnum>@}
                                b
                                @{c <vector>@}))
@result{} #t

(typ.tagged-bindings-syntax? #'(@{a <fixnum>@}
                                @{b <string>@}
                                c))
@result{} #t
@end example
@end defun


@defun parse-tagged-bindings-syntax @var{stx}
@defunx parse-tagged-bindings-syntax @var{stx} @var{input-form-stx}
Assume @var{stx} is a syntax object representing a proper list of
possibly tagged binding identifiers; parse the list and return 2 values:
a list of identifiers representing the binding identifiers, a list of
identifiers and #f representing the type tags; @class{top} is used when
no tag is present.

The optional argument @var{input-form-stx} is meant to be a syntax
object representing the form from which @var{stx} was extracted; it is
used as @code{form} field when raising a syntax violation.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.parse-tagged-bindings-syntax #'(@{a <fixnum>@}))
@result{} (#'a) (#'<fixnum>)

(typ.parse-tagged-bindings-syntax #'(@{a <fixnum>@}
                                     @{b <string>@}))
@result{} (#'a #'b) (#'<fixnum> #'<string>)

(typ.parse-tagged-bindings-syntax #'(@{a <fixnum>@}
                                     @{b <string>@}
                                     @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<fixnum> #'<string> #'<vector>)

(typ.parse-tagged-bindings-syntax #'(a))
@result{} (#'a) (#'<top>)

(typ.parse-tagged-bindings-syntax #'(a b))
@result{} (#'a #'b) (#'<top> #'<top>)

(typ.parse-tagged-bindings-syntax #'(a b c))
@result{} (#'a #'b #'c) (#'<top> #'<top> #'<top>)

(typ.parse-tagged-bindings-syntax #'(a @{b <string>@}))
@result{} (#'a #'b) (#'<top> #'<string>)

(typ.parse-tagged-bindings-syntax #'(@{a <fixnum>@} b))
@result{} (#'a #'b) (#'<fixnum> #'<top>)

(typ.parse-tagged-bindings-syntax #'(a
                                     @{b <string>@}
                                     @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<top> #'<string> #'<vector>)

(typ.parse-tagged-bindings-syntax #'(@{a <fixnum>@}
                                     b
                                     @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<fixnum> #'<top> #'<vector>)

(typ.parse-tagged-bindings-syntax #'(@{a <fixnum>@}
                                     @{b <string>@}
                                     c))
@result{} (#'a #'b #'c) (#'<fixnum> #'<string> #'<top>)
@end example
@end defun

@c page
@node typed parsers bindings lambda
@subsubsection Parsing @func{lambda} formals


To describe the supported syntax for @func{lambda} formals we use the
conventions: @meta{id}, @meta{rest-id} and @meta{args-id} are argument
identifiers; @meta{tag} and @meta{rv-tag} are tag identifiers.  We
accept the following standard formals formats:

@example
@meta{args-id}
(@meta{id} ...)
(@metao{id} @meta{id} ... . @meta{rest-id})
@end example

@noindent
and in addition the following tagged formals:

@example
(brace @meta{args-id} @meta{args-tag})
(@meta{arg} ...)
(@metao{arg} @meta{arg} ... . @meta{rest-arg})
((brace _ @metao{rv-tag} @meta{rv-tag} ...) @meta{arg} ...)
((brace _ @metao{rv-tag} @meta{rv-tag} ...) @meta{arg} ... . @meta{rest-arg})
@end example

@noindent
where @meta{arg} is a tagged argument with one of the formats:

@example
@meta{arg-id}
(brace @meta{arg-id} @meta{arg-tag})
@end example

@noindent
the identifiers @func{brace} and @func{_} are the syntax bindings
exported by @library{vicare}; the first item with identifier @func{_} is
a special syntax that allows to specify the tags of the @func{lambda}
return values.

The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun lambda-tagging-signature? @var{obj}
Return @true{} if @var{obj} represents a @func{lambda} tagging
signature; otherwise return @false{}.  @var{obj} is a @func{lambda}
tagging signature if it is a pair and:

@itemize
@item
Its car is null or a proper list of tag identifiers representing the
return value tags.

@item
Its cdr is a proper or improper list of tag identifiers representing the
tags of the arguments.
@end itemize
@end defun


@defun standard-lambda-formals-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing @rnrs{6}
standard @func{lambda} formals; otherwise return @false{}.  The return
value is true if @var{stx} is a proper or improper list of identifiers,
with a standalone identifier being acceptable.
@end defun


@defun tagged-lambda-formals-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing valid tagged
or untagged formals for a @func{lambda} syntax; otherwise return
@false{}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.tagged-lambda-formals-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}))
@result{} #t

(typ.tagged-lambda-formals-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} #t

;;; untagged

(typ.tagged-lambda-formals-syntax? #'(a))
@result{} #t

(typ.tagged-lambda-formals-syntax? #'(a b))
@result{} #t

(typ.tagged-lambda-formals-syntax? #'(a b c))
@result{} #t

;;; mixed tagged and untagged

(typ.tagged-lambda-formals-syntax? #'(a
                                      @{b <string>@}))
@result{} #t

(typ.tagged-lambda-formals-syntax? #'(@{a <fixnum>@}
                                      b))
@result{} #t

(typ.tagged-lambda-formals-syntax? #'(a
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} #t

(typ.tagged-lambda-formals-syntax? #'(@{a <fixnum>@}
                                      b
                                      @{c <vector>@}))
@result{} #t

(typ.tagged-lambda-formals-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      c)
@result{} #t

;;; args argument

(typ.tagged-lambda-formals-syntax? #'@{args <fixnums>@})
@result{} #t

(typ.tagged-lambda-formals-syntax? #'args)
@result{} #t

;;; rest argument

(typ.tagged-lambda-formals-syntax?
    #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-lambda-formals-syntax?
    #'(@{a <fixnum>@} . rest))
@result{} #t

(typ.tagged-lambda-formals-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-lambda-formals-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} #t

;;; return values tagging

(typ.tagged-lambda-formals-syntax? #'(@{_ <fixnum>@} a b))
@result{} #t

(typ.tagged-lambda-formals-syntax?
    #'(@{_ <fixnum>@} @{a <flonum>@} @{b <string>@}))
@result{} #t

(typ.tagged-lambda-formals-syntax?
    #'(@{_ <fixnum> <flonum>@} @{a <vector>@} @{b <string>@}))
@result{} #t

(typ.tagged-lambda-formals-syntax?
    #'(@{_ <fixnum> <flonum>@} . @{args <fixnums>@}))
@result{} #t
@end example
@end defun


@defun parse-tagged-lambda-formals-syntax @var{stx}
@defunx parse-tagged-lambda-formals-syntax @var{stx} @var{input-form-stx}
Given a syntax object @var{stx} representing tagged @func{lambda}
formals: parse it and split formals from tags.  If successful return 2
values: a proper or improper list of identifiers representing the
standard formals; a syntax object representing the @func{lambda} tagging
signature.

The optional argument @var{input-form-stx} is meant to be a syntax
object representing the form from which @var{stx} was extracted; it is
used as @code{form} field when raising a syntax violation.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.parse-tagged-lambda-formals-syntax #'(@{a <fixnum>@}
                                           @{b <string>@}))
@result{} (#'a #'b) (() #'<fixnum> #'<string>)

(typ.parse-tagged-lambda-formals-syntax #'(@{a <fixnum>@}
                                           @{b <string>@}
                                           @{c <vector>@}))
@result{} (a b c) (() <fixnum> <string> <vector>))

;;; untagged

(typ.parse-tagged-lambda-formals-syntax #'(a))
@result{} (#'a) (() #'<top>)

(typ.parse-tagged-lambda-formals-syntax #'(a b))
@result{} (#'a #'b) (() #'<top> #'<top>)

(typ.parse-tagged-lambda-formals-syntax #'(a b c))
@result{} (#'a #'b #'c) (() #'<top> #'<top> #'<top>)

;;; mixed tagged and untagged

(typ.parse-tagged-lambda-formals-syntax #'(a
                                           @{b <string>@}))
@result{} (#'a #'b) (() #'<top> #'<string>)

(typ.parse-tagged-lambda-formals-syntax #'(@{a <fixnum>@}
                                           b))
@result{} (#'a #'b) (() #'<fixnum> #'<top>)

(typ.parse-tagged-lambda-formals-syntax #'(a
                                           @{b <string>@}
                                           @{c <vector>@}))
@result{} (#'a #'b #'c) (() #'<top> #'<string> #'<vector>)

(typ.parse-tagged-lambda-formals-syntax #'(@{a <fixnum>@}
                                           b
                                           @{c <vector>@}))
@result{} (#'a #'b #'c) (() #'<fixnum> #'<top> #'<vector>)

(typ.parse-tagged-lambda-formals-syntax #'(@{a <fixnum>@}
                                           @{b <string>@}
                                           c)
@result{} (#'a #'b #'c) (() #'<fixnum> #'<string> #'<top>)

;;; args argument

(typ.parse-tagged-lambda-formals-syntax #'@{args <fixnums>@})
@result{} #'args (() . #'<fixnums>)

(typ.parse-tagged-lambda-formals-syntax #'args)
@result{} #'args (() . #'<top>)

;;; rest argument

(typ.parse-tagged-lambda-formals-syntax
    #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} (#'a . #'rest) (() #'<fixnum> . #'<fixnums>)

(typ.parse-tagged-lambda-formals-syntax
    #'(@{a <fixnum>@} . rest))
@result{} (#'a . #'rest) (() #'<fixnum> . #'<top>)

(typ.parse-tagged-lambda-formals-syntax
    #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} (#'a #'b . #'rest) (() #'<fixnum> #'<string> . #'<fixnums>)

(typ.parse-tagged-lambda-formals-syntax
    #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} (#'a #'b . #'rest) (() #'<fixnum> #'<string> . #'<top>)

;;; return values tagging

(typ.parse-tagged-lambda-formals-syntax #'(@{_ <fixnum>@} a b))
@result{} (#'a #'b) ((#'<fixnum>) #'<top> #'<top>)

(typ.parse-tagged-lambda-formals-syntax
    #'(@{_ <fixnum>@} @{a <flonum>@} @{b <string>@}))
@result{} (#'a #'b) ((#'<fixnum>) #'<flonum> #'<string>)

(typ.parse-tagged-lambda-formals-syntax
    #'(@{_ <fixnum> <flonum>@} @{a <vector>@} @{b <string>@}))
@result{} (#'a #'b) ((#'<fixnum> #'<flonum>) #'<vector> #'<string>)

(typ.parse-tagged-lambda-formals-syntax
    #'(@{_ <fixnum> <flonum>@} . @{args <fixnums>@}))
@result{} #'args ((#'<fixnum> #'<flonum>) . #'<fixnums>)
@end example
@end defun

@c page
@node typed parsers bindings values
@subsubsection Parsing values formals


To describe the supported syntax for values formals we use the
conventions: @meta{id}, @meta{rest-id} and @meta{args-id} are argument
identifiers; @meta{tag} and @meta{rv-tag} are tag identifiers.  We
accept the following standard formals formats:

@example
@meta{args-id}
(@meta{id} ...)
(@metao{id} @meta{id} ... . @meta{rest-id})
@end example

@noindent
and in addition the following tagged formals:

@example
(brace @meta{args-id} @meta{args-tag})
(@meta{arg} ...)
(@metao{arg} @meta{arg} ... . @meta{rest-arg})
@end example

@noindent
where @meta{arg} is a tagged argument with one of the formats:

@example
@meta{arg-id}
(brace @meta{arg-id} @meta{arg-tag})
@end example

@noindent
the identifier @func{brace} is the syntax binding exported by
@library{vicare}.

The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun values-tagging-signature? @var{obj}
Return @true{} if @var{obj} represents a @func{let-values} tagging
signature; otherwise return @false{}.  @var{obj} is a @func{let-values}
signature if it is a proper or improper list of tag identifiers
representing the tags of the bindings.
@end defun


@defun standard-values-formals-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing @rnrs{6}
standard @func{let-values} formals; otherwise return @false{}.  The
return value is true if @var{stx} is a proper or improper list of
identifiers, with a standalone identifier being acceptable.
@end defun


@defun tagged-values-formals-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing valid tagged
or untagged formals for a @func{let-values} syntax; otherwise return
@false{}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.tagged-values-formals-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}))
@result{} #t

(typ.tagged-values-formals-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} #t

;;; untagged

(typ.tagged-values-formals-syntax? #'(a))
@result{} #t

(typ.tagged-values-formals-syntax? #'(a b))
@result{} #t

(typ.tagged-values-formals-syntax? #'(a b c))
@result{} #t

;;; mixed tagged and untagged

(typ.tagged-values-formals-syntax? #'(a
                                      @{b <string>@}))
@result{} #t

(typ.tagged-values-formals-syntax? #'(@{a <fixnum>@}
                                      b))
@result{} #t

(typ.tagged-values-formals-syntax? #'(a
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} #t

(typ.tagged-values-formals-syntax? #'(@{a <fixnum>@}
                                      b
                                      @{c <vector>@}))
@result{} #t

(typ.tagged-values-formals-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      c)
@result{} #t

;;; args argument

(typ.tagged-values-formals-syntax? #'@{args <fixnums>@})
@result{} #t

(typ.tagged-values-formals-syntax? #'args)
@result{} #t

;;; rest argument

(typ.tagged-values-formals-syntax?
    #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-values-formals-syntax?
    #'(@{a <fixnum>@} . rest))
@result{} #t

(typ.tagged-values-formals-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-values-formals-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} #t
@end example
@end defun


@defun parse-tagged-values-formals-syntax @var{stx}
@defunx parse-tagged-values-formals-syntax @var{stx} @var{input-form-stx}
Given a syntax object @var{stx} representing tagged @func{let-values}
formals: parse it and split formals from tags.  If successful return 2
values: a proper or improper list of identifiers representing the
standard formals; a syntax object representing the @func{values} tagging
signature.

The optional argument @var{input-form-stx} is meant to be a syntax
object representing the form from which @var{stx} was extracted; it is
used as @code{form} field when raising a syntax violation.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.parse-tagged-values-formals-syntax #'(@{a <fixnum>@}
                                           @{b <string>@}))
@result{} (#'a #'b) (#'<fixnum> #'<string>)

(typ.parse-tagged-values-formals-syntax #'(@{a <fixnum>@}
                                           @{b <string>@}
                                           @{c <vector>@}))
@result{} (a b c) (<fixnum> <string> <vector>))

;;; untagged

(typ.parse-tagged-values-formals-syntax #'(a))
@result{} (#'a) (#'<top>)

(typ.parse-tagged-values-formals-syntax #'(a b))
@result{} (#'a #'b) (#'<top> #'<top>)

(typ.parse-tagged-values-formals-syntax #'(a b c))
@result{} (#'a #'b #'c) (#'<top> #'<top> #'<top>)

;;; mixed tagged and untagged

(typ.parse-tagged-values-formals-syntax #'(a
                                           @{b <string>@}))
@result{} (#'a #'b) (#'<top> #'<string>)

(typ.parse-tagged-values-formals-syntax #'(@{a <fixnum>@}
                                           b))
@result{} (#'a #'b) (#'<fixnum> #'<top>)

(typ.parse-tagged-values-formals-syntax #'(a
                                           @{b <string>@}
                                           @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<top> #'<string> #'<vector>)

(typ.parse-tagged-values-formals-syntax #'(@{a <fixnum>@}
                                           b
                                           @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<fixnum> #'<top> #'<vector>)

(typ.parse-tagged-values-formals-syntax #'(@{a <fixnum>@}
                                           @{b <string>@}
                                           c)
@result{} (#'a #'b #'c) (#'<fixnum> #'<string> #'<top>)

;;; args argument

(typ.parse-tagged-values-formals-syntax #'@{args <fixnums>@})
@result{} #'args (. #'<fixnums>)

(typ.parse-tagged-values-formals-syntax #'args)
@result{} #'args (. #'<top>)

;;; rest argument

(typ.parse-tagged-values-formals-syntax
    #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} (#'a . #'rest) (#'<fixnum> . #'<fixnums>)

(typ.parse-tagged-values-formals-syntax
    #'(@{a <fixnum>@} . rest))
@result{} (#'a . #'rest) (#'<fixnum> . #'<top>)

(typ.parse-tagged-values-formals-syntax
    #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} (#'a #'b . #'rest) (#'<fixnum> #'<string> . #'<fixnums>)

(typ.parse-tagged-values-formals-syntax
    #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} (#'a #'b . #'rest) (#'<fixnum> #'<string> . #'<top>)
@end example
@end defun

@c end of file
