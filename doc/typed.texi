@node typed
@chapter Experimental typed language


@value{PRJNAME}'s expander implements an extension to the language
defined by @rnrs{6} that allows the definition of typed bindings;

@quotation
@strong{NOTE} Typed language support is currently experimental.
@end quotation

@menu
* typed concepts::              Typed language concepts.
* typed parsers::               Parsing tagged syntaxes.
* typed bindings::              Typed language binding properties.
* typed object specs::          Object type specification.
@end menu

@c page
@node typed concepts
@section Typed language concepts


@subsubheading Tag identifiers

A @dfn{tag identifier} is a bound identifier whose syntactic binding
label gensym has a specific entry in its property list; such entry has
an instance of @code{object-type-spec} as value.  Tag identifiers must
be bound (otherwise they do not have a syntactic binding label), but it
does not matter to what they are bound.  Typical examples of tag
identifiers are:

@itemize
@item
Struct type identifiers defined by @func{define-struct}; they are
automatically made tag identifiers by @value{PRJNAME}.

@item
@rnrs{6} record type identifiers defined by @func{define-record-type};
they are automatically made tag identifiers by @value{PRJNAME}.

@item
A set of non--core macro identifiers (whose implementation is integrated
in the expander) are exported by the library @library{vicare expander
tags} to be the tags of built--in @value{PRJNAME} objects.  Some of them
are: @class{fixnum}, @class{string}, @class{vector},
@class{textual-input-port}.
@end itemize

We can easily create a tag identifier as:

@example
(import (vicare)
  (vicare expander tags)
  (for (prefix (vicare expander object-type-specs) typ.)
    expand))

(define-syntax <my-tag>
  (let ()
    (set-identifier-tag! #'<my-tag>
      (make-object-type-spec #'<my-tag> #'<top> ...))
    (lambda (x) #f)))
@end example

@noindent
where @class{my-tag} is a tag identifier and @class{top} is its parent
tag.  Tag identifiers are organised in a tree hierarchy, with subtags
inheriting properties of supertags; by convention, @class{top} is the
parent of all the tag identifiers, the root of the tree.

@c ------------------------------------------------------------

@subsubheading Tagged identifier

A @dfn{tagged identifier} is a bound identifier whose syntactic binding
label gensym has a specific entry in its property list; such entry has a
tag identifier as value.  Tagged identifiers must be bound (otherwise
they do not have a syntactic binding label).  Tagged identifiers are
created by the built--in binding syntaxes @func{lambda}, @func{define},
@func{let}, @func{letrec}, @func{let-values}, etc.

An example of tagged binding creation follows:

@example
#!vicare
(import (vicare)
  (vicare expander tags))

(define @{O <fixnum>@}
  123)
@end example

@noindent
the identifier @code{O} is a tagged identifier with tag identifier
@class{fixnum}; the braces are used to tag the first identifier with the
second identifier.  At the time the tagged identifier is created: the
tag identifier must already be a tag identifier.

@c page
@node typed parsers
@section Parsing tagged syntaxes


The library @library{vicare expander object-type-specs} exports
functions to validate and parse syntax objects representing tagged and
untagged bindings.

@quotation
@strong{NOTE} To make the examples simpler: the return value of the
functions is represented by syntax objects that are @func{syntax=?} to
the returned values and written with the reader syntax.  For example,
when the return values are the syntax objects:

@example
#<syntax expr=X> #<syntax expr=<fixnum>>
@end example

@noindent
they are represented as:

@example
#'X #'<fixnum>
@end example
@end quotation

@menu
* typed parsers signatures::    Tag signatures data representations.
* typed parsers predicates::    Syntax predicates.
* typed parsers ids::           Parsing standalone bindings.
* typed parsers lists::         Parsing proper lists of bindings.
* typed parsers formals::       Parsing tagged formals.
* typed parsers callable::      Parsing tagged callable signatures.
@end menu

@c page
@node typed parsers signatures
@subsection Tag signatures data representations


A @dfn{callable specification} is a syntax object representing the name,
arguments and return values of a callable object: a function or macro.
A callable can be used as:

@example
(@meta{callable} @meta{arg} ...)
@end example

@noindent
but not as:

@example
(apply ?callable ?arg ...)
@end example

A @dfn{return values signature} is an object representing the type and
number of callable return values.  When the callable has one or more
return values: a proper list of tag identifiers is used to represent
them.  When the callable has no return values: null is used.  When the
callable has an unspecified number of return values: @false{} is used.

A @dfn{formals signature} is an object representing the number and tags
of a callable formal arguments; it is a proper or improper list of tag
identifiers, with null and a standalone tagged identifier being
acceptable.

A @dfn{callable signature} is an object representing the number and tags
of callable arguments and return values.  @ref{typed parsers callable}
for the callable syntax specification.

@menu
* typed parsers signatures rv::       Signatures of return values.
* typed parsers signatures formals::  Signatures of formals.
* typed parsers signatures callable:: Full callable signatures.
@end menu

@c page
@node typed parsers signatures rv
@subsubsection Signatures of return values


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@deftp {Struct Type} retvals-signature
Struct type representing the type signature of callable's return
values.  It has the following fields:

@table @code
@item tags
When the callable has one or more return values: a proper or improper
list of tag identifiers is used to represent them.  When the callable
has no return values: null is used.  When the callable has an
unspecified number of return values: @false{} is used.
@end table
@end deftp


@defun make-retvals-signature @var{tags}
Build and return a new @objtype{retvals-signature} instance.
@end defun


@defun retvals-signature? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{retvals-signature}.
@end defun


@defun retvals-signature-tags @var{rv-signature}
Accessor for the field of @objtype{retvals-signature} instances.
@end defun


@defun retvals-signature=? @vari{rv-signature} @varii{rv-signature}
The arguments must be instances of @objtype{retvals-signature}.
Return @true{} if the arguments are equal, @false{} otherwise.
@end defun

@c page
@node typed parsers signatures formals
@subsubsection Signatures of formals


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@deftp {Struct Type} formals-signature
Struct type representing the type signature of callable's formals.  It
has the following fields:

@table @code
@item tags
A proper or improper list of tag identifiers, with null and a standalone
tagged identifier being acceptable.
@end table
@end deftp


@defun make-formals-signature @var{tags}
Build and return a new @objtype{formals-signature} instance.
@end defun


@defun formals-signature? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{formals-signature}.
@end defun


@defun formals-signature-tags @var{formals-signature}
Accessor for the field of @objtype{formals-signature} instances.
@end defun


@defun formals-signature=? @vari{formals-signature} @varii{formals-signature}
The arguments must be instances of @objtype{formals-signature}.  Return
@true{} if the arguments are equal, @false{} otherwise.
@end defun

@c page
@node typed parsers signatures callable
@subsubsection Full callable signatures


The following bindings are exported by the library @library{vicare
expander object-type-specs}.

@deftp {Struct Type} callable-signature
Struct type representing the type signature of callables.  It has the
following fields:

@table @code
@item return-values
An instance of @objtype{retvals-signature}.

@item formals
An instance of @objtype{formals-signature}.
@end table
@end deftp


@defun make-callable-signature @var{rv-signature} @var{formals-signature}
Build and return a new @objtype{callable-signature} instance.
@end defun


@defun callable-signature? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{callable-signature}.
@end defun


@defun callable-signature-return-values @var{signature}
@defunx callable-signature-formals @var{signature}
Accessor for the fields of @objtype{callable-signature} instances.
@end defun


@defun callable-signature-return-values-tags @var{signature}
Return the content of the @code{tags} field in the
@objtype{retvals-signature} instance from the @code{return-values} field
of @var{signature}.
@end defun


@defun callable-signature-formals-tags @var{signature}
Return the content of the @code{tags} field in the
@objtype{formals-signature} instance from the @code{formals} field of
@var{signature}.
@end defun


@defun callable-signature=? @vari{signature} @varii{signature}
The arguments must be instances of @objtype{callable-signature}.  Return
@true{} if the arguments are equal, @false{} otherwise.
@end defun

@c page
@node typed parsers predicates
@subsection Syntax predicates


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun standard-formals-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing @rnrs{6}
standard @func{lambda} and @func{let-values} formals; otherwise return
@false{}.  The return value is true if @var{stx} is a proper or improper
list of identifiers, with null and a standalone identifier being
acceptable.
@end defun


@defun formals-signature-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing the tag
signature of a tagged formals syntax; otherwise return @false{}.  The
return value is true if @var{stx} is a proper or improper list of tag
identifiers, with null and a standalone tag identifier being acceptable.
@end defun


@defun retvals-signature-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing the tag
signature of a set of return values; otherwise return @false{}.  The
return value is true if @var{stx} is @false{}, null or a proper or
improper list of tag identifiers, with a standalone tag identifier being
acceptable.
@end defun

@c page
@node typed parsers ids
@subsection Parsing standalone identifiers


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun tagged-identifier-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing a tagged or
untagged identifier, otherwise return @false{}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.tagged-identifier-syntax? #'(brace X <fixnum>)) @result{} #t
(typ.tagged-identifier-syntax? #'@{X <fixnum>@})       @result{} #t
(typ.tagged-identifier-syntax? #'X)                  @result{} #t
(typ.tagged-identifier-syntax? 123)                  @result{} #f
@end example
@end defun


@defun parse-tagged-identifier-syntax @var{stx}
If @var{stx} is a tagged or untagged identifier, return 2 values: the
identifier representing the binding name and the identifier representing
the tag; otherwise raise an exception with condition type
@condition{syntax}.  When no tag is present: the tag identifier defaults
to @class{top}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.parse-tagged-identifier-syntax #'(brace X <fixnum>))
@result{} #'X #'<fixnum>

(typ.parse-tagged-identifier-syntax #'@{X <fixnum>@})
@result{} #'X #'<fixnum>

(typ.parse-tagged-identifier-syntax #'X)
@result{} #'X #'<top>

(receive (id tag)
    (typ.parse-tagged-identifier-syntax #'@{X <fixnum>@})
  (free-identifier=? id  #'X)           @result{} #t
  (free-identifier=? tag #'<fixnum>))   @result{} #t
@end example
@end defun

@c page
@node typed parsers lists
@subsection Parsing proper lists of bindings


Lists of tagged bindings are often used in binding syntaxes like
@func{let}, @func{do} and similar.  For example, when expanding the
syntax:

@example
#!vicare
(let ((@{a <fixnum>@} 1)
      (@{b <string>@} "b")
      (c            #t))
  . @meta{body})
@end example

@noindent
a list of tagged bindings is extracted:

@example
(#'(brace a <fixnum>) #'(brace b <string>) #'c)
@end example

@noindent
and parsed to yield the identifiers and the tags:

@example
(#'a #'b #'c) (#'<fixnum> #'<string> #'<top>)
@end example

The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun list-of-tagged-bindings? @var{stx}
Return @true{} if @var{stx} is a syntax object representing a proper
list of tagged or untagged identifiers, otherwise return @false{}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@}
                                 @{b <string>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@}
                                 @{b <string>@}
                                 @{c <vector>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(a))
@result{} #t

(typ.list-of-tagged-bindings? #'(a b))
@result{} #t

(typ.list-of-tagged-bindings? #'(a b c))
@result{} #t

(typ.list-of-tagged-bindings? #'(a @{b <string>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@} b))
@result{} #t

(typ.list-of-tagged-bindings? #'(a
                                 @{b <string>@}
                                 @{c <vector>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@}
                                 b
                                 @{c <vector>@}))
@result{} #t

(typ.list-of-tagged-bindings? #'(@{a <fixnum>@}
                                 @{b <string>@}
                                 c))
@result{} #t
@end example
@end defun


@defun parse-list-of-tagged-bindings @var{stx}
@defunx parse-list-of-tagged-bindings @var{stx} @var{input-form-stx}
Assume @var{stx} is a syntax object representing a proper list of
possibly tagged binding identifiers; parse the list and, when
successful, return 2 values: a list of identifiers representing the
binding identifiers, a list of identifiers representing the type tags;
@class{top} is used when no tag is present.  If an error occurs raise an
exception with condition object type @condition{syntax}.

The identifiers must be distinct according to @func{bound-identifier=?}.

The optional argument @var{input-form-stx} is meant to be a syntax
object representing the form from which @var{stx} was extracted; it is
used as @code{form} field when raising a syntax violation.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@}))
@result{} (#'a) (#'<fixnum>)

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@}
                                      @{b <string>@}))
@result{} (#'a #'b) (#'<fixnum> #'<string>)

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<fixnum> #'<string> #'<vector>)

(typ.parse-list-of-tagged-bindings #'(a))
@result{} (#'a) (#'<top>)

(typ.parse-list-of-tagged-bindings #'(a b))
@result{} (#'a #'b) (#'<top> #'<top>)

(typ.parse-list-of-tagged-bindings #'(a b c))
@result{} (#'a #'b #'c) (#'<top> #'<top> #'<top>)

(typ.parse-list-of-tagged-bindings #'(a @{b <string>@}))
@result{} (#'a #'b) (#'<top> #'<string>)

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@} b))
@result{} (#'a #'b) (#'<fixnum> #'<top>)

(typ.parse-list-of-tagged-bindings #'(a
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<top> #'<string> #'<vector>)

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@}
                                      b
                                      @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<fixnum> #'<top> #'<vector>)

(typ.parse-list-of-tagged-bindings #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      c))
@result{} (#'a #'b #'c) (#'<fixnum> #'<string> #'<top>)
@end example
@end defun

@c page
@node typed parsers formals
@subsection Parsing tagged formals


Tagged formals syntax is used by @func{let-values}, @func{let*-values},
@func{define-values} and similar syntaxes; it is @strong{not} used by
@func{lambda} and related syntaxes.

To describe the supported syntax for tagged formals we use the
conventions: @meta{id}, @meta{rest-id} and @meta{args-id} are argument
identifiers; @meta{arg-tag}, @meta{rest-tag} and @meta{args-tag} are tag
identifiers.  The predicate and parser functions for tagged formals
accept the following standard @rnrs{6} formals formats:

@example
@meta{args-id}
(@meta{id} ...)
(@metao{id} @meta{id} ... . @meta{rest-id})
@end example

@noindent
and in addition the following tagged formals:

@example
(brace @meta{args-id} @meta{args-tag})
(@meta{arg} ...)
(@metao{arg} @meta{arg} ... . @meta{rest-arg})
@end example

@noindent
where @meta{arg} is a tagged identifier with one of the formats:

@example
@meta{arg-id}
(brace @meta{arg-id} @meta{arg-tag})
@end example

@noindent
the identifier @func{brace} is the syntax binding exported by
@library{vicare}.

@noindent
the binding identifiers must be distinct according to
@func{bound-identifier=?}.

The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun tagged-formals-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing a tagged
formals syntax; otherwise return @false{}.  @var{stx} is a tagged
formals syntax if it is a proper or improper list of tagged identifiers,
wich null and a standalone tagged identifier being acceptable.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.tagged-formals-syntax? #'(@{a <fixnum>@}
                               @{b <string>@}))
@result{} #t

(typ.tagged-formals-syntax? #'(@{a <fixnum>@}
                               @{b <string>@}
                               @{c <vector>@}))
@result{} #t

;;; untagged

(typ.tagged-formals-syntax? #'(a))
@result{} #t

(typ.tagged-formals-syntax? #'(a b))
@result{} #t

(typ.tagged-formals-syntax? #'(a b c))
@result{} #t

;;; mixed tagged and untagged

(typ.tagged-formals-syntax? #'(a
                               @{b <string>@}))
@result{} #t

(typ.tagged-formals-syntax? #'(@{a <fixnum>@}
                               b))
@result{} #t

(typ.tagged-formals-syntax? #'(a
                               @{b <string>@}
                               @{c <vector>@}))
@result{} #t

(typ.tagged-formals-syntax? #'(@{a <fixnum>@}
                               b
                               @{c <vector>@}))
@result{} #t

(typ.tagged-formals-syntax? #'(@{a <fixnum>@}
                               @{b <string>@}
                               c)
@result{} #t

;;; args argument

(typ.tagged-formals-syntax? #'@{args <fixnums>@})
@result{} #t

(typ.tagged-formals-syntax? #'args)
@result{} #t

;;; rest argument

(typ.tagged-formals-syntax?
    #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-formals-syntax?
    #'(@{a <fixnum>@} . rest))
@result{} #t

(typ.tagged-formals-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-formals-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} #t
@end example
@end defun


@defun parse-tagged-formals-syntax @var{stx}
@defunx parse-tagged-formals-syntax @var{stx} @var{input-form-stx}
Given a syntax object @var{stx} representing tagged formals: parse it
and split formals from tags.  If successful return 2 values: a proper or
improper list of identifiers representing the standard formals; an
instance of @objtype{formals-signature} holding the tag identifiers.  If
an error occurs raise an exception with condition object type
@condition{syntax}.

The optional argument @var{input-form-stx} is meant to be a syntax
object representing the form from which @var{stx} was extracted; it is
used as @code{form} field when raising a syntax violation.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(define (split stx)
  (receive (standard-formals signature)
      (typ.parse-tagged-formals-syntax stx)
    (values standard-formals (formals-signature-tags signature))))

(split #'(@{a <fixnum>@} @{b <string>@}))
@result{} (#'a #'b) (#'<fixnum> #'<string>)

(split #'(@{a <fixnum>@} @{b <string>@} @{c <vector>@}))
@result{} (a b c) (<fixnum> <string> <vector>))

;;; untagged

(split #'(a))
@result{} (#'a) (#'<top>)

(split #'(a b))
@result{} (#'a #'b) (#'<top> #'<top>)

(split #'(a b c))
@result{} (#'a #'b #'c) (#'<top> #'<top> #'<top>)

;;; mixed tagged and untagged

(split #'(a @{b <string>@}))
@result{} (#'a #'b) (#'<top> #'<string>)

(split #'(@{a <fixnum>@} b))
@result{} (#'a #'b) (#'<fixnum> #'<top>)

(split #'(a @{b <string>@} @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<top> #'<string> #'<vector>)

(split #'(@{a <fixnum>@} b @{c <vector>@}))
@result{} (#'a #'b #'c) (#'<fixnum> #'<top> #'<vector>)

(split #'(@{a <fixnum>@} @{b <string>@} c))
@result{} (#'a #'b #'c) (#'<fixnum> #'<string> #'<top>)

;;; args argument

(split #'@{args <fixnums>@})
@result{} #'args (. #'<fixnums>)

(split #'args)
@result{} #'args (. #'<top>)

;;; rest argument

(split #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} (#'a . #'rest) (#'<fixnum> . #'<fixnums>)

(split #'(@{a <fixnum>@} . rest))
@result{} (#'a . #'rest) (#'<fixnum> . #'<top>)

(split #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} (#'a #'b . #'rest) (#'<fixnum> #'<string> . #'<fixnums>)

(split #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} (#'a #'b . #'rest) (#'<fixnum> #'<string> . #'<top>)
@end example
@end defun

@c page
@node typed parsers callable
@subsection Parsing tagged callable signatures


Callable signatures syntax is used by @func{lambda} and similar
syntaxes.

To describe the supported syntax for callable signatures we use the
conventions: @meta{id}, @meta{rest-id} and @meta{args-id} are argument
identifiers; @meta{arg-tag}, @meta{rest-tag}, @meta{args-tag},
@meta{rv-tag} and @meta{rv-rest-tag} are tag identifiers.  The predicate
and parser functions for callable signatures accept the following
standard @rnrs{6} formals formats:

@example
@meta{args-id}
(@meta{id} ...)
(@metao{id} @meta{id} ... . @meta{rest-id})
@end example

@noindent
and in addition the following tagged formals:

@example
(brace @meta{args-id} @meta{args-tag})
(@meta{arg} ...)
(@metao{arg} @meta{arg} ... . @meta{rest-arg})
(@meta{retvals} @meta{arg} ...)
(@meta{retvals} @meta{arg} ... . @meta{rest-arg})
@end example

@noindent
where @meta{arg} is a tagged argument with one of the formats:

@example
@meta{arg-id}
(brace @meta{arg-id} @meta{arg-tag})
@end example

@noindent
@meta{retvals} is a special syntax that allows to specify the number and
tags of the expression return values; it has one of the formats:

@example
(brace _ @meta{rv-tag} ...)
(brace _ @meta{rv-tag} ... . @meta{rv-rest-tag})
@end example

@noindent
the identifiers @func{brace} and @func{_} are the syntax bindings
exported by @library{vicare}.

The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun tagged-callable-spec-syntax? @var{stx}
Return @true{} if @var{stx} is a syntax object representing valid tagged
callable signature syntax; otherwise return @false{}.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(typ.tagged-callable-spec-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} #t

;;; untagged

(typ.tagged-callable-spec-syntax? #'(a))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(a b))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(a b c))
@result{} #t

;;; mixed tagged and untagged

(typ.tagged-callable-spec-syntax? #'(a
                                      @{b <string>@}))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(@{a <fixnum>@}
                                      b))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(a
                                      @{b <string>@}
                                      @{c <vector>@}))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(@{a <fixnum>@}
                                      b
                                      @{c <vector>@}))
@result{} #t

(typ.tagged-callable-spec-syntax? #'(@{a <fixnum>@}
                                      @{b <string>@}
                                      c)
@result{} #t

;;; args argument

(typ.tagged-callable-spec-syntax? #'@{args <fixnums>@})
@result{} #t

(typ.tagged-callable-spec-syntax? #'args)
@result{} #t

;;; rest argument

(typ.tagged-callable-spec-syntax?
    #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{a <fixnum>@} . rest))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} #t

;;; return values tagging

(typ.tagged-callable-spec-syntax? #'(@{_ <fixnum>@} a b))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{_ <fixnum>@} @{a <flonum>@} @{b <string>@}))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{_ <fixnum> <flonum>@} @{a <vector>@} @{b <string>@}))
@result{} #t

(typ.tagged-callable-spec-syntax?
    #'(@{_ <fixnum> <flonum>@} . @{args <fixnums>@}))
@result{} #t
@end example
@end defun


@defun parse-tagged-callable-spec-syntax @var{stx}
@defunx parse-tagged-callable-spec-syntax @var{stx} @var{input-form-stx}
Given a syntax object @var{stx} representing tagged callable signature
syntax: parse it and split formals from tags.  If successful return 2
values: a proper or improper list of identifiers representing the
standard formals; an instance of @objtype{callable-signature}.  If an
error occurs: raise an exception with condition object type
@condition{syntax}.

The optional argument @var{input-form-stx} is meant to be a syntax
object representing the form from which @var{stx} was extracted; it is
used as @code{form} field when raising a syntax violation.

@example
#!vicare
(import (vicare)
  (vicare expander tags)
  (prefix (vicare expander object-type-specs) typ.))

(define (split input)
  (let-values (((standard-formals-stx callable)
                (typ.parse-tagged-callable-spec-syntax input)))
    (define formals-tags
      (typ.callable-signature-formals-tags callable))
    (define rv-tags
      (typ.callable-signature-return-values-tags callable))
    (values standard-formals-stx rv-tags formals-tags)))

(split #'(@{a <fixnum>@} @{b <string>@}))
@result{} (#'a #'b) #f (#'<fixnum> #'<string>)

(split #'(@{a <fixnum>@} @{b <string>@} @{c <vector>@}))
@result{} #'(a b c) #f (#'<fixnum> #'<string> #'<vector>)

;;; untagged

(split #'(a))
@result{} (#'a) #f (#'<top>)

(split #'(a b))
@result{} (#'a #'b) #f (#'<top> #'<top>)

(split #'(a b c))
@result{} (#'a #'b #'c) #f (#'<top> #'<top> #'<top>)

;;; mixed tagged and untagged

(split #'(a @{b <string>@}))
@result{} (#'a #'b) #f (#'<top> #'<string>)

(split #'(@{a <fixnum>@} b))
@result{} (#'a #'b) #f (#'<fixnum> #'<top>)

(split #'(a @{b <string>@} @{c <vector>@}))
@result{} (#'a #'b #'c) #f (#'<top> #'<string> #'<vector>)

(split #'(@{a <fixnum>@} b @{c <vector>@}))
@result{} (#'a #'b #'c) #f (#'<fixnum> #'<top> #'<vector>)

(split #'(@{a <fixnum>@} @{b <string>@} c))
@result{} (#'a #'b #'c) #f (#'<fixnum> #'<string> #'<top>)

;;; args argument

(split #'@{args <fixnums>@})
@result{} #'args #f #'<fixnums>

(split #'args)
@result{} #'args #f #'<top>

;;; rest argument

(split #'(@{a <fixnum>@} . @{rest <fixnums>@}))
@result{} (#'a . #'rest) #f (#'<fixnum> . #'<fixnums>)

(split #'(@{a <fixnum>@} . rest))
@result{} (#'a . #'rest) #f (#'<fixnum> . #'<top>)

(split #'(@{a <fixnum>@} @{b <string>@} . @{rest <fixnums>@}))
@result{} (#'a #'b . #'rest) #f (#'<fixnum> #'<string> . #'<fixnums>)

(split #'(@{a <fixnum>@} @{b <string>@} . rest))
@result{} (#'a #'b . #'rest) #f (#'<fixnum> #'<string> . #'<top>)

;;; return values tagging

(split #'(@{_@} a b))
@result{} (#'a #'b) () (#'<top> #'<top>)

(split #'(@{_ <fixnum>@} a b))
@result{} (#'a #'b) (#'<fixnum>) (#'<top> #'<top>)

(split #'(@{_ <fixnum>@} @{a <flonum>@} @{b <string>@}))
@result{} (#'a #'b) (#'<fixnum>) (#'<flonum> #'<string>)

(split #'(@{_ <fixnum> <flonum>@} @{a <vector>@} @{b <string>@}))
@result{} (#'a #'b) (#'<fixnum> #'<flonum>) (#'<vector> #'<string>)

(split #'(@{_ <fixnum> <flonum>@} . @{args <fixnums>@}))
@result{} #'args (#'<fixnum> #'<flonum>) #'<fixnums>
@end example
@end defun

@c page
@node typed bindings
@section Typed language binding properties


@menu
* typed bindings tag::          Tag identifier bindings.
* typed bindings tagged::       Tagged identifier bindings.
@end menu

@c page
@node typed bindings tag
@subsection Tag identifier bindings


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun set-identifier-object-type-spec! @var{type-id} @var{spec}
Add to the property list of the syntactic binding label of @var{type-id}
an entry representing an object type specification; return unspecified
values.  If @var{type-id} already has an object type specification
property: an exception is raised with condition object type
@condition{&syntax}.

@var{type-id} must be a bound identifier; when this call succeeds:
@var{type-id} becomes a tag identifier.  @var{spec} must be an instance
of @objtype{object-type-spec}.
@end defun


@defun identifier-object-type-spec @var{type-id}
Retrieve from the property list of the syntactic binding label of
@var{type-id} the @objtype{object-type-spec} instance representing the
object type specification.

@var{type-id} must be a bound identifier; if it also is a tag
identifier: the return value is the @objtype{object-type-spec} instance;
otherwise the return value is @false{}.
@end defun


@defun set-label-object-type-spec! @var{label} @var{spec}
Add to the property list of the syntactic binding @var{label} an entry
representing an object type specification; return unspecified values.
If @var{label} already has an object type specification property: an
exception is raised with condition object type @condition{&syntax}.

@var{label} must be the symbol used as syntactic binding label for a
bound identifier; when this call succeeds: the associated identifiers
become a tag identifiers.  @var{spec} must be an instance of
@objtype{object-type-spec}.
@end defun


@defun label-object-type-spec @var{label}
Retrieve from the property list of @var{label} the
@objtype{object-type-spec} instance representing the object type
specification.

@var{label} must be a symbol used as syntactic binding label for a bound
identifier; if the latter is also a tag identifier: the return value is
the @objtype{object-type-spec} instance; otherwise the return value is
@false{}.
@end defun


@defun tag-identifier? @var{obj}
Return @true{} if @var{obj} is a bound identifier with "object-type-spec"
property set; otherwise return @false{}.
@end defun


@defun all-tag-identifiers? @var{stx}
Return @true{} if @var{stx} is a syntax object representing a proper or
improper list of tag identifiers; otherwise return @false{}.
@end defun


@defun tag-super-and-sub? @var{super-tag} @var{sub-tag}
Given two tag identifiers: return @true{} if @var{super-tag} is
@func{free-identifier=?}  to @var{sub-tag} or one of its ancestors.
@end defun

@c page
@node typed bindings tagged
@subsection Tagged identifier bindings


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@defun set-identifier-tag! @var{binding-id} @var{tag}
Given a syntactic binding identifier and a tag identifier: add @var{tag}
to the property list of @var{binding-id} as binding type tagging; this
tag should represent the object type referenced by the binding.  Return
unspecified values.  If @var{label} already has a tag property: an
exception is raised with condition object type @condition{syntax}.
@end defun


@defun identifier-tag @var{binding-id}
Given a syntactic binding identifier: retrieve from its property list
the tag identifier representing the binding type tagging; this tag
identifier should represent the object type referenced by the binding.
If the identifier has no associated type tag: return @false{}.
@end defun


@defun set-label-tag! @var{label} @var{tag}
Given a syntactic binding label and a tag identifier: add @var{tag} to
the property list of @var{label} as binding type tagging; this tag
should represent the object type referenced by the binding.  Return
unspecified values.

If the operation succeeds: the associated binding identifiers become
tagged identifiers.  If @var{label} already has a tag property: an
exception is raised with condition object type @condition{syntax}.
@end defun


@defun label-tag @var{label}
Given a syntactic binding label: retrieve from its property list the tag
identifier representing the binding type tagging; this tag identifier
should represent the object type referenced by the binding.  If the
label has no associated type tag: return @false{}.
@end defun


@defun tagged-identifier? @var{id}
Return @true{} if @var{id} is a bound identifier having a type tagging;
otherwise return @false{}.  If the return value is true: @var{id} is a
bound identifier created by some binding syntaxes (@func{define},
@func{let}, @func{letrec}, @dots{}).  If @var{id} is not a bound
identifier: an exception is raised.
@end defun

@c page
@node typed object specs
@section Object type specification


The following bindings are exported by the library @library{vicare
expander object-type-specs}.


@deftp {Struct Type} object-type-spec
Type of structs representing the object type to which expressions in
syntax objects will evaluate; all the Scheme objects are meant to be
representable with this type specification.  It has the following
fields:

@table @code
@item type-id
A bound identifier representing the name of this type; what matters is
that it is bound, not what it is bound to.  This identifier has this
very instance in its syntactic binding property list.

@item pred-id
An identifier bound to the type predicate.

@item accessor-maker
@false{} or an accessor maker procedure accepting 2 arguments and
returning 1 value.

@itemize
@item
The arguments are: an identifier representing a slot name; a boolean,
true if the requested accessor is safe, false if it is unsafe.

@item
The return value is a syntax object evaluating to a slot accessor, or
false if this @objtype{object-type-spec} does not provide an accessor
for the selected slot.
@end itemize

If the slot name is invalid for some reason (for example the slot is
hidden): the proceure must raise an exception.  If this
@objtype{object-type-spec} does not implement the selected slot: the
return value must be @false{} and the slot will be searched in the
parent @objtype{object-type-spec}, if any.

@item mutator-maker
@false{} or a mutator maker procedure accepting 2 arguments and
returning 1 value.

@itemize
@item
The arguments are: an identifier representing a slot name; a boolean,
true if the requested mutator is safe, false if it is unsafe.

@item
The return value is a syntax object evaluating to a slot mutator, or
false if this @objtype{object-type-spec} does not provide a mutator for
the selected slot.
@end itemize

If the slot name is invalid for some reason (for example the slot is
immutable): the proceure must raise an exception.  If this
@objtype{object-type-spec} does not implement the selected slot: the
return value must be false and the slot will be searched in the parent
@objtype{object-type-spec}, if any.

@item dispatcher
False or a dispatcher procedure accepting a single argument and
returning a single value, and acting like a macro transformer.

The argument must be a syntax object representing with the format:

@example
(@meta{var} @metao{arg} @meta{arg} ...)
@end example

@noindent
where @meta{var} is an expression evaluating to a single object whose
type is described by this structure.  The return value must be a syntax
object representing the output form: an expression to be further
expanded.

@item parent-spec
@false{} or an instance of @objtype{object-type-spec} describing the
parent of this type.
@end table
@end deftp


@defun make-object-type-spec @var{type-id} @var{pred-id}
@defunx make-object-type-spec @var{type-id} @var{pred-id} @var{accessor-maker} @var{mutator-maker} @var{dispatcher} @var{parent-id}
Build and return a new instance of @objtype{object-type-spec}.
@end defun


@defun object-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{object-type-spec}, otherwise return @false{}.
@end defun

@c end of file
