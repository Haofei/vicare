@node dynamic environment
@appendix Notes on the dynamic environment


In this section we inspect, by examples, the concepts of ``dynamic
environment'' and ``dynamic extent of a function call''.  @ref{scheme
basic dynamic extent, Dynamic extent and the dynamic environment}, for
the meaning as defined by @rnrs{6}.

@menu
* dynamic environment intro::   Introduction to the concept of dynamic
                                environment.
* dynamic environment parms::   Parameters: the archetype of state in
                                the dynamic environment.
* dynamic environment extent::  The dynamic extent of a function call.
@end menu

@c page
@node dynamic environment intro
@appendixsec Introduction to the concept of dynamic environment


The dynamic environment is a subset of the state of a @command{vicare}
process that is maintained with the in--guard and out--guard thunks of
@func{dynamic-wind}.

Let's consider the following program prelude:

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define var)

(define (step id)
  (add-result (list id var))
  (++ var))

(define-syntax dotimes
  (syntax-rules ()
    ((_ ?count . ?body)
     (do ((i 0 (+ 1 i)))
         ((= i ?count))
       . ?body))
    ))
@end example

@noindent
we can call the function @func{step} to access and mutate the current
value of the variable @code{var}; @syntax{dotimes} is a simple macro
that evaluates a body a number of times.  For example we can do:

@example
(define (doit id init)
  (set! var init)
  (dotimes 5
    (step id)))

(with-result
  (doit 'single 0)
  1)
@result{} (1 ((single 0)
       (single 1)
       (single 2)
       (single 3)
       (single 4)))
@end example

@noindent
this program does not define a dynamic environment.

Now, with the same prelude, let's consider the following code making use
of coroutines:

@example
(define (doit id init)
  (define local-var)
  (coroutine
      (lambda ()
        (dynamic-wind
            (lambda ()
              (set! var local-var))
            (lambda ()
              (set! var init)
              (dotimes 5
                (step id)
                (yield)))
            (lambda ()
              (set! local-var var))))))

(with-result
  (doit 'one  0)
  (doit 'two 10)
  (finish-coroutines)
  1)
@result{} (1 ((one 0) (two 10)
       (one 1) (two 11)
       (one 2) (two 12)
       (one 3) (two 13)
       (one 4) (two 14)))
@end example

@noindent
this program defines a dynamic environment:

@itemize
@item
The in--guard thunk stores in @code{var} the local value
@code{local-var}:

@example
(lambda ()
  (set! var local-var))
@end example

@item
The out--guard thunk saves in @code{local-var} the global value
@code{var}:

@example
(lambda ()
  (set! local-var var))
@end example
@end itemize

@noindent
this way the function @func{step} called by the body thunk of
@func{dynamic-wind} accesses and mutates a variable @code{var} that
holds a value ``private'' to the coroutine.

@c ------------------------------------------------------------------------

@unnumberedsubsec The current exception handler

The standard @func{with-exception-handler} uses the same mechanism to
install in the dynamic environment the current exception handler.  The
following program shows how @func{with-exception-handler} transparently
installs as handler a closure for each coroutine:

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define-syntax dotimes
  (syntax-rules ()
    ((_ ?count . ?body)
     (do ((i 0 (+ 1 i)))
         ((= i ?count))
       . ?body))
    ))

(define (doit name init)
  (define X init)
  (coroutine
      (lambda ()
        (with-exception-handler
            (lambda (E)
              (++ X))
          (lambda ()
            (dotimes 5
              (add-result (list name
                                (raise-continuable (void))))
              (yield)))))))

(with-result
  (doit 'one 0)
  (doit 'two 10)
  (finish-coroutines)
  1)
@result{} (1 ((one 1) (two 11)
       (one 2) (two 12)
       (one 3) (two 13)
       (one 4) (two 14)
       (one 5) (two 15)))
@end example

@c page
@node dynamic environment parms
@appendixsec Parameters: the archetype of state in the dynamic environment


Parameters are the perfect example of using the dynamic environment to
define a state that is ``local'' to the dynamic extent of a function
call; @ref{iklib parameters}, for details.

The following example shows how in a call:

@example
(with-exception-handler @meta{handler} @meta{thunk})
@end example

@noindent
the @meta{handler} is called in the dynamic environment of the call to
@meta{thunk}, so that it can access the dynamic environment that
contributed to cause the exception:

@example
(import (vicare))

(define parm
  (make-parameter #f))

(parametrise ((parm 'outer-parm))
  (with-exception-handler
      (lambda (E)
        (parm))
    (lambda ()
      (parametrise ((parm 'inner-parm))
        (raise-continuable 2)))))
@result{} inner-parm
@end example

The following example shows how @syntax{parametrise} causes the value of
the parameter to be ``local'' to a coroutine:

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define-syntax dotimes
  (syntax-rules ()
    ((_ ?count . ?body)
     (do ((i 0 (+ 1 i)))
         ((= i ?count))
       . ?body))
    ))

(define parm
  (make-parameter #f))

(define (doit name init)
  (parametrise ((parm init))
    (coroutine
        (lambda ()
          (dotimes 5
            (add-result (list name (parm)))
            (parm (++ (parm)))
            (yield))))))

(with-result
   (doit 'one  0)
   (doit 'two 10)
   (finish-coroutines)
   1)
@result{} (1 ((one 0) (two 10)
       (one 1) (two 11)
       (one 2) (two 12)
       (one 3) (two 13)
       (one 4) (two 14)))
@end example

@c page
@node dynamic environment extent
@appendixsec The dynamic extent of a function call


The dynamic environment is maintained by the standard function
@func{dynamic-wind}, which has the arguments:

@example
(dynamic-wind @var{in-guard} @var{thunk} @var{out-guard})
@end example

@noindent
the thunk @var{in-guard} is called every time the execution flow enters
the dynamic extent of the call to @var{thunk}; the thunk @var{out-guard}
is called every time the execution flow exits the dynamic extent of the
call to @var{thunk}.

We always create the dynamic extent of a function call by calling the
function; then, by saving continuations, we can enter and exit the
dynamic extent any number of times.  Let's try to understand what this
means.

@itemize
@item
The simple way to enter and exit the dynamic extent of a call to
@var{thunk} is the call and return:

@example
(import (vicare))

(with-result
  (dynamic-wind
      (lambda ()
        (add-result 'in-guard))
      (lambda ()
        (add-result 'thunk)
        1)
      (lambda ()
        (add-result 'out-guard))))
@result{} (1 (in-guard thunk out-guard))
@end example

@item
A more sophisticated way to exit the dynamic extent is to call an escape
procedure that reinstates a previously saved continuation:

@example
(import (vicare))

(with-result
  (call/cc
      (lambda (escape)
        (dynamic-wind
            (lambda ()
              (add-result 'in-guard))
            (lambda ()
              (add-result 'thunk-in)
              (escape 2)
              (add-result 'thunk-out)
              1)
            (lambda ()
              (add-result 'out-guard))))))
@result{} (2 (in-guard thunk-in out-guard))
@end example

@noindent
in this example @var{thunk} is called but it never performs a normal
function return.

@item
If we want to abort a dynamic extent by raising an exception: from the
installed exception handler we must call an escape procedure that
reinstates a previously saved continuation.

@example
(import (vicare))

(with-result
  (call/cc
      (lambda (escape)
        (with-exception-handler
            (lambda (E)
              (add-result 'handler)
              (escape E))
          (lambda ()
            (dynamic-wind
                (lambda ()
                  (add-result 'in-guard))
                (lambda ()
                  (add-result 'thunk-in)
                  (raise 2)
                  (add-result 'thunk-out)
                  1)
                (lambda ()
                  (add-result 'out-guard))))))))
@result{} (2 (in-guard thunk-in handler out-guard))
@end example

@item
The coroutines infrastructure saves continuations to enter and exit
dynamic extents any number of times, hiding the complexities.

@example
(import (vicare))

(with-result
  (coroutine
      (lambda ()
        (dynamic-wind
            (lambda ()
              (add-result '(1 in-guard)))
            (lambda ()
              (add-result '(1.1 thunk))
              (yield)
              (add-result '(1.2 thunk))
              (yield)
              (add-result '(1.3 thunk)))
            (lambda ()
              (add-result '(1 out-guard))))))

  (coroutine
      (lambda ()
        (dynamic-wind
            (lambda ()
              (add-result '(2 in-guard)))
            (lambda ()
              (add-result '(2.1 thunk))
              (yield)
              (add-result '(2.2 thunk))
              (yield)
              (add-result '(2.3 thunk)))
            (lambda ()
              (add-result '(2 out-guard))))))

  (finish-coroutines)
  1)
@result{} (1 ((1 in-guard) (1.1 thunk) (1 out-guard)
       (2 in-guard) (2.1 thunk) (2 out-guard)
       (1 in-guard) (1.2 thunk) (1 out-guard)
       (2 in-guard) (2.2 thunk) (2 out-guard)
       (1 in-guard) (1.3 thunk) (1 out-guard)
       (2 in-guard) (2.3 thunk) (2 out-guard)))
@end example
@end itemize


About exiting from the dynamic extent of a function call, we must
acknowledge that:

@itemize
@item
The normal return from a function call exits its dynamic extent.

@item
Calling an escape procedure from within a function call to reinstate a
continuation outside the function, exits the dynamic extent of the call.

@example
(define (fun escape)
  (do-something)
  (escape 123)
  (do-something))

(call/cc fun)
@end example

@item
Raising a continuable or non--continuable exception from within a
function call, by itself, does @strong{not} exit the dynamic extent of
the call.

@example
(define (fun)
  (do-something)
  ;;Does not exit the dynamic extent of the call to FUN.
  (raise 123))
@end example

@item
Both the tests and expressions in the clauses of the standard syntax
@syntax{guard} are executed outside the extent of the @syntax{guard}
body.

@item
There is @strong{no} guarantee that: after exiting the dynamic extent of
a function call without a normal return: such extent will be reentered
later and continue to a normal return.
@end itemize



@c Local Variables:
@c mode: texinfo
@c TeX-master: "vicare-scheme"
@c End:
