@node dynamic environment
@appendix Notes on the dynamic environment


In this section we inspect, by examples, the concepts of ``dynamic
environment'' and ``dynamic extent of a function call''.  @ref{scheme
basic dynamic extent, Dynamic extent and the dynamic environment}, for
the meaning as defined by @rnrs{6}.

@menu
* dynamic environment intro::   Introduction to the concept of dynamic
                                environment.
* dynamic environment exit::    Exiting from the dynamic extent of a
                                function call.
@end menu

@c page
@node dynamic environment intro
@appendixsec Introduction to the concept of dynamic environment


The dynamic environment is a subset of the state of a @command{vicare}
process that is maintained with the in--guard and out--guard thunks of
@func{dynamic-wind}.

Let's consider the following program prelude:

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define var)

(define (step id)
  (add-result (list id var))
  (++ var))

(define-syntax dotimes
  (syntax-rules ()
    ((_ ?count . ?body)
     (do ((i 0 (+ 1 i)))
         ((= i ?count))
       . ?body))
    ))
@end example

@noindent
we can call the function @func{step} to access and mutate the current
value of the variable @code{var}; @syntax{dotimes} is a simple macro
that evaluates a body a number of times.  For example we can do:

@example
(define (doit id init)
  (set! var init)
  (dotimes 5
    (step id)))

(with-result
  (doit 'single 0)
  1)
@result{} (1 ((single 0)
       (single 1)
       (single 2)
       (single 3)
       (single 4)))
@end example

@noindent
this program does not define a dynamic environment.

Now, with the same prelude, let's consider the following code making use
of coroutines:

@example
(define (doit id init)
  (define local-var)
  (coroutine
      (lambda ()
        (dynamic-wind
            (lambda ()
              (set! var local-var))
            (lambda ()
              (set! var init)
              (dotimes 5
                (step id)
                (yield)))
            (lambda ()
              (set! local-var var))))))

(with-result
  (doit 'one  0)
  (doit 'two 10)
  (finish-coroutines)
  1)
@result{} (1 ((one 0) (two 10)
       (one 1) (two 11)
       (one 2) (two 12)
       (one 3) (two 13)
       (one 4) (two 14)))
@end example

@noindent
this program defines a dynamic environment:

@itemize
@item
The in--guard thunk stores in @code{var} the local value
@code{local-var}:

@example
(lambda ()
  (set! var local-var))
@end example

@item
The out--guard thunk saves in @code{local-var} the global value
@code{var}:

@example
(lambda ()
  (set! local-var var))
@end example
@end itemize

@noindent
this way the function @func{step} called by the body thunk of
@func{dynamic-wind} accesses and mutates a variable @code{var} that
holds a value ``private'' to the coroutine.

@c ------------------------------------------------------------------------

@unnumberedsubsec The current exception handler

The standard @func{with-exception-handler} uses the same mechanism to
install in the dynamic environment the current exception handler.  The
following program shows how @func{with-exception-handler} transparently
installs as handler a closure for each coroutine:

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define-syntax dotimes
  (syntax-rules ()
    ((_ ?count . ?body)
     (do ((i 0 (+ 1 i)))
         ((= i ?count))
       . ?body))
    ))

(define (doit name init)
  (define X init)
  (coroutine
      (lambda ()
        (with-exception-handler
            (lambda (E)
              (++ X))
          (lambda ()
            (dotimes 5
              (add-result (list name
                                (raise-continuable (void))))
              (yield)))))))

(with-result
  (doit 'one 0)
  (doit 'two 10)
  (finish-coroutines)
  1)
@result{} (1 ((one 1) (two 11)
       (one 2) (two 12)
       (one 3) (two 13)
       (one 4) (two 14)
       (one 5) (two 15)))
@end example

@c page
@node dynamic environment exit
@appendixsec Exiting from the dynamic extent of a function call


About exiting from the dynamic extent of a function call, we must
acknowledge that:

@itemize
@item
The normal return from a function call exits its dynamic extent.

@item
Calling an escape procedure from within a function call to reinstate a
continuation outside the function, exits the dynamic extent of the call.

@example
(define (fun escape)
  (do-something)
  (escape 123)
  (do-something))

(call/cc fun)
@end example

@item
Raising a continuable or non--continuable exception from within a
function call, by itself, does @strong{not} exit the dynamic extent of
the call.

@example
(define (fun)
  (do-something)
  ;;Does not exit the dynamic extent of the call to FUN.
  (raise 123))
@end example

@item
Both the tests and expressions in the clauses of the standard syntax
@syntax{guard} are executed outside the extent of the @syntax{guard}
body.

@item
There is @strong{no} guarantee that: after exiting the dynamic extent of
a function call without a normal return: such extent will be reentered
later and continue to a normal return.
@end itemize



@c Local Variables:
@c mode: texinfo
@c TeX-master: "vicare-scheme"
@c End:
