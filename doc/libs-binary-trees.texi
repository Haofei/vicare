@node bst
@chapter Binary tree skeletons


@cindex Library @library{vicare containers binary-trees}
@cindex @library{vicare containers binary-trees}, library


The library @library{vicare containers binary-trees} implements the
skeleton functions needed by binary search trees.

@menu
* bst bnodes::                  Binary node objects.
* bst unodes::                  Unbalanced binary node objects.
@end menu

@c page
@node bst bnodes
@section Binary node objects


Binary search trees are composed of ``binary node objects'' linked
together in a tree hierarchy.  The object type @objtype{<binary-node>}
is the base type of all the node types.

@menu
* bst bnodes objects::          Binary node data type.
* bst bnodes access::           Accessors and mutators for binary nodes.
* bst bnodes pred::             Structure predicates for binary nodes.
* bst bnodes searching::        Searching in binary trees.
* bst bnodes iterating::        Iterating over binary trees.
* bst bnodes validating::       Validating binary trees.
@end menu

@c page
@node bst bnodes objects
@subsection Binary node data type


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.


@deftp {@rnrs{6} Record Type} <binary-node>
@cindex @var{bnode} argument
@cindex Argument @var{bnode}
Record type representing a node in a binary tree.  The
@objtype{<binary-node>} type is non--generative and available for
subtyping.  In this documentation @objtype{<binary-node>} object
arguments to functions are indicated as @var{bnode}.

@objtype{<binary-node>}  has the following fields:

@table @code
@item sort-key
An object used as sort key.

@item parent
False or an instance of @objtype{<binary-node>} representing the parent
node.

@item left
False or an instance of @objtype{<binary-node>} representing the left
subtree.

@item right
False or an instance of @objtype{<binary-node>} representing the right
subtree.
@end table
@end deftp


@defun make-binary-node
@defunx make-binary-node @var{key}
@defunx make-binary-node @var{key} @var{left} @var{right}
Build and return a new instance of @objtype{<binary-node>} referencing
@var{key} as sort key.  When @var{key} is not given: the sort key is set
to @code{(void)}.

The optional @var{left} and @var{right} arguments must be @false{} or
instances of @objtype{<binary-node>} representing the left and right
subtrees.

The @code{parent} field of the new instance is set to @false{}.
@end defun


@defun binary-node? @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{<binary-node>};
otherwise return @false{}.
@end defun

@c page
@node bst bnodes access
@subsection Accessors and mutators for binary nodes


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-node-parent @var{bnode}
@defunx $binary-node-parent @var{bnode}
Accessor for the parent node of @var{bnode}.  Return @false{} or an
instance of @objtype{<binary-node>}.
@end defun

@c ------------------------------------------------------------------------

@defun binary-node-left @var{bnode}
@defunx $binary-node-left @var{bnode}
Accessor for the left subtree of @var{bnode}.  Return @false{} or an
instance of @objtype{<binary-node>}.
@end defun


@defun binary-node-left-set! @var{bnode} @var{left}
@defunx $binary-node-left-set! @var{bnode} @var{left}
Mutator for the left subtree of a @objtype{<binary-node>} instance.  The
argument @var{left} must be @false{} or instances of
@objtype{<binary-node>} representing the left subtree.  When @var{left}
is a node: it is mutated to reference @var{bnode} as parent.
@end defun

@c ------------------------------------------------------------------------

@defun binary-node-right @var{bnode}
@defunx $binary-node-right @var{bnode}
Accessor for the right subtree of @var{bnode}.  Return @false{} or an
instance of @objtype{<binary-node>}.
@end defun


@defun binary-node-right-set! @var{bnode} @var{right}
@defunx $binary-node-right-set! @var{bnode} @var{right}
Mutator for the right subtree of a @objtype{<binary-node>} instance.
The argument @var{right} must be @false{} or instances of
@objtype{<binary-node>} representing the right subtree.  When
@var{right} is a node: it is mutated to reference @var{bnode} as parent.
@end defun

@c ------------------------------------------------------------------------

@defun binary-node-sort-key @var{bnode}
@defunx $binary-node-sort-key @var{bnode}
Accessor for the payload object of @var{bnode}.
@end defun


@defun binary-node-sort-key-set! @var{bnode} @var{obj}
@defunx $binary-node-sort-key-set! @var{bnode} @var{obj}
Mutator for the payload object of a @objtype{<binary-node>} instance.
@end defun

@c ------------------------------------------------------------------------

@defun binary-node-replace-in-parent! @var{old-child} @var{new-child}
@defunx $binary-node-replace-in-parent! @var{old-child} @var{new-child}
In the parent of @var{old-child}: replace @var{old-child} with
@var{new-child}.  @var{old-child} must be an instance of
@objtype{<binary-node>}.  @var{new-child} must be @false{} or an
instance of @objtype{<binary-node>}.
@end defun

@c page
@node bst bnodes pred
@subsection Structure predicates for binary nodes


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-node-parent-and-left-child? @vari{bnode} @varii{bnode}
@defunx $binary-node-parent-and-left-child? @vari{bnode} @varii{bnode}
Return @true{} if @varii{bnode} is the left child of @vari{bnode};
otherwise return @false{}.
@end defun


@defun binary-node-parent-and-right-child? @vari{bnode} @varii{bnode}
@defunx $binary-node-parent-and-right-child? @vari{bnode} @varii{bnode}
Return @true{} if @varii{bnode} is the right child of @vari{bnode};
otherwise return @false{}.
@end defun


@defun binary-node-parent-and-child? @vari{bnode} @varii{bnode}
@defunx $binary-node-parent-and-child? @vari{bnode} @varii{bnode}
Return @true{} if @varii{bnode} is the left or right child of
@vari{bnode}; otherwise return @false{}.
@end defun

@c page
@node bst bnodes searching
@subsection Searching in binary trees


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-tree-minimum @var{root}
@defunx binary-tree-minimum @var{root} @var{empty-tree-handler}
@defunx $binary-tree-minimum @var{root} @var{empty-tree-handler}
Search and return the minimum node in the tree starting from @var{root};
the minimum node is the leftmost from @var{root}.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The optional argument @var{empty-tree-handler} must be a thunk.  If
@var{root} is @false{} and @var{empty-tree-handler} is not used: the
return value is @false{}.  If @var{root} is @false{} and
@var{empty-tree-handler} is used: the return value is the return value
of @var{empty-tree-handler}.
@end defun


@defun binary-tree-maximum @var{root}
@defunx binary-tree-maximum @var{root} @var{empty-tree-handler}
@defunx $binary-tree-maximum @var{root} @var{empty-tree-handler}
Search and return the maximum node in the tree starting from @var{root};
the maximum node is the rightmost from @var{root}.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The optional argument @var{empty-tree-handler} must be a thunk.  If
@var{root} is @false{} and @var{empty-tree-handler} is not used: the
return value is @false{}.  If @var{root} is @false{} and
@var{empty-tree-handler} is used: the return value is the return value
of @var{empty-tree-handler}.
@end defun


@defun binary-tree-find @var{root} @var{compare}
@defunx binary-tree-find @var{root} @var{compare} @var{empty-tree-handler}
@defunx $binary-tree-find @var{root} @var{compare} @var{empty-tree-handler}
Search and return a node in the tree starting from @var{root} based on
its sort key.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The argument @var{compare} must be a procedure accepting an instance of
@objtype{<binary-node>} as single argument; it must return a single
value:

@table @code
@item 0
If the argument node satisfies the search criterion.

@item -1
If the argument node has sort key less than the sort key of the target
node.

@item +1
If the argument node has sort key greater than, or equal to, the sort
key of the target node.
@end table

The optional argument @var{empty-tree-handler} must be a thunk.  If the
target node is not found and @var{empty-tree-handler} is not used: the
return value is @false{}.  If the target node it not found and
@var{empty-tree-handler} is used: the return value is the return value
of @var{empty-tree-handler}.

@lisp
(import (vicare)
  (vicare containers binary-trees))

(define (tree . key*)
  (fold-left (lambda (root key)
               (unbalanced-tree-insert! root key<
                 (make-unbalanced-binary-node key)))
    #f key*))

(define (key< one two)
  (< (binary-node-sort-key one)
     (binary-node-sort-key two)))

(define (make-comparison-proc target-key)
  (lambda (node)
    (let ((key (binary-node-sort-key node)))
      (cond ((= target-key key)        0)
            ((< target-key key)       -1)
            (else                     +1)))))

(binary-node-sort-key
  (binary-tree-find (tree 5 3 8 1 4 6 9 0 2 7 10)
                    (make-comparison-proc 4)
                    (lambda () 'not-found)))
@result{} 4
@end lisp
@end defun

@c page
@node bst bnodes iterating
@subsection Iterating over binary trees


@menu
* bst bnodes iterating in-order::       In-order iterations.
* bst bnodes iterating pre-order::      Pre-order iterations.
* bst bnodes iterating post-order::     Post-order iterations.
* bst bnodes iterating level-order::    Level-order iterations.
@end menu

@c page
@node bst bnodes iterating in-order
@subsubsection In--order iterations


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-node-begin-in-order-forwards @var{root}
@defunx $binary-node-begin-in-order-forwards @var{root}
Void.
@end defun


@defun binary-node-step-in-order-forwards @var{root}
@defunx $binary-node-step-in-order-forwards @var{root}
Void.
@end defun

@c page
@node bst bnodes iterating pre-order
@subsubsection Pre--order iterations


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-node-begin-pre-order-forwards @var{root}
@defunx $binary-node-begin-pre-order-forwards @var{root}
Void.
@end defun


@defun binary-node-step-pre-order-forwards @var{root}
@defunx $binary-node-step-pre-order-forwards @var{root}
Void.
@end defun

@c page
@node bst bnodes iterating post-order
@subsubsection Post--order iterations


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-node-begin-post-order-forwards @var{root}
@defunx $binary-node-begin-post-order-forwards @var{root}
Void.
@end defun


@defun binary-node-step-post-order-forwards @var{root}
@defunx $binary-node-step-post-order-forwards @var{root}
Void.
@end defun

@c page
@node bst bnodes iterating level-order
@subsubsection Level--order iterations


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-node-begin-level-order-forwards @var{root}
@defunx $binary-node-begin-level-order-forwards @var{root}
Void.
@end defun


@defun binary-node-step-level-order-forwards @var{root}
@defunx $binary-node-step-level-order-forwards @var{root}
Void.
@end defun

@c page
@node bst bnodes validating
@subsection Validating binary trees


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-tree-valid? @var{root} @var{key<}
@defunx $binary-tree-valid? @var{root} @var{key<}
Traverse a binary search tree from @var{root} verifying that: all the
left subtrees have sort key less than their parents; all the right
subtrees have sort key greater than, or equal to, than their parents.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>} representing the root of the
tree.

The argument @var{key<} must be a procedure taking @math{2} arguments
being instances of @objtype{<binary-nod>}: it must return true if the
first argument has sort key less than the sort key of the second
argument; otherwise it must return @false{}.
@end defun

@c page
@node bst unodes
@section Unbalanced binary node objects


Unbalanced binary search trees are sorted in such a way that:

@itemize
@item
The left child node has key less than the one of the root node.

@item
The right child node has key greater than, or equal to, the one of the
root node.
@end itemize

@noindent
no effort is made to balance the this search tree.

@menu
* bst unodes objects::          Unbalanced binary node data type.
* bst unodes ops::              Operations on unbalanced trees.
@end menu

@c page
@node bst unodes objects
@subsection Unbalanced binary node data type


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.


@deftp {@rnrs{6} Record Type} <unbalanced-binary-node>
@cindex @var{unode} argument
@cindex Argument @var{unode}
Record type representing a node in a binary tree.  The
@objtype{<unbalanced-binary-node>} type is non--generative and available
for subtyping.  It is derived from @objtype{<binary-node>}.  In this
documentation @objtype{<unbalanced-binary-node>} object arguments to
functions are indicated as @var{unode}.
@end deftp


@defun make-unbalanced-binary-node
@defunx make-unbalanced-binary-node @var{key}
@defunx make-unbalanced-binary-node @var{key} @var{left} @var{right}
Build and return a new instance of @objtype{<unbalanced-binary-node>}
referencing @var{key} as sort key.  When @var{key} is not given: the
sort key is set to @code{(void)}.

The optional arguments @var{left} and @var{right} arguments must be
@false{} or instances of @objtype{<unbalanced-binary-node>} representing
the and right subtrees.

The @code{parent} field of the new instance is set to @false{}.
@end defun


@defun unbalanced-binary-node? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{<unbalanced-binary-node>}; otherwise return @false{}.
@end defun

@c page
@node bst unodes ops
@subsection Operations on unbalanced binary nodes


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun unbalanced-tree-insert! @var{root} @var{key<} @var{unode}
@defunx $unbalanced-tree-insert! @var{root} @var{key<} @var{unode}
Insert a new node into an unbalanced binary tree.

The argument @var{root} must be @false{} or an instance of
@objtype{<unbalanced-binary-node>} representing the root of the tree.

The argument @var{key<} must be a procedure accepting two arguments of
type @objtype{<binary-node>} and returning: true if the first argument
as sort key less than the second argument; @false{} otherwise.  Example:

@lisp
(define (key< one two)
  (< (binary-node-sort-key one)
     (binary-node-sort-key two)))
@end lisp

The argument @var{unode} must be an instance of
@objtype{<unbalanced-binary-node>} representing the new node to insert.
This node is meant to have left and right fields set to @false{}.
@end defun


@defun unbalanced-tree-remove! @var{unode}
@defunx $unbalanced-tree-remove! @var{unode}
Remove a node from an unbalanced binary tree.  @var{unode} must be the
instance of @objtype{<unbalanced-binary-node>} to remove.  The return
value is the node that took the place of @var{unode} in the tree.
@end defun


@c Local Variables:
@c mode: texinfo
@c TeX-master: "vicare-libs"
@c End:
