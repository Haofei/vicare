@node bst
@chapter Binary tree skeletons


@cindex Library @library{vicare containers binary-trees}
@cindex @library{vicare containers binary-trees}, library


The library @library{vicare containers binary-trees} implements the
skeleton functions needed by binary search trees.

@menu
* bst binary bnodes::           Binary node objects.
* bst binary unodes::           Unbalanced binary node objects.
@end menu

@c page
@node bst binary bnodes
@section Binary node objects


Binary search trees are composed of ``binary node objects'' linked
together in a tree hierarchy.  The object type @objtype{<binary-node>}
is the base type of all the node types.

@menu
* bst binary bnodes objects::   Binary node data type.
* bst binary bnodes access::    Accessors and mutators for binary nodes.
* bst binary bnodes searching:: Searching in binary trees.
@end menu

@c page
@node bst binary bnodes objects
@subsection Binary node data type


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.


@deftp {@rnrs{6} Record Type} <binary-node>
@cindex @var{bnode} argument
@cindex Argument @var{bnode}
Record type representing a node in a binary tree.  The
@objtype{<binary-node>} type is non--generative and available for
subtyping.  In this documentation @objtype{<binary-node>} object
arguments to functions are indicated as @var{bnode}.

@objtype{<binary-node>}  has the following fields:

@table @code
@item sort-key
An object used as sort key.

@item left
False or an instance of @objtype{<binary-node>} representing the left
subtree.

@item right
False or an instance of @objtype{<binary-node>} representing the right
subtree.
@end table
@end deftp


@defun make-binary-node
@defunx make-binary-node @var{key}
@defunx make-binary-node @var{key} @var{left} @var{right}
Build and return a new instance of @objtype{<binary-node>} referencing
@var{key} as sort key.  When @var{key} is not given: the sort key is set
to @code{(void)}.

The optional @var{left} and @var{right} arguments must be @false{} or
instances of @objtype{<binary-node>} representing the left and right
subtrees.
@end defun


@defun binary-node? @var{obj}
Return @true{} if @var{obj} is an instance of @objtype{<binary-node>};
otherwise return @false{}.
@end defun

@c page
@node bst binary bnodes access
@subsection Accessors and mutators for binary nodes


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-node-left @var{bnode}
@defunx $binary-node-left @var{bnode}
Accessor for the left subtree of @var{bnode}.  Return @false{} or an
instance of @objtype{<binary-node>}.
@end defun


@defun binary-node-left-set! @var{bnode} @var{left}
@defunx $binary-node-left-set! @var{bnode} @var{left}
Mutator for the left subtree of a @objtype{<binary-node>} instance.  The
argument @var{left} must be @false{} or instances of
@objtype{<binary-node>} representing the left subtree.
@end defun

@c ------------------------------------------------------------------------

@defun binary-node-right @var{bnode}
@defunx $binary-node-right @var{bnode}
Accessor for the right subtree of @var{bnode}.  Return @false{} or an
instance of @objtype{<binary-node>}.
@end defun


@defun binary-node-right-set! @var{bnode} @var{right}
@defunx $binary-node-right-set! @var{bnode} @var{right}
Mutator for the right subtree of a @objtype{<binary-node>} instance.
The argument @var{right} must be @false{} or instances of
@objtype{<binary-node>} representing the right subtree.
@end defun

@c ------------------------------------------------------------------------

@defun binary-node-sort-key @var{bnode}
@defunx $binary-node-sort-key @var{bnode}
Accessor for the payload object of @var{bnode}.
@end defun


@defun binary-node-sort-key-set! @var{bnode} @var{obj}
@defunx $binary-node-sort-key-set! @var{bnode} @var{obj}
Mutator for the payload object of a @objtype{<binary-node>} instance.
@end defun

@c page
@node bst binary bnodes searching
@subsection Searching in binary trees


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun binary-tree-minimum @var{root}
@defunx binary-tree-minimum @var{root} @var{empty-tree-handler}
@defunx $binary-tree-minimum @var{root} @var{empty-tree-handler}
Search and return the minimum node in the tree starting from @var{root};
the minimum node is the leftmost from @var{root}.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The optional argument @var{empty-tree-handler} must be a thunk.  If
@var{root} is @false{} and @var{empty-tree-handler} is not used: the
return value is @false{}.  If @var{root} is @false{} and
@var{empty-tree-handler} is used: the return value is the return value
of @var{empty-tree-handler}.
@end defun


@defun binary-tree-maximum @var{root}
@defunx binary-tree-maximum @var{root} @var{empty-tree-handler}
@defunx $binary-tree-maximum @var{root} @var{empty-tree-handler}
Search and return the maximum node in the tree starting from @var{root};
the maximum node is the rightmost from @var{root}.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The optional argument @var{empty-tree-handler} must be a thunk.  If
@var{root} is @false{} and @var{empty-tree-handler} is not used: the
return value is @false{}.  If @var{root} is @false{} and
@var{empty-tree-handler} is used: the return value is the return value
of @var{empty-tree-handler}.
@end defun


@defun binary-tree-find @var{root} @var{compare}
@defunx binary-tree-find @var{root} @var{compare} @var{empty-tree-handler}
@defunx $binary-tree-find @var{root} @var{compare} @var{empty-tree-handler}
Search and return a node in the tree starting from @var{root} based on
its sort key.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The argument @var{compare} must be a procedure accepting an instance of
@objtype{<binary-node>} as single argument; it must return a single
value:

@table @code
@item 0
If the argument node satisfies the search criterion.

@item -1
If the argument node has sort key less than the sort key of the target
node.

@item +1
If the argument node has sort key greater than, or equal to, the sort
key of the target node.
@end table

The optional argument @var{empty-tree-handler} must be a thunk.  If the
target node is not found and @var{empty-tree-handler} is not used: the
return value is @false{}.  If the target node it not found and
@var{empty-tree-handler} is used: the return value is the return value
of @var{empty-tree-handler}.

@lisp
(import (vicare)
  (vicare containers binary-trees))

(define (tree . key*)
  (fold-left (lambda (root key)
               (unbalanced-tree-insert! root key<
                 (make-unbalanced-binary-node key)))
    #f key*))

(define (key< one two)
  (< (binary-node-sort-key one)
     (binary-node-sort-key two)))

(define (make-comparison-proc target-key)
  (lambda (node)
    (let ((key (binary-node-sort-key node)))
      (cond ((= target-key key)        0)
            ((< target-key key)       -1)
            (else                     +1)))))

(binary-node-sort-key
  (binary-tree-find (tree 5 3 8 1 4 6 9 0 2 7 10)
                    (make-comparison-proc 4)
                    (lambda () 'not-found)))
@result{} 4
@end lisp
@end defun

@c ------------------------------------------------------------------------

@subsubheading Searching a node and its parent


@defun binary-tree-minimum-and-parent @var{root}
@defunx binary-tree-minimum-and-parent @var{root} @var{parent}
@defunx binary-tree-minimum-and-parent @var{root} @var{parent} @var{empty-tree-handler}
@defunx $binary-tree-minimum-and-parent @var{root} @var{parent} @var{empty-tree-handler}
Search and minimum node in the tree starting from @var{root}; the
minimum node is the leftmost from @var{root}.  Return two values: the
target node and its parent node.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The argument @var{parent} must be @false{} or an instance of
@objtype{<binary-node>} being parent of @var{root}; this means that
@var{root} is in the left or right field of @var{parent}.  When not
used: @var{parent} defaults to @false{}.

The optional argument @var{empty-tree-handler} must be a thunk.  If
@var{root} is @false{} and @var{empty-tree-handler} is not used: the
return values are both @false{}.  If @var{root} is @false{} and
@var{empty-tree-handler} is used: the return values are the return
values of @var{empty-tree-handler}.
@end defun


@defun binary-tree-maximum-and-parent @var{root}
@defunx binary-tree-maximum-and-parent @var{root} @var{parent}
@defunx binary-tree-maximum-and-parent @var{root} @var{parent} @var{empty-tree-handler}
@defunx $binary-tree-maximum-and-parent @var{root} @var{parent} @var{empty-tree-handler}
Search the maximum node in the tree starting from @var{root}; the
maximum node is the rightmost from @var{root}.  Return two values: the
target node and its parent node.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The argument @var{parent} must be @false{} or an instance of
@objtype{<binary-node>} being parent of @var{root}; this means that
@var{root} is in the left or right field of @var{parent}.  When not
used: @var{parent} defaults to @false{}.

The optional argument @var{empty-tree-handler} must be a thunk.  If
@var{root} is @false{} and @var{empty-tree-handler} is not used: the
return values are both @false{}.  If @var{root} is @false{} and
@var{empty-tree-handler} is used: the return values are the return
values of @var{empty-tree-handler}.
@end defun


@defun binary-tree-find-and-parent @var{root} @var{compare}
@defunx binary-tree-find-and-parent @var{root} @var{compare} @var{parent}
@defunx binary-tree-find-and-parent @var{root} @var{compare} @var{parent} @var{empty-tree-handler}
@defunx $binary-tree-find-and-parent @var{root} @var{compare} @var{parent} @var{empty-tree-handler}
Search a node in the tree starting from @var{root} based on its sort
key.  Return two values: the target node and its parent node.

The argument @var{root} must be @false{}, to represent an empty tree, or
an instance of @objtype{<binary-node>}.

The argument @var{parent} must be @false{} or an instance of
@objtype{<binary-node>} being parent of @var{root}; this means that
@var{root} is in the left or right field of @var{parent}.  When not
used: @var{parent} defaults to @false{}.

The argument @var{compare} must be a procedure accepting an instance of
@objtype{<binary-node>} as single argument; it must return a single
value:

@table @code
@item 0
If the argument node satisfies the search criterion.

@item -1
If the argument node has sort key less than the sort key of the target
node.

@item +1
If the argument node has sort key greater than, or equal to, the sort
key of the target node.
@end table

The optional argument @var{empty-tree-handler} must be a thunk.  If the
target node is not found and @var{empty-tree-handler} is not used: the
return values are both @false{}.  If the target node is not found and
@var{empty-tree-handler} is used: the return values are the return
values of @var{empty-tree-handler}.
@end defun

@c page
@node bst binary unodes
@section Unbalanced binary node objects


Unbalanced binary search trees are sorted in such a way that:

@itemize
@item
The left child node has key less than the one of the root node.

@item
The right child node has key greater than, or equal to, the one of the
root node.
@end itemize

@noindent
no effort is made to balance the this search tree.

@menu
* bst binary unodes objects::   Unbalanced binary node data type.
* bst binary unodes ops::       Operations on unbalanced trees.
@end menu

@c page
@node bst binary unodes objects
@subsection Unbalanced binary node data type


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.


@deftp {@rnrs{6} Record Type} <unbalanced-binary-node>
@cindex @var{unode} argument
@cindex Argument @var{unode}
Record type representing a node in a binary tree.  The
@objtype{<unbalanced-binary-node>} type is non--generative and available
for subtyping.  It is derived from @objtype{<binary-node>}.  In this
documentation @objtype{<unbalanced-binary-node>} object arguments to
functions are indicated as @var{unode}.
@end deftp


@defun make-unbalanced-binary-node
@defunx make-unbalanced-binary-node @var{key}
@defunx make-unbalanced-binary-node @var{key} @var{left} @var{right}
Build and return a new instance of @objtype{<unbalanced-binary-node>}
referencing @var{key} as sort key.  When @var{key} is not given: the
sort key is set to @code{(void)}.

The optional @var{left} and @var{right} arguments must be @false{} or
instances of @objtype{<unbalanced-binary-node>} representing the left
and right subtrees.
@end defun


@defun unbalanced-binary-node? @var{obj}
Return @true{} if @var{obj} is an instance of
@objtype{<unbalanced-binary-node>}; otherwise return @false{}.
@end defun

@c page
@node bst binary unodes ops
@subsection Operations on unbalanced binary nodes


The following syntactic bindings are exported by the library
@library{vicare containers binary-trees}.  The bindings whose name is
prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun unbalanced-tree-insert! @var{root} @var{key<} @var{unode}
@defunx $unbalanced-tree-insert! @var{root} @var{key<} @var{unode}
Insert a new node into an unbalanced binary tree.

The argument @var{root} must be @false{} or an instance of
@objtype{<unbalanced-binary-node>} representing the root of the tree.

The argument @var{key<} must be a procedure accepting two arguments of
type @objtype{<binary-node>} and returning: true if the first argument
as sort key less than the second argument; @false{} otherwise.  Example:

@lisp
(define (key< one two)
  (< (binary-node-sort-key one)
     (binary-node-sort-key two)))
@end lisp

The argument @var{unode} must be an instance of
@objtype{<unbalanced-binary-node>} representing the new node to insert.
This node is meant to have left and right fields set to @false{}.
@end defun



@c Local Variables:
@c mode: texinfo
@c TeX-master: "vicare-libs"
@c End:
