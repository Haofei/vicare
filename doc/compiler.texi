@node compiler
@chapter Wild notes on the compiler internals


This chapter is a collection of notes on the internals of the compiler.

@menu
* compiler topics::             Internals documentation by topics.
* compiler code::               Introduction to compiler's code.
@end menu

@c page
@node compiler topics
@section Internals documentation by topics


@menu
* compiler topics top bindings::        Handling of library top level
                                        bindings.
@end menu

@c page
@node compiler topics top bindings
@subsection Handling of library top level bindings


Bindings defined by the core language form @func{library-letrec*} are
named @dfn{top level bindings}.  Three operations are possible on top
level bindings:

@table @strong
@item initialisation
It is performed with the core language form:

@example
($init-symbol-value! ?loc ?init-rhs)
@end example

@item reference
It is performed with the core language form:

@example
($symbol-value ?loc)
@end example

@item assignment
It is performed with the core language form:

@example
($set-symbol-value! ?loc ?new-rhs)
@end example
@end table

So we can think of a library:

@example
(library (the-lib)
  (export a)
  (import (rnrs))
  (define a 1)
  (display a))
@end example

@c page
@node compiler code
@section Introduction to compiler's code


@menu
* compiler code conventions::   Compiler coding conventions.
@end menu

@c page
@node compiler code conventions
@subsection Compiler coding conventions


Throughout the compiler code variables with the following names appear:

@table @var
@item op
Scheme symbol representing an @strong{operation} to be directly
translated into assembly.  Examples: @samp{alloc}, @samp{mref},
@samp{mref32}, @samp{bref}, @samp{logand}, @samp{logxor}, @samp{logor},
@samp{int+}, @samp{int-}, @samp{int*}, @samp{int-quotient},
@samp{int-remainder}, @samp{sll}, @samp{sra}.

@item rator
Represents a reference to an @strong{operator}: a function coded in
assembly or C language.

@item rands
Scheme list holding the @strong{operands} to which an operation must be
applied.  These operands are in such a format that can be directly used
in the assembly S--expression like:

@example
(make-set eax (car rands))
@end example

@noindent
which generate an assignment operation to store the first element of
@var{rands} into the @code{eax} processor register.
@end table

@c end of file
