@node compiler
@chapter Wild notes on the compiler internals


This chapter is a collection of notes on the internals of the compiler.

@menu
* compiler machinery::          Introduction to execution machinery.
* compiler code::               Introduction to compiler's code.
* compiler stack::              Scheme stack management.
@end menu

@macro fpr{}
@acronym{FPR}
@end macro

@c page
@node compiler machinery
@section Introduction to execution machinery


The execution machinery of compiled Scheme code is a bit intricated when
compared with the execution of, say, ``normal'' compiled C code; this is
because the following features must be implemented:

@table @strong
@item Closures
Scheme functions are not just blocks of machine code: they are allowed
to reference variable values captured at run time.  Multiple closures
(referencing different instances of the same semantic variables) can
share the same block of machine code.  Multiple closures (referencing
different blocks of machine code) can share the same variable values.
@ref{objects closures, Closure objects}.

@item Tail calls
Whenever a Scheme function call happens in tail position: it must be
implemented in such a way that @strong{no} new stack frame is created
for the callee function; rather the stack frame of the caller is
destroyed and reused as callee's frame.  This allows the use of tail
calls as proper idiom to implement all the execution loops, even when
such loops have an ``infinite'' number of iterations, without the risk
of overflowing the Scheme stack.

@item Continuations
Scheme code is allowed to save the current continuation and resume it
later any number of times.
@end table

@menu
* compiler machinery simplifications::  Simplification assumptions.
* compiler machinery call frames::      Basics of function call frames.
* compiler machinery continuations::    The current continuation.
* compiler machinery stack overflow::   Scheme stack overflow.
* compiler machinery call arguments::   Function call arguments.
* compiler machinery call retvals::     Function call return values.
* compiler machinery tail calls::       Tail calls optimisation.
* compiler machinery locals::           Local variables.
@end menu

@c page
@node compiler machinery simplifications
@subsection Simplification assumptions


To make it easy to explain the run time behaviour of @value{PRJNAME}, we
will assume the validity of the following simplifications:

@enumerate
@item
At the start of a user program execution: the Scheme stack is empty.
This is false because, at @value{PRJNAME} launch time, the boot image is
loaded and initialised, executing a lot of compiled Scheme code.  But
starting with an empty stack makes reasoning simpler.

@item
No expressions and function calls are inlined.  This is false because
the compiler precomputes some expressions, inlines some function calls
and removes bindings whenever possible; this makes the executed code
different from the original Scheme code.  But we want to show sample
Scheme code as close as possible to the one that gets executed.

@item
Unless otherwise specified: no tail call optimisation (@acronym{TCO}) is
performed.  This is false because, whenever it recognises a function
call in tail position, @value{PRJNAME} always performs the call in such
a way that the new stack frame overwrites the old one.  But we want to
show simple functions that create new stack frames.

@item
The function @func{call/cc} is implemented without nested function
calls.  This is depends upon the function call integration optimisations
performed by the compiler.  But reasoning about simple function call is
simpler.

@item
There is no dynamic environment to be captured by continuations.  This
is false because whenever @func{dynamic-wind} is used stacks of
in--guard and out--guard functions are created and captured by
continuations; the continuation escape function, created by
@func{call/cc}, does invoke such guard functions to keep the dynamic
environment synchronised with the execution flow.  But learning about
continuations alone already introduces enough complications.
@end enumerate

@c page
@node compiler machinery call frames
@subsection Basics of function call frames


In the following discussion we assume the validity of machinery
simplifications to focus on some aspect of the runtime behaviour,
@ref{compiler machinery simplifications, Simplification assumptions}.


@c page
@node compiler machinery continuations
@subsection The current continuation


In the following discussion we assume the validity of machinery
simplifications to focus on some aspect of the runtime behaviour,
@ref{compiler machinery simplifications, Simplification assumptions}.

Let's think of a process in execution as having: a table of descriptors,
a code memory segment, a heap memory segment and a stack memory segment,
@ref{fig:process_segments, compiler machinery continuations}.  The
Instruction Pointer @cpu{} register (@acronym{IP}) keeps track of the
next instruction to execute in the code segment; the Stack Pointer
@cpu{} register (@acronym{SP}) keeps track of the current location on
the stack; dynamically allocated data goes in the heap segment.

@float Figure,fig:process_segments
@example
|---|---|---| descriptors table
  |   |   |
  |   |   |      IP
  |   |   v      v
  |   |   |------+---------------| code segment
  |   v
  |   |----------------------| heap segment
  v
  |----------+-----------| stack segment
             ^
             SP
@end example
@caption{Memory segments of a process in execution.}
@end float

One way to implement continuations is to push the current @acronym{IP}
on the stack segment, duplicate the stack segment itself, finally save
somewhere the @acronym{SP}; later we can reinstall the saved stack
segment, reset the @acronym{SP} and perform a @code{ret} assembly
instruction that will pop the saved @acronym{IP} and resume the
execution; @ref{fig:duplicated_stack_segment, compiler machinery
continuations}.  Of course we must make sure that the resources
referenced by the saved stack segment are not released while the
continuation still exists.

@float Figure,fig:duplicated_stack_segment
@example
|---|---|---| descriptors table
  |   |   |
  |   |   |     IP IP1
  |   |   v      v v
  |   |   |------+-+--------------| code segment
  |   v
  |   |----------------------| heap segment
  |
  v           IP1
  |----------+--+---------| stack segment
             ^
             SP

              IP1
  |----------+--+---------| duplicated stack segment
             ^
             SP
@end example
@caption{Duplicated stack segment as continuation implementation
mechanism.}
@end float

Stack segment duplication is @strong{not} the way @value{PRJNAME}
implements continuations; but the actual implementation is not
conceptually different.  Let's look at this simple program that does not
create explicit continuations:

@example
(import (rnrs))
(define (alpha) (beta))
(define (beta)  (delta))
(define (delta) 123)
(alpha)
@end example

@noindent
let's assume that no function integration is performed by the compiler
(no function inlining).

@value{PRJNAME} allocates a memory segment to be used as stack, the
executes the call to @func{alpha} pushing its stack frame on the stack;
as nested function calls are performed: new stack frames are pushed on
the stack, @ref{fig:continuation_stack_grow, compiler machinery
continuations}.

@float Figure,fig:continuation_stack_grow
@example
        <-- growing direction --

|-----------------------------|--------|
                               frame of
                                alpha


|--------------------|--------|--------|
                      frame of frame of
                        beta    alpha


|-----------|--------|--------|--------|
             frame of frame of frame of
              delta     beta    alpha
@end example
@caption{Scheme stack segment after calling @func{alpha}, @func{beta},
@func{delta}.}
@end float

When the functions return the stack rewinds; when there are no more
stack frames: there is nowhere to return to, so the program terminates,
@ref{fig:continuation_stack_rewind, compiler machinery continuations}.

@float Figure,fig:continuation_stack_rewind
@example
       <-- growing direction --

|--------------------|--------|--------|
                      frame of frame of
                        beta    alpha

|-----------------------------|--------|
                               frame of
                                alpha

|--------------------------------------|
@end example
@caption{Scheme stack segment after returning from @func{delta},
@func{beta}, @func{alpha}.}
@end float

Under @value{PRJNAME} machine words on the stack are immutable by
definition; let's see why.  Scheme has two kinds of values: immediate
and compound.

@itemize
@item
Each instance of an immediate value (boolean, fixnum, character,
@dots{}) is fully contained in a single machine word; immediate values
are moved around in @cpu{} registers and memory locations and they are
immutable; immediate values are put on the stack if it is needed for the
execution of a program.

@item
Each instance of a compound value (pair, vector, record, @dots{}) is
composed of a memory block, actually holding the data, and a reference
to it: a machine word being the tagged address of the first byte in the
memory block.

If we mutate a vector with @func{vector-set!}: we mutate the memory
block, the reference to such vector is untouched.  References to
compound values are immutable.

@value{PRJNAME} always allocates compound values' memory blocks on the
heap, while references are moved around in @cpu{} registers and memory
locations; references are put on the stack if it is needed for the
execution of a program.
@end itemize

Let's consider the following program making use of a continuation:

@example
(import (rnrs))
(define (alpha)  ((beta) values))
(define (beta)   (delta))
(define (delta)  (call/cc proc))
(define (proc k) k)
(alpha)
@end example

@noindent
this is what happens: @func{alpha} is called, @func{alpha} calls
@func{beta}, @func{beta} calls @func{delta}, @func{delta} call
@func{call/cc}, @func{call/cc} creates a continuation object and applies
@func{proc} to its escape function; @func{proc} returns the escape
function to @func{beta}, @func{beta} returns the escape function to
@func{alpha}, @func{alpha} applies the escape function to @func{values},
the escape function makes the execution flow go back to the body of
@func{delta} and returns @func{values}, @func{delta} returns
@func{values} to @func{beta}, @func{beta} returns @func{values} to
@func{alpha}, @func{alpha} applies @func{values} to @func{values},
@func{values} returns and the program terminates.

Now let's see what this program execution means for the stack segment.
When functions are called the stack grows as before, with the addition
of a call to @func{call/cc}, @ref{fig:continuation_stack_grow, compiler
machinery continuations}.  Then @func{call/cc} creates a continuation
object @var{D} (which is a ``normal'' Scheme compound object)
representing the current Scheme stack,
@ref{fig:continuation_cont_object, compiler machinery continuations}.

@float Figure,fig:continuation_cont_object
@example
       <-- growing direction --

|--|--------|--------|--------|--------|
    frame of frame of frame of frame of
    call/cc   delta     beta    alpha

            |..........................|
              stack portion referenced
            by the continuation object D
@end example
@caption{Scheme stack segment ``freezed'' by the continuation object.}
@end float

From now on the portion of the Scheme stack referenced by the
continuation object is no more used to execute code, it is ``freezed'';
for all the practical purposes it is no more part of the stack segment,
the deepest frame on the Scheme stack is now the frame of
@func{call/cc}.  The continuation object @var{D} is registered in the
process status as ``process next continuation''.

@func{call/cc} calls @func{proc} in tail position, which means that
@func{proc} reuses the stack frame of @func{call/cc},
@ref{fig:continuation_frame_reuse, compiler machinery continuations}.

@float Figure,fig:continuation_frame_reuse
@example
       <-- growing direction --

|--|--------|--------|--------|--------|
    frame of freezed  freezed  freezed
    proc     frame of frame of frame of
              delta     beta    alpha

            |..........................|
              stack portion referenced
            by the continuation object D
@end example
@caption{Calling @func{proc} in tail position reuses the top stack
frame.}
@end float

Now @func{proc} must return the continuation escape function @var{k} to
the caller @func{delta}; notice that there are no more stack frames up
from the one of @func{proc}, but there is a ``next continuation'' object
in the process status, @ref{fig:continuation_return_delta, compiler
machinery continuations}.  Here are the steps:

@enumerate
@item
The continuation object @var{D} is mutated to reference only the frame
of @func{delta}.  A new continuation object @var{B} is created to
reference the rest of the freezed frames; @var{B} becomes the new
``process next continuation'' object and also the ``next continuation''
of @var{D}.

@item
The frame of @func{proc} is moved down the stack segment by an amount of
bytes equal to the size of the frame of @func{delta}.

@item
The freezed frame of @func{delta} is copied into the space just created
and the copy becomes the deepest stack frame.

@item
The execution flow returns to @func{delta}, right after the instructions
that called @func{call/cc}.
@end enumerate

@float Figure,fig:continuation_return_delta
@example
          <-- growing direction --

|--------|--------|--------|--------|--------|
 frame of frame of freezed  freezed  freezed
 proc     delta    frame of frame of frame of
                    delta     beta    alpha
                  |........|
         freezed frame of D

                           |..................|
                           freezed frames of B
@end example
@caption{Returning to @func{delta}.}
@end float

Returning from @func{delta} to @func{beta} is similar; notice that there
are no more stack frames up from the one of @func{delta}, but there is a
``next continuation'' object in the process status,
@ref{fig:continuation_return_beta, compiler machinery continuations}.
Here are the steps:

@enumerate
@item
The continuation object @var{B} is mutated to reference only the frame
of @func{beta}.  A new continuation object @var{A} is created to
reference the rest of the freezed frames; @var{A} becomes the new
``process next continuation'' object and also the ``next continuation''
of @var{B}.

@item
The frame of @func{delta} is moved down the stack segment by an amount
of bytes equal to the size of the frame of @func{beta}.

@item
The freezed frame of @func{beta} is copied into the space just created
and the copy becomes the deepest stack frame.

@item
The execution flow returns to @func{beta}, right after the instructions
that called @func{delta}.
@end enumerate

@float Figure,fig:continuation_return_beta
@example
          <-- growing direction --

|--------|--------|--------|--------|--------|
 frame of frame of freezed  freezed  freezed
 delta    beta     frame of frame of frame of
                    delta     beta    alpha
                  |........|
         freezed frame of D

                           |........|
                  freezed frame of B

                                    |.........|
                            freezed frame of A
@end example
@caption{Returning to @func{beta}.}
@end float

Finally @func{beta} must return to @func{alpha}; notice that there are
no more stack frames up from the one of @func{alpha}, but there is a
``next continuation'' object in the process status,
@ref{fig:continuation_return_alpha, compiler machinery continuations}.
Here are the steps:

@enumerate
@item
The continuation object @var{A} references a single freezed frame: the
last one.  The process status is updated to ``no more continuation
objects''.

@item
The frame of @func{beta} is moved down the stack segment by an amount of
bytes equal to the size of the frame of @func{alpha}.

@item
The freezed frame of @func{alpha} is copied into the space just created
and the copy becomes the deepest stack frame.

@item
The execution flow returns to @func{alpha}, right after the instructions
that called @func{beta}.
@end enumerate

@float Figure,fig:continuation_return_alpha
@example
          <-- growing direction --

|--------|--------|--------|--------|--------|
 frame of frame of freezed  freezed  freezed
 beta     alpha    frame of frame of frame of
                    delta     beta    alpha
                  |........|
         freezed frame of D

                           |........|
                 freezed frames of B

                                    |.........|
                           freezed frames of A
@end example
@caption{Returning to @func{alpha}.}
@end float

@func{alpha} applies the escape function @var{K} to @func{values}; this
call happens in tail position, so the frame of @func{alpha} is reused by
the escape function, @ref{fig:continuation_apply_escape, compiler
machinery continuations}.  The escape function reinstalls the
continuation object @var{D} as ``process next continuation''.

@float Figure,fig:continuation_apply_escape
@example
          <-- growing direction --

|--------|--------|--------|--------|--------|
          frame of freezed  freezed  freezed
          K        frame of frame of frame of
                    delta     beta    alpha
@end example
@caption{Applying the continuation escape function.}
@end float

@c page
@node compiler machinery stack overflow
@subsection Scheme stack overflow


In the following discussion we assume the validity of machinery
simplifications to focus on some aspect of the runtime behaviour,
@ref{compiler machinery simplifications, Simplification assumptions}.

@c page
@node compiler machinery call arguments
@subsection Function call arguments


In the following discussion we assume the validity of machinery
simplifications to focus on some aspect of the runtime behaviour,
@ref{compiler machinery simplifications, Simplification assumptions}.


@c page
@node compiler machinery call retvals
@subsection Function call return values


In the following discussion we assume the validity of machinery
simplifications to focus on some aspect of the runtime behaviour,
@ref{compiler machinery simplifications, Simplification assumptions}.

@c page
@node compiler machinery tail calls
@subsection Tail calls implementation


In the following discussion we assume the validity of machinery
simplifications to focus on some aspect of the runtime behaviour, with
the exception that we allow the compiler to perform tail calls
optimisation (@acronym{TCO}), @ref{compiler machinery simplifications,
Simplification assumptions}.

@c page
@node compiler machinery locals
@subsection Local variables


In the following discussion we assume the validity of machinery
simplifications to focus on some aspect of the runtime behaviour,
@ref{compiler machinery simplifications, Simplification assumptions}.


@c page
@node compiler code
@section Introduction to compiler's code


@menu
* compiler code conventions::   Compiler coding conventions.
@end menu

@c page
@node compiler code conventions
@subsection Compiler coding conventions


Throughout the compiler code variables with the following names appear:

@table @var
@item op
Scheme symbol representing an @strong{operation} to be directly
translated into assembly.  Examples: @samp{alloc}, @samp{mref},
@samp{mref32}, @samp{bref}, @samp{logand}, @samp{logxor}, @samp{logor},
@samp{int+}, @samp{int-}, @samp{int*}, @samp{int-quotient},
@samp{int-remainder}, @samp{sll}, @samp{sra}.

@item rator
Represents a reference to an @strong{operator}: a function coded in
assembly or C language.

@item rands
Scheme list holding the @strong{operands} to which an operation must be
applied.  These operands are in such a format that can be directly used
in the assembly S--expression like:

@example
(make-set eax (car rands))
@end example

@noindent
which generate an assignment operation to store the first element of
@var{rands} into the @code{eax} processor register.
@end table

@c page
@node compiler stack
@section Scheme stack management


In this section we want to explain how the Scheme stack in managed by
@value{PRJNAME}.

@menu
* compiler stack alloc::        Stack allocation and basic management.
* compiler stack args::         Function arguments on the stack.
* compiler stack call::         Executing a @code{call} instruction.
@end menu

@c page
@node compiler stack alloc
@subsection Stack allocation and basic management


The Scheme stack is a block of memory allocated with @cfunc{mmap};
multiple blocks are allocated when more space is needed, each block is
called @dfn{stack segment}.  At any moment, the stack segment currently
in use is referenced by the following fields of the @pcb{} structure:

@table @code
@item ikptr stack_base
Raw memory pointer referencing the first byte in the stack segment.

@item unsigned long stack_size
Number of bytes allocated for this stack segment; it is always a
multiple of the host system page size.
@end table

@example
pcb->stack_base         use growth
       v              <-------------
lo mem |-------------------------------------| hi mem

       |.....................................| pcb->stack_size
@end example

When first allocated by C code, the stack is empty.  In the tradition of
stacks: the use of a stack segment grows from high memory addresses to
low memory addresses.

@c ------------------------------------------------------------

@subsubheading Calling Scheme functions and returning

Entering Scheme code from C code and exiting Scheme code to C code does
not happen directly; rather it involves hand--written assembly code:

@itemize
@item
The C code calls an assembly routine which prepares the @cpu{}
registers, then calls a Scheme function.

@item
The Scheme code returns to the assembly routine, which in turn restores
the @cpu{} registers and returns to the C code.
@end itemize

@noindent
the assembly code is in the file @file{ikarus-enter.S}, the C function
calling the assembly routine is in the file @file{ikarus-exec.c}.

Calling functions and returning from them is performed as follows:

@itemize
@item
Entering Scheme code execution from assembly code always involves the
execution of the assembly instruction @code{call}.

@item
Calling a Scheme function from Scheme code happens through a @code{call}
or @code{jmp} instruction.

@item
Returning from Scheme code to Scheme code happens through a @code{ret}
or @code{jmp} instruction.

@item
Returning from Scheme code to assembly code happens through a @code{ret}
or @code{jmp} instruction.
@end itemize

For simplicity in introducing the stack management, we assume that:

@itemize
@item
Calling a Scheme function always happens through a @code{call}
instruction.

@item
Returning from a function call always happens through a @code{ret}
instruction.

@item
All the Scheme functions return a single value.
@end itemize

The assembly routine calling Scheme code is @code{ik_asm_enter} and its
return address is labeled @code{ik_underflow_handler}; assuming
@var{REG} is a @cpu{} register holding the address of a Scheme function,
the assembly code is similar to:

@example
ik_asm_enter:
   ...                          ;assembly instructions
   call *@var{REG}
ik_underflow_handler:
   ...                          ;assembly instructions
   ret                          ;return to C code
@end example

@noindent
when the @code{call} is performed: the return address
@code{ik_underflow_handler} is pushed on the stack.

@c ------------------------------------------------------------

@subsubheading Stack frames

The @cpu{} keeps track of the current position on the stack with the
@dfn{Frame Pointer Register} (@fpr{}, which is @code{%esp} on the Intel
architecture); such register contains the memory address of the current
stack location, the @dfn{top} of the stack.  The first function frame
starts from the end of the stack segment; when we enter Scheme code for
the first time, we set the @fpr{} so that it references the machine word
right after the end of the stack segment:

@example
pcb->stack_base         use growth           FPR
       v              <-------------          v
lo mem |-------------------------------------|-| hi mem

       |.....................................| pcb->stack_size
@end example

@noindent
and perform a @code{call} instruction which pushes the return address
@code{ik_underflow_handler} on the stack segment, decrementing @fpr{} by
a wordsize; so right after the first @code{call}, the stack segment
looks as follows:

@example
                        high memory
                  |                      |
               -- |----------------------|          --
                . | ik_underflow_handler | <-- FPR  . frame
                . |----------------------|          --
pcb->stack_size .            ...
                . |----------------------|
                . |                      | <-- pcb->stack_base
               -- |----------------------|
                  |                      |
                         low memory
@end example

@noindent
performing a @code{ret} assembly instruction in this situation would
just increment the @fpr{} and let the execution flow go back to the code
at the assembly label @code{ik_underflow_handler}.  Notice that we first
enter a Scheme program by calling a Scheme function with zero arguments.

@ref{compiler stack args} for details on how function arguments are put
on the stack; here we only need to know that a function occupies some
space on the stack, called a @dfn{stack frame}:

@example
      high memory
|                      |
|----------------------|         --
|    return address    | <-- FPR .
|----------------------|         .
|     local value 0    |         . function
|----------------------|         . stack
|     local value 1    |         . frame
|----------------------|         .
|     local value 2    |         .
|----------------------|         --
|                      |
       low memory
@end example

@c ------------------------------------------------------------

@subsubheading Handling stack overflow

Nested function call after nested function call the stack segment fills
up towards low memory addresses:

@example
pcb->stack_base         use growth
       v              <-------------
lo mem |-------------------------------------| hi mem

       |...................|.....|.....|.....|
                            frame frame frame
@end example

@noindent
there is a limit, a ``red line'', below which the current stack segment
is considered full: we need to allocate a new one and allocate the
function frames there.  The limit is registered in the @pcb{} structure
fields:

@table @code
@item ikptr frame_redline
Raw memory pointer referencing a location in the current stack segment;
when Scheme code execution uses the stack crossing the ``red line''
represented by this field: the current stack segment is considered full.
@end table

A stack segment in stack overflow looks like this:

@example
pcb->stack_base  pcb->frame_redline
       v          v
lo mem |----------+--------------------------| hi mem

       |.......|.....|.....|.....|.....|.....|
        unused  frame frame frame frame frame
@end example

Each compiled Scheme function contains, right at the beginning, code
that checks if the red line has been crossed; so, when a stack segment
is full, at the first subsequent Scheme function call, @value{PRJNAME}
takes control and allocates a new stack segment doing what is needed to
proceed the execution on the new stack.  This ``proceeding on the new
stack'' is called @dfn{stack overflow}.

How is this implemented?  Let's say we have called a function
@func{alpha} whose frame has crossed the red line, then the function
@func{beta} is called:

@example
      high memory
|                      |
|----------------------|                         --
|    return address    |                         .
|----------------------|                         .
|     local value 0    |                         . alpha
|----------------------|                         . frame
|     local value 1    | <-- pcb->frame_redline  .
|----------------------|                         .
|     local value 2    |                         .
|----------------------|                         --
|    return address    | <-- FPR                 .
|----------------------|                         .
|     local value 0    |                         . beta
|----------------------|                         . frame
|     local value 1    |                         .
|----------------------|                         .
|     local value 2    |                         .
|----------------------|                         --
|                      |
       low memory
@end example

@noindent
the code in @func{beta} detects the situation simply by the comparison:

@example
pcb->frame_redline < FPR
@end example

@noindent
and calls an routine to exit Scheme code execution and call the C
function @cfunc{ik_stack_overflow}.  A new stack segment is called

@c QUIIIIIIIIIIIIIIIIIIIIII

the current
Scheme stack is stored away in a Scheme continuation and a new stack
segment is allocated and installed as Scheme stack.  See the C function
 for how this is implemented.  When the
function returns: the stored continuation is reinstated and execution
continues on the old stack.

@c ------------------------------------------------------------

@subsubheading Context switching between Scheme code and C code

@table @code
@item ikptr frame_pointer
@item ikptr frame_base
@end table

@c page
@node compiler stack args
@subsection Function arguments on the stack


Right after the first function call that enters Scheme code from
assembly code, the stack segment looks as follows:

@example
      high memory
|                      |
|----------------------|
|                      | <-- pcb->frame_base
|----------------------|
| ik_underflow_handler | <-- FPR
|----------------------|
           ...
|----------------------|
|                      | <-- pcb->stack_base
|----------------------|
|                      |
       low memory
@end example

If the called Scheme function needs some local variables, it allocates
them on the stack:

@example
      high memory
|                      |
|----------------------|                         --
| ik_underflow_handler | <-- FPR                 .
|----------------------|                         .
|   local variable 0   | <-- FPR - 1 * wordsize  . first
|----------------------|                         . called
|   local variable 1   | <-- FPR - 2 * wordsize  . function
|----------------------|                         . frame
|   local variable 2   | <-- FPR - 3 * wordsize  .
|----------------------|                         --
|                      |
       low memory
@end example

@noindent
notice that local values are ``moved'' on the stack, not ``pushed'':
executing the assembly instruction @code{push} would decrement the
@fpr{}, we do not want this; rather we reserve frame space for a
function call and never mutate the @fpr{} until the function returns or
calls another function.

If the Scheme function needs to call another Scheme function, as in:

@example
(sub-func arg0 arg1 arg2)
@end example

@noindent
it moves the arguments on the stack, leaving an empty machine word:

@example
      high memory
|                      |
|----------------------|         --
| ik_underflow_handler | <-- FPR .
|----------------------|         .
|   local variable 0   |         . first
|----------------------|         . called
|   local variable 1   |         . function
|----------------------|         . frame
|   local variable 2   |         .
|----------------------|         --
|                      |
|----------------------|
|      argument 0      |
|----------------------|
|      argument 1      |
|----------------------|
|      argument 2      |
|----------------------|
|                      |
       low memory
@end example

@noindent
it adjusts the @fpr{} by explicitly subtracting the appropriate offset
from it:

@example
      high memory
|                      |
|----------------------|         --
| ik_underflow_handler |         .
|----------------------|         .
|   local variable 0   |         . first
|----------------------|         . called
|   local variable 1   |         . function
|----------------------|         . frame
|   local variable 2   | <-- FPR .
|----------------------|         --
|                      |
|----------------------|
|      argument 0      |
|----------------------|
|      argument 1      |
|----------------------|
|      argument 2      |
|----------------------|
|                      |
       low memory
@end example

@noindent
and finally it performs a @code{call} instruction, which pushes a return
address on the stack right in the empty machine word:

@example
      high memory
|                      |
|----------------------|         --
| ik_underflow_handler |         .
|----------------------|         .
|   local variable 0   |         . first
|----------------------|         . called
|   local variable 1   |         . function
|----------------------|         . frame
|   local variable 2   |         .
|----------------------|         --
|    return address    | <-- FPR .
|----------------------|         .
|      argument 0      |         . sub-func
|----------------------|         . called
|      argument 1      |         . function
|----------------------|         . frame
|      argument 2      |         .
|----------------------|         --
|                      |
       low memory
@end example

When the function @func{sub-func} executes a @code{ret} instruction: the
execution flow returns to @code{return address} and the @fpr{} is
incremented by a machine word:

@example
      high memory
|                      |
|----------------------|         --
| ik_underflow_handler |         .
|----------------------|         .
|   local variable 0   |         . first
|----------------------|         . called
|   local variable 1   |         . function
|----------------------|         . frame
|   local variable 2   | <-- FPR .
|----------------------|         --
|                      |
       low memory
@end example

@noindent
now the first called function adjusts the @fpr{} by explicitly adding
the appropriate offset to it:

@example
      high memory
|                      |
|----------------------|         --
| ik_underflow_handler | <-- FPR .
|----------------------|         .
|   local variable 0   |         . first
|----------------------|         . called
|   local variable 1   |         . function
|----------------------|         . frame
|   local variable 2   |         .
|----------------------|         --
|                      |
       low memory
@end example

@noindent
and is finally ready to go on with the execution.

@c page
@node compiler stack call
@subsection Executing a @code{call} instruction


The usual mechanism of performing an assembly language @code{call}
instruction is this:

@example
caller's code   callee's code       stack
 --- lo mem       --- lo mem         --- hi mem
  .                .                  .
  .                .                  .  caller stuff
  .                .                  .
 call FUNC        enter <-- FUNC      .   <--- %esp before
 after <-- ADDR    .                 ADDR <--- %esp after
  .                .                  .
  .               ret                 .   calleee stuff
  .                .                  .
 --- hi mem       --- hi mem         --- lo mem
@end example

@noindent
when the caller executes a @code{call} instruction:

@enumerate
@item
The stack pointer register @code{%esp} is decremented by the size of a
machine word.

@item
The memory address referencing the first byte of the instruction
@code{after} is stored on the memory location referenced by the stack
pointer register @code{%esp}.

@item
The execution flow jumps to the memory address @code{FUNC}, which must
contain the first byte of the instruction @code{enter}.
@end enumerate

The usual mechanism of performing an assembly language @code{ret}
instruction is this:

@example
caller's code   callee's code       stack
 --- lo mem       --- lo mem         --- hi mem
  .                .                  .
  .                .                  .  caller stuff
  .                .                  .
 call FUNC       enter <-- FUNC       .   <--- %esp after
 after <-- ADDR    .                 ADDR <--- %esp before
  .                .                  .
  .               ret                 .   calleee stuff
  .                .                  .
 --- hi mem       --- hi mem         --- lo mem
@end example

@noindent
when the callee executes a @code{ret} instruction:

@enumerate
@item
The memory address referenced by the stack pointer register @code{%esp}
is stored in then instruction pointer register.

@item
The stack pointer register @code{%esp} is incremented by the size of a
machine word.

@item
The execution flow jumps to the memory address in the instruction
pointer.
@end enumerate

@noindent
after the @code{ret} the stack is left in the same state it was at the
moment the @code{call} was executed.

Now let's say that, when generating binary code for a @code{call}
instruction, we put some static data right before the @code{call}:

@example
 caller's code              stack
    --- lo mem               --- hi mem
     .                        .
     .                        .
     .                        .
    jmp L0                    .
    data_machine_word_1       .   <--- %esp before call
    data_machine_word_2      ADDR <--- %esp after call
    data_machine_word_3       .
    call FUNC  <--- L0        .
    after      <--- ADDR      .
     .                        .
     .                        .
     .                        .
    --- hi mem               --- lo mem
@end example

@noindent
let's name @code{call_size} the number of bytes occupied by the
instruction @code{call FUNC}; when the callee begins execution:

@itemize
@item
It can access the return address by retrieving the machine word at
@code{%esp}.

@item
It can access the constant @code{data_machine_word_1} by retrieving the
machine word at:

@example
%esp - call_size - 0 * wordsize
@end example

@item
It can access the constant @code{data_machine_word_2} by retrieving the
machine word at:

@example
%esp - call_size - 1 * wordsize
@end example

@item
It can access the constant @code{data_machine_word_3} by retrieving the
machine word at:

@example
%esp - call_size - 2 * wordsize
@end example
@end itemize

@c end of file
