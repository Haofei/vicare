@node compiler
@chapter Wild notes on the compiler internals


This chapter is a collection of notes on the internals of the compiler.

@menu
* compiler machinery::          Introduction to execution machinery.
* compiler code::               Introduction to compiler's code.
* compiler stack::              Scheme stack management.
@end menu

@c ------------------------------------------------------------

@macro aar{}
@acronym{AAR}
@end macro

@macro apr{}
@acronym{APR}
@end macro

@macro cpr{}
@acronym{CPR}
@end macro

@macro fpr{}
@acronym{FPR}
@end macro

@macro pcr{}
@acronym{PCR}
@end macro

@c page
@node compiler machinery
@section Introduction to execution machinery


The execution machinery of compiled Scheme code is a bit intricated when
compared with the execution of, say, ``normal'' compiled C code; this is
because the following features must be implemented:

@table @strong
@item Closures
Scheme functions are not just blocks of machine code: they are allowed
to reference variable values captured at run time.  Multiple closures
(referencing different instances of the same semantic variables) can
share the same block of machine code.  Multiple closures (referencing
different blocks of machine code) can share the same variable values.
@ref{objects closures, Closure objects}.

@item Tail calls
Whenever a Scheme function call happens in tail position: it must be
implemented in such a way that @strong{no} new stack frame is created
for the callee function; rather the stack frame of the caller is
destroyed and reused as callee's frame.  This allows the use of tail
calls as proper idiom to implement all the execution loops, even when
such loops have an ``infinite'' number of iterations, without the risk
of overflowing the Scheme stack.

@item Continuations
Scheme code is allowed to save the current continuation and resume it
later any number of times.
@end table

@menu
* compiler machinery simplifications::  Simplification assumptions.
* compiler machinery registers::        Special @cpu{} registers.
* compiler machinery scheme stack::     Basics of the Scheme stack.
* compiler machinery call frames::      Basics of function call frames.
* compiler machinery continuations::    The current continuation.
* compiler machinery stack overflow::   Scheme stack overflow.
* compiler machinery call arguments::   Function call arguments.
* compiler machinery call retvals::     Function call return values.
* compiler machinery tail calls::       Tail calls optimisation.
* compiler machinery locals::           Local variables.
@end menu

@c page
@node compiler machinery simplifications
@subsection Simplification assumptions


To make it easy to explain the run time behaviour of @value{PRJNAME}, we
will assume the validity of the following simplifications:

@enumerate
@item
At the start of a user program execution: the Scheme stack is empty.
This is false because, at @value{PRJNAME} launch time, the boot image is
loaded and initialised, executing a lot of compiled Scheme code.  But
starting with an empty stack makes reasoning simpler.

@item
No expressions and function calls are inlined.  This is false because
the compiler precomputes some expressions, inlines some function calls
and removes bindings whenever possible; this makes the executed code
different from the original Scheme code.  But we want to show sample
Scheme code as close as possible to the one that gets executed.

@item
Unless otherwise specified: no tail call optimisation (@acronym{TCO}) is
performed.  This is false because, whenever it recognises a function
call in tail position, @value{PRJNAME} always performs the call in such
a way that the new stack frame overwrites the old one.  But we want to
show simple functions that create new stack frames.

@item
The function @func{call/cc} is implemented without nested function
calls.  This is depends upon the function call integration optimisations
performed by the compiler.  But reasoning about simple function call is
simpler.

@item
There is no dynamic environment to be captured by continuations.  This
is false because whenever @func{dynamic-wind} is used stacks of
in--guard and out--guard functions are created and captured by
continuations; the continuation escape function, created by
@func{call/cc}, does invoke such guard functions to keep the dynamic
environment synchronised with the execution flow.  But learning about
continuations alone already introduces enough complications.

@item
When discussing sample programs we assume that only the code we see is
executed.  This is false because whenever a user program is run: the
code is loaded and compiled, then some initialisation is performed
before running it.  Rather when dissussing the execution of:

@example
(import (rnrs))
(define (one a)
  (+ a 1))
(one 2)
@end example

@noindent
we assume that the first executed code is the expression @code{(one 2)}.
@end enumerate

@c page
@node compiler machinery registers
@subsection Special @cpu{} registers


@cindex Special @cpu{} registers
@cindex @cpu{} registers with special roles


While running Scheme code @value{PRJNAME} assigns a special role to some
@cpu{} registers.

@table @strong
@item Accumulator and Arguments count Register, @aar{}
@cindex Accumulator and Arguments count Register, @aar{}
@cindex @aar{}, Accumulator and Arguments count Register
It is used to hold:

@itemize
@item
The result of Assembly instructions.

@item
A fixnum representing the negated number of arguments to the function
call that is about to happen.

@item
The return value from a function call that just returned, when such
function returns a single value.

@item
A fixnum representing the negated number of return values from a
function call that just returned, when such function returns @math{0},
@math{2} or more values.
@end itemize

@noindent
it is also used as general purpose register.  On a 32-bit i686 @cpu{} it
is the register @code{EAX}.

@item Allocation Pointer Register, @apr{}
@cindex Allocation Pointer Register, @apr{}
@cindex @apr{}, Allocation Pointer Register
Holds the address of the first free machine word in the memory segment
of the Scheme heap nursery.  On a 32-bit i686 @cpu{} it is the register
@code{EBP}.

@item Closure Pointer Register, @cpr{}
@cindex Closure Pointer Register, @cpr{}
@cindex @cpr{}, Closure Pointer Register
Holds the tagged address of a machine word in the Scheme heap,
representing the reference to the closure object being executed; when no
closure is being executed: it is set to zero.  It is used to enter the
execution of the closure code and to access the free variables the
closure is closed upon.  On a 32-bit i686 @cpu{} it is the register
@code{EDI}.

@item Frame Pointer Register, @fpr{}
@cindex Frame Pointer Register, @fpr{}
@cindex @fpr{}, Frame Pointer Register
Holds the address of the machine word in the memory segment of the
Scheme stack holding the return address of the last performed function
call.  It is used to access the machine words on the stack containing
function arguments and local variables.  On a 32-bit i686 @cpu{} it is
the register @code{ESP}.

@item Process Control Register, @pcr{}
@cindex Process Control Register, @pcr{}
@cindex @pcr{}, Process Control Register
Holds the raw address of a machine word in the C language heap; such
address references the first word in the @pcb{} data structure.  On a
32-bit i686 @cpu{} it is the register @code{ESI}.
@end table

@c page
@node compiler machinery scheme stack
@subsection Basics of the Scheme stack


We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, @ref{compiler machinery
simplifications, Simplification assumptions}.

When running C code: the state of the Scheme stack is represented by the
fields of the @pcb{} data structure.  When running Scheme code: the
state of the Scheme stack is represented by the Frame Pointer Register
(@fpr{}) and some fields of the @pcb{} data structure.

When the execution flow moves from C language code to Scheme language
code or from Scheme code to C code: Assembly language routines are
executed to perform some low--level operations.  Such Assembly code
takes care of synchronising the @pcb{} fields with the @cpu{} registers.

Let's start by taking a look at an empty Scheme stack segment,
@ref{fig:CMSC_stack_size, compiler machinery call frames}.  The stack
memory segment begins at the machine word referenced by the @pcb{} field
@code{stack_base} (included) and ends at the machine word referenced by
the @pcb{} field @code{frame_base} (excluded).  @code{stack_base}
changes only when the stack overflows, @code{frame_base} changes when
the stack overflows and every time a continuation object is created.

@float Figure,fig:CMSC_stack_size
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|                     --
           .                                 .
           .                                 . stack
           .                                 . segment
|----------------------|                     . size
|                      | <- pcb->stack_base  .
|----------------------|                     --
|                      |
       low memory
@end example
@caption{Size of the Scheme stack segment.}
@end float

The stack space is consumed starting from the high memory addresses
towards the low memory addresses; the first used word on the Scheme
stack is right below the machine word referenced by @code{frame_base}.

Upon creation: the first machine word on the stack is initialised to the
address of the Assembly routine @code{ik_underflow_handler}; when the
execution flow of Scheme code returns to such address: the routine takes
care of switching from Scheme code to C code and itself returns to a C
function.

When running C code: the machine word holding the address of the
underflow handler is referenced by the @pcb{} field
@code{frame_pointer}, @ref{fig:CMSC_empty_stack_C, compiler machinery
call frames}.  When running Scheme code: the machine word holding the
address of the underflow handler is referenced by the @fpr{} register,
@ref{fig:CMSC_empty_stack_Scheme, compiler machinery call frames}.

@float Figure,fig:CMSC_empty_stack_C
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler | <- pcb->frame_pointer
|----------------------|
            .
            .
            .
|----------------------|
|                      | <- pcb->stack_base
|----------------------|
|                      |
       low memory
@end example
@caption{Empty Scheme stack as represented in the @pcb{} structure while
running C code.}
@end float

@float Figure,fig:CMSC_empty_stack_Scheme
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler | <- Frame Pointer Register (FPR)
|----------------------|
            .
            .
            .
|----------------------|
|                      | <- pcb->stack_base
|----------------------|
|                      |
       low memory
@end example
@caption{Empty Scheme stack as represented in the @cpu{} registers and
the @pcb{} structure while running Scheme code.}
@end float

@c page
@node compiler machinery call frames
@subsection Basics of function call frames


We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, @ref{compiler machinery
simplifications, Simplification assumptions}.

Let's consider the program:

@example
(import (rnrs))
(define (one A)
  (+ A 1))
(one 2)
@end example

@noindent
in which the call to Scheme function generates a stack frame; the form
@code{(one 2)} is the ``call site'' and we can think of it as generating
Assembly code containing the chunk:

@example
(call address_of_one)
(label return_address)
@end example

Let's start with an empty Scheme stack represented by @cpu{} registers
and @pcb{} fields, @ref{fig:CMCF_empty_stack_Scheme, compiler machinery
call frames}.

@float Figure,fig:CMCF_empty_stack_Scheme
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler | <- Frame Pointer Register (FPR)
|----------------------|
            .
            .
            .
|----------------------|
|                      | <- pcb->stack_base
|----------------------|
|                      |
       low memory
@end example
@caption{Empty Scheme stack as represented in the @cpu{} registers and
the @pcb{} structure while running Scheme code.}
@end float

Running the program means executing the following operations:

@enumerate
@item
Prepare to call @func{one}: put the single argument on the stack
@math{2} machine words below the underflow handler,
@ref{fig:CMCF_one_before, compiler machinery call frames}.

@float Figure,fig:CMCF_one_before
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler | <- FPR
|----------------------|
|                      | <- FPR - 1*wordsize
|----------------------|
|    argument A == 2   | <- FPR - 2*wordsize
|----------------------|
|                      |
       low memory
@end example
@caption{Preparing the function call to @func{one} by putting the
argument on the stack.}
@end float

@item
Call @func{one}: execute the Assembly instruction @code{call}; this puts
the return address on the stack and decrements the @fpr{} by a machine
word, @ref{fig:CMCF_one_after, compiler machinery call frames}.  Notice
that the stack now contains a single stack frame representing the status
of the code before the call.

@float Figure,fig:CMCF_one_after
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler |
|----------------------|         --
|    return address    | <- FPR  . frame of caller
|----------------------|         --
|    argument A == 2   |
|----------------------|
|                      |
       low memory
@end example
@caption{Stack right after the function call to @func{one}.}
@end float

@item
Prepare to call @func{+}: put the two arguments on the stack @math{2}
machine words below the return address, @ref{fig:CMCF_plus_before,
compiler machinery call frames}.

@float Figure,fig:CMCF_plus_before
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler |
|----------------------|         --
|    return address    | <- FPR  . frame of caller
|----------------------|         --
|    argument A == 2   |         .
|----------------------|         . frame of ONE
|                      |         .
|----------------------|         --
|   1st argument == 2  |
|----------------------|
|   2nd argument == 1  |
|----------------------|
|                      |
       low memory
@end example
@caption{Preparing the call to @func{+}.}
@end float

@item
Adjust the @fpr{} to reference the machine word right above the one that
will hold the return address, @ref{fig:CMCF_plus_adjust, compiler
machinery call frames}.

@float Figure,fig:CMCF_plus_adjust
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler |
|----------------------|         --
|    return address    |         . frame of caller
|----------------------|         --
|    argument A == 2   | <- FPR
|----------------------|
|                      |
|----------------------|
|   1st argument == 2  |
|----------------------|
|   2nd argument == 1  |
|----------------------|
|                      |
       low memory
@end example
@caption{Adjusting the @fpr{} for the call to @func{+}.}
@end float

@item
Call @func{+}: execute the Assembly instruction @code{call}; this puts
the return address on the stack and decrements the @fpr{} by a machine
word, @ref{fig:CMCF_plus_after, compiler machinery call frames}.  Notice
that the stack now contains two stack frames representing the status of
the code before the call.

@float Figure,fig:CMCF_plus_after
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler |
|----------------------|         --
|    return address    |         . frame of caller
|----------------------|         --
|    argument A == 2   |         .
|----------------------|         . frame of ONE
|    return address    | <- FPR  .
|----------------------|         --
|   1st argument == 2  |
|----------------------|
|   2nd argument == 1  |
|----------------------|
|                      |
       low memory
@end example
@caption{Stack right after the call to @func{+}.}
@end float

@item
Let's skip how @func{+} performs the addition and just assume that the
result is stored in the @aar{} register.

@item
Return from @func{+}: execute the Assembly instruction @code{ret} which:
loads the machine word from the stack location referenced by @fpr{} into
the @cpu{}'s Instruction Pointer Register, increments the @fpr{} by a
machine words, jumps to the code address in the Instruction Pointer
Register, @ref{fig:CMCF_plus_ret, compiler machinery call frames}.

@float Figure,fig:CMCF_plus_ret
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler |
|----------------------|         --
|    return address    |         . frame of caller
|----------------------|         --
|    argument A == 2   | <- FPR  .
|----------------------|         . frame of ONE
|    return address    |         .
|----------------------|         --
|                      |
       low memory
@end example
@caption{Stack right after the @code{ret} instruction that returns from
@func{+}.}
@end float

@item
Adjust back the @fpr{} to reference return address of the caller
@ref{fig:CMCF_caller_adjust, compiler machinery call frames}.

@float Figure,fig:CMCF_caller_adjust
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler |
|----------------------|         --
|    return address    | <- FPR  . frame of caller
|----------------------|         --
|    argument A == 2   |
|----------------------|
|                      |
       low memory
@end example
@caption{Adjusting the @fpr{} back after returning from @func{+}.}
@end float

@item
Return from @func{one}: execute the Assembly instruction @code{ret}
which: loads the machine word from the stack location referenced by
@fpr{} into the @cpu{}'s Instruction Pointer Register, increments the
@fpr{} by a machine words, jumps to the code address in the Instruction
Pointer Register, @ref{fig:CMCF_one_ret, compiler machinery call
frames}.  The return value is still in the @aar{} register.

@float Figure,fig:CMCF_one_ret
@example
      high memory
|                      |
|----------------------|
|                      | <- pcb->frame_base
|----------------------|
| ik_underflow_handler | <- FPR
|----------------------|
|                      |
       low memory
@end example
@caption{Stack right after the @code{ret} instruction that returns from
@func{+}.}
@end float

@item
The form @code{(one 2)} is the only top--level expression in the
program, so, after executing it, the execution flow must go back to the
C code that started the program; we can imagine the Assembly code:

@example
(call address_of_one)
(label return_address)
;; move the return value from AAR to the stack
(movl AAR (disp (- wordsize) FPR))
(ret)
@end example

@noindent
where @code{(ret)} jumps to the underflow handler.
@end enumerate

After the program execution the stack is left empty at it was at the
beginning; this is because no continuation objects have been created.

@c page
@node compiler machinery continuations
@subsection The current continuation


We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, @ref{compiler machinery
simplifications, Simplification assumptions}.

Let's think of a process in execution as having: a table of descriptors,
a code memory segment, a heap memory segment and a stack memory segment,
@ref{fig:process_segments, compiler machinery continuations}.  The
Instruction Pointer @cpu{} register (@acronym{IP}) keeps track of the
next instruction to execute in the code segment; the Stack Pointer
@cpu{} register (@acronym{SP}) keeps track of the current location on
the stack; dynamically allocated data goes in the heap segment.

@float Figure,fig:process_segments
@example
|---|---|---| descriptors table
  |   |   |
  |   |   |      IP
  |   |   v      v
  |   |   |------+---------------| code segment
  |   v
  |   |----------------------| heap segment
  v
  |----------+-----------| stack segment
             ^
             SP
@end example
@caption{Memory segments of a process in execution.}
@end float

One way to implement continuations is to push the current @acronym{IP}
on the stack segment, duplicate the stack segment itself, finally save
somewhere the @acronym{SP}; later we can reinstall the saved stack
segment, reset the @acronym{SP} and perform a @code{ret} assembly
instruction that will pop the saved @acronym{IP} and resume the
execution; @ref{fig:duplicated_stack_segment, compiler machinery
continuations}.  Of course we must make sure that the resources
referenced by the saved stack segment are not released while the
continuation still exists.

@float Figure,fig:duplicated_stack_segment
@example
|---|---|---| descriptors table
  |   |   |
  |   |   |     IP IP1
  |   |   v      v v
  |   |   |------+-+--------------| code segment
  |   v
  |   |----------------------| heap segment
  |
  v           IP1
  |----------+--+---------| stack segment
             ^
             SP

              IP1
  |----------+--+---------| duplicated stack segment
             ^
             SP
@end example
@caption{Duplicated stack segment as continuation implementation
mechanism.}
@end float

Stack segment duplication is @strong{not} the way @value{PRJNAME}
implements continuations; but the actual implementation is not
conceptually different.  Let's look at this simple program that does not
create explicit continuations:

@example
(import (rnrs))
(define (alpha) (beta))
(define (beta)  (delta))
(define (delta) 123)
(alpha)
@end example

@noindent
let's assume that no function integration is performed by the compiler
(no function inlining).

@value{PRJNAME} allocates a memory segment to be used as stack, the
executes the call to @func{alpha} pushing its stack frame on the stack;
as nested function calls are performed: new stack frames are pushed on
the stack, @ref{fig:continuation_stack_grow, compiler machinery
continuations}.

@float Figure,fig:continuation_stack_grow
@example
        <-- growing direction --

|-----------------------------|--------|
                               frame of
                                alpha


|--------------------|--------|--------|
                      frame of frame of
                        beta    alpha


|-----------|--------|--------|--------|
             frame of frame of frame of
              delta     beta    alpha
@end example
@caption{Scheme stack segment after calling @func{alpha}, @func{beta},
@func{delta}.}
@end float

When the functions return the stack rewinds; when there are no more
stack frames: there is nowhere to return to, so the program terminates,
@ref{fig:continuation_stack_rewind, compiler machinery continuations}.

@float Figure,fig:continuation_stack_rewind
@example
       <-- growing direction --

|--------------------|--------|--------|
                      frame of frame of
                        beta    alpha

|-----------------------------|--------|
                               frame of
                                alpha

|--------------------------------------|
@end example
@caption{Scheme stack segment after returning from @func{delta},
@func{beta}, @func{alpha}.}
@end float

Under @value{PRJNAME} machine words on the stack are immutable by
definition; let's see why.  Scheme has two kinds of values: immediate
and compound.

@itemize
@item
Each instance of an immediate value (boolean, fixnum, character,
@dots{}) is fully contained in a single machine word; immediate values
are moved around in @cpu{} registers and memory locations and they are
immutable; immediate values are put on the stack if it is needed for the
execution of a program.

@item
Each instance of a compound value (pair, vector, record, @dots{}) is
composed of a memory block, actually holding the data, and a reference
to it: a machine word being the tagged address of the first byte in the
memory block.

If we mutate a vector with @func{vector-set!}: we mutate the memory
block, the reference to such vector is untouched.  References to
compound values are immutable.

@value{PRJNAME} always allocates compound values' memory blocks on the
heap, while references are moved around in @cpu{} registers and memory
locations; references are put on the stack if it is needed for the
execution of a program.
@end itemize

Let's consider the following program making use of a continuation:

@example
(import (rnrs))
(define (alpha)  ((beta) values))
(define (beta)   (delta))
(define (delta)  (call/cc proc))
(define (proc k) k)
(alpha)
@end example

@noindent
this is what happens: @func{alpha} is called, @func{alpha} calls
@func{beta}, @func{beta} calls @func{delta}, @func{delta} call
@func{call/cc}, @func{call/cc} creates a continuation object and applies
@func{proc} to its escape function; @func{proc} returns the escape
function to @func{beta}, @func{beta} returns the escape function to
@func{alpha}, @func{alpha} applies the escape function to @func{values},
the escape function makes the execution flow go back to the body of
@func{delta} and returns @func{values}, @func{delta} returns
@func{values} to @func{beta}, @func{beta} returns @func{values} to
@func{alpha}, @func{alpha} applies @func{values} to @func{values},
@func{values} returns and the program terminates.

Now let's see what this program execution means for the stack segment.
When functions are called the stack grows as before, with the addition
of a call to @func{call/cc}, @ref{fig:continuation_stack_grow, compiler
machinery continuations}.  Then @func{call/cc} creates a continuation
object @var{D} (which is a ``normal'' Scheme compound object)
representing the current Scheme stack,
@ref{fig:continuation_cont_object, compiler machinery continuations}.

@float Figure,fig:continuation_cont_object
@example
       <-- growing direction --

|--|--------|--------|--------|--------|
    frame of frame of frame of frame of
    call/cc   delta     beta    alpha

            |..........................|
              stack portion referenced
            by the continuation object D
@end example
@caption{Scheme stack segment ``freezed'' by the continuation object.}
@end float

From now on the portion of the Scheme stack referenced by the
continuation object is no more used to execute code, it is ``freezed'';
for all the practical purposes it is no more part of the stack segment,
the deepest frame on the Scheme stack is now the frame of
@func{call/cc}.  The continuation object @var{D} is registered in the
process status as ``process next continuation''.

@func{call/cc} calls @func{proc} in tail position, which means that
@func{proc} reuses the stack frame of @func{call/cc},
@ref{fig:continuation_frame_reuse, compiler machinery continuations}.

@float Figure,fig:continuation_frame_reuse
@example
       <-- growing direction --

|--|--------|--------|--------|--------|
    frame of freezed  freezed  freezed
    proc     frame of frame of frame of
              delta     beta    alpha

            |..........................|
              stack portion referenced
            by the continuation object D
@end example
@caption{Calling @func{proc} in tail position reuses the top stack
frame.}
@end float

Now @func{proc} must return the continuation escape function @var{k} to
the caller @func{delta}; notice that there are no more stack frames up
from the one of @func{proc}, but there is a ``next continuation'' object
in the process status, @ref{fig:continuation_return_delta, compiler
machinery continuations}.  Here are the steps:

@enumerate
@item
The continuation object @var{D} is mutated to reference only the frame
of @func{delta}.  A new continuation object @var{B} is created to
reference the rest of the freezed frames; @var{B} becomes the new
``process next continuation'' object and also the ``next continuation''
of @var{D}.

@item
The frame of @func{proc} is moved down the stack segment by an amount of
bytes equal to the size of the frame of @func{delta}.

@item
The freezed frame of @func{delta} is copied into the space just created
and the copy becomes the deepest stack frame.

@item
The execution flow returns to @func{delta}, right after the instructions
that called @func{call/cc}.
@end enumerate

@float Figure,fig:continuation_return_delta
@example
          <-- growing direction --

|--------|--------|--------|--------|--------|
 frame of frame of freezed  freezed  freezed
 proc     delta    frame of frame of frame of
                    delta     beta    alpha
                  |........|
         freezed frame of D

                           |..................|
                           freezed frames of B
@end example
@caption{Returning to @func{delta}.}
@end float

Returning from @func{delta} to @func{beta} is similar; notice that there
are no more stack frames up from the one of @func{delta}, but there is a
``next continuation'' object in the process status,
@ref{fig:continuation_return_beta, compiler machinery continuations}.
Here are the steps:

@enumerate
@item
The continuation object @var{B} is mutated to reference only the frame
of @func{beta}.  A new continuation object @var{A} is created to
reference the rest of the freezed frames; @var{A} becomes the new
``process next continuation'' object and also the ``next continuation''
of @var{B}.

@item
The frame of @func{delta} is moved down the stack segment by an amount
of bytes equal to the size of the frame of @func{beta}.

@item
The freezed frame of @func{beta} is copied into the space just created
and the copy becomes the deepest stack frame.

@item
The execution flow returns to @func{beta}, right after the instructions
that called @func{delta}.
@end enumerate

@float Figure,fig:continuation_return_beta
@example
          <-- growing direction --

|--------|--------|--------|--------|--------|
 frame of frame of freezed  freezed  freezed
 delta    beta     frame of frame of frame of
                    delta     beta    alpha
                  |........|
         freezed frame of D

                           |........|
                  freezed frame of B

                                    |.........|
                            freezed frame of A
@end example
@caption{Returning to @func{beta}.}
@end float

Finally @func{beta} must return to @func{alpha}; notice that there are
no more stack frames up from the one of @func{alpha}, but there is a
``next continuation'' object in the process status,
@ref{fig:continuation_return_alpha, compiler machinery continuations}.
Here are the steps:

@enumerate
@item
The continuation object @var{A} references a single freezed frame: the
last one.  The process status is updated to ``no more continuation
objects''.

@item
The frame of @func{beta} is moved down the stack segment by an amount of
bytes equal to the size of the frame of @func{alpha}.

@item
The freezed frame of @func{alpha} is copied into the space just created
and the copy becomes the deepest stack frame.

@item
The execution flow returns to @func{alpha}, right after the instructions
that called @func{beta}.
@end enumerate

@float Figure,fig:continuation_return_alpha
@example
          <-- growing direction --

|--------|--------|--------|--------|--------|
 frame of frame of freezed  freezed  freezed
 beta     alpha    frame of frame of frame of
                    delta     beta    alpha
                  |........|
         freezed frame of D

                           |........|
                 freezed frames of B

                                    |.........|
                           freezed frames of A
@end example
@caption{Returning to @func{alpha}.}
@end float

@func{alpha} applies the escape function @var{K} to @func{values}; this
call happens in tail position, so the frame of @func{alpha} is reused by
the escape function, @ref{fig:continuation_apply_escape, compiler
machinery continuations}.  The escape function reinstalls the
continuation object @var{D} as ``process next continuation''.

@float Figure,fig:continuation_apply_escape
@example
          <-- growing direction --

|--------|--------|--------|--------|--------|
          frame of freezed  freezed  freezed
          K        frame of frame of frame of
                    delta     beta    alpha
@end example
@caption{Applying the continuation escape function.}
@end float

@c page
@node compiler machinery stack overflow
@subsection Scheme stack overflow


We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, @ref{compiler machinery
simplifications, Simplification assumptions}.

@c page
@node compiler machinery call arguments
@subsection Function call arguments


We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, @ref{compiler machinery
simplifications, Simplification assumptions}.


@c page
@node compiler machinery call retvals
@subsection Function call return values


We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, @ref{compiler machinery
simplifications, Simplification assumptions}.

@c page
@node compiler machinery tail calls
@subsection Tail calls implementation


We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, with the exception that we allow the
compiler to perform tail calls optimisation (@acronym{TCO}),
@ref{compiler machinery simplifications, Simplification assumptions}.

@c page
@node compiler machinery locals
@subsection Local variables


We assume the validity of machinery simplifications to focus on some
aspect of the runtime behaviour, @ref{compiler machinery
simplifications, Simplification assumptions}.

Local variables are put on the Scheme stack in such a way that the stack
frame can be left immutable if it is freezed in a Scheme continuation
object.  Immutable local variables and mutable local variables, before
the first mutation, are just put in machine words on the stack frame;
mutable local variables after the first mutation are put in the single
slot of a Scheme vector whose reference is put on the stack.

@c ------------------------------------------------------------

@subsubheading Immutable local variables only


Let's consider the following program in which the function @func{one}
has only immutable local variables:

@example
(import (rnrs))
(define (one A B)
  (let ((C 3)
        (D 4))
    (list A B C D)))
(one 1 2)
@end example

@noindent
right after the call to @func{one} the arguments are on the stack below
the return address, @ref{fig:CML_arguments_on_stack, compiler machinery
locals}.

@float Figure,fig:CML_arguments_on_stack
@example
      high memory
|                      |
|----------------------|         --
            .                    .
            .                    . caller
            .                    . stack frame
|----------------------|         .
|    return address    | <- FPR  .
|----------------------|         --
|    argument A == 1   |         .
|----------------------|         . stack frame
|    argument B == 2   |         . of ONE
|----------------------|         .
|                      |
       low memory
@end example
@caption{Stack frame with arguments.}
@end float

Then the local values are put on the stack, right below the arguments,
@ref{fig:CML_locals_on_stack, compiler machinery locals}.

@float Figure,fig:CML_locals_on_stack
@example
      high memory
|                      |
|----------------------|                      --
            .                                 .
            .                                 . caller
            .                                 . stack frame
|----------------------|                      .
|    return address    | <- FPR               .
|----------------------|                      --
|    argument A == 1   | <- FPR - 1*wordsize  .
|----------------------|                      .
|    argument B == 2   | <- FPR - 2*wordsize  .
|----------------------|                      . stack frame
|       local C == 3   | <- FPR - 3*wordsize  . of ONE
|----------------------|                      .
|       local D == 4   | <- FPR - 4*wordsize  .
|----------------------|                      .
|                      |
       low memory
@end example
@caption{Stack frame with arguments and local variables.}
@end float

We can imagine the function @func{one} compiled to pseudo--code as
follows:

@example
(define (one stack-slot-1 stack-slot-2)
  (let-on-stack ((stack-slot-3 3)
                 (stack-slot-4 4))
    (list stack-slot-1
          stack-slot-2
          stack-slot-3
          stack-slot-4)))
@end example

@noindent
if the Assembly code needs to copy the value of the local variable
@code{stack-slot-3} into the @cpu{} register @aar{}, it just does it as
stack memory access:

@example
(movl (disp (* -3 wordsize) FPR) AAR)
@end example

If a continuation object is created with this scenario on the stack:
everything is ready, because the stack frame never needs to be mutated.

@c ------------------------------------------------------------

@subsubheading Mutable local variables


Let's consider the following program in which the function @func{one}
has both an immutable local variable and a mutable one:

@example
(import (rnrs))
(define (one A B)
  (let ((C 3)
        (D 4))
    (display (list A B C D))
    (set! D 41)
    (display (list A B C D))
    (set! D 42)
    (display (list A B C D))))
(one 1 2)
@end example

@noindent
after the call to @func{one} the arguments and the local variables are
put on the stack below the return address, @ref{fig:CML_before_mutation,
compiler machinery locals}.

@float Figure,fig:CML_before_mutation
@example
      high memory
|                      |
|----------------------|                      --
            .                                 .
            .                                 . caller
            .                                 . stack frame
|----------------------|                      .
|    return address    | <- FPR               .
|----------------------|                      --
|    argument A == 1   | <- FPR - 1*wordsize  .
|----------------------|                      .
|    argument B == 2   | <- FPR - 2*wordsize  .
|----------------------|                      . stack frame
|       local C == 3   | <- FPR - 3*wordsize  . of ONE
|----------------------|                      .
|       local D == 4   | <- FPR - 4*wordsize  .
|----------------------|                      .
|                      |
       low memory
@end example
@caption{Stack frame with arguments and local variables before the first
local variable mutation.}
@end float

Before the first local variable mutation (the @code{set!} form): if the
Assembly code needs to copy the value of the local variable
@code{stack-slot-4} into the @cpu{} register @aar{}, it just does it as
stack memory access:

@example
(movl (disp (* -3 wordsize) FPR) AAR)
@end example

@noindent
because the value is just there.  If a continuation object is created
with this scenario on the stack: everything is ready, because the stack
frame never needs to be mutated.

When the mutable local variable is assigned: something has to change.
We can imagine the function @func{one} compiled to pseudo--code as
follows:

@example
(define (one stack-slot-1 stack-slot-2)
  (let-on-stack ((stack-slot-3 3)
                 (stack-slot-4 4))
    (display (list stack-slot-1
                   stack-slot-2
                   stack-slot-3
                   stack-slot-4))
    (set! stack-slot-4 (vector 41))
    (display (list stack-slot-1
                   stack-slot-2
                   stack-slot-3
                   ($vector-ref stack-slot-4 0)))
    ($vector-set! stack-slot-4 0 42)
    (display (list stack-slot-1
                   stack-slot-2
                   stack-slot-3
                   ($vector-ref stack-slot-4 0)))))
@end example

@noindent
whenever the local variable assignment happens: a Scheme vector is
allocated on the heap and filled with the new variable's value; then a
reference to such object is stored in the stack slot reserved to the
local variable.  From this point onwards: access to the local variable
happens through the primitive operations @func{$vector-ref} and
@func{$vector-set!}.

If a continuation object is created after the local variable first
mutation: everything is ready, the stack frame does not need to be
mutated because the mutable location is in the Scheme vector.

@c ------------------------------------------------------------

@subsubheading Mutable arguments


Mutable argument bindings are handled in the same way of mutable local
variables.  Let's consider the following program in which the function
@func{one} has a mutable argument:

@example
(import (rnrs))
(define (one A)
  (display A)
  (set! A 2)
  (display A)
  (set! A 3)
  (display A))
(one 1)
@end example

@noindent
We can imagine the function @func{one} compiled to pseudo--code as
follows:

@example
(define (one stack-slot-1)
  (display stack-slot-1)
  (set! stack-slot-1 (vector 2))
  (display ($vector-ref stack-slot-1 0))
  ($vector-set! stack-slot-1 0 3)
  (display ($vector-ref stack-slot-1 0))
@end example

@c page
@node compiler code
@section Introduction to compiler's code


@menu
* compiler code conventions::   Compiler coding conventions.
@end menu

@c page
@node compiler code conventions
@subsection Compiler coding conventions


Throughout the compiler code variables with the following names appear:

@table @var
@item op
Scheme symbol representing an @strong{operation} to be directly
translated into assembly.  Examples: @samp{alloc}, @samp{mref},
@samp{mref32}, @samp{bref}, @samp{logand}, @samp{logxor}, @samp{logor},
@samp{int+}, @samp{int-}, @samp{int*}, @samp{int-quotient},
@samp{int-remainder}, @samp{sll}, @samp{sra}.

@item rator
Represents a reference to an @strong{operator}: a function coded in
assembly or C language.

@item rands
Scheme list holding the @strong{operands} to which an operation must be
applied.  These operands are in such a format that can be directly used
in the assembly S--expression like:

@example
(make-set eax (car rands))
@end example

@noindent
which generate an assignment operation to store the first element of
@var{rands} into the @code{eax} processor register.
@end table

@c page
@node compiler stack
@section Scheme stack management


In this section we want to explain how the Scheme stack in managed by
@value{PRJNAME}.

@menu
* compiler stack alloc::        Stack allocation and basic management.
* compiler stack args::         Function arguments on the stack.
* compiler stack call::         Executing a @code{call} instruction.
@end menu

@c page
@node compiler stack alloc
@subsection Stack allocation and basic management


The Scheme stack is a block of memory allocated with @cfunc{mmap};
multiple blocks are allocated when more space is needed, each block is
called @dfn{stack segment}.  At any moment, the stack segment currently
in use is referenced by the following fields of the @pcb{} structure:

@table @code
@item ikptr stack_base
Raw memory pointer referencing the first byte in the stack segment.

@item unsigned long stack_size
Number of bytes allocated for this stack segment; it is always a
multiple of the host system page size.
@end table

@example
pcb->stack_base         use growth
       v              <-------------
lo mem |-------------------------------------| hi mem

       |.....................................| pcb->stack_size
@end example

When first allocated by C code, the stack is empty.  In the tradition of
stacks: the use of a stack segment grows from high memory addresses to
low memory addresses.

@c ------------------------------------------------------------

@subsubheading Calling Scheme functions and returning

Entering Scheme code from C code and exiting Scheme code to C code does
not happen directly; rather it involves hand--written assembly code:

@itemize
@item
The C code calls an assembly routine which prepares the @cpu{}
registers, then calls a Scheme function.

@item
The Scheme code returns to the assembly routine, which in turn restores
the @cpu{} registers and returns to the C code.
@end itemize

@noindent
the assembly code is in the file @file{ikarus-enter.S}, the C function
calling the assembly routine is in the file @file{ikarus-exec.c}.

Calling functions and returning from them is performed as follows:

@itemize
@item
Entering Scheme code execution from assembly code always involves the
execution of the assembly instruction @code{call}.

@item
Calling a Scheme function from Scheme code happens through a @code{call}
or @code{jmp} instruction.

@item
Returning from Scheme code to Scheme code happens through a @code{ret}
or @code{jmp} instruction.

@item
Returning from Scheme code to assembly code happens through a @code{ret}
or @code{jmp} instruction.
@end itemize

For simplicity in introducing the stack management, we assume that:

@itemize
@item
Calling a Scheme function always happens through a @code{call}
instruction.

@item
Returning from a function call always happens through a @code{ret}
instruction.

@item
All the Scheme functions return a single value.
@end itemize

The assembly routine calling Scheme code is @code{ik_asm_enter} and its
return address is labeled @code{ik_underflow_handler}; assuming
@var{REG} is a @cpu{} register holding the address of a Scheme function,
the assembly code is similar to:

@example
ik_asm_enter:
   ...                          ;assembly instructions
   call *@var{REG}
ik_underflow_handler:
   ...                          ;assembly instructions
   ret                          ;return to C code
@end example

@noindent
when the @code{call} is performed: the return address
@code{ik_underflow_handler} is pushed on the stack.

@c ------------------------------------------------------------

@subsubheading Stack frames

The @cpu{} keeps track of the current position on the stack with the
@dfn{Frame Pointer Register} (@fpr{}, which is @code{%esp} on the Intel
architecture); such register contains the memory address of the current
stack location, the @dfn{top} of the stack.  The first function frame
starts from the end of the stack segment; when we enter Scheme code for
the first time, we set the @fpr{} so that it references the machine word
right after the end of the stack segment:

@example
pcb->stack_base         use growth           FPR
       v              <-------------          v
lo mem |-------------------------------------|-| hi mem

       |.....................................| pcb->stack_size
@end example

@noindent
and perform a @code{call} instruction which pushes the return address
@code{ik_underflow_handler} on the stack segment, decrementing @fpr{} by
a wordsize; so right after the first @code{call}, the stack segment
looks as follows:

@example
                        high memory
                  |                      |
               -- |----------------------|          --
                . | ik_underflow_handler | <-- FPR  . frame
                . |----------------------|          --
pcb->stack_size .            ...
                . |----------------------|
                . |                      | <-- pcb->stack_base
               -- |----------------------|
                  |                      |
                         low memory
@end example

@noindent
performing a @code{ret} assembly instruction in this situation would
just increment the @fpr{} and let the execution flow go back to the code
at the assembly label @code{ik_underflow_handler}.  Notice that we first
enter a Scheme program by calling a Scheme function with zero arguments.

@ref{compiler stack args} for details on how function arguments are put
on the stack; here we only need to know that a function occupies some
space on the stack, called a @dfn{stack frame}:

@example
      high memory
|                      |
|----------------------|         --
|    return address    | <-- FPR .
|----------------------|         .
|     local value 0    |         . function
|----------------------|         . stack
|     local value 1    |         . frame
|----------------------|         .
|     local value 2    |         .
|----------------------|         --
|                      |
       low memory
@end example

@c ------------------------------------------------------------

@subsubheading Handling stack overflow

Nested function call after nested function call the stack segment fills
up towards low memory addresses:

@example
pcb->stack_base         use growth
       v              <-------------
lo mem |-------------------------------------| hi mem

       |...................|.....|.....|.....|
                            frame frame frame
@end example

@noindent
there is a limit, a ``red line'', below which the current stack segment
is considered full: we need to allocate a new one and allocate the
function frames there.  The limit is registered in the @pcb{} structure
fields:

@table @code
@item ikptr frame_redline
Raw memory pointer referencing a location in the current stack segment;
when Scheme code execution uses the stack crossing the ``red line''
represented by this field: the current stack segment is considered full.
@end table

A stack segment in stack overflow looks like this:

@example
pcb->stack_base  pcb->frame_redline
       v          v
lo mem |----------+--------------------------| hi mem

       |.......|.....|.....|.....|.....|.....|
        unused  frame frame frame frame frame
@end example

Each compiled Scheme function contains, right at the beginning, code
that checks if the red line has been crossed; so, when a stack segment
is full, at the first subsequent Scheme function call, @value{PRJNAME}
takes control and allocates a new stack segment doing what is needed to
proceed the execution on the new stack.  This ``proceeding on the new
stack'' is called @dfn{stack overflow}.

How is this implemented?  Let's say we have called a function
@func{alpha} whose frame has crossed the red line, then the function
@func{beta} is called:

@example
      high memory
|                      |
|----------------------|                         --
|    return address    |                         .
|----------------------|                         .
|     local value 0    |                         . alpha
|----------------------|                         . frame
|     local value 1    | <-- pcb->frame_redline  .
|----------------------|                         .
|     local value 2    |                         .
|----------------------|                         --
|    return address    | <-- FPR                 .
|----------------------|                         .
|     local value 0    |                         . beta
|----------------------|                         . frame
|     local value 1    |                         .
|----------------------|                         .
|     local value 2    |                         .
|----------------------|                         --
|                      |
       low memory
@end example

@noindent
the code in @func{beta} detects the situation simply by the comparison:

@example
pcb->frame_redline < FPR
@end example

@noindent
and calls an routine to exit Scheme code execution and call the C
function @cfunc{ik_stack_overflow}.  A new stack segment is called

@c QUIIIIIIIIIIIIIIIIIIIIII

the current
Scheme stack is stored away in a Scheme continuation and a new stack
segment is allocated and installed as Scheme stack.  See the C function
 for how this is implemented.  When the
function returns: the stored continuation is reinstated and execution
continues on the old stack.

@c ------------------------------------------------------------

@subsubheading Context switching between Scheme code and C code

@table @code
@item ikptr frame_pointer
@item ikptr frame_base
@end table

@c page
@node compiler stack args
@subsection Function arguments on the stack


Right after the first function call that enters Scheme code from
assembly code, the stack segment looks as follows:

@example
      high memory
|                      |
|----------------------|
|                      | <-- pcb->frame_base
|----------------------|
| ik_underflow_handler | <-- FPR
|----------------------|
           ...
|----------------------|
|                      | <-- pcb->stack_base
|----------------------|
|                      |
       low memory
@end example

If the called Scheme function needs some local variables, it allocates
them on the stack:

@example
      high memory
|                      |
|----------------------|                         --
| ik_underflow_handler | <-- FPR                 .
|----------------------|                         .
|   local variable 0   | <-- FPR - 1 * wordsize  . first
|----------------------|                         . called
|   local variable 1   | <-- FPR - 2 * wordsize  . function
|----------------------|                         . frame
|   local variable 2   | <-- FPR - 3 * wordsize  .
|----------------------|                         --
|                      |
       low memory
@end example

@noindent
notice that local values are ``moved'' on the stack, not ``pushed'':
executing the assembly instruction @code{push} would decrement the
@fpr{}, we do not want this; rather we reserve frame space for a
function call and never mutate the @fpr{} until the function returns or
calls another function.

If the Scheme function needs to call another Scheme function, as in:

@example
(sub-func arg0 arg1 arg2)
@end example

@noindent
it moves the arguments on the stack, leaving an empty machine word:

@example
      high memory
|                      |
|----------------------|         --
| ik_underflow_handler | <-- FPR .
|----------------------|         .
|   local variable 0   |         . first
|----------------------|         . called
|   local variable 1   |         . function
|----------------------|         . frame
|   local variable 2   |         .
|----------------------|         --
|                      |
|----------------------|
|      argument 0      |
|----------------------|
|      argument 1      |
|----------------------|
|      argument 2      |
|----------------------|
|                      |
       low memory
@end example

@noindent
it adjusts the @fpr{} by explicitly subtracting the appropriate offset
from it:

@example
      high memory
|                      |
|----------------------|         --
| ik_underflow_handler |         .
|----------------------|         .
|   local variable 0   |         . first
|----------------------|         . called
|   local variable 1   |         . function
|----------------------|         . frame
|   local variable 2   | <-- FPR .
|----------------------|         --
|                      |
|----------------------|
|      argument 0      |
|----------------------|
|      argument 1      |
|----------------------|
|      argument 2      |
|----------------------|
|                      |
       low memory
@end example

@noindent
and finally it performs a @code{call} instruction, which pushes a return
address on the stack right in the empty machine word:

@example
      high memory
|                      |
|----------------------|         --
| ik_underflow_handler |         .
|----------------------|         .
|   local variable 0   |         . first
|----------------------|         . called
|   local variable 1   |         . function
|----------------------|         . frame
|   local variable 2   |         .
|----------------------|         --
|    return address    | <-- FPR .
|----------------------|         .
|      argument 0      |         . sub-func
|----------------------|         . called
|      argument 1      |         . function
|----------------------|         . frame
|      argument 2      |         .
|----------------------|         --
|                      |
       low memory
@end example

When the function @func{sub-func} executes a @code{ret} instruction: the
execution flow returns to @code{return address} and the @fpr{} is
incremented by a machine word:

@example
      high memory
|                      |
|----------------------|         --
| ik_underflow_handler |         .
|----------------------|         .
|   local variable 0   |         . first
|----------------------|         . called
|   local variable 1   |         . function
|----------------------|         . frame
|   local variable 2   | <-- FPR .
|----------------------|         --
|                      |
       low memory
@end example

@noindent
now the first called function adjusts the @fpr{} by explicitly adding
the appropriate offset to it:

@example
      high memory
|                      |
|----------------------|         --
| ik_underflow_handler | <-- FPR .
|----------------------|         .
|   local variable 0   |         . first
|----------------------|         . called
|   local variable 1   |         . function
|----------------------|         . frame
|   local variable 2   |         .
|----------------------|         --
|                      |
       low memory
@end example

@noindent
and is finally ready to go on with the execution.

@c page
@node compiler stack call
@subsection Executing a @code{call} instruction


The usual mechanism of performing an assembly language @code{call}
instruction is this:

@example
caller's code   callee's code       stack
 --- lo mem       --- lo mem         --- hi mem
  .                .                  .
  .                .                  .  caller stuff
  .                .                  .
 call FUNC        enter <-- FUNC      .   <--- %esp before
 after <-- ADDR    .                 ADDR <--- %esp after
  .                .                  .
  .               ret                 .   calleee stuff
  .                .                  .
 --- hi mem       --- hi mem         --- lo mem
@end example

@noindent
when the caller executes a @code{call} instruction:

@enumerate
@item
The stack pointer register @code{%esp} is decremented by the size of a
machine word.

@item
The memory address referencing the first byte of the instruction
@code{after} is stored on the memory location referenced by the stack
pointer register @code{%esp}.

@item
The execution flow jumps to the memory address @code{FUNC}, which must
contain the first byte of the instruction @code{enter}.
@end enumerate

The usual mechanism of performing an assembly language @code{ret}
instruction is this:

@example
caller's code   callee's code       stack
 --- lo mem       --- lo mem         --- hi mem
  .                .                  .
  .                .                  .  caller stuff
  .                .                  .
 call FUNC       enter <-- FUNC       .   <--- %esp after
 after <-- ADDR    .                 ADDR <--- %esp before
  .                .                  .
  .               ret                 .   calleee stuff
  .                .                  .
 --- hi mem       --- hi mem         --- lo mem
@end example

@noindent
when the callee executes a @code{ret} instruction:

@enumerate
@item
The memory address referenced by the stack pointer register @code{%esp}
is stored in then instruction pointer register.

@item
The stack pointer register @code{%esp} is incremented by the size of a
machine word.

@item
The execution flow jumps to the memory address in the instruction
pointer.
@end enumerate

@noindent
after the @code{ret} the stack is left in the same state it was at the
moment the @code{call} was executed.

Now let's say that, when generating binary code for a @code{call}
instruction, we put some static data right before the @code{call}:

@example
 caller's code              stack
    --- lo mem               --- hi mem
     .                        .
     .                        .
     .                        .
    jmp L0                    .
    data_machine_word_1       .   <--- %esp before call
    data_machine_word_2      ADDR <--- %esp after call
    data_machine_word_3       .
    call FUNC  <--- L0        .
    after      <--- ADDR      .
     .                        .
     .                        .
     .                        .
    --- hi mem               --- lo mem
@end example

@noindent
let's name @code{call_size} the number of bytes occupied by the
instruction @code{call FUNC}; when the callee begins execution:

@itemize
@item
It can access the return address by retrieving the machine word at
@code{%esp}.

@item
It can access the constant @code{data_machine_word_1} by retrieving the
machine word at:

@example
%esp - call_size - 0 * wordsize
@end example

@item
It can access the constant @code{data_machine_word_2} by retrieving the
machine word at:

@example
%esp - call_size - 1 * wordsize
@end example

@item
It can access the constant @code{data_machine_word_3} by retrieving the
machine word at:

@example
%esp - call_size - 2 * wordsize
@end example
@end itemize

@c end of file
