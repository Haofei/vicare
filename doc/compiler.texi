@node compiler
@chapter Low level interface to the compiler


@cindex @library{vicare system $compiler}, library
@cindex Library @library{vicare system $compiler}
@cindex Compiler passes
@cindex Passes, compiler


@value{PRJNAME} is a compiler for the Scheme language; internally it
implements a multitude of passes, each of which performing a
transformation step from Scheme code to executable binary code.  The
library @library{vicare system $compiler} exports one binding for each
compiler pass, allowing inspection of the performed transformations.

This section contains some documentation for each pass; however, it is
almost impossible to truly understand what a pass does without reading
the source code, where additional documentation is present in the form
of comments.

@menu
* compiler intro::              Introduction to the compilation process.
* compiler conv::               Compiler coding conventions.
* compiler topics::             Inspection by topics.
* compiler options::            General configuration options.
* compiler unparse::            Unparsing intermediate representations.

Compiler passes

* compiler full::               The full transformation.
* compiler recordize::          Scheme code to nested structs.
* compiler dircalls::           Optimisation for direct calls.
* compiler letrec::             Optimisation of @func{letrec} and @func{letrec*}
                                forms.
* compiler optimisation::       Source optimisation.
* compiler refassig::           Rewriting references and assignments.
* compiler tags::               Tagging known properties.
* compiler sanitise bindings::  Sanitising bindings.
* compiler direct jumps::       Optimisation for direct jumps.
* compiler global assign::      Inserting global assignments.
* compiler vars::               Introducing storage locations.
* compiler closure makers::     Introducing closure makers.
* compiler lifting::            Closures optimization and @objtype{clambda}
                                lifting.
* compiler primcalls::          Introducing primitive calls.
* compiler freevar refs::       Rewriting references to free variables.
* compiler engine::             Inserting engine checks.
* compiler stack::              Inserting stack overflow checks.
* compiler cogen::              Full assembly code generation.
* compiler assember::           Binary code generation.

Code generation passes

* compiler primop::             Expanding primitive operations.
* compiler order::              Imposing calling convention and
                                evaluation order.
* compiler frame::              Assigning frame sizes.
* compiler color::              Colorising by Chaitin.
* compiler flatten::            Flattening codes.
@end menu

@c page
@node compiler intro
@section Introduction to the compilation process


@cindex Core language


An expression in the core language is Scheme code fully expanded in
which: no syntactic bindings are present; all the lexical bindings have
a unique name represented by a lex gensym; all the top level lexical
bindings are associated to a loc gensym used to hold the binding's
current value.  The compiler is used to process:

@itemize
@item
Full @func{library} forms and full @rnrs{6} programs the expander has
transformed into @func{library-letrec*} core language forms.

@item
Standalone expressions from invocations of @rnrs{6}'s @func{eval}, for
example read by the @repl{}, either in the context of a stateless
environment or in the context of a stateful interactive environment.
@end itemize

@noindent
these symbolic expressions must be compiled after correct initialisation
of location gensyms for:

@itemize
@item
All the lexical bindings defined by the boot image.

@item
All the lexical bindings defined by the imported libraries.

@item
All the bindings previously defined in the stateful interactive
environment, if such was used for the expansion process.
@end itemize

The compiler recognises the following core language forms, whose
semantics is similar to the corresponding standard language syntax:

@example
(library-letrec* ((@meta{lhs} @meta{loc} @meta{rhs}) ...) @meta{body})
(quote @meta{datum})
(if @meta{test} @meta{consequent} @meta{alternate})
(set! @meta{lhs} @meta{rhs})
(begin @metao{body} @meta{body} ...)
(let     ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(letrec  ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(letrec* ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(case-lambda (@meta{formals} @meta{body}) ...)
(annotated-case-lambda @meta{annotation} (@meta{formals} @meta{body}) ...)
(lambda @meta{formals} @meta{body})
(foreign-call "@meta{function-name}" @meta{arg} ...)
(primitive @meta{prim})
(annotated-call @meta{annotation} @meta{fun} @meta{arg} ...)
@meta{lex}
(@meta{func} @meta{arg} ...)
@end example

@noindent
where: a standalone @meta{lex} atom is a lex gensym, interpreted as
reference to binding; @meta{lhs} stands for ``left--hand side'' and it
is a lex gensym; @meta{rhs} stands for ``right--hand side''; @meta{loc}
is a loc gensym; @meta{prim} is a symbol representing the public name of
a core lexical primitive.

@c page
@node compiler conv
@section Compiler coding conventions


Throughout the compiler code variables with the following names appear:

@table @var
@item op
Scheme symbol representing an @strong{operation} to be directly
translated into assembly.  Examples: @samp{alloc}, @samp{mref},
@samp{mref32}, @samp{bref}, @samp{logand}, @samp{logxor}, @samp{logor},
@samp{int+}, @samp{int-}, @samp{int*}, @samp{int-quotient},
@samp{int-remainder}, @samp{sll}, @samp{sra}.

@item rator
Represents a reference to an @strong{operator}: a function coded in
assembly or C language.

@item rands
Scheme list holding the @strong{operands} to which an operation must be
applied.  These operands are in such a format that can be directly used
in the assembly S--expression like:

@example
(make-set eax (car rands))
@end example

@noindent
which generates an assignment operation to store the first element of
@var{rands} into the @code{eax} processor register.
@end table

@c page
@node compiler topics
@section By topic inspection of behaviour


It is useful to inspect how the compiler handles specific code elements
throughout different passes.

@menu
* compiler topics topbind::     Handling of lexical top level bindings.
* compiler topics locbind::     Handling of lexical local bindings.
* compiler topics clambda::     Handling of lambda expressions.
@end menu

@c page
@node compiler topics topbind
@subsection Handling of lexical top level bindings


@subsubheading Core language representation

Bindings defined by the core language form @func{library-letrec*} are
named @dfn{top level bindings}; they are akin to the C language ``global
variables''.  The form @func{library-letrec*} has the format:

@example
(library-letrec* ((@meta{lex} @meta{loc} @meta{init}) ...) @meta{body})
@end example

@noindent
in which: @meta{lex} is a lexical gensym that uniquely identifies the
binding in the core language form; @meta{loc} is a location gensym which
will be used at run--time to hold the current value of the binding in
its @code{value} slot; @meta{init} is the initialisation expression.

References to top level bindings are represented by standalone
@meta{lex} gensyms; assignments to top level bindings are represented by
@func{set!} forms:

@example
(set! @meta{lex} @meta{rhs})
@end example

@noindent
where the right--hand side expression @meta{rhs} will, at run--time,
evaluate to the new binding's value.

@c ------------------------------------------------------------

@subsubheading Recordised language representation

The @func{library-letrec*} form is recordised into a @objtype{rec*bind}
form:

@example
(rec*bind ((@meta{prel} @meta{init}) ...) @meta{body})
@end example

@noindent
in which @meta{prel} is a @objtype{prelex} struct holding both the
@meta{lex} and @meta{loc} gensyms.  References to top level bindings are
represented by standalone @objtype{prelex} structs; assignments to top
level bindings are represented by @objtype{assign} structs:

@example
(assign @meta{prel} @meta{rhs})
@end example

@c ------------------------------------------------------------

@subsubheading Implementation of references and assignments

Since the actual value of a top level binding is stored in the
@code{value} field of a loc gensym:

@itemize
@item
References to top level bindings must be transformed into:

@example
(funcall (primref $symbol-value) (constant @meta{loc}))
@end example

@noindent
which extracts the value from slot @code{value} of @meta{loc}.

@item
Common assignments to top level bindings must be transformed into:

@example
(funcall (primref $set-symbol-value!)
         (constant @meta{loc})
         @meta{rhs})
@end example

@noindent
which stores a new value in the slot @code{value} of @meta{loc}.

@item
Single assignments to top level bindings which also serve as binding
initialisations must be transformed into:

@example
(funcall (primref $init-symbol-value!)
         (constant @meta{loc})
         @meta{rhs})
@end example

@noindent
which stores a new value in the slot @code{value} of @meta{loc} and,
only if the value is recognised at run--time as being closure object,
also stores value in the slot @code{proc}.
@end itemize

@c ------------------------------------------------------------

@subsubheading Results of optimising @objtype{rec*bind} forms

A compiler pass takes care of performing ``@func{letrec} optimisation'':
structs of type @objtype{rec*bind} are transformed into a nested
hierarchy of @objtype{bind}, @objtype{fix} and @objtype{assign} forms.
Different cases must be handled in different ways.

@itemize
@item
Some non--recursive ``simple'' and unassigned bindings end up defined as
follows:

@example
(bind ((@meta{prel} @meta{init}))
  @meta{body})
@end example

@noindent
the transformation of references is straightforward.  As example, let's
consider:

@example
(library-letrec*
    ((a.lex a.loc '1)
     (b.lex b.loc '2))
  ((primitive display) a.lex b.lex))
@end example

@noindent
which is recordised and transformed into:

@example
(bind ((a.lex_0 (constant 1)))
  (bind ((b.lex_0 (constant 2)))
    (funcall (primref display) (constant 1) (constant 2))))
@end example

@noindent
in which the references to bindings are integrated by the source
optimiser.

@item
Some non--recursive ``simple'' and assigned bindings end up defined as
follows:

@example
(bind ((@meta{prel} @meta{init}))
  @meta{body})
@end example

@noindent
the transformation of references and assignments is straightforward.  As
example, let's consider:

@example
(library-letrec*
    ((a.lex a.loc '1)
     (b.lex b.loc '2))
  (begin
    (set! a.lex '11)
    (set! b.lex '22)
    ((primitive display) a.lex b.lex)))
@end example

@noindent
which is recordised and transformed into:

@example
(bind ((a.lex_0 (constant 1)))
  (bind ((b.lex_0 (constant 2)))
    (seq
      (funcall (primref $set-symbol-value!)
               (constant a.loc)
               (constant 11))
      (funcall (primref $set-symbol-value!)
               (constant b.loc)
               (constant 22))
      (funcall (primref display)
               (funcall (primref $symbol-value)
                        (constant a.loc))
               (funcall (primref $symbol-value)
                        (constant b.loc))))))
@end example

@item
Some @strong{unassigned} top level bindings end up defined (roughly) as
follows:

@example
(bind ((@meta{prel} (constant #<void>)))
  (assign @meta{prel} @meta{init})
  @meta{body})
@end example

@noindent
this might happen when the initialisation expressions in the original
@objtype{rec*bind} need to access the machine words in which the
bindings' values are stored; so, at run--time, first we need to allocate
the loc gensyms and then we can evaluate the initialisation expressions
and store the resulting value in the gensym itself.

In this special case, since the binding is unassigned in the original
code, the @objtype{assign} struct is introduced by the compiler and it
is the only assignment for the binding.  The compiler recognises this
case and transforms:

@example
(assign @meta{prel} @meta{init})
@end example

@noindent
into:

@example
(funcall (primref $init-symbol-value!)
         (constant @meta{loc})
         @meta{init})
@end example

@noindent
in which @meta{loc} is the loc gensym of the binding.

@item
When top level bindings are unassigned and have initialisation
expression being a @objtype{clambda} form: they end up being defined by
a @objtype{fix} struct; the @func{letrec} optimiser takes care of
recognising and handling such case.  As example:

@example
(library-letrec*
    ((a.lex a.loc (lambda () '1))
     (b.lex a.loc (lambda () '2)))
  ((primitive display) (a.lex)))
@end example

@noindent
is transformed into:

@example
(fix ((a.lex_0 (lambda () (constant 1)))
      (b.lex_0 (lambda () (constant 2))))
  (funcall (primref display) (constant 1)))
@end example

@noindent
in which the call to @func{a.lex} is integrated by the source optimiser.
@end itemize

@c page
@node compiler topics locbind
@subsection Handling of lexical local bindings


Lexical local bindings are defined in the core language by the forms:
@func{let}, @func{letrec}, @func{letrec*}, @func{lambda},
@func{case-lambda}, @func{annotated-case-lambda}.  These forms have
syntax:

@example
(let     ((@meta{lex} @meta{rhs}) ...) @meta{body})
(letrec  ((@meta{lex} @meta{rhs}) ...) @meta{body})
(letrec* ((@meta{lex} @meta{rhs}) ...) @meta{body})
(case-lambda (@meta{formals} @meta{body}) ...)
(annotated-case-lambda @meta{annotation} (@meta{formals} @meta{body}) ...)
(lambda @meta{formals} @meta{body})
@end example

@noindent
in which: @meta{lex} is a lexical gensym that uniquely identifies the
binding in the core language form; @meta{rhs} is the initialisation
expression; @meta{formals} is a proper or improper list of lex gensyms
uniquely identifying arguments to function.

References to local bindings are represented by standalone @meta{lex}
gensyms; assignments to local bindings are represented by @func{set!}
forms:

@example
(set! @meta{lex} @meta{rhs})
@end example

@noindent
where the right--hand side expression @meta{rhs} will, at run--time,
evaluate to the new binding's value.

@c ------------------------------------------------------------

@subsubheading Recordised language representation

The @func{let}, @func{letrec} and @func{letrec*} forms are recordised
into nested hierarchies of @objtype{bind}, @objtype{recbind} and
@objtype{rec*bind} structs:

@example
(bind     ((@meta{prel} @meta{rhs}) ...) @meta{body})
(recbind  ((@meta{prel} @meta{rhs}) ...) @meta{body})
(rec*bind ((@meta{prel} @meta{rhs}) ...) @meta{body})
@end example

@noindent
in which @meta{prel} is a @objtype{prelex} struct holding the @meta{lex}
gensym.

The @func{lambda}, @func{case-lambda} and @func{annotated-case-lambda}
forms are recordised as @objtype{clambda} structs:

@example
(clambda (@meta{prel-formals} @meta{body}) ...)
@end example

@noindent
in which @meta{prel-formals} is a a proper or improper list of
@objtype{prel} structs representing arguments to each @objtype{clambda}
clause.

References to local bindings are represented by standalone
@objtype{prelex} structs; assignments to local bindings are represented
by @objtype{assign} structs:

@example
(assign @meta{prel} @meta{rhs})
@end example

@c ------------------------------------------------------------

@subsubheading Implementation of references and assignments

We distinguish between bindings that are only referenced (unassigned,
read--only) and bindings that are also assigned (assigned, read--write).
Example of code in which the binding @code{X} is only referenced:

@example
(let ((X 123)) (display X))
@end example

@noindent
example of code in which the binding @code{X} is assigned and
referenced:

@example
(let ((X 123)) (set! X 456) (display X))
@end example

The implementation technique for continuations used by @value{PRJNAME}
mandates that: once an immediate Scheme object or reference to
non--immediate Scheme object is stored in a machine word on the Scheme
stack, such machine word @strong{must not be mutated}; this allows the
run--time system to copy stack frames at will.  As a consequence the
following implementation techniques for local bindings are adopted:

@itemize
@item
The value of unassigned lexical local bindings is stored in words
allocated on the Scheme stack, with no further troubles.

@item
The value of assigned lexical local bindings is stored in single--slot
vectors providing mutable memory locations: a vector of one slot for
each binding; a word allocated on the Scheme stack contains a reference
to the single--slot vector.
@end itemize

References to unassigned bindings must be implemented as Scheme stack
operations; references and assignments to assigned bindings must be
substituted with appropriate vector operations.

@c ------------------------------------------------------------

@subsubheading Recordisation and transformation of unassigned bindings

After the @func{letrec} optimiser has processed @objtype{recbind} and
@objtype{rec*bind} forms, unassigned local bindings always end up
defined as:

@example
(bind ((@meta{prel} @meta{rhs})) @meta{body})
@end example

@noindent
and references are represented by standalone @objtype{prelex} structs.
Whenever a @meta{rhs} expression is recognised to be of type
@objtype{clambda}, the corresponding @objtype{bind} is transformed into:

@example
(fix ((@meta{prel} @meta{rhs})) @meta{body})
@end example

@noindent
No further transformations are needed for recordised code.

@c ------------------------------------------------------------

@subsubheading Recordisation and transformation of assigned bindings

After the @func{letrec} optimiser has processed @objtype{recbind} and
@objtype{rec*bind} forms, assigned local bindings always end up defined
as:

@example
(bind ((@meta{prel} @meta{rhs})) @meta{body})
@end example

@noindent
references are represented by standalone @objtype{prelex} structs and
assignments are represented by @objtype{assign} structs.

@quotation
@strong{NOTE} No matter if a @meta{rhs} expression is of type
@objtype{clambda}: its associated @objtype{bind} struct is @strong{not}
transformed into a @objtype{fix} struct; only unassigned
@objtype{clambda} bindings can be defined by a @objtype{fix} struct.
@end quotation

Definitions, references and assignments are transformed by introducing
the appropriate vector operations; such operation are equivalent to the
following:

@example
(let ((x 123))
  (set! x 456)
  x)
@end example

@noindent
is transformed into:

@example
(let ((t 123))
  (let ((x (vector t)))
    ($vector-set! x 0 456)
    ($vector-ref  x 0)))
@end example

@noindent
where the temporary binding @code{t} is generated by the compiler; the
code always only access the first and single slot of the vector.  Using
recordised code:

@example
(bind ((x_0 123))
  (seq
    (assign x_0 456)
    x))
@end example

@noindent
is transformed into:

@example
(bind ((x_0 123))
  (bind ((x_1 (funcall (primref vector) x_0)))
    (seq
      (funcall (primref $vector-set!)
               x_1
               (constant 0)
               (constant 456))
      (funcall (primref $vector-ref)
               x_1
               (constant 0)))))
@end example

Formal bindings in @objtype{clambda} structs are also processed this
way; for example:

@example
(lambda (a)
  (display a)
  (set! a 1)
  a)
@end example

@noindent
is transformed into:

@example
(lambda (a_0)
  (bind ((a_1 (funcall (primref vector) a_0)))
    (seq
      (funcall (primref display)
               (funcall (primref $vector-ref)
                        a_1 (constant 0)))
      (funcall (primref $vector-set!)
               a_1 (constant 0) (constant 1))
      (funcall (primref $vector-ref)
               a_1 (constant 0)))))
@end example

@quotation
@strong{NOTE} Assigned local bindings whose RHS expression is a
@objtype{clambda} struct are also transformed by introducing a vector.
After this transformation: there are no more @objtype{bind} struct whose
RHS is a @objtype{clambda} struct.
@end quotation

@c page
@node compiler topics clambda
@subsection Handling of lambda expressions


@c ------------------------------------------------------------

@subsubheading Handling of assigned @objtype{clambda} bindigns

If a binding is assigned, it is defined by a @objtype{bind} struct:

@example
(bind ((@meta{lhs} @meta{init}))
  (seq
    (assign @meta{lhs} @meta{rhs})
    @meta{rest}))
@end example

@noindent
and so it is transformed by introducing a vector to hold the read--write
machine word:

@example
(bind ((@meta{tmp} @meta{init}))
  (bind ((@meta{lhs} (funcall (primref vector) @meta{tmp})))
    (seq
      (funcall (primref $vector-set!)
               @meta{lhs} (constant 0) @meta{rhs})
      @meta{rest})))
@end example

@noindent
if its @meta{init} expression is a @objtype{clambda} struct, it is
further transformed as follows:

@example
(fix ((@meta{tmp} @meta{clambda}))
  (bind ((@meta{lhs} (funcall (primref vector) @meta{tmp})))
    (seq
      (funcall (primref $vector-set!)
               @meta{lhs} (constant 0) @meta{rhs})
      @meta{rest})))
@end example

@noindent
so, in the end, @objtype{clambda} expressions originally bound to
assigned bindings end up defined by @objtype{fix} forms.

@c page
@node compiler options
@section General configuration options


The following bindings are exported by the library @library{vicare
system $compiler}.


@deffn Parameter $descriptive-labels
When set to true: attempt to generate descriptive pretty names for
gensyms used by the compiler as lexical gensyms, loc gensyms and code
labels; this is useful for debugging purposes and code generation
inspection.  When set to false: attempt to generate gensyms in the
fastest way.
@end deffn

@c page
@node compiler unparse
@section Unparsing intermediate representations


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $unparse-recordized-code @var{input}
Given as argument a struct instance representing recordised code: build
and return a symbolic expression that can be printed in human readable
form.  @var{input} can be any structure that is produced by the compiler
passes.
@end defun


@defun $unparse-recordized-code/pretty @var{input}
Given as argument a struct instance representing recordised code: build
and return a symbolic expression that can be printed in human readable
form.  @var{input} can be any structure that is produced by the compiler
passes.

This function attempts to unparse recordised code and reconstruct a
Scheme--like symbolic expression; the returned sexp does @strong{not}
exactly represent the input.
@end defun


@defun $unparse-recordized-code/sexp @var{input}
Given as argument a struct instance representing recordised code: build
and return a symbolic expression that can be printed in human readable
form.  @var{input} can be any structure that is produced by the compiler
passes.  The output of this function is similar to
@func{$unparse-recordized-code} but more human readable.
@end defun

@c page
@node compiler full
@section The full transformation


The sequence of compiler passes is:

@example
recordize
optimize-direct-calls
optimize-letrec
source-optimize
rewrite-references-and-assignments
introduce-tags (optional)
sanitize-bindings
optimize-for-direct-jumps
insert-global-assignments
introduce-vars
introduce-closure-makers
optimize-combinator-calls/lift-clambdas
@end example

@noindent
the sequence in which the passes are performed @strong{cannot} be
changed; they must be performed in the specified order.  The passes
functions are to be considered unsafe: if the input is invalid, the
behaviour is undefined.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $compile-core-expr->code @var{core-language-sexp}
@end defun

@c page
@node compiler recordize
@section Scheme code to nested structs


The core language forms produced by the expander are converted to
``recordised code'' by the compiler before actually generating machine
code; recordised code is a nested hierarchy of struct instances.  The
struct types used for this recordisation are used to represent code in
the core language in a way which is better inspectable and optimisable.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $recordize @var{core-language-form}
Given a symbolic expression representing a form in the core language,
convert it into a nested hierarchy of struct instances; return the outer
struct instance.

This function expects a symbolic expression with perfect syntax: no
syntax errors are checked.  We expect this function to be executed
without errors, no exceptions should be raised unless an internal error
makes it happen.

In addition the following operations are performed:

@itemize
@item
Determine some properties of the code and store relative informations in
the struct instances.  For example: is a lexical binding ever referenced
or assigned?

@item
The application of some special lexical primitives is transformed into a
core language expression integrated in the original source code, then
recordised.  See below for details.
@end itemize
@end defun

@menu
* compiler recordize bindings:: Recordisation of bindings.
* compiler recordize specials:: Special lexical primitives.
* compiler recordize examples:: Recordisation examples.
* compiler recordize debug::    Introduction of debug calls.
@end menu

@c page
@node compiler recordize bindings
@subsection Recordisation of bindings


The core language forms that define bindings are:

@example
(library-letrec* ((@meta{lhs} @meta{loc} @meta{rhs}) ...) @meta{body})
(let     ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(letrec  ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(letrec* ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(lambda @meta{formals} @meta{body})
(case-lambda (@meta{formals} @meta{body}) ...)
(annotated-case-lambda @meta{annotation} (@meta{formals} @meta{body}) ...)
@end example

@noindent
and as special case:

@example
(set! @meta{lhs} @meta{rhs})
@end example

@noindent
when present at the top level.  In all these expressions @meta{lhs} is a
lexical gensym uniquely identifying the binding.

The recordisation process transforms:

@itemize
@item
@func{library-letrec*} and @func{letrec*} forms into @objtype{rec*bind}
structs, in which defined lex gensyms are substituted with
@objtype{prelex} structs.

@item
@func{letrec} forms into @objtype{recbind} structs, in which defined lex
gensyms are substituted with @objtype{prelex} structs.

@item
@func{let} forms into @objtype{bind} structs, in which defined lex
gensyms are substituted with @objtype{prelex} structs.

@item
@func{lambda}, @func{case-lambda} and @func{annotated-case-lambda} forms
into @objtype{clambda} structs, in which lex gensyms representing
bindings defined by function arguments are substituted with
@objtype{prelex} structs.
@end itemize

@c ------------------------------------------------------------

@subsubheading Undefined bindings and previously defined bindings

In the core language input expression: if a binding is defined by the
expression itself, its lex gensym is present as left--hand side in a
@func{let}, @func{letrec}, @func{letrec*}, @func{library-letrec*} form
or as formal argument in a @func{lambda}, @func{case-lambda},
@func{annotated-case-lambda} form.  Otherwise the lex gensym represents
an undefined binding or a binding defined outside the input form.

Every symbol in the input form not present as left--hand side in a
@objtype{bind}, @objtype{recbind}, @objtype{rec*bind} struct or formal
argument in a @objtype{clambda} struct is interpreted as a reference to
undefined or previously defined binding.  This interpretation includes:

@itemize
@item
Bindings defined by imported libraries.

@item
Bindings defined by expressions previously evaluated and added to an
interaction environment.

@item
Bindings that appear for the first time in top level assignment forms:

@example
(set! @meta{lhs} @meta{rhs})
@end example

@noindent
like the definitions of syntax transformers in the visit code generated
by the expander or standalone expressions evaluated at the @repl{}; such
assignments to undefined bindings cause a new binding to be generated.
@end itemize

@noindent
for all these cases: the lex gensym acts also as loc gensym.

After the recordisation process:

@itemize
@item
All the lex gensyms in reference position representing bindings not
defined by the input expression have been converted to:

@example
(funcall (primref top-level-value) (constant @meta{loc}))
@end example

@noindent
where @meta{loc} is the loc gensym of the binding.  If this binding is
truly undefined: the call to @func{top-level-value} will raise an
exception at run--time.

@item
All the lex gensyms in assignment position representing bindings not
defined by the input expression have been converted to:

@example
(funcall (primref $init-symbol-value!) (constant @meta{loc}) @meta{rhs})
@end example

@noindent
where @meta{loc} is the loc gensym of the binding; this is the run--time
definition of a new binding.
@end itemize

@noindent
so all the @objtype{prelex} structs introduced by @func{$recordize}
represent bindings defined by the input expression.

@quotation
@strong{NOTE} As specified by @rnrs{6}, bindings defined by imported
libraries must not be mutated; this means core language forms like:

@example
(set! @meta{loc} @meta{rhs})
@end example

@noindent
in which @meta{loc} is the loc gensym of an imported binding are
forbidden.  It is the responsibility of the expander not to generate
such assignment forms for bindings defined by imported libraries.
@end quotation

@quotation
@strong{NOTE} The special handling of core language assignment forms:

@example
(set! @meta{lex} @meta{rhs})
@end example

@noindent
in which @meta{lex} is both the lex and loc gensym of a binding not
defined by the input expression allows:

@itemize
@item
The correct handling of visit code generated by the expander.

@item
The definition of bindings by @func{eval} (for example at the @repl{})
using just @func{set!} rather than a proper binding form.  This case
allows bindings to be added to interaction environment using weird
syntaxes; here is an example session at the @repl{}:

@example
vicare> (let () (set! a 1) (set! b 2) #f)
$1 = #f

vicare> a
$1 = 1

vicare> b
$1 = 2
@end example

@noindent
It is the responsibility of the expander to forbid such definitions when
processing libraries and programs.
@end itemize
@end quotation

@c page
@node compiler recordize specials
@subsection Special lexical primitives


Whenever, in the recordisation process, the compiler recognises the
application of some special lexical core primitives: it transforms such
application into an equivalent core language expression integrated in
the original source code.  This transformation is equivalent to the
source integration performed by the compiler's source optimiser when
compiling user defined code, but it acts upon primitives defined by the
boot image.


@deffn {Integrated Primitive} make-parameter @var{init}
@deffnx {Integrated Primitive} make-parameter @var{init} @var{guard}
Integration of the primitive function @func{make-parameter}, @ref{iklib
parameters, make-parameter}.
@end deffn

@c page
@node compiler recordize examples
@subsection Recordisation examples


@subsubheading Handling of imported bindings

Let's imagine the following library:

@example
(library (libtest compiler-internals)
  (export a-func a-thunk a-const)
  (import (rnrs (6)))
  (define (a-func a b)
    (+ a b))
  (define (a-thunk)
    "ciao")
  (define a-const 123))
@end example

@noindent
it is recordised as follows:

@example
(rec*bind ((a-func_0  (lambda (a_0 b_0)
                        (funcall (primref +) a_0 b_0)))
           (a-thunk_0 (lambda ()
                        (constant "ciao")))
           (a-const_0 (constant 123)))
  (constant #<void>))
@end example

@noindent
if this library is imported as in:

@example
(library (recordize-demo-1)
  (export)
  (import (rnrs) (libtest compiler-internals))
  (list a-const (a-thunk) (a-func 1 2)))
@end example

@noindent
the resulting recordised code is:

@example
(rec*bind ()
  (funcall (primref list)
           (funcall (primref top-level-value)
                    (constant a-const))
           (funcall (funcall (primref top-level-value)
                             (constant a-thunk)))
           (funcall (funcall (primref top-level-value)
                             (constant a-func))
                             (constant 1)
                             (constant 2))))
@end example

@noindent
where the symbols @code{a-const}, @code{a-thunk}, @code{a-func} are the
location gensyms of the imported bindings.

@c page
@node compiler recordize debug
@subsection Introduction of debug calls


Whenever debugging mode is enabled, application forms like:

@example
(@meta{func} @meta{arg} ...)
@end example

@noindent
are expanded and recordised into:

@example
(funcall (primref debug-call)
         @meta{annotation}
         @meta{rator} @meta{rand} ...)
@end example

@noindent
where: @meta{rator} is the recordised version of @meta{func};
@meta{rand} is the recordised version of @meta{arg}; @meta{annotation}
is a debugging annotation:

@example
(constant (@meta{annotation-source} . (@meta{func} @meta{arg} ...)))
@end example

@noindent
in which @meta{annotation-source} has one of the formats:

@example
#f
(@meta{port-identifier} . @meta{first-character-offset})
@end example

@noindent
the introducion of @func{debug-call} is performed no matter what
expression @meta{func} is.

@c ------------------------------------------------------------

@subsubheading Example: @func{lambda} application

The standard language form:

@example
((lambda (x) x) 1)
@end example

@noindent
is expanded into the core language form:

@example
(annotated-call @meta{annotation-struct}
                (annotated-case-lambda #'(lambda (x) x)
                                       ((x x)))
                (quote 1))
@end example

@noindent
which is recordised as:

@example
(funcall (primref debug-call)
         (constant (@meta{annotation-source} . ((lambda (x) x) '1)))
         (lambda (x_0) x_0)
         (constant 1))
@end example

@c ------------------------------------------------------------

@subsubheading Example: @func{let} application

The standard language form:

@example
((let ((f (lambda (y) y)))
   f)
  1)
@end example

@noindent
is expanded and recordised into:

@example
(funcall (primref debug-call)
         (constant (@meta{annotation-source}
                    . ((let ((f (lambda (x) x))) f) 1)))
         (bind ((f_0 (lambda (x_0) x_0))) f_0)
         (constant 1))
@end example

@c page
@node compiler dircalls
@section Optimisation for direct calls


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $optimize-direct-calls @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.

Inspect application forms:

@example
(funcall @meta{operator} @meta{operand} ...)
@end example

@noindent
and attempt to integrate the @meta{operator} when possible.
@end defun

@menu
* compiler dircalls lambda::    Examples of @code{clambda} integration.
* compiler dircalls let::       Examples of bindings integration.
* compiler dircalls cond::      Example: @func{cond} syntaxes.
* compiler dircalls debug::     Examples of @func{debug-call} integration.
@end menu

@c page
@node compiler dircalls lambda
@subsection Examples of @code{clambda} integration


By definition, a ``direct closure application'' like:

@example
((lambda (x) x) 123)
@end example

@noindent
can be transformed to:

@example
   (let ((x 123)) x)
@end example

@noindent
in which the operator @func{lambda} form is integrated; so it can be
converted to low level operations that more efficiently implement the
binding; direct calls optimisation attempts to perform such integration.
Notice that in the case:

@example
((case-lambda
   ((x) x)
   ((x y) y))
 123)
@end example

@noindent
the integration yields:

@example
(let ((x 123)) x)
@end example

@noindent
and the clause with two arguments is just discarded and never compiled.

@c page
@node compiler dircalls let
@subsection Examples of bindings integration


There are other integration possibilities when the operator of an
application form is a complex expression:

@example
((let ((?lhs ?rhs) ...) ?body) ?rand ...)
===> (let ((?lhs ?rhs) ...)
       (?body ?rand ...))

((letrec ((?lhs ?rhs) ...) ?body) ?rand ...)
===> (letrec ((?lhs ?rhs) ...)
       (?body ?rand ...))

((letrec ((?lhs ?rhs) ...) ?body) ?rand ...)
===> (letrec* ((?lhs ?rhs) ...)
       (?body ?rand ...))
@end example

@c page
@node compiler dircalls cond
@subsection Example: @func{cond} syntaxes


@func{cond} syntaxes are expanded as follows:

@example
(cond ((this X)
       => (lambda (Y)
            (that Y)))
      (else
       (those)))
@end example

@noindent
becomes:

@example
(let ((t (this X)))
  (if t
      ((lambda (Y) (that Y)) t)
    (those)))
@end example

@noindent
which contains a direct call, which will be optimised to:

@example
(let ((t (this X)))
  (if t
      (let ((Y t)) (that Y))
    (those)))
@end example

@c page
@node compiler dircalls debug
@subsection Examples of @func{debug-call} integration


As example of integration, the standard language form:

@example
((lambda (x) x) 1)
@end example

@noindent
is expanded into the core language form:

@example
(annotated-call ?annotation-struct
                (annotated-case-lambda #'(lambda (x) x)
                                       ((x x)))
                (quote 1))
@end example

@noindent
which is recordised as:

@example
(funcall (primref debug-call)
         (constant (@meta{annotation-source} . ((lambda (x) x) '1)))
         (lambda (x_0) x_0)
         (constant 1))
@end example

@noindent
and integrated as:

@example
(bind ((x_0 (constant 1)))
  x_0)
@end example

@noindent
where we can see there is no more a function application.

Another example, the standard language form:

@example
((let ((f (lambda (y) y)))
   f)
 '1)
@end example

@noindent
is expanded and recordised into:

@example
(funcall (primref debug-call)
         (constant (@meta{annotation-source}
                    . ((let ((f (lambda (x) x))) f) 1)))
         (bind ((f_0 (lambda (x_0) x_0))) f_0)
         (constant 1))
@end example

@noindent
and integrated as:

@example
(bind ((f_0 (lambda (y_0) y_0)))
  (funcall (primref debug-call)
           (constant (@meta{annotation-source}
                      . ((let ((f (lambda (y) y))) f) 1)))
           f_0
           (constant 1)))
@end example

@noindent
where we can see the @func{debug-call} moved into the body.

@c page
@node compiler letrec
@section Optimisation of @func{letrec} and @func{letrec*} forms


@value{PRJNAME}'s compiler offers multiple algorithms to implement and
optimise the core language forms @func{letrec}, @func{letrec*} and
@func{library-letrec*}, whose syntax is:

@example
(letrec ((@meta{lhs} @meta{rhs}) ...) @meta{body})

(letrec* ((@meta{lhs} @meta{rhs}) ...) @meta{body})

(library-letrec* ((@meta{lhs} @meta{loc} @meta{rhs}) ...) @meta{body})
@end example

@noindent
notice that the @meta{body} is a single form.  The transformations for
@func{letrec*} and @func{library-letrec*} are equal; the difference
between the two lies in the implementation of allocations, references
and assignments to the @meta{lhs}.

When this compiler pass is applied to the recordised code, the forms
have already been transformed into:

@example
(recbind  ((@meta{lhs} @meta{rhs}) ...) @meta{body})

(rec*bind ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
where instances of the structure @objtype{recbind} represent
@func{letrec} forms and instances of the structure @objtype{rec*bind}
represent @func{letrec*} and @func{library-letrec*} forms.

After this compiler pass has been applied: @objtype{recbind} and
@objtype{rec*bind} structs are no more present in the returned code,
having been substituted with @objtype{bind} and @objtype{fix} structs.
So in the returned code: every @objtype{prelex} struct represents a
binding defined either by @objtype{bind} or @objtype{fix}.

@menu
* compiler letrec algo::        Introduction to the algorithms.
* compiler letrec api::         Transformations programming interface.
* compiler letrec notes::       General notes on the context of
                                @func{letrec} optimisations.
* compiler letrec basic::       The basic transformation algorithm.
* compiler letrec wsd::         The @wsd{} transformation algorithm.
* compiler letrec scc::         The @scc{} transformation algorithm.
@end menu

@c page
@node compiler letrec algo
@subsection Introduction to the algorithms


The compiler implements three algorithms: @code{basic}, @code{waddell},
@code{scc}.  The default and more advanced is @code{scc}; there is
little reason to use the other algorithms when processing real code.

The @code{basic} transformation is the one that defines the
@func{letrec} syntax from the @rnrs{5} standard document.

The @code{waddell} transformation focuses on generating @code{fix}
structures representing recursive binding forms for unassigned
@func{lambda} expressions.  To understand this algorithm, and the code,
we @strong{must} read the following paper:

@quotation
[@wsd{}] Oscar Waddell, Dipanwita Sarkar, R. Kent Dybvig.
``Fixing Letrec: A Faithful Yet Efficient Implementation of Scheme's
Recursive Binding Construct''.
@end quotation

The @code{scc} algorithm is an evolution of the @code{waddell}
transformation that better processes bindings, taking into account their
actual dependency graph.  To understand this algorithm, and the code, we
@strong{must} read the following paper:

@quotation
[@scc{}] Abdulaziz Ghuloum, R. Kent Dybvig.  ``Fixing Letrec
(reloaded)''.  Workshop on Scheme and Functional Programming '09.
@end quotation

@noindent
the described algorithm makes use of Tarjan's algorithms to partition
the nodes of a graph into Strongly Connected Components (@scc{}):

@quotation
Tarjan, Robert Endre.  ``Depth--first search and linear graph
algorithms''.  SIAM Journal on Computing 1 (2): 146-160, 1972.
@end quotation

@noindent
for details on the @scc{} algorithm, we can also refer to the
Wikipedia article ``Tarjan's strongly connected components
algorithm''@footnote{@url{https:@//@//en.wikipedia.org@//wiki@//Tarjan%27s_strongly_connected_components_algorithm}}.

@c page
@node compiler letrec api
@subsection Transformations programming interface


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $optimize-letrec @var{recordised-code}
Perform transformations and optimisations to convert the recordised
representation of @func{letrec}, @func{letrec*} and
@func{libary-letrec*} core language forms into a composition of low
level binding constructs and assignments.
@end defun


@deffn Parameter $check-for-illegal-letrec
If set to true: @func{$optimize-letrec} will perform an
additional recordized code pass to check for illegal binding references
in the right--hand sides of @func{letrec}, @func{letrec*} and
@func{library-letrec*} syntaxes, raising a syntax violation error if one
is found.  This is the default.

If set to false: the validating pass is not performed, faithfully hoping
for no problems in code.
@end deffn


@deffn Parameter $current-letrec-pass
Select the transformations performed by
@func{$optimize-letrec}; possible values are the symbols:

@table @code
@item basic
Perform the basic transformation.

@item waddell
Perform a transformation similar (but no equal) to the one described in
the [@wsd{}] paper.

@item scc
Perform a transformation similar (but no equal) to the one described in
the [@scc{}] paper.  This is the default.
@end table
@end deffn

@c page
@node compiler letrec notes
@subsection General notes on the context of @func{letrec} optimisations


@subsubheading On @func{let} and @func{let*} bindings

Let's consider the following program:

@example
(import (rnrs))
(let ((A B))
  #t)
@end example

@noindent
it will fail with ``unbound identifier B''; we are @strong{not}
concerned with unbound identifiers in this compiler pass.  So let's move
on to the following program:

@example
(import (rnrs))
(let ((A 123))
  (let ((A A))
    #t))
@end example

@noindent
no errors here: the identifier @code{A} in reference position is
captured by the outer @func{let} binding for @code{A}.  Now this
program:

@example
(import (rnrs))
(let* ((A 123)
       (B A))
  #t)
@end example

@noindent
everything is all right; now this program:

@example
(import (rnrs))
(let* ((A 123)
       (A A))
  #t)
@end example

@noindent
again no error: the identifier @code{A} in reference position is
captured by the first @func{let*} binding for @code{A}; @func{let*}
allows us to create bindings with the same name.

@c ------------------------------------------------------------

@subsubheading @func{letrec} bindings

Let's move to the @func{letrec} syntax.  This program is legal:

@example
(import (rnrs))
(letrec ((A (lambda () A)))
  #t)
@end example

@noindent
because @func{letrec} defines recursive bindings, so we are allowed to
reference @code{A} in the right--hand side of the binding for @code{A}
itself, as long as we put such reference in the body of a @func{lambda}.

This program is also legal:

@example
(import (rnrs))
(letrec ((A (lambda () B))
         (B (lambda () A)))
  #t)
@end example

@noindent
because the cross references to @code{A} and @code{B} are in the body of
@func{lambda} syntaxes.

This program is illegal:

@example
(import (rnrs))
(letrec ((A (list A)))
  #t)
@end example

@noindent
because the identifier @code{A} in reference position is not in the body
of a @func{lambda} syntax: to evaluate the right--hand side of the
binding we need the value of the binding itself.  Notice that @code{A}
in reference position is @strong{not} an unbound identifier: it is
captured by the @code{A} in binding position; it is just ``illegal'' and
we must detect this situation, according to @rnrs{6}.

This program is illegal:

@example
(import (rnrs))
(letrec ((A 123)
         (B (list A)))
  #t)
@end example

@noindent
because the identifier @code{A} in reference position is not in the body
of a @func{lambda} syntax: @func{letrec} does not impose an order to the
evaluation of the init expressions, so to evaluate the right--hand side
of the binding we need the value of the binding itself.

@c ------------------------------------------------------------

@subsubheading On @func{letrec*} bindings

Let's move to the @func{letrec*} syntax; it is similar, but not equal,
to @func{letrec}.  This program is legal:

@example
(import (rnrs))
(letrec* ((A (lambda () A)))
  #t)
@end example

@noindent
because @func{letrec*} defines recursive bindings, so we are allowed to
reference @code{A} in the right--hand side of the binding for @code{A}
itself, as long as we put such reference in the body of a @func{lambda}.

This program is also legal:

@example
(import (rnrs))
(letrec* ((A (lambda () B))
          (B (lambda () A)))
  #t)
@end example

@noindent
because the cross references to @code{A} and @code{B} are in the body of
@func{lambda} syntaxes.

This program is illegal:

@example
(import (rnrs))
(letrec* ((A (list A)))
  #t)
@end example

@noindent
because the identifier @code{A} in reference position is not in the body
of a @func{lambda} syntax: to evaluate the right--hand side of the
binding we need the value of the binding itself.  Again, notice that
@code{A} in reference position is @strong{not} an unbound identifier: it
is captured by the @code{A} in binding position; it is just ``illegal''
and we must detect this situation, according to @rnrs{6}.

This program is legal:

@example
(import (rnrs))
(letrec* ((A 123)
          (B (list A)))
  #t)
@end example

@noindent
because @func{letrec*} imposes a left--to--right order to the evaluation
of the init expressions.

@c ------------------------------------------------------------

@subsubheading On illegal bindings

@rnrs{6} mandates that illegal references to bindings established by
@func{letrec} and @func{letrec*} are detected at run--time and cause an
assertion violation to be raised.  @value{PRJNAME} detects them at
compile--time, so some fully @rnrs{6}-compliant code will not work under
@value{PRJNAME}.

The following code is illegal under both @rnrs{6} and @value{PRJNAME}:

@example
(import (rnrs))
(letrec ((x y)
         (y x))
  'should-not-get-here)
@end example

The following program will run under a @rnrs{6}-compliant
implementation:

@example
(import (rnrs))
(letrec ((x (if (eq? (cons 1 2)
                     (cons 1 2))
                x
              1)))
  x)
@end example

@noindent
because the form @code{x} in reference position in the right--hand side
of the binding is never evaluated; under @value{PRJNAME} this code will
rather raise a syntax violation at compile--time.

@c ------------------------------------------------------------

@subsubheading Bindings on the Scheme stack

In the @objtype{recbind} forms the right--hand side expressions
@meta{rhs} have no imposed order of evaluation; the following two forms,
in which the order of the bindings is reversed, must be completely
equivalent:

@example
(recbind ((@metai{lhs} @metai{rhs})
          (@metaii{lhs} @metaii{rhs}))
  @meta{body})

(recbind ((@metaii{lhs} @metaii{rhs})
          (@metai{lhs} @metai{rhs}))
  @meta{body})
@end example

In the @func{rec*bind} forms the right-hand side expressions @meta{rhs}
must be evaluated in the same order in which they appear.

In a lower--level compiler pass: instances of struct @objtype{bind} will
be converted to code that evaluates the @meta{rhs} expressions and store
their return value into appropriately allocated Scheme stack machine
words; a machine word for every @meta{lhs} will be allocated, each
@meta{lhs} will represent an actual ``local variable''.

If we think about the Scheme stack, it is clear why @objtype{bind}
structures cannot represent recursive bindings; given the core language
expression:

@example
(letrec ((f (lambda () f)))
  @meta{body})
@end example

@noindent
the internal representation must be:

@example
(bind ((f_0 '#!void))
  (seq
    (assign f_0 (lambda () f_0))
    @meta{body}))
@end example

@noindent
so that: first @objtype{bind} reserves a Scheme stack machine word for
the local variable, initialised to @code{#<void>}; then a closure object
is created, referencing the local variable @code{f_0}; finally a
reference to the closure object is stored in @code{f_0}.  To create the
closure object, we must first know the address of the allocated machine
word.

When processing @objtype{recbind} and @objtype{rec*bind} structures: we
must make sure that a machine word is allocated on the Scheme stack
before the address of such word is needed by the @meta{rhs} expressions.
We do this by transforming @objtype{recbind} and @objtype{rec*bind}
instances into a composition of @objtype{bind} and @objtype{assign}
instances.

@c page
@node compiler letrec basic
@subsection The basic transformation algorithm


The basic transformations are equivalent to:

@example
(letrec ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@expansion{} (let ((@meta{lhs} #!void) ...)
      (let ((@meta{tmp} @meta{rhs}) ...)
        (set! @meta{lhs} @meta{tmp}) ...
        @meta{body}))

(letrec* ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@expansion{} (let ((@meta{lhs} #!void) ...)
      (set! @meta{lhs} @meta{rhs}) ...
      @meta{body})
@end example

@noindent
and in recordised code are represented as:

@example
(recbind ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@expansion{} (bind ((@meta{lhs} #!void) ...)
      (bind ((@meta{tmp} @meta{rhs}) ...)
        (assign @meta{lhs} @meta{tmp}) ...
        @meta{body}))

(rec*bind ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@expansion{} (bind ((@meta{lhs} #!void) ...)
      (assign @meta{lhs} @meta{rhs}) ...
      @meta{body})
@end example

@noindent
as example, with these transformations the library:

@example
(library (optimize-letrec-basic-demo)
  (export a b c)
  (import (rnrs))
  (define (a) 1)
  (define (b) (a) 2)
  (define (c) (b) 3))
@end example

@noindent
is transformed into:

@example
(bind ((a_0 '#!void)
       (b_0 '#!void)
       (c_0 '#!void))
 (seq
   (set! a_0 (lambda () '1))
   (set! b_0 (lambda () (seq (funcall a_0) '2)))
   (set! c_0 (lambda () (seq (funcall b_0) '3)))
   (funcall void)))
@end example

@c page
@node compiler letrec wsd
@subsection The @wsd{} transformation algorithm


The @wsd{} algorithm recognises some properties of the bindings
to allow: less assignment operations, more efficient generation of
unassigned function bindings in the same lexical contour.

When processing a @func{letrec} or @func{letrec*} core language form
@wsd{} classifies each binding into: @code{unreferenced},
@code{simple}, @code{complex} or @code{fixable}.  @value{PRJNAME}'s
implementation of @wsd{} leaves unreferenced bindings alone, in
this compiler pass, to be processed later by the source optimiser; an
unreferenced binding is classified as @code{simple}.  It also renames
the category @code{lambda} into @code{fixable}.

@c ------------------------------------------------------------

@subsubheading The @func{letrec} transformation

If the form is a @func{letrec}: we do @strong{not} care about the order
of evaluation of the right--hand sides, so given the core language form:

@example
(letrec ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
we transform it into:

@example
(let ((@meta{simple.lhs} @meta{simple.rhs}) ...)
  (let ((@meta{complex.lhs} '#!void) ...)
    (let ((@meta{fixable.lhs} @meta{fixable.rhs}) ...)
      (let ((@meta{tmp} @meta{complex.rhs}) ...)
        (set! @meta{complex.lhs} @meta{tmp}) ...
        @meta{body}))))
@end example

@noindent
in which the @meta{complex.rhs} expressions are evaluated in unspecified
order.  In recordised code, the input expression:

@example
(recbind ((@meta{lhs} @meta{rhs}) ...) ?body)
@end example

@noindent
is transformed into:

@example
(bind ((@meta{simple.lhs} @meta{simple.rhs}) ...)
  (bind ((@meta{complex.lhs} '#!void) ...)
    (fix ((@meta{fixable.lhs} @meta{fixable.rhs}) ...)
      (bind ((@meta{tmp} @meta{complex.rhs}) ...)
        (assign @meta{complex.lhs} @meta{tmp}) ...
        @meta{body}))))
@end example

@c ------------------------------------------------------------

@subsubheading The @func{letrec*} transformation

If the form is a @func{letrec*}: we @strong{do care} about the order of
evaluation of the right--hand sides, so given the core language form:

@example
(letrec* ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
we transform it into:

@example
(let ((@meta{simple.lhs} @meta{simple.rhs}) ...)
  (let ((@meta{complex.lhs} '#!void) ...)
    (let ((@meta{fixable.lhs} @meta{fixable.rhs}) ...)
      (set! @meta{complex.lhs} @meta{complex.rhs}) ...
      @meta{body})))
@end example

@noindent
in which the @meta{complex.rhs} expressions are evaluated in the same
order in which they appear in the core language form.  In recordised
code, the input expression:

@example
(rec*bind ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
is transformed into:

@example
(bind ((@meta{simple.lhs} @meta{simple.rhs}) ...)
  (bind ((@meta{complex.lhs} '#!void) ...)
    (fix ((@meta{fixable.lhs} @meta{fixable.rhs}) ...)
      (assign @meta{complex.lhs} @meta{complex.rhs}) ...
      @meta{body})))
@end example

@c ------------------------------------------------------------

@subsubheading Notes

The really important thing about the @wsd{} transformations is to
generate reliable @code{fix} bindings definitions: the classification of
``fixable'' bindings must be reliable.  This covers the very common case
of @func{library} forms whose top level function definitions are
unassigned; for example, the library:

@example
(library (optimize-letrec-waddell-demo)
  (export a b c)
  (import (rnrs))
  (define (a) 1)
  (define (b) (a) 2)
  (define (c) (b) 3))
@end example

@noindent
is transformed into:

@example
(bind ()        ;simple
  (bind ()      ;complex
    (fix ((a_0 (lambda () '1))
          (b_0 (lambda () (seq (funcall a_0) '2)))
          (c_0 (lambda () (seq (funcall b_0) '3))))
      (funcall void))))
@end example

The algorithm's implementation can be conservative and suboptimal in
classifying bindings as @code{complex}, even though they could be
@code{simple} or @code{fixable}, whenever the classification as
@code{simple} or @code{fixable} requires too much work or is unreliable;
in other words: when in doubt, just call it @code{complex}.  One of the
purposes of the @scc{} algorithm is exactly to improve such
classification.

@c page
@node compiler letrec scc
@subsection The @scc{} transformation algorithm


The @scc{} algorithm builds a directed graph representation of the
bindings in a single @objtype{recbind} or @objtype{rec*bind} structure,
outlining the dependencies among right--hand side expressions; in the
graph each binding is a vertex (also called node).  It then applies
Tarjan's algorithm to the graph and partitions the bindings into
clusters of Strongly Connected Components (@scc{}).

Here is the gist of the algorithm:

@enumerate
@item
Given the core language @func{letrec} form:

@example
(letrec ((D (lambda () B))
         (C D)
         (B C)
         (A B))
  @meta{body})
@end example

@noindent
we build a directed graph of dependencies between the bindings; the
graph of dependencies for the given form is:

@example
A --> B --> C
      ^     |
      |     |
      D <---
@end example

@item
We perform a depth--first visit of the directed graph; during the visit
we step from the current vertex to a successor one, following an
outgoing edge, if it has not already been visited; a depth--first visit
is like entering a maze and always turn right at cross roads.  While
visiting the vertexes: we push each visited vertex on a stack; we rank
each vertex with a zero--based serial index.

The following picture shows an ongoing visit with path @samp{A},
@samp{B}, @samp{C}, @samp{D}; the serial index of each vertex is in
square brackets:

@example
A[0] --> B[1] --> C[2]     STK == A, B, C, D
           ^       |
           .       |
           .       |
         D[3] <----
@end example

@noindent
let's say we are visiting @samp{D} and considering the successor vertex
@samp{B} as next step.

@enumerate a
@item
@samp{B} has already been visited, so we do not enter it; the index of
@samp{B} is @samp{1}, less than the index of @samp{D} which is @samp{3},
so we mutate the index of @samp{D} to be @samp{1}:

@example
A[0] --> B[1] --> C[2]     STK == A, B, C, D
           ^        |
           .        |
           .        |
         D[1] <-----
@end example

@noindent
there are no more successor vertexes from @samp{D} so we step back to
@samp{C}; notice that we leave the stack unchanged.

@item
Upon stepping back to @samp{C}: we recognise that the index of @samp{C}
is @samp{2}, less than the index of @samp{D} which is @samp{1}; so we
mutate the index of @samp{C} to be @samp{1}:

@example
A[0] --> B[1] --> C[1]     STK == A, B, C, D
           ^        .
           .        .
           .        .
         D[1] <.....
@end example

@noindent
there are no more successor vertexes from @samp{C} so we step back to
@samp{B}; notice that we leave the stack unchanged.

@item
Upon stepping back to @samp{B}: we recognise that the index of @samp{B}
is @samp{1}, greater than or equal to the index of @samp{C} which is
@samp{1}; we leave the index of @samp{B} unchanged.  Now we recognise
that: after visiting all the vertexes successors to @samp{B}, the index
of @samp{B} is unchanged; we conclude that all the nodes on the stack up
to and including @samp{B} are part of a Strongly Connected Component:

@example
STK == A, B, C, D
         |-------| SCC
@end example

@noindent
so we pop them from the stack and form a cluster with them.  The
vertexes in a cluster are marked as ``done'' and will be skipped in
further steps of the visit, as if they are not there.
@end enumerate

@item
Clusters of @scc{}s are formed and accumulated while stepping back from
the depth--first visit, the accumulated clusters are in reverse order.
This implementation of Tarjan's algorithm guarantees that the returned
list of clusters is in the correct order for RHS evaluation in
@objtype{recbind} or @objtype{rec*bind} structs:

@itemize
@item
The RHS of bindings in the first cluster from the list, must be
evaluated before the RHS of bindings in the second cluster.

@item
The RHS of bindings in the second cluster from the list, must be
evaluated before the RHS of bindings in the third cluster.

@item
And so on.
@end itemize

So we can arrange the evaluation as if each cluster comes from a nested
binding form; if the returned list is:

@example
((@meta{cluster-binding-1} ...)
 (@meta{cluster-binding-2} ...)
 (@meta{cluster-binding-3} ...))
@end example

@noindent
the equivalent nested binding forms are:

@example
(recbind (@meta{cluster-binding-3} ...)
  (recbind (@meta{cluster-binding-2} ...)
    (recbind (@meta{cluster-binding-1} ...)
      @meta{body})))
@end example

@item
Each cluster of @scc{}s generates a nested hierarchy of bindings; first
the bindings are partitioned into fixable and non--fixable, the a form
like the following is generated:

@example
(bind ((@meta{complex.lhs} '#!void) ...)
  (fix ((@meta{fixable.lhs} @meta{fixable.rhs}) ...)
    (assign @meta{complex.lhs} @meta{complex.rhs}) ...
    @meta{body}))
@end example
@end enumerate

@c page
@node compiler optimisation
@section Source optimisation


For an introduction to the source code see the thesis:

@quotation
Oscar Waddell.  ``Extending the Scope of Syntactic Abstraction''.  PhD.
Thesis.  Indiana University Computer Science Department.  August 1999.
@end quotation

@noindent
and the paper:

@quotation
Oscar Waddell, R. Kent Dybvig.  ``Fast and Effective Procedure
Inlining''.  Indiana University.  Computer Science Department.
Technical Report No. 484.
@end quotation

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $source-optimize @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.
@end defun


@deffn Parameter $source-optimizer-passes-count
Specify how many passes to perform with the source optimizer; it must be
a positive fixnum.  Defaults to @code{1}; it is set to 2 when the
optimisation level is @code{3}.

It makes sense to perform zero, one or two passes; it is unlikely that
more passes can do significant improvement.
@end deffn


The following bindings are exported by the library @library{vicare}.


@deffn Parameter optimize-level
The optimization level; accepted values are the fixnums @code{0},
@code{1}, @code{2}, @code{3}.  Defaults to @code{2}.
@end deffn


@deffn Parameter $cp0-effort-limit
The initial value of an "effort counter" that is decremented every time
an optimisation is performed by the source optimiser; when the counter
reaches zero: the current optimisation effort is abandoned and the
original input expression kept as is.  It is set every time the
optimiser enters specific subexpressions of the input.
@end deffn


@deffn Parameter $cp0-size-limit
The initial value of a (estimated) code size counter that is decremented
every time an optimisation is performed by the source optimiser; when
the counter reaches zero: the current optimisation effort is abandoned
and the original input expression kept as is.  It is set every time the
optimiser enters specific subexpressions of the input.
@end deffn

@c page
@node compiler refassig
@section Rewriting references and assignments


References to bindings in recordised code are represented as standalone
@objtype{prelex} structures; assignments to bindings in recordised code
are represented as @objtype{assign} structs:

@example
(assign @meta{prel} @meta{rhs})
@end example

@noindent
in which @meta{prel} is a @objtype{prelex} structure and the right--hand
side @meta{rhs} is recordised code which, evaluated at run--time, will
return the new binding's value.

With respect to how references and assignments are actually implemented,
there are three kinds of lexical bindings:

@itemize
@item
Top level bindings, defined by @func{library-letrec*} core language
forms; @ref{compiler topics topbind, Handling of lexical top level
bindings}.

@item
Unassigned (read--only) local bindings, defined by @func{let},
@func{letrec} and @func{letrec*} core language forms and never subjected
to a @func{set!} core language form; @ref{compiler topics locbind,
Handling of lexical local bindings}.

@item
Assigned (read--write) local bindings, defined by @func{let},
@func{letrec} and @func{letrec*} core language forms and subjected to
one or more @func{set!} core language forms; @ref{compiler topics
locbind, Handling of lexical local bindings}.
@end itemize

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $rewrite-references-and-assignments @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.

Transform references and assignments for top level lexical bindings and
unassigned local lexical bindings according to the implementation of
such operations.  Remembering that the actual value of a top level
binding is stored in the @code{value} field of a loc gensym, this
function performs the following transformations:

@itemize
@item
References to top level bindings are transformed into:

@example
(funcall (primref $symbol-value) (constant @meta{loc}))
@end example

@noindent
which extracts the value from slot @code{value} of the loc gensym
@meta{loc}.

@item
Common assignments to top level bindings are transformed into:

@example
(funcall (primref $set-symbol-value!)
         (constant @meta{loc})
         @meta{rhs})
@end example

@noindent
which stores a new value in the slot @code{value} of the log gensym
@meta{loc}.

@item
Single assignments to top level bindings which also serve as binding
initialisations are transformed into:

@example
(funcall (primref $init-symbol-value!)
         (constant @meta{loc})
         @meta{rhs})
@end example

@noindent
which stores a new value in the slot @code{value} of @meta{loc} and,
only if the value is recognised at run--time as being closure object,
also stores value in the slot @code{proc}.

@item
Definitions of assigned local bindings are transformed as follows:

@example
(bind ((@meta{prel} @meta{init})) @meta{body})
@expansion{} (bind ((@meta{tmp-prel} @meta{init}))
      (bind ((@meta{prel} (funcall (primref vector)
                             @meta{tmp-prel})))
        @meta{body}))
@end example

@item
References to assigned local bindings are transformed from standalone
@objtype{prelex} structs to:

@example
(funcall (primref $vector-ref) @meta{prel} (constant 0))
@end example

@item
Assignments to assigned local bindings are transformed as follows:

@example
(assign @meta{prel} @meta{rhs})
@expansion{} (funcall (primref $vector-set!)
            @meta{prel}
            (constant 0)
            @meta{rhs})
@end example
@end itemize

After this compiler pass: there are no more @objtype{assign} structs in
the returned recordised code.
@end defun

@c page
@node compiler tags
@section Tagging known properties


This optional compiler pass analyses the type of values returned by
expressions with the purpose of transforming @objtype{funcall}
recordised forms:

@example
(funcall (primref @meta{prim-name}) @meta{rand} ...)
(funcall @meta{rator}               @meta{rand} ...)
@end example

into:

@example
(funcall (primref @meta{prim-name})       (known @meta{rand} @meta{rand-type}) ...)
(funcall (known @meta{rator} @meta{rator-type}) (known @meta{rand} @meta{rand-type}) ...)
@end example

@noindent
where: @meta{rator-type} is the type description of the value returned
by @meta{rator}; each @meta{rand-type} is the type description of the
value returned by the corresponding @meta{rand}; a @objtype{primref}
operator is left untouched.  The type descriptions are records of type
@objtype{core-type-tag} whose represented types are inferred by this
compiler pass.

The structs of type @objtype{known} are annotation ``tags'' consumed by
the functions generating the implementation of the core primitive
operations; for example, given the recordised code:

@example
(funcall (primref vector-length) @meta{rand})
@end example

@noindent
which makes use of the primitive operation @func{vector-length}:

@itemize
@item
If no type tag is assigned to @meta{rand}: the implementation of
@func{vector-length} integrated at the call site must include a
validation of @meta{rand} as vector object.

@item
If the tag @code{T:vector} is introduced for the operand:

@example
(funcall (primref vector-length) (known @meta{rand} T:vector))
@end example

@noindent
the implementation of @func{vector-length} integrated at the call site
does @strong{not} include a validation of @meta{RAND} as vector object.
@end itemize

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $introduce-tags @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.
@end defun


@deffn Parameter $perform-tag-analysis
When true the pass @func{$introduce-tags} is performed, else it is
skipped.  Defaults to @true{}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Properties propagation through function arguments

Let's examine what happens when a variable reference is used as operand
for the primitive operation @func{cdr}; the primitive @func{cdr} accepts
a pair as operand.  In the following standard code example the variable
@code{x} is of unknown type, when its binding is created @code{x} is
left untagged:

@example
(let ((f (lambda (y) y))
      (x (read)))
  (f (cdr x))
  (f x))
@end example

@noindent
but, after being used as argument for @func{cdr} without raising an
exception: it is known that its type is @code{T:pair}, so the second
reference to @code{x} is tagged with @code{T:pair}; the result of the
transformation is:

@example
(bind ((f_0 (lambda (y_0) y_0))
       (x_0 (funcall (primref read))))
  (seq
    (funcall (known f_0 (T:procedure T:non-false
                         T:nonimmediate T:object))
      (funcall (primref cdr) x_0))
    (funcall (known f_0 (T:procedure T:non-false
                         T:nonimmediate T:object))
      (known x_0 (T:pair T:non-false
                  T:nonimmediate T:object)))))
@end example

We know that a ``wrong operand type'' exception is non--continuable; so
if @func{cdr} raises an exception because @code{x} is not a pair: the
control flow cannot come back.  This allows us to determine type
informations and propagate them after the arguments have been validated.

@c page
@node compiler sanitise bindings
@section Sanitizing bindings


This compiler pass makes sure that every @objtype{clamba} struct appears
as direct right--hand side expression in a @objtype{fix} struct:

@example
(fix ((@meta{lhs} @meta{clambda})) @meta{body})
@end example

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $sanitize-bindings @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.

Perform the following transformations:

@itemize
@item
@objtype{clambda} structs that already appear as RHS of @objtype{fix}
structs are left alone.

@item
@objtype{clambda} structs appearing as RHS in single--binding
@objtype{bind} structs cause the @objtype{bind} struct to be replaced by
a @objtype{fix} struct:

@example
(bind ((@meta{lhs} @meta{clambda})) @meta{body})
@expansion{} (fix ((@meta{lhs} @meta{clambda})) @meta{body})
@end example

@item
@objtype{clambda} structs appearing as RHS in multiple--binding
@objtype{bind} structs cause the @objtype{bind} struct to be split into
a @objtype{bind} struct and a @objtype{fix} struct in which the bindings
are partitioned:

@example
(bind ((@metao{lhs} @meta{clambda})
       (@metai{lhs} @meta{rhs}))
  @meta{body})
@expansion{} (bind ((@metai{lhs} @meta{rhs}))
      (fix ((@metao{lhs} @meta{clambda}))
        @meta{body}))
@end example

@item
@objtype{clambda} structs appearing as standalone expressions (that is:
not directly as RHS of a @objtype{bind} or @objtype{fix} struct) are
``lifted'' as follows:

@example
(clambda (@meta{formals} @meta{body}) ...)
@expansion{} (fix ((tmp (clambda (@meta{formals} @meta{body}) ...)))
      tmp)
@end example
@end itemize

In the returned struct of recordised code: all the @objtype{clambda}
structs appear in the code as right--hand side initialisation
expressions of @objtype{fix} structs; all the @objtype{bind} structs
have a non--@objtype{clambda} struct as right--hand side initialisation
expression.
@end defun

@c page
@node compiler direct jumps
@section Optimisation for direct jumps


Let's consider the following code in which the @func{lambda} sexp has
not been integrated at the call site:

@example
(let ((f (lambda (x) x)))
  (f 123))
@end example

@noindent
by inspecting this code we can verify at compile--time that that
@code{f} references a @objtype{clambda} and the application form has the
correct number of operands; @value{PRJNAME} offers a technique to
implement a ``full closure object application'' @code{(f 123)} as a
faster ``direct jump call'' to the @objtype{clambda} clause with the
correct number of operands.  Another example, when the @objtype{clambda}
has multiple clauses:

@example
(let ((f (case-lambda
           ((x)   x)
           ((x y) (list x y)))))
  (f 1 2))
@end example

@noindent
by inspecting this code we can verify at compile--time that @code{f}
references a @objtype{clambda} and that it is called with 2 arguments:
there is technique that allows to implement the application @code{(f 1
2)} as a direct jump to the clause with 2 arguments.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $optimize-for-direct-jumps @var{input}
Perform code optimisation traversing the whole hierarchy in @var{input},
which must be a struct instance representing recordised code, and
building a new hierarchy of optimised, recordised code; return the new
hierarchy.

Transform @objtype{funcall} structs into @objtype{jmpcall} structs
whenever in the application form:

@example
(funcall @meta{operator} @meta{operand} ...)
@end example

@noindent
the operator is a binding reference known to reference a
@objtype{clambda} struct.

Upon entering this transformation: all the @objtype{clambda} structs
must appear in the input as right--hand side initialisation expressions
of @objtype{fix} structs; all the @objtype{bind} structs must have a
non--@objtype{clambda} struct as right--hand side initialisation
expression.
@end defun

@c ------------------------------------------------------------

@subsubheading Examples

Let's see some example in which we have disable function integration in
application forms.  The standard code:

@example
(let ((f (case-lambda
           ((a)   1)
           ((a b) 2))))
  (list (f 1) (f 1 2)))
@end example

@noindent
is transformed into:

@example
(fix ((f_0 (case-lambda
             ((a_0)     (constant 1))
             ((a_1 b_0) (constant 2)))))
  (funcall (primref list)
    (jmpcall asmlabel:f:clambda:case-1
             f_0 (constant 1))
    (jmpcall asmlabel:f:clambda:case-2
             f_0 (constant 1) (constant 2))))
@end example

@noindent
where @code{asmlabel:f:clambda:case-1} is a placeholder for the address
of the machine code entry point of the first case of the
@objtype{clambda} bound to @code{f_0} (the one with 1 argument);
@code{asmlabel:f:clambda:case-2} represents the machine code entry point
of the second case.

The following core language code defines a recursive function:

@example
(letrec ((f (case-lambda
              (()  (f '1))
              ((a) a))))
  ((primitive list) (f) (f '2)))
@end example

@noindent
and it is transformed into:

@example
(fix ((f_0 (case-lambda
             (()
              (jmpcall asmlabel:f:clambda:case-1
                       f_0 (constant 1)))
             ((a_0)
              a_0))))
  (funcall (primref list)
    (jmpcall asmlabel:f:clambda:case-0
             f_0)
    (jmpcall asmlabel:f:clambda:case-1
             f_0 (constant 2))))
@end example

@noindent
where we see the recursive function call is also optimised as direct
jump.

@c page
@node compiler global assign
@section Inserting global assignments


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $insert-global-assignments @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of transformed, recordized code;
return the new hierarchy.

This module inserts global assignments forms that put the value of
lexical top level bindings in the slot @code{value} of the corresponding
loc gensym; for bindings whose value is a closure object: the value is
also stored in the @code{proc} slot of the loc gensym.
@end defun


As example, the library:

@example
(library (insert-global-assignments-demo-1)
  (export a b c d)
  (import (rnrs))
  (define (a) '1)
  (define (b) '2)
  (define (c) '3)
  (define d '4))
@end example

@noindent
is expanded into the core language form:

@example
(library-letrec*
    ((a.lex a.loc (lambda () '1))
     (b.lex b.loc (lambda () '2))
     (c.lex c.loc (lambda () '3))
     (d.lex d.loc '4))
  (quote #!void))
@end example

@noindent
then recordised and transformed into:

@example
(fix ((a.lex_0 (lambda () (constant 1)))
      (b.lex_0 (lambda () (constant 2)))
      (c.lex_0 (lambda () (constant 3))))
  (seq
    (funcall (primref $set-symbol-value/proc!)
             (constant a.loc) a.lex_0)
    (funcall (primref $init-symbol-value!)
             (constant b.loc) b.lex_0)
    (funcall (primref $init-symbol-value!)
             (constant c.loc) c.lex_0)
    (bind ((d.lex_0 (constant 4)))
      (seq
        (funcall (primref $init-symbol-value!)
                 (constant d.loc) d.lex_0)
        (constant #!void)))))
@end example

@c page
@node compiler vars
@section Introducing storage locations


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $introduce-vars @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.

Replace all the @objtype{prelex} structs in recordised code with
@objtype{var} structs; this is because after this compiler pass we need
a different set of properties to handle variable bindings.
@end defun

@c page
@node compiler closure makers
@section Introducing closure makers


We can think of @objtype{clambda} structs as representing code that,
once compiled, becomes the machine code stored in code objects
implementing Scheme functions.  This compiler pass wraps each
@objtype{clambda} struct into a @objtype{closure-maker} struct, which
represents code that, executed at run--time, builds and returns a
closure object using the @objtype{clambda}'s code object as
implementation.  While wrapping @objtype{clambda}, a list of variable
references that are free in the body of the @objtype{clambda} is
gathered for future use.

@quotation
@strong{NOTE} The @strong{true} purpose of this compiler pass is to
gather lists of free variables referenced by @objtype{clambda} bodies.
We might introduce the closure makers at a later pass and store the
lists of free variables in the @objtype{clambda} structs; we introduce
the closure makers here because it helps a bit in reasoning about the
transformations.
@end quotation

Upon entering this compiler pass:

@itemize
@item
For bindings defined by @objtype{bind} structs:

@example
(bind ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
the @meta{lhs} are @objtype{var} structs; the @meta{rhs} are
non--@objtype{clambda} structs; the @objtype{var} in @meta{lhs} do
@strong{not} appear in the @meta{rhs} expressions.

@item
For bindings defined by @objtype{fix} structs:

@example
(fix ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
the @meta{lhs} are @objtype{var} structs; the @meta{rhs} are
@objtype{clambda} structs; the @objtype{var} in @meta{lhs} might appear
in the @meta{rhs} expressions.

@item
Structs of type @objtype{clambda} appear only as right--hand side
expressions of @objtype{fix} structs.
@end itemize

This compiler pass transforms:

@example
(fix ((@meta{lhs} @meta{clambda-rhs}) ...) @meta{body})
@end example

@noindent
into:

@example
(fix ((@meta{lhs} (closure-maker @meta{clambda-rhs})) ...) @meta{body})
@end example

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $introduce-closure-makers @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.

This function wraps each @objtype{clambda} struct in the input
recordised code into @objtype{closure-maker} structures, compiling a
list of free variables referenced by each @objtype{clambda}.
@end defun

@c ------------------------------------------------------------

@subsubheading Examples

This example generates a function with no free variables:

@example
(lambda () '1)
@expansion{} (fix ((tmp_0 (closure-maker (lambda () (constant 1))
                                no-freevars)))
      tmp_0)
@end example

This example generates a multi--clause function with no free variables:

@example
(case-lambda
 (() '1)
 ((a) a))
@expansion{} (fix ((tmp_0 (closure-maker (case-lambda
                                 (()    (constant 1))
                                 ((a_0) a_0))
                                no-freevars)))
      tmp_0)
@end example

This example generates a function with a free variable:

@example
(let ((a ((primitive read))))
  (lambda () a))
@expansion{} (bind ((a_0 (funcall (primref read))))
      (fix ((tmp_0 (closure-maker (lambda () a_0)
                                  (freevars: a_0))))
        tmp_0))
@end example

This example generates a recursive function with no free variables other
than the reference to itself:

@example
(letrec ((f (lambda () (f))))
  f)
@expansion{} (fix ((f_0 (closure-maker
                  (lambda ()
                    (jmpcall asmlabel:f:clambda:case-0 f_0))
                  (freevars: f_0))))
      f_0)
@end example

The core language form:

@example
(library-letrec*
    ((a a.loc (lambda () '1))
     (b b.loc (lambda () '2))
     (c c.loc (lambda () '3))
     (d d.loc '4))
  (quote #!void))
@end example

@noindent
is transformed into:

@example
(fix ((a_0 (closure-maker (lambda () (constant 1)) no-freevars))
      (b_0 (closure-maker (lambda () (constant 2)) no-freevars))
      (c_0 (closure-maker (lambda () (constant 3)) no-freevars)))
  (seq
    (funcall (primref $set-symbol-value/proc!)
             (constant a.loc) a_0)
    (funcall (primref $init-symbol-value!)
             (constant b.loc) b_0)
    (funcall (primref $init-symbol-value!)
             (constant c.loc) c_0)
    (bind ((d_0 (constant 4)))
      (seq
        (funcall (primref $init-symbol-value!)
                 (constant d.loc) d_0)
        (constant #!void)))))
@end example

@c page
@node compiler lifting
@section Closures optimization and @objtype{clambda} lifting


This compiler pass performs @objtype{clambda} lifting and optimisation
of calls to functions without free variables.

@menu
* compiler lifting intro::         Introduction to @objtype{clambda} lifting.
* compiler lifting prerequisites:: Prerequisites for codes lifting.
* compiler lifting combinators::   Combinators and non--combinators.
* compiler lifting optimisation::  Optimisation of combinator calls.
* compiler lifting examples::      Examples of combinators and
                                   non--combinators.
* compiler lifting substitutions:: Substitution optimisations.
* compiler lifting api::           @objtype{clambda} lifting @api{}.
@end menu

@c page
@node compiler lifting intro
@subsection Introduction to @objtype{clambda} lifting


The purpose of this compiler pass is to partition the input expression
into: the code that will be compiled to code objects implementing
closure objects; code that will be compiled to a code object
implementing the main body of the expression.  As example, the library:

@example
(library (clambda-lifting-demo-0)
  (export a b c d)
  (import (rnrs))
  (define (a) '1)
  (define (b) '2)
  (define (c) '3)
  (define d 4))
@end example

@noindent
is expanded into:

@example
(library-letrec*
    ((a a.loc (lambda () '1))
     (b b.loc (lambda () '2))
     (c c.loc (lambda () '3))
     (d d.loc '4))
  (quote #!void))
@end example

@noindent
before this compiler pass it is transformed into:

@example
(fix ((a_0 (closure-maker (lambda () (constant 1)) no-freevars))
      (b_0 (closure-maker (lambda () (constant 2)) no-freevars))
      (c_0 (closure-maker (lambda () (constant 3)) no-freevars)))
  (seq
    (funcall (primref $set-symbol-value/proc!)
             (constant a.loc) a_0)
    (funcall (primref $init-symbol-value!)
             (constant b.loc) b_0)
    (funcall (primref $init-symbol-value!)
             (constant c.loc) c_0)
    (bind ((d_0 (constant 4)))
      (seq
        (funcall (primref $init-symbol-value!)
                 (constant d.loc) d_0)
        (constant #!void)))))
@end example

@noindent
and after this compiler pass it will become:

@example
(codes
  ((lambda (label: asmlabel:c:clambda) () (constant 3))
   (lambda (label: asmlabel:b:clambda) () (constant 2))
   (lambda (label: asmlabel:a:clambda) () (constant 1)))
  (seq
    (funcall (primref $set-symbol-value/proc!)
      (constant a.loc)
      (closure-maker (code-loc asmlabel:a:clambda) no-freevars))
    (funcall (primref $init-symbol-value!)
      (constant b.loc)
      (closure-maker (code-loc asmlabel:b:clambda) no-freevars))
    (funcall (primref $init-symbol-value!)
      (constant c.loc)
      (closure-maker (code-loc asmlabel:c:clambda) no-freevars))
    (bind ((d_0 (constant 4)))
      (seq
        (funcall (primref $init-symbol-value!)
          (constant d.loc) d_0)
        (constant #!void)))))
@end example

We see the result of the transformation is a struct of type
@objtype{codes} in which the @objtype{clambda} forms have been extracted
and separated; in addition, the top level @objtype{fix} struct has been
removed and references to the @objtype{fix} bindings have been replaced
by @objtype{closure-maker} forms, this happens because all the functions
are combinators.

The @objtype{closure-maker} form:

@example
(closure-maker (code-loc asmlabel:a:clambda) no-freevars)
@end example

@noindent
will be compiled to code that returns a closure object implementing the
function @code{a}, with assembly entry point label
@code{asmlabel:a:clambda}.

@c page
@node compiler lifting prerequisites
@subsection Prerequisites for codes lifting


When arriving at this compiler pass the input recordised code is such
that:

@itemize
@item
All the @objtype{clambda} structs are wrapped into
@objtype{closure-maker} structs.

@item
All the @objtype{closure-maker} structs appear as right--hand side
expressions of bindings defined by @objtype{fix} structs.

@item
Bindings defined by @objtype{fix} structs are immutable and their
right--hand side expressions are all @objtype{closure-maker} structs.

@item
Bindings defined by @objtype{bind} structs are immutable and their
right--hand side expressions are of type different from
@objtype{closure-maker} and @objtype{clambda}.  These bindings are
immutable because the assigned ones have been previously transformed
into immutable references to mutable vector objects.

@item
If the right--hand side expression of a binding defined by
@objtype{bind} is a @objtype{var} struct: such binding defines a
synonym.  For example:

@example
(bind ((a @meta{rhs}))
  (bind ((b a))
    @meta{body}))
@end example

@noindent
the binding @code{b} is immutable, so @code{b} is a synonym of @code{a};
it is perfectly all right to substitute all the occurrences of the
@objtype{var} @code{b} in @meta{body} with occurrences of the
@objtype{var} @code{a}.
@end itemize

@c page
@node compiler lifting combinators
@subsection Combinators and non--combinators


To discuss the transformations we define:

@table @emph
@item combinator
A Scheme function without free variables; a combinator does not capture
any binding.  The closure object implementing a combinator can be
created once and for all at compile--time; for example:

@example
(define (compute x y z)
  (define (lincomb a b c)
    (+ (* a b) (* a c)))
  (lincomb x y z))
@end example

@noindent
assuming function integration is disabled: the closure object
implementing the function @func{lincomb} can be created once at
compile--time and reused at every call to @func{compute}.

@item non--combinator
A Scheme function with free variables, whose current value must be
captured at run--time.  To implement a non--combinator: a new closure
object must be created at run--time every time the control flow reaches
the @func{lambda} form, to capture the current values of the free
variables; for example:

@example
(define (adder x)
  (lambda (x)
    (+ x y)))
@end example

@noindent
at every call to the function @func{adder} a new closure object must be
created and returned, capturing the value of the argument @code{x}.
@end table

We want to discuss how to recognise combinators and non--combinators
among the bindings defined by a @objtype{fix} struct.  Let's consider
the recordised code:

@example
(bind ((@metai{lhs} @metai{rhs}) ...)
  (fix ((@metao{lhs} @metao{rhs}) ...)
    (bind ((@metaii{lhs} @metaii{rhs}) ...)
      @meta{body})))
@end example

@noindent
at this point in the sequence of compiler passes, we know that all the
@metao{rhs} are @objtype{closure-maker} structs.  The @objtype{var}
structs @metao{lhs} and @metai{lhs} may appear in the body of each
@metao{rhs}, while the internally defined @objtype{var} structs
@metaii{lhs} cannot; so the @metaii{lhs} do not influence the nature of
the @metao{rhs} expressions: we can ignore all the internally defined
bindings.  So let's switch to inspect the recordised code:

@example
(bind ((@metai{lhs} @metai{rhs}) ...)
  (fix ((@metao{lhs} @metao{rhs}) ...)
    @meta{body}))
@end example

@noindent
the @objtype{var} structs @metao{lhs} and @metai{lhs} may appear in the
body of each @metao{rhs}; this includes the case of recursive
@metao{rhs}, in which a @metao{lhs} @objtype{var} appears in the list of
free variables of the associated @metao{rhs}.

@itemize
@item
If a list of free variables is empty: the corresponding @metao{rhs} is a
combinator.  For example, in the recordised code:

@example
(bind ((a @meta{rhs-a}) (b @meta{rhs-b}))
  (fix ((f (closure-maker (lambda () '3) no-freevars))
        (g (closure-maker (lambda () '4) no-freevars)))
    @meta{body}))
@end example

@noindent
both the @objtype{fix}--bound functions have empty list of free
variables, so both functions are combinators.

@item
If a list of free variables contains only externally defined @metai{lhs}
structs: the corresponding @metao{rhs} is a non--combinator.  For
example, in the recordised code:

@example
(bind ((a @meta{rhs-a}) (b @meta{rhs-b}))
  (fix ((f (closure-maker (lambda () a)
                          (freevars: a)))
        (g (closure-maker (lambda () (constant 3))
                          no-freevars)))
    @meta{body}))
@end example

@noindent
the function bound to @code{f} has the @objtype{var} @code{a} in its
free variables list; the value of the free variable @code{a} is known
only at run--time, so the closure maker must capture a run--time value,
so the function @code{f} is a non--combinator.

@item
If a list of free variables contains only @metao{lhs} structs defined at
by the same @objtype{fix} and bound to combinators: the corresponding
@metao{rhs} is a combinator.  For example, in the recordised code:

@example
(bind ((a @meta{rhs-a}) (b @meta{rhs-b}))
  (fix ((f (closure-maker (lambda () (constant 3))
                          no-freevars))
        (g (closure-maker (lambda () (funcall f))
                          (freevars: f))))
    @meta{body}))
@end example

@noindent
the function bound to @code{f} has no free variables, so it is a
combinator; the function bound to @code{g} has @code{f} in its list of
free variables; the value of @code{f} is known at compile--time, so the
closure maker of @code{g} does not need to capture a free variable's
run--time value, so the function @code{g} is a combinator too.

@item
If every list of free variables contains only @metao{lhs} structs
defined by the same @objtype{fix}: all the corresponding @metao{rhs} are
combinators.  For example, in the recordised code:

@example
(bind ((a @meta{rhs-a}) (b @meta{rhs-b}))
  (fix ((f (closure-maker (lambda () (funcall g))
                          (freevars: g)))
        (g (closure-maker (lambda () (funcall f))
                          (freevars: f))))
    @meta{body}))
@end example

@noindent
both the functions have lists of free variables including only
@objtype{var} structs defined by the same @objtype{fix}; the values of
the free variables is known at compile--time, so the closure makers do
not need to capture the free variables' run--time values, so both the
functions are combinators.

@item
If a list of free variables contains a @metao{lhs} struct bound to a
non--combinator, the corresponding @metao{rhs} is a non--combinator too.
For example, in the recordised code:

@example
(bind ((a @meta{rhs-a}) (b @meta{rhs-b}))
  (fix ((f (closure-maker (lambda () a)
                          (freevars: a)))
        (g (closure-maker (lambda () (funcall f))
                          (freevars: f))))
    @meta{body}))
@end example

@noindent
the function bound to @code{f} is a non--combinator; the function bound
to @code{g} has @code{f} in its free variables list; the value of
@code{f} includes the run--time value of @code{a}, so the value of the
free variable @code{f} is known only at run--time, so the closure maker
of @code{g} must capture the run--time value, so the function @code{g}
is a non--combinator too.
@end itemize

@c page
@node compiler lifting optimisation
@subsection Optimisation of combinator calls


If a Scheme function is a combinator it does not need to capture the
current value of any binding; this means we can adopt two opposite
strategies of implementation:

@itemize
@item
For every combinator function definition: we might create a single
closure object at compile--time and use it everywhere the function is
referenced.  We create a combinator closure object and keep it in memory
even when the running Scheme process never uses the function.

@item
For every reference to combinator function: we might create a different
closure object at compile-time.  We delay the creation of a closure
object until the combinator function is actually referenced by the
running Scheme process.
@end itemize

@noindent
this compiler pass, as implemented by @value{PRJNAME}, assumes that
delaying the creation of combinator closure objects is advantageous.  As
example, the core language expression:

@example
(let ((f (lambda () '1)))
   ((primitive list) (f) (f)))
@end example

@noindent
is transformed into:

@example
(codes
 ((lambda (label: asmlabel:f:clambda) () (constant 1)))
 (funcall (primref list)
   (jmpcall asmlabel:f:clambda:case-0
            (closure-maker (code-loc asmlabel:f:clambda)
                           no-freevars))
   (jmpcall asmlabel:f:clambda:case-0
            (closure-maker (code-loc asmlabel:f:clambda)
                           no-freevars))))
@end example

@noindent
where multiple @objtype{closure-maker} structs are introduced for the
same function.

The fact that we introduce multiple @objtype{closure-maker} structs to
create closure objects with the same @objtype{clambda} implementation,
takes advantage of the @rnrs{6} statement that we cannot assume Scheme
functions are @func{eq?} to themselves:

@example
(define (func) @meta{body})
(eq? func func) @result{} unspecified
@end example

@noindent
for example, the following core language
form:

@example
(let ((a (lambda () '1)))
  ((primitive eq?) a a))
@end example

@noindent
is transformed into:

@example
(codes
  ((lambda (label: asmlabel:a:clambda) () (constant 1)))
  (funcall (primref eq?)
    (closure-maker (code-loc asmlabel:a:clambda) no-freevars)
    (closure-maker (code-loc asmlabel:a:clambda) no-freevars)))
@end example

@noindent
further transformations of the code might recognise the operands of
@func{eq?} as being references to the same function, but in more complex
cases this may not happen.

@c page
@node compiler lifting examples
@subsection Examples of combinators and non--combinators


Let's consider some examples of code creating a function and reason
about the function being a combinator or a non--combinator; in these
examples function integration has been disabled.

@c ------------------------------------------------------------

@subsubheading Standalone combinator

This core language expression:

@example
(lambda () ((primitive read)))
@end example

@noindent
is transformed into:

@example
(codes
  ((lambda (label: asmlabel:anonymous:clambda)
     () (funcall (primref read))))
  (closure-maker (code-loc asmlabel:anonymous:clambda)
                 no-freevars))
@end example

@noindent
the returned function looks like it is closed upon the binding
@func{read}, but in truth @func{read} is a primitive function whose
value is known at compile--time; so the returned function is a
combinator.

@c ------------------------------------------------------------

@subsubheading Simple combinators definition

This core language expression:

@example
(let ((f (lambda () '1))
      (g (lambda () '2)))
  ((primitive list) (f) (g)))
@end example

@noindent
defines two combinator functions; the @objtype{closure-maker} struct is
introduced at the functions' call site:

@example
(codes
  ((lambda (label: asmlabel:g:clambda) () (constant 2))
   (lambda (label: asmlabel:f:clambda) () (constant 1)))
  (funcall (primref list)
    (jmpcall asmlabel:f:clambda:case-0
             (closure-maker (code-loc asmlabel:f:clambda)
                            no-freevars))
    (jmpcall asmlabel:g:clambda:case-0
             (closure-maker (code-loc asmlabel:g:clambda)
                            no-freevars))))
@end example

@c ------------------------------------------------------------

@subsubheading Multiple calls to single combinator

This core language form:

@example
(let ((f (lambda () '1)))
   ((primitive list) (f) (f)))
@end example

@noindent
defines a combinator function; multiple @objtype{closure-maker} structs
are introduced at the call site for the same function:

@example
(codes
  ((lambda (label: asmlabel:f:clambda) () (constant 1)))
  (funcall (primref list)
    (jmpcall asmlabel:f:clambda:case-0
             (closure-maker (code-loc asmlabel:f:clambda)
                            no-freevars))
    (jmpcall asmlabel:f:clambda:case-0
             (closure-maker (code-loc asmlabel:f:clambda)
                            no-freevars))))
@end example

@c ------------------------------------------------------------

@subsubheading Non--combinator definition

In the core language expression:

@example
(let ((a ((primitive read))))
  (lambda () a))
@end example

@noindent
the returned function is a non--combinator because its return value
depends upon the value of the binding @code{a} at the time the closure
object is created; @code{a} is a free variable in the body of the
function and the function is closed upon it.  Indeed such form is
transformed into:

@example
(codes
  ((lambda (label: asmlabel:anonymous:clambda) () a_0))
  (bind ((a_0 (funcall (primref read))))
    (fix ((tmp_0 (closure-maker
                   (code-loc asmlabel:anonymous:clambda)
                   (freevars: a_0))))
      tmp_0)))
@end example

@c ------------------------------------------------------------

@subsubheading Multiple calls to non--combinator

In this example a single non--combinator is called twice:

@example
(let ((a ((primitive read))))
  (let ((f (lambda () a)))
    ((primitive list) (f) (f))))
@end example

@noindent
the result of the transformation is:

@example
(codes
  ((lambda (label: asmlabel:f:clambda) () a_0))
  (bind ((a_0 (funcall (primref read))))
    (fix ((f_0 (closure-maker (code-loc asmlabel:f:clambda)
                              (freevars: a_0))))
      (funcall (primref list)
               (jmpcall asmlabel:f:clambda:case-0 f_0)
               (jmpcall asmlabel:f:clambda:case-0 f_0)))))
@end example

@noindent
we see that a single @objtype{closure-maker} is introduced.

@c ------------------------------------------------------------

@subsubheading Recursive combinator and non--combinator

A self reference in a recursive function does not necessarily make it a
non--combinator.  For example:

@example
(letrec ((f (lambda () (f))))
  @meta{body})
@end example

@noindent
is transformed into:

@example
(codes
  ((lambda (label: asmlabel:f:clambda) ()
     (jmpcall asmlabel:f:clambda:case-0
              (closure-maker (code-loc asmlabel:f:clambda)
                             no-freevars))))
  (closure-maker (code-loc asmlabel:f:clambda) no-freevars))
@end example

@noindent
there are no free variables other than the recursive reference, so the
function is a combinator.  Conversely, in the expression:

@example
(let ((a ((primitive read))))
  (letrec ((f (lambda (x) (f a))))
    (f '1)))
@end example

@noindent
in addition to the self reference there is a non--removable free
variable, so the result of the transformation is:

@example
(codes
  ((lambda (label: asmlabel:f:clambda) (x_0)
      (jmpcall asmlabel:f:clambda:case-1 f_0 a_0)))
  (bind ((a_0 (funcall (primref read))))
    (fix ((f_0 (closure-maker (code-loc asmlabel:f:clambda)
                              (freevars: a_0))))
      (jmpcall asmlabel:f:clambda:case-1 f_0 (constant 1)))))
@end example

@c ------------------------------------------------------------

@subsubheading Cycle of combinator calls

In this expression functions defined at the same lexical contour call
each other in a cycle:

@example
(letrec* ((a (lambda () (d)))
          (b (lambda () (a)))
          (c (lambda () (b)))
          (d (lambda () (c))))
  ((primitive list) (a) (b) (c) (d)))
@end example

@noindent
there are no true free variables, so all the functions are implemented
as combinators:

@smallexample
(codes
 ((lambda (label: asmlabel:a:clambda) ()
     (jmpcall asmlabel:d:clambda:case-0
              (closure-maker (code-loc asmlabel:d:clambda)
                             no-freevars)))
  (lambda (label: asmlabel:d:clambda) ()
     (jmpcall asmlabel:c:clambda:case-0
              (closure-maker (code-loc asmlabel:c:clambda)
                             no-freevars)))
  (lambda (label: asmlabel:c:clambda) ()
     (jmpcall asmlabel:b:clambda:case-0
              (closure-maker (code-loc asmlabel:b:clambda)
              no-freevars)))
  (lambda (label: asmlabel:b:clambda) ()
     (jmpcall asmlabel:a:clambda:case-0
              (closure-maker (code-loc asmlabel:a:clambda)
              no-freevars))))
 (funcall (primref list)
   (jmpcall asmlabel:a:clambda:case-0
            (closure-maker (code-loc asmlabel:a:clambda)
                           no-freevars))
   (jmpcall asmlabel:b:clambda:case-0
            (closure-maker (code-loc asmlabel:b:clambda)
                           no-freevars))
   (jmpcall asmlabel:c:clambda:case-0
            (closure-maker (code-loc asmlabel:c:clambda)
                           no-freevars))
   (jmpcall asmlabel:d:clambda:case-0
            (closure-maker (code-loc asmlabel:d:clambda)
            no-freevars))))
@end smallexample

@c ------------------------------------------------------------

@subsubheading Cycle of non--combinator calls

In this expression functions defined at the same lexical contour call
each other in a cycle; one of them has a true free variable, causing all
of them to be non--combinators:

@example
(let ((v ((primitive read))))
  (letrec* ((a (lambda (x) (d x)))
            (b (lambda (x) (a x)))
            (c (lambda (x) (b x)))
            (d (lambda (x) (c v))))
    ((primitive list) (a '1) (b '2) (c '3) (d '4))))
@end example

@noindent
the result of the transformation is:

@smallexample
(codes
 ((lambda (label: asmlabel:a:clambda) (x_0)
     (jmpcall asmlabel:d:clambda:case-1 d_0 x_0))
  (lambda (label: asmlabel:d:clambda) (x_1)
     (jmpcall asmlabel:c:clambda:case-1 c_0 v_0))
  (lambda (label: asmlabel:c:clambda) (x_2)
     (jmpcall asmlabel:b:clambda:case-1 b_0 x_2))
  (lambda (label: asmlabel:b:clambda) (x_3)
     (jmpcall asmlabel:a:clambda:case-1 a_0 x_3)))
 (bind ((v_0 (funcall (primref read))))
   (fix ((a_0 (closure-maker (code-loc asmlabel:a:clambda)
                             (freevars: d_0)))
         (d_0 (closure-maker (code-loc asmlabel:d:clambda)
                             (freevars: c_0 v_0)))
         (c_0 (closure-maker (code-loc asmlabel:c:clambda)
                             (freevars: b_0)))
         (b_0 (closure-maker (code-loc asmlabel:b:clambda)
                             (freevars: a_0))))
     (funcall (primref list)
       (jmpcall asmlabel:a:clambda:case-1 a_0 (constant 1))
       (jmpcall asmlabel:b:clambda:case-1 b_0 (constant 2))
       (jmpcall asmlabel:c:clambda:case-1 c_0 (constant 3))
       (jmpcall asmlabel:d:clambda:case-1 d_0 (constant 4))))))
@end smallexample

@c page
@node compiler lifting substitutions
@subsection Substitution optimisations


This compiler pass performs substitutions of binding references with the
purpose of optimising their implementation.  One of the possible results
is to reduce the number of free variables non--combinator functions are
closed upon; if all the free variables are removed: some non--combinator
functions can be implemented as combinators.

@c ------------------------------------------------------------

@subsubheading Substituting references to combinators

This has already been discussed.  Whenever a function is recognised to
be a combinator: every reference to it is substituted with a form
building and returning a new closure object; as example, the core
language form:

@example
(let ((f (lambda () '1)))
  (f))
@end example

@noindent
is transformed into:

@example
(codes
  ((lambda (label: asmlabel:f:clambda) () (constant 1)))
  (jmpcall asmlabel:f:clambda:case-0
           (closure-maker (code-loc asmlabel:f:clambda)
                          no-freevars)))
@end example

@c ------------------------------------------------------------

@subsubheading Synonym variables substitution

In the following core language expression:

@example
(let ((a ((primitive read))))
  (let ((b a))
    b))
@end example

@noindent
the binding @code{b} is a synonym for @code{a}, so it is transformed into:

@example
(codes
  ()
  (bind ((a_0 (funcall (primref read))))
    a_0))
@end example

In the following recordised code:

@example
(fix ((a_0 (lambda () @meta{body})))
  (bind ((b_0 a_0))
    (fix ((c_0 (lambda () (funcall b_0))))
      c_0)))
@end example

@noindent
the returned value looks like a closure upon the binding @code{b_0}, but
in truth it is known at compile--time that @code{b_0} is an immutable
binding referencing a @objtype{clambda} struct and also which
@objtype{clambda} is referenced; so the function bound to @code{c_0} is
just a combinator; more: everywhere a reference to @code{b_0} appears we
can substitute it with a reference to @code{a_0}, and so we can
transform the code to:

@example
(fix ((a_0 (lambda () @meta{body})))
  (bind ((b_0 a_0))
    (fix ((c_0 (lambda () (funcall a_0))))
      c_0)))
@end example

@quotation
@strong{NOTE} While synonym binding elimination is performed by this
compiler pass: it should have already been performed by the source
optimiser.
@end quotation

@c page
@node compiler lifting api
@subsection @objtype{clambda} lifting @api{}


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $optimize-combinator-calls/lift-clambdas @var{input}
Perform code transformation traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code in the core language, and building a new hierarchy of transformed,
recordised code; return a @objtype{codes} struct.

Perform @objtype{clambda} lifting and optimisation of calls to functions
without free variables.
@end defun

@c page
@node compiler primcalls
@section Introducing primitive calls


The purpose of this compiler pass is to examine all the function calls:

@example
(@meta{operator} @meta{operand} ...)
@end example

@noindent
which, in recordized code, are represented by struct instances of type
@objtype{funcall}; everything else is left untouched.  If the
@meta{operator} is a struct instance of type @objtype{primref}
representing a primitive operation: such struct is replaced by an
appropriate struct instance of type @objtype{primcall}.  So recordised
code like:

@example
(funcall (primref @meta{name}) (@meta{operand} ...))
@end example

@noindent
is transformed into:

@example
(primcall @meta{name} (@meta{operand} ...))
@end example

If the @objtype{funcall} struct represents a call to a proper lexical
core primitive function (not operation): it is left untouched as
@objtype{funcall} struct.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $introduce-primcalls @var{input}
Perform code transformation traversing the whole hierarchy in
@var{input}, which must be a @objtype{codes} struct representing
recordised code; build and return a new @objtype{codes} struct.

Transform @objtype{funcall} structs representing core primitive
operation applications into @objtype{primcall} structs.
@end defun


As example, @func{list} is both a lexical core function and a core
primitive operation which must return a new list at each invocation; so
the core language expression:

@example
((primitive list) '1 '2)
@end example

@noindent
is transformed into:

@example
(codes
  ()
  (primcall list (constant 1) (constant 2)))
@end example

@c page
@node compiler freevar refs
@section Rewriting references to free variables


This compiler pass rewrites references to free variables in closure
objects to forms actually accessing the values from the run--time
closure object.

We know that a Scheme closure object (satisfiying the predicate
@func{procedure?}) has memory layout:

@example
                0   1   2   3   4   5
 |------------|---|---|---|---|---|---| closure object
       ^
       |      |.......................|
  pointer to     one slot for every
  binary code    free variable
@end example

@noindent
the purpose of this compiler pass is to replace references to free
variables with @objtype{primcall} structs representing the use of the
primitive @func{$cpref}.

In addition, it transforms every @objtype{closure-maker} not appearing
as right-hand side expression of a @objtype{fix} into:

@example
(fix ((tmp ?closure-maker))
  tmp)
@end example

@noindent
this is an independent task that must be performed somewhere, and we do
it here.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $rewrite-freevar-references @var{input}
Perform code transformation traversing the whole hierarchy in
@var{input}, which must be a @objtype{codes} struct representing
recordised code; build and return a new @objtype{codes} struct.

Introduce primitive calls to the primitive operation @func{$cpref} to
access free variables in closure objects.
@end defun


As example, the core language expression:

@example
(let ((a ((primitive read))))
  (lambda () a))
@end example

@noindent
is transformed into:

@example
(codes
  ((lambda (label: asmlabel:anonymous:clambda) (cp_0)
     (primcall $cpref cp_0 (constant 0))))
  (bind ((a_0 (funcall (primref read))))
    (fix ((tmp_0 (closure-maker
                    (code-loc asmlabel:anonymous:clambda)
                    (freevars: a_0))))
      tmp_0)))
@end example

@noindent
and the following core language expression, defining an assigned free
variable:

@example
(let ((a ((primitive read))))
  (lambda ()
    (begin
      (set! a '1)
      a)))
@end example

@noindent
is transformed into:

@example
(codes
 ((lambda (label: asmlabel:anonymous:clambda) (cp_0)
     (seq
       (primcall $vector-set!
                 (primcall $cpref cp_0 (constant 0))
                 (constant 0)
                 (constant 1))
       (primcall $vector-ref
                 (primcall $cpref cp_0 (constant 0))
                 (constant 0)))))
 (bind ((a_0 (funcall (primref read))))
   (bind ((a_1 (primcall vector a_0)))
     (fix ((tmp_0 (closure-maker
                     (code-loc asmlabel:anonymous:clambda)
                     (freevars: a_1))))
       tmp_0))))
@end example

@c page
@node compiler engine
@section Inserting engine checks


This compiler pass traverses all the function bodies and, if the body
contains at least one @objtype{jmpcall} struct or one @objtype{funcall}
struct (in which the operator is @strong{not} a @objtype{primref}), it
transforms the @meta{body} into:

@example
(seq
  (primcall $do-event ())
  @meta{body})
@end example

@noindent
the call to the primitive operation @func{$do-event} suspends the
execution of Scheme code for the current internal process and enters an
internal subprocess which can take actions asynchronously.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $insert-engine-checks @var{input}
Perform code transformation traversing the whole hierarchy in
@var{input}, which must be a @objtype{codes} struct representing
recordised code; build and return a new @objtype{codes} struct.

Insert calls to the primitive operation @func{$do-event} when
appropriate.
@end defun

@c page
@node compiler stack
@section Inserting stack overflow checks


This compiler pass traverses all the function bodies and: if a
@meta{body} contains code that will cause further use of the Scheme
stack, it transforms it as follows:

@example
(seq
  (primcall $stack-overflow-check ())
  @meta{body})
@end example

@noindent
so that, right after entering the execution of a function, the call to
the primitive operation @func{$stack-overflow-check} checks if the
current Scheme stack is about to be exhausted.  If a @meta{body} does
not make further use of the stack: its function execution is a ``stack
tail''.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $insert-stack-overflow-check @var{input}
Perform code transformation traversing the whole hierarchy in
@var{input}, which must be a @objtype{codes} struct representing
recordised code; build and return a new @objtype{codes} struct.

Insert calls to the primitive operation @func{$stack-overflow-check}
when appropriate.
@end defun

@c page
@node compiler cogen
@section Full assembly code generation


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $alt-cogen @var{input}
@end defun

@c page
@node compiler assember
@section Binary code generation


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $assemble-sources @var{input}
@end defun

@c page
@node compiler primop
@section Expanding primitive operations


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $specify-representation @var{input}
@end defun

@c page
@node compiler order
@section Imposing calling convention and evaluation order


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $impose-calling-convention/evaluation-order @var{input}
@end defun

@c page
@node compiler frame
@section Assigning frame sizes


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $assign-frame-sizes @var{input}
@end defun

@c page
@node compiler color
@section Colorising by Chaitin


For an introduction to register allocation see:

@center @url{http://en.wikipedia.org/wiki/Register_allocation}

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $color-by-chaitin @var{input}
@end defun

@c page
@node compiler flatten
@section Flattening codes


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $flatten-codes @var{input}
@end defun



@c Local Variables:
@c mode: texinfo
@c TeX-master: "vicare-scheme"
@c End:
