@node expander
@chapter Expander internals


@value{PRJNAME}'s expander is a development of the expander library
@code{psyntax} written by Abdulaziz Ghuloum and Kent Dybvig and released
to the public under a very liberal license.  @ref{references expander}
for the bibliography on the expansion process.

@menu
* expander intro::              Introduction to the expansion process.
* expander lexenv::             The lexical environment.
@end menu

@c page
@node expander intro
@section Introduction to the expansion process


While discussing the expander operations, we will always refer to source
code in the form of libraries.  @rnrs{6} also defines top level
programs; however, under @value{PRJNAME}:

@itemize
@item
The process of expanding programs is almost equal to the process of
expanding libraries.  The differences are: a program does not export
syntactic bindings; the top level body of a program intermixes
definitions and expressions, while the top level body of a library
separates definitions and expressions.

@item
The result of expanding a library is equal to the result of expanding a
program.

@item
The output of the expander is the input of the compiler, and such input
is equal when compiling a library and when compiling a program.
@end itemize

@noindent
so if we understand how libraries are expanded, we also understand how
programs are expanded.

@menu
* expander intro times::        Evaluation times.
* expander intro bindings::     Syntactic bindings.
* expander intro lex::          Lexical variables, labels,
                                location gensyms.
@end menu

@c page
@node expander intro times
@subsection Evaluation times


Throughout the code there are several references to different code
evaluation times.  The following library from @bibref{exp1} allows us to
explore what those times mean.

@lisp
(library (times-demo)
  (export
    call-time invoke-time expand-time visit-time compile-time)
  (import (vicare)
    (prefix (srfi :19) srfi.))

  (define call-time
    (lambda ()
      (receive-and-return (S)
          (srfi.date->string (srfi.current-date))
        (printf "call time: ~a\n" S))))

  (define invoke-time
    (let ((t (receive-and-return (S)
                 (srfi.date->string (srfi.current-date))
               (printf "invoke time: ~a\n" S))))
      (lambda () t)))

  (define-syntax expand-time
    (lambda (stx)
      (receive-and-return (S)
          (srfi.date->string (srfi.current-date))
        (printf "expand time: ~a\n" S))))

  (define-syntax visit-time
    (let ((t (receive-and-return (S)
                 (srfi.date->string (srfi.current-date))
               (printf "visit time: ~a\n" S))))
      (lambda (stx) t)))

  (define-syntax compile-time
    (lambda (stx)
      (let-syntax ((t (lambda (stx)
                        (receive-and-return (S)
                            (srfi.date->string (srfi.current-date))
                          (printf "compile time: ~a\n" S)))))
        (t))))

  #| end of library |# )
@end lisp

@c page
@node expander intro bindings
@subsection Syntactic bindings


@cindex Initial environment, definition of
@cindex Syntactic bindings, definition of
@cindex Lexical bindings, definition of
@cindex Syntactic bindings, definition of
@cindex Top level bindings, definition of
@cindex Local bindings, definition of

@cindex Definition of initial environment
@cindex Definition of syntactic bindings
@cindex Definition of lexical bindings
@cindex Definition of syntactic bindings
@cindex Definition of top level bindings
@cindex Definition of local bindings

@cindex bindings, syntactic


A syntactic binding is an association between an identifier and the
result of evaluating an expression; there are different kinds:

@table @dfn
@item primitive syntax bindings
Basic syntactic forms built into the language.  They are
@syntax{lambda}, @syntax{define}, @syntax{let} and similar,
@syntax{define-syntax}, @syntax{letrec-syntax}, @syntax{if},
@syntax{and}, @syntax{or} and all the rest.

@item variable bindings
Associations between identifiers and expressions evaluated at run--time.
They are established by @syntax{define}, @syntax{let}, @syntax{letrec}
and similar.

@item keyword bindings
Associations between identifiers and expressions evaluated at
expand--time.  The identifiers in this role are called @dfn{syntactic
keywords} (not to be confused with keyword objects).  Keyword bindings
are also named @dfn{macros} or just @dfn{syntaxes}.
@end table

@noindent
we see that primitive syntax bindings are like keyword bindings built
into the language.

A syntactic binding descriptor is a pair with the following format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
where @meta{binding-type} is a symbol and the format of
@meta{binding-value} depends on the binding type.

@c ------------------------------------------------------------------------

@subsubheading Identifiers in binding position and reference position

Let's consider the following syntactic form:

@lisp
(let ((a 1))
  a)
@end lisp

@noindent
the @syntax{let} syntax defines a variable binding whose name is
@samp{a}; a variable binding is an association between a name and the
result of evaluating an expression at run--time.

Let's consider the following form:

@lisp
(let-syntax ((a (identifier-syntax 1)))
  a)
@end lisp

@noindent
@syntax{let-syntax} defines a keyword binding whose name is @samp{a}; a
keyword binding is an association between a name and the result of
evaluating an expression at expand--time.

The identifiers @samp{a} in the first argument of @syntax{let} and
@syntax{let-syntax} are in @dfn{binding position}; the identifiers in
the bodies of @syntax{let} and @syntax{let-syntax} are in @dfn{reference
position}.  The identifier in reference position is a reference to the
identifier in binding position: we say that the identifier in reference
position is ``captured'' by the identifier in binding position.

@c ------------------------------------------------------------------------

@subsubheading Lexical environment

The expansion process proceeds from the outer forms to the inner forms.
Given the syntactic form:

@lisp
(let ((a 1))
  (let ((b 2))
    (+ a b)))
@end lisp

@noindent
first the outer @syntax{let} is processed and the syntactic binding for
@samp{a} is established; then the inner @syntax{let} is processed and
the syntactic binding for @samp{b} is established; finally the
expression @code{(+ a b)} is processed in a lexical context in which the
syntactic bindings exist.

The region of the syntactic binding @samp{a} is the inner @syntax{let}
form; notice that the binding for @samp{a} is not visible in the
right--hand side of its definition.  The region of the syntactic binding
@samp{b} is the internal expression.

During the expansion process: syntactic bindings are added to an
internal data structure that collects the associations, keeping track of
nested regions of visibility: the @dfn{lexical environment}.  The
lexical environment is somewhat handled like a stack: while entering
internal expressions, syntactic binding descriptors are pushed on the
stack.

@c ------------------------------------------------------------------------

@subsubheading Initial environment, top level bindings, local bindings

Let's consider the following library:

@lisp
(library (demo)
  (export)
  (import (rnrs (6)))

  (define var 1)

  (define (fun a)
    (let ((b 2))
      (let-syntax ((c (identifier-syntax 3)))
        (display (+ a b c))
        (newline))))

  (define-syntax syn
    (syntax-rules ()
      ((_ ?obj)
       (display ?obj))))

  (import (prefix (vicare posix) px.))
  (display (px.getenv "PATH"))
  (newline)

  #| end of library |# )
@end lisp

@noindent
we introduce the definitions:

@table @dfn
@item initial lexical environment
The syntactic bindings imported by the @clause{import} clause of the
@clause{library} form and by the @syntax{import} syntax in the body of
the library, constitute the initial lexical environment for the
expansion process of the library.

In the example: the initial environment is the set of bindings exported
by the libraries @library{rnrs (6)} and @library{vicare posix}.

@quotation
@strong{NOTE} An @syntax{import} syntax that appears in an internal body
as in:

@lisp
(lambda ()
  (import (srfi :19))
  (do-something))
@end lisp

@noindent
does @strong{not} add bindings to the initial environment: it adds them
to the local lexical environment.
@end quotation

@item top level syntactic bindings
Syntactic bindings defined in the body of the library with
@syntax{define} and @syntax{define-syntax}; the ones defined by
@syntax{define} are variable bindings, the ones defined by
@syntax{define-syntax} are keyword bindings.

Top level bindings are visible in the whole library body: their region
is the whole body.  Top level bindings have indefinite extent: their
values are never garbage collected, they exists for the whole life of
the @value{EXECUTABLE} process.

In the example: @samp{var} and @samp{fun} are top level variables;
@samp{syn} is a top level keyword.

Every identifier in reference position that is not captured by a
syntactic binding definition in the library itself must be captured by a
binding in the initial environment; otherwise an exception is raised
with condition object of type @condition{undefined}.

@item local syntactic bindings
Syntactic bindings defined by a syntax that limits their region of
visibility to a subform of the library body.  Bindings defined by
@syntax{let} and similar syntaxes are local variable bindings, as well
as those defined by @syntax{define} in an internal body.  Bindings
defined by @syntax{let-syntax} and similar syntaxes are local keyword
bindings, as well as those defined by @syntax{define-syntax} in an
internal body.

In the example: @samp{a} and @samp{b} are local variable bindings;
@samp{c} is a local keyword binding.
@end table

@c page
@node expander intro lex
@subsection Lexical variables, labels, location gensyms


Let's consider the library:

@lisp
(library (demo)
  (export this)
  (import (rnrs (6)))
  (define this 8)
  (define that 9)
  (let ((a 1))
    (let ((a 2))
      (list a this that))))
@end lisp

@noindent
and concentrate on the body:

@lisp
(define this 8)
(define that 9)
(let ((a 1))
  (let ((a 2))
    (list a this that)))
@end lisp

This code defines 4 syntactic bindings: @samp{this} and @samp{that} as
top level variable bindings, of which @samp{this} is also exported;
outer @samp{a} as local variable binding; inner @samp{a} as local
variable binding.

The purpose of the expansion process is to transform the input code into
output code expressed in the core language.  After the expansion
process, every syntactic binding is renamed so that its name is unique
in the whole library body.  For example, we can imagine this
pseudo--code:

@lisp
(define lex.this 8)
(define lex.that 9)
(let ((lex.a.1 1))
  (let ((lex.a.2 2))
    ((primitive list) lex.a.2 lex.this lex.that)))
@end lisp

@noindent
notice that the original identifier @func{list}, in reference position,
has been replaced by the symbolic expression @code{(primitive list)}
because it is captured by the core primitive binding of the initial
lexical environment.  The code undergoes the following lexical variable
name substitutions:

@multitable {original name} {lexical variable name}
@headitem original name @tab lexical variable name
@item this @tab lex.this
@item that  @tab lex.that
@item outer a @tab lex.a.1
@item inner a @tab lex.a.2
@end multitable

@noindent
where the @code{lex.*} symbols are gensyms; such gensyms are named
@dfn{lexical gensyms} or @dfn{lex gensyms}.  They uniquely identify a
syntactic binding established in the library.

Renaming bindings is one of the core purposes of the expansion process;
it is performed while visiting the source code as a tree in
breadth--first order.

@c ------------------------------------------------------------------------

@subsubheading Lexical contours and ribs

To distinguish among different bindings with the same name (like the two
local bindings both named @samp{a} in the example) we must distinguish
among different @dfn{lexical contours}: different regions of visibility
for a set of syntactic bindings.

Every @syntax{let} syntax defines a new lexical contour; lexical
contours can be nested by nesting @syntax{let} syntaxes; the library
body is a lexical contour itself.

@quotation
@strong{NOTE} For simplicity, here we ignore the fact that @syntax{let},
in truth, defines 2 lexical contours: one for the bindings established
by its first argument and one for the internal definitions.  In the
example there are no internal definitions, so the internal contour is
not used.
@end quotation

@float Figure,fix:expander-intro-1
@example
 -------------------------------------------------
| (define this 8)              ;top-level contour |
| (define that 9)                                 |
| (let ((a 1))                                    |
|  -----------------------------------------      |
| |                            ;contour 1   |     |
| | (let ((a 2))                            |     |
| |  -------------------------------------  |     |
| | |                          ;contour 2 | |     |
| | | (list a this that)                  | |     |
| |  -------------------------------------  |     |
| |   )                                     |     |
|  -----------------------------------------      |
|   )                                             |
 -------------------------------------------------
@end example
@caption{Picture of lexical contours.}
@end float

An @func{eq?}-unique object is assigned to each lexical contour; such
objects are called @dfn{marks}.  In practise each syntactic binding is
associated to the mark representing its visibility region.  So the
original code is accompanied by the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item this @tab top-mark
@item that @tab top-mark
@item outer a @tab 1-mark
@item inner a @tab 2-mark
@end multitable

@noindent
which are registered in a component of the lexical environment: a record
of type @objtype{<rib>}.  Every lexical contour is described by a rib;
the rib for the top level contour holds the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item this @tab top-mark
@item that @tab top-mark
@end multitable

@noindent
the rib of the outer @syntax{let} holds the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item outer a @tab 1-mark
@end multitable

@noindent
the rib of the inner @syntax{let} holds the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item inner a @tab 2-mark
@end multitable

@c ------------------------------------------------------------------------

@subsubheading Syntax objects and syntax identifiers

While the code is being visited by the expander: data structures called
@dfn{syntax objects} are created to keep track of the lexical contours.

@enumerate
@item
At first, the whole code is in a syntax object referencing the top rib
structure:

@example
#<syntax-object
   expr=(begin
          (define this 8)
          (define that 9)
          (let ((a 1))
            (let ((a 2))
              (list a this that))))
   rib=#<<rib> mark=top-mark>>
@end example

@noindent
syntactic bindings established in this contour will get the top-mark;
expressions in the right--hand sides of binding definitions are expanded
in the context of the top-mark.

@item
After the outer contour has been processed, the outer @syntax{let} is in
a syntax object:

@example
#<syntax-object
   expr=(let ((a 1))
          (let ((a 2))
            (list a this that)))
   rib=#<<rib> mark=1-mark>>
@end example

@noindent
syntactic bindings established in this contour will get the 1-mark;
expressions in the right--hand sides of binding definitions are expanded
in the context of the top-mark.

@item
After the outer @syntax{let} has been processed, the inner @syntax{let}
is in a syntax object:

@example
#<syntax-object
   expr=(let ((a 2))
          (list a this that))
   rib=#<<rib> mark=2-mark>>
@end example

@noindent
syntactic bindings established in this contour will get the 2-mark;
expressions in the right--hand sides of binding definitions are expanded
in the context of the 1-mark.

@item
After the inner @syntax{let} has been processed, the expression is in a
syntax object:

@example
#<syntax-object
   expr=(list a this that)
   rib=#<<rib> mark=2-mark>>
@end example

@noindent
the expression is expanded in the context of the 2-mark.
@end enumerate

A syntax object having a syntactic binding name as source code
expression is called @dfn{syntactic identifiers}; an identifier is a
data structure holding the mark of its visibility region/lexical contour
among its fields.

@c ------------------------------------------------------------------------

@subsubheading Label gensyms and ribs

An @func{eq?}-unique object is assigned to each syntactic binding: a
gensym indicated as @dfn{label gensym} or just @dfn{label}; such
associations are also stored in the rib representing a lexical contour:

@multitable {original name} {lexical contour mark} {label}
@headitem original name @tab lexical contour mark @tab label
@item this     @tab top-mark  @tab lab.this
@item that     @tab top-mark  @tab lab.that
@item outer a  @tab 1-mark    @tab lab.a.1
@item inner a  @tab 2-mark    @tab lab.a.2
@end multitable

@noindent
where the symbols @code{lab.*} are gensyms.

@c ------------------------------------------------------------------------

@subsubheading Lexical variable gensyms and the @lexenv{}

The fact that the lex gensyms in the expanded code are syntactic
bindings representing variables is registered in a portion of the
lexical environment indicated as @lexenv{}.  So the expanded code is
accompanied by the association:

@multitable {lab.that} {lexical variables}
@headitem label @tab lexical variables
@item lab.this  @tab lex.this
@item lab.that  @tab lex.that
@item lab.a.1   @tab lex.a.1
@item lab.a.2   @tab lex.a.2
@end multitable

Notice that, after the expansion: the original names of the internal
bindings (those defined by @syntax{let}) do not matter anymore; the
original names of the non--exported top level bindings do not matter
anymore; only the original name of the exported top level bindings is
still important.

@c ------------------------------------------------------------------------

@subsubheading Storage location gensyms and @ExportEnv{}

About the value of syntactic bindings:

@itemize
@item
The value of local variables goes on the Scheme stack and it exists only
while the code is being evaluated.

@item
The value of local keywords goes on the Scheme stack and it exists only
while the code is being expanded.

@item
The value of top level bindings must be stored in some persistent
location, because it must exist for the whole time the library is loaded
in a running @value{PRJNAME} process.
@end itemize

But where is a top level binding value stored?  The answer is: gensyms
are created for the sole purpose of acting as storage locations for top
level bindings; such gensyms are indicated as @dfn{location gensyms} or
@dfn{loc gensyms}.  Under @value{PRJNAME}, symbols are data structures
having a @code{value} slot: such slot has @func{symbol-value} as
accessor and @func{set-symbol-value!} as mutator and it is used as
storage location.

So the expanded code is accompanied by the following association:

@multitable {lab-this} {location gensym}
@headitem label @tab location gensym
@item lab.this  @tab loc.this
@item lab.that  @tab loc.that
@end multitable

@noindent
where the @code{loc.*} symbols are gensyms.  To represent the
association between the top level binding labels (both the exported ones
and the non--exported ones) and their storage location gensyms, the
expander builds a data structure indicated as @ExportEnv{}.

@c ------------------------------------------------------------------------

@subsubheading Exported bindings and @ExportSubst{}

Not all the top level syntactic bindings are exported by a library.  To
list those that are, a data structure is built and indicated as
@ExportSubst{}; such data structure associates the external name of
exported bindings to their label gensym.  For the example library, the
@ExportSubst{} represents the association:

@multitable {lab.this} {external name}
@headitem label @tab external name
@item lab.this  @tab this
@end multitable

If the @clause{export} clause of the @clause{library} form renames a
binding as in:

@example
(export (rename this external-this))
@end example

@noindent
then the @ExportSubst{} represents the association:

@multitable {lab.this} {external name}
@headitem label @tab external name
@item lab.this  @tab external-this
@end multitable

@c page
@node expander lexenv
@section The lexical environment


@menu
* expander lexenv boot::        The boot image component.
* expander lexenv lexenv::      The @lexenv{} component.
* expander lexenv fluids::      How fluid syntaxes work.
* expander lexenv synonyms::    How synonym syntaxes work.
@end menu

@c page
@node expander lexenv boot
@subsection The boot image component


The syntactic bindings exported by the boot image are all those exported
by the library @library{psyntax system $all}; this is an internal
library that should not be used for normal operations.

A syntactic binding descriptor is a pair with the following format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
where @meta{binding-type} is a symbol and the format of
@meta{binding-value} depends on the binding type.  The syntactic
bindings exported by the boot image have descriptors defined in, and
only in, the file @file{makefile.sps} in @value{PRJNAME}'s source code
tree.  Every boot image syntactic binding has a label gensym associated
to it: the binding's descriptor is stored in the @code{value} slot of
the label.

@quotation
Symbol objects are data structures with a slot named @code{value},
accessor @func{symbol-value} and mutator @func{set-symbol-value!}; this
slot is usually initialised to the built--in object returned by
@code{(unbound-object)}.
@end quotation

We can easily inspect the boot image syntactic binding descriptors;
first let's create a lexical environment object with the system library:

@lisp
(define env (environment '(psyntax system $all)))
@end lisp

@noindent
then let's look at some descriptors:

@itemize
@item
Primitive function @func{display}:

@lisp
(define-values (label syntactic-binding-descriptor)
  (environment-binding 'display env))
syntactic-binding-descriptor  @result{} (core-prim . display)
(symbol-value label)          @result{} (core-prim . display)
(eq? syntactic-binding-descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the binding descriptor pair: the @meta{binding-type} is the symbol
@samp{core-prim} and the @meta{binding-value} is the symbol
@samp{display}, which is the public name of the primitive function.

@item
Core primitive syntax @syntax{lambda}:

@lisp
(define-values (label syntactic-binding-descriptor)
  (environment-binding 'lambda env))
syntactic-binding-descriptor  @result{} (core-macro . lambda)
(symbol-value label)          @result{} (core-macro . lambda)
(eq? syntactic-binding-descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the binding descriptor pair: the @meta{binding-type} is the symbol
@samp{core-macro} and the @meta{binding-value} is the symbol
@samp{lambda}, which is the public name of the primitive syntax.

@item
Non--core primitive syntax @syntax{let}:

@lisp
(define-values (label syntactic-binding-descriptor)
  (environment-binding 'let env))
syntactic-binding-descriptor  @result{} (macro . let)
(symbol-value label)          @result{} (macro . let)
(eq? syntactic-binding-descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the binding descriptor pair: the @meta{binding-type} is the symbol
@samp{macro} and the @meta{binding-value} is the symbol @samp{let},
which is the public name of the primitive syntax.

@item
Condition object type @condition{condition}, which is implemented as
@rnrs{6} record type:

@lisp
(define-values (label syntactic-binding-descriptor)
  (environment-binding '&condition env))
syntactic-binding-descriptor
@result{} ($core-rtd &condition-rtd &condition-rcd)
(symbol-value label)
@result{} ($core-rtd &condition-rtd &condition-rcd)
(eq? syntactic-binding-descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the binding descriptor pair: the @meta{binding-type} is the symbol
@samp{$core-rtd} and the @meta{binding-value} is the list:

@example
(&condition-rtd &condition-rcd)
@end example

@noindent
we can further inspect @code{&condition-rtd} and @code{&condition-rcd}:

@lisp
(receive (label syntactic-binding-descriptor)
    (environment-binding '&condition-rtd env)
  syntactic-binding-descriptor)
@result{} (core-prim . &condition-rtd)

(receive (label syntactic-binding-descriptor)
    (environment-binding '&condition-rcd env)
  syntactic-binding-descriptor)
@result{} (core-prim . &condition-rcd)
@end lisp
@end itemize

If we know the public name of a primitive syntactic binding
(@func{display}, @syntax{lambda}, @syntax{let}, @condition{condition},
@dots{}) we can retrieve the binding's label; given the label we can
retrieve the binding descriptor.

For core primitive functions, record--type descriptors and
record--constructor descriptors:

@itemize
@item
Given the primitive's public name we can retrieve the binding type, the
storage location gensym and so the system value, @ref{iklib symbols
system, System values bound to symbols}.

@item
Given the primitive's label gensym we can retrieve the binding type, the
public name and so the storage location gensym and the system value,
@ref{iklib symbols labels, Retrieving syntactic binding labels}.
@end itemize

Core primitive syntaxes and non--core primitive syntaxes have
implementation integrated in the expander:

@itemize
@item
Given the primitive's public name we can retrieve the binding type and
the label gensym.

@item
Given the primitive's label gensym we can retrieve the binding type and
the public name.
@end itemize

@c ------------------------------------------------------------------------

@subsubheading Boot image entry types

All the boot image's syntactic binding descriptors have the format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
and they are of the following types.

@table @strong
@item Integrated syntax
Some syntaxes are built into the expander and do not even have an
internal transformer function.  A syntactic binding representing an
integrated syntax has the format:

@example
(@meta{name} . ())
@end example

@noindent
where: @meta{binding-type} is @meta{name}, a symbol representing the
public name of the syntax; @meta{binding-value} is null.

Some of these core language syntaxes are: @syntax{define-syntax},
@syntax{define-alias}, @syntax{define-fluid-syntax}, @syntax{module},
@syntax{library}, @syntax{begin}, @syntax{import}, @syntax{export},
@syntax{set!}, @syntax{let-syntax}, @syntax{letrec-syntax},
@syntax{stale-when}, @syntax{begin-for-syntax},
@syntax{eval-for-expand}.

@item Core macro
A syntactic binding representing a core macro integrated in the expander
has the format:

@example
(core-macro . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the
syntax.  The core syntax transformer functions are implemented by the
expander in the module exporting the function
@func{core-macro-transformer}, which is used to map core syntax names to
transformer functions.

The implementation of core syntaxes cannot be decomposed into uses of
other syntaxes.  Some of these syntaxes are: @syntax{quote},
@syntax{lambda}, @syntax{case-lambda}, @syntax{let}, @syntax{letrec},
@syntax{letrec*}, @syntax{if}, @syntax{foreign-call},
@syntax{syntax-case}, @syntax{syntax}, @syntax{fluid-let-syntax},
@syntax{internal-body}.

@item Non--core macro
A binding representing a non--core syntax integrated in the expander has
the format:

@example
(macro . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the
syntax.  The non--core syntax transformer functions are implemented by
the expander in the module exporting the function
@func{non-core-macro-transformer}, which is used to map non--core syntax
names to transformer functions.

The implementation of non--core syntaxes can be decomposed into uses of
other syntaxes.  Some of these syntaxes are:

@example
define-struct define-record-type define-condition-type
define-enumeration
do or and xor
cond case
let* let-values let*-values syntax-rules
quasiquote quasisyntax with-syntax identifier-syntax
let*-syntax
define-syntax-rule define-auxiliary-syntaxes define-syntax*
when unless while until for returnable
case-define define* case-define* lambda* case-lambda*
define-values receive receive-and-return begin0
include
assert try with-unwind-protection guard
@end example

@item Core primitive
A syntactic binding representing a core primitive exported by the boot
image has the format:

@example
(core-prim . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the core
primitive.  These core primitives are all the primitive functions, the
record--type descriptors, the record--constructor descriptors.

@item Core record--type name
A binding representing @rnrs{6}'s record--type name exported by the boot
image has the format:

@example
($core-rtd . (@meta{rtd-name} @meta{rcd-name}))
@end example

@noindent
where: @meta{rtd-name} is a symbol representing the public name of the
identifier to which the record--type descriptor was originally bound;
@meta{rcd-name} is a symbol representing the public name of the
identifier to which the default record--constructor descriptor was
originally bound.

For example: these entries are used to represent the predefined @rnrs{6}
condition object types.

@item Fluid syntax
A binding representing a fluid syntax has the format:

@example
($fluid . @meta{fluid-main-label})
@end example

@noindent
where @meta{fluid-main-label} is the label gensym of the fluid syntax;
@ref{expander lexenv fluids, How fluid syntaxes work}.

Some of the fluid syntaxes are: @syntax{__who__}, @syntax{return},
@syntax{continue}, @syntax{break}, @syntax{with}, @syntax{brace},
@syntax{<>}.
@end table

@c page
@node expander lexenv lexenv
@subsection The @lexenv{} component


A @lexenv{} is an alist managed somewhat like a stack; while the
expansion proceeds, visiting the code in breadth--first order: the
@lexenv{} is updated by pushing new entries on the stack.  Each entry is
a pair, list or improper list and maps a label gensym to its associated
syntactic binding descriptor.

A @lexenv{} entry has the following format:

@example
(@meta{label} . @meta{syntactic-binding-descriptor})
@end example

@noindent
where: @meta{label} is a label gensym uniquely associated to a syntactic
binding; @meta{syntactic-binding-descriptor} is a syntactic binding
descriptor.

A syntactic binding descriptor is a pair with the following format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
where @meta{binding-type} is a symbol and the format of
@meta{binding-value} depends on the binding type.

@c ------------------------------------------------------------------------

@subsubheading Top level or local variable bindings

A syntactic binding representing a variable binding, as created by
@syntax{let} and similar syntaxes, @syntax{lambda}, @syntax{case-lambda}
or @syntax{define}, has descriptor with format:

@example
(lexical . (@meta{lexvar} . @meta{mutated}))
@end example

@noindent
where: @meta{lexvar} is a lexical gensym representing the name of the
lexical variable binding in the expanded code; @meta{mutated} is a
boolean, true if somewhere in the code the value of this binding is
mutated.

We want to keep track of mutated variables because we do not want to
export from a library a mutable variable.

@c ------------------------------------------------------------------------

@subsubheading Imported variable bindings

A syntactic binding representing a variable binding imported from
another library has descriptor with format:

@example
(global . (@meta{library} . @meta{loc}))
@end example

@noindent
where: @meta{library} represents the library from which the binding is
exported; @meta{loc} is the storage location gensym containing the
variable's value in its @code{value} field.

When the variable is defined by an imported library: @meta{library} is a
record of type @objtype{library}.  When the variable was defined by a
previous @repl{} expression: @meta{library} is the symbol
@samp{*interaction*}.

Labels associated to these imported bindings have the list representing
the binding itself stored in their "value" fields.

@c ------------------------------------------------------------------------

@subsubheading Top level or local non--identifier macro

A syntactic binding representing a keyword binding with non--variable
transformer defined by the code being expanded has descriptor with
format:

@example
(local-macro . (@meta{transformer} . @meta{expanded-expr}))
@end example

@noindent
where: @meta{transformer} is a function implementing the macro
transformer; @meta{expanded-expr} is the expression in fully expanded
code representing the right--hand side of the syntax definition.
@meta{transformer} is the result of compiling and evaluating
@meta{expanded-expr}.

For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

@example
(set! @meta{loc} @meta{expanded-code})
@end example

@noindent
where @meta{loc} is the storage location gensym of the macro.

These syntactic bindings are established by @syntax{define-syntax},
@syntax{let-syntax} and similar, when their right--hand side evaluates
to a function.

@c ------------------------------------------------------------------------

@subsubheading Top level or local identifier macro

A syntactic binding representing a keyword binding with variable
transformer defined by the code being expanded has descriptor with
format:

@example
(local-macro! . (@meta{transformer} . @meta{expanded-expr}))
@end example

@noindent
where: @meta{transformer} is a function implementing the macro
transformer; @meta{expanded-expr} is the expression in fully expanded
code representing the right--hand side of the syntax definition.
@meta{transformer} is the result of compiling and evaluating
@meta{expanded-expr}.

For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

@example
(set! @meta{loc} @meta{expanded-code})
@end example

@noindent
where @meta{loc} is the storage location gensym of the macro.

These syntactic bindings are established by @syntax{define-syntax},
@syntax{let-syntax} and similar, when their right--hand side evaluates
to the return value of @func{make-variable-transformer}.

@c ------------------------------------------------------------------------

@subsubheading Imported non--identifier macro

A syntactic binding representing a keyword binding with a non--variable
transformer defined by code in an imported library has descriptor with
format:

@example
(global-macro . (@meta{library} . @meta{loc}))
@end example

@noindent
where: @meta{library} is a record of type @objtype{library} describing
the library from which the macro is exported; @meta{loc} is the storage
location gensym containing the transformer function in its @code{value}
field.

Label gensyms associated to these imported bindings have the list
representing the binding descriptor itself stored in their @code{value}
field.

@c ------------------------------------------------------------------------

@subsubheading Imported identifier macro

A syntactic binding representing a keyword binding with variable
transformer defined by code in an imported library has descriptor with
format:

@example
(global-macro! . (@meta{library} . @meta{loc}))
@end example

@noindent
where: @meta{library} is a record of type @objtype{library} describing
the library from which the macro is exported; @meta{loc} is the storage
location gensym containing the transformer function in its @code{value}
field.

Label gensyms associated to these imported bindings have the list
representing the binding descriptor itself stored in their @code{value}
field.

@c ------------------------------------------------------------------------

@subsubheading Top level or local compile--time value

A syntactic binding representing a keyword binding associated to a
compile--time value defined by the code being expanded has descriptor
with format:

@example
(local-ctv . (@meta{object} . @meta{expanded-expr}))
@end example

@noindent
where: @meta{object} is the actual value computed at expand time;
@meta{expanded-expr} is the result of fully expanding the right--hand
side of the syntax definition.  @meta{object} is the result of compiling
and evaluating @meta{expanded-expr}.

For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

@example
(set! @meta{loc} @meta{expanded-code})
@end example

@noindent
where @meta{loc} is the storage location gensym of the macro.

These syntactic bindings are established by @syntax{define-syntax},
@syntax{let-syntax} and similar, when their right--hand side evaluates
to the return value of @func{make-compile-time-value}.

@c ------------------------------------------------------------------------

@subsubheading Imported compile--time value

A syntactic binding representing a keyword binding associated to a
compile-time value imported from another library has descriptor with
format:

@example
(global-ctv . (@meta{library} . @meta{loc}))
@end example

@noindent
where: @meta{library} is a record of type @objtype{library} describing
the library from which the binding is imported; @meta{loc} is the gensym
containing the actual object in its @code{value} field.

Label gensyms associated to these imported bindings have the list
representing the binding descriptor itself stored in their @code{value}
field.

@c ------------------------------------------------------------------------

@subsubheading Module interface

A syntactic binding representing a keyword binding associated to the
interface of a @syntax{module} syntax defined by the code being expanded
has descriptor with format:

@example
($module . @meta{module-interface})
@end example

@noindent
where @meta{module-interface} is a record of type
@objtype{module-interface}.

Syntactic bindings of this type are established by uses of the syntax
@syntax{module}.

@c ------------------------------------------------------------------------

@subsubheading Pattern variable

A syntactic binding representing a keyword binding associated to a
pattern variable, as created by @syntax{syntax-case} and
@syntax{syntax-rules}, in the body of the library being expanded has
descriptor with format:

@example
(syntax . (@meta{name} . @meta{level}))
@end example

@noindent
where: @meta{name} is the symbol representing the name of the pattern
variable; @meta{level} is a non--negative exact integer representing the
ellipsis nesting level.

The @syntax{syntax-case} patterns below will generate the displayed
syntactic binding descriptors:

@example
?a                      ->  (syntax . (?a . 0))
(?a)                    ->  (syntax . (?a . 0))
(((?a)))                ->  (syntax . (?a . 0))
(?a ...)                ->  (syntax . (?a . 1))
((?a) ...)              ->  (syntax . (?a . 1))
((((?a))) ...)          ->  (syntax . (?a . 1))
((?a ...) ...)          ->  (syntax . (?a . 2))
(((?a ...) ...) ...)    ->  (syntax . (?a . 3))
@end example

@c ------------------------------------------------------------------------

@subsubheading Top level or local struct descriptor

A syntactic binding representing a keyword binding associated to a
@value{PRJNAME}'s struct--type descriptor defined by the code being
expanded has descriptor with format:

@example
($rtd . @meta{type-descriptor-struct})
@end example

@noindent
where @meta{type-descriptor-struct} is a struct representing the
struct--type descriptor.

@c ------------------------------------------------------------------------

@subsubheading Top level or local @rnrs{6} record--type name

A syntactic binding representing a keyword binding associated to a
@rnrs{6}'s record--type name defined by the code being expanded has
descriptor with one of the formats:

@example
($rtd . (@meta{rtd-name} @meta{rcd-name}))
($rtd . (@meta{rtd-name} @meta{rcd-name} . @meta{spec}))
@end example

@noindent
where: @meta{rtd-name} is the identifier to which the record--type
descriptor is bound; @meta{rcd-name} is the identifier to which the
default record--constructor descriptor is bound; @meta{spec} is an
instance of record type @objtype{r6rs-record-type-spec}.

@c ------------------------------------------------------------------------

@subsubheading Fluid syntax

A syntactic binding representing a keyword binding associated to a fluid
syntax has the format:

@example
($fluid . @meta{fluid-label})
@end example

@noindent
where @meta{fluid-label} is the label gensym associated to the fluid
syntax.

@c ------------------------------------------------------------------------

@subsubheading Synonym syntax

A syntactic binding descriptor representing a keyword binding associated
to a synonym syntax has the format:

@example
($synonym . @meta{synonym-label})
@end example

@noindent
where @meta{synonym-label} is the label gensym associated to the synonym
syntax.

@c ------------------------------------------------------------------------

@subsubheading @syntax{begin-for-syntax} code

Each use of @syntax{begin-for-syntax} generates visit code that must be
added to compiled libraries.  Whenever a @syntax{begin-for-syntax} use
is expanded the following entry is pushed on the @lexenv{}:

@example
(@meta{unused-label} . (begin-for-syntax . @meta{visit-code}))
@end example

@noindent
where: @meta{unused-label} is a dummy label gensym which not bound in
the current rib; @meta{visit-code} is a full core language expression
representing the expanded contents of the @syntax{begin-for-syntax} use.

@c ------------------------------------------------------------------------

@subsubheading displaced lexical

These lists have a format similar to a @lexenv{} entry representing a
syntactic binding, but they are used to represent a failed search into a
@lexenv{}.

The following special value represents an unbound label:

@example
(displaced-lexical . #f)
@end example

@noindent
this is an ``identifier out of context'' error.

The following special value represents the result of a lexical
environment query with invalid label value (not a symbol):

@example
(displaced-lexical . ())
@end example

@c page
@node expander lexenv fluids
@subsection How fluid syntaxes work


When a fluid syntax's syntactic binding is established by
@syntax{define-fluid-syntax} in the source code of a library or program:

@example
(define-fluid-syntax @meta{lhs} @meta{rhs})
@end example

@noindent
an identifier @meta{lhs} is associated to a main label @meta{label} in
the current rib; an entry is pushed on the @lexenv{}:

@example
(@meta{label} . ($fluid . @meta{fluid-label}))
@end example

@noindent
when querying the @lexenv{} for the binding descriptor associated to
@meta{label}: the descriptor with type @code{$fluid} is always returned,
qualifying the binding as fluid syntax.

At the same time, @syntax{define-fluid-syntax} pushes another entry on
the @lexenv{}:

@example
(@meta{fluid-label} . @meta{syntactic-binding})
@end example

@noindent
where @meta{syntactic-binding} is the concrete binding descriptor
created by expanding and evaluating @meta{rhs} then interpreting its
return value.

Given the identifier @meta{lhs}: we can retrieve the associated
@meta{label} and so the @meta{fluid-label}; then we can ``follow
through'' @meta{fluid-label} to retrieve the actual binding descriptor.

The fluid syntax can be redefined any number of times by using
@syntax{fluid-let-syntax}:

@example
(fluid-let-syntax ((@meta{lhs} @meta{inner-rhs})) . @meta{body})
@end example

@noindent
causing other entries associated to @meta{fluid-label} to be pushed on
the @lexenv{}:

@example
(@meta{fluid-label} . @meta{inner-syntactic-binding})
@end example

@noindent
where @meta{inner-syntactic-binding} is the binding descriptor resulting
from expanding and evaluating @meta{inner-rhs} then interpreting its
return value.

When searching the @lexenv{} for a syntactic binding descriptor matching
the label @meta{fluid-label}: the topmost entry is found, so the binding
appears to be redefined.

@c ------------------------------------------------------------------------

@subsubheading Primitive fluid syntaxes

This is @strong{not} what happens for the primitive fluid syntaxes
exported by the boot image like @syntax{return}, @syntax{break} and
@syntax{continue}.  For these syntaxes the lexical environment of the
boot image includes only the entries:

@example
(@meta{return-label}   . ($fluid .   @meta{return-fluid-label}))
(@meta{break-label}    . ($fluid .    @meta{break-fluid-label}))
(@meta{continue-label} . ($fluid . @meta{continue-fluid-label}))
@end example

@noindent
and there are no entries for the fluid labels @meta{return-fluid-label},
@meta{break-fluid-label} and @meta{continue-fluid-label}.  The keywords
of these fluid syntaxes are bound in the environment, but they are bound
to ``nothing''; trying to follow through the fluid labels to the
concrete binding descriptors will result in the binding descriptor:

@example
(displaced-lexical . #f)
@end example

@noindent
which is interpreted as the error ``keyword identifier out of context''.

Such half--defined fluid syntaxes are fully usable as auxiliary syntaxes
and can be redefined with @syntax{fluid-let-syntax}.  There are
@strong{no} transformer functions for @syntax{return}, @syntax{break},
@syntax{continue} and similar syntaxes.

@c page
@node expander lexenv synonyms
@subsection How synonym syntaxes work


When an synonym syntax binding is established:

@lisp
(define-syntax @meta{lhs} (make-synonym-transformer @meta{id}))
@end lisp

@noindent
an identifier @meta{lhs} is associated to a main label @meta{label} in
the current rib; an entry is pushed on the @lexenv{}:

@example
(@meta{label} . ($synonym . @meta{synonym-label}))
@end example

@noindent
where @meta{synonym-label} is the label bound to the identifier
@meta{id}.  Given the identifier @meta{lhs}: we can retrieve the
associated @meta{label} and so the @meta{synonym-label}; then we can
``follow through'' @meta{synonym-label} to retrieve the actual binding
descriptor associated to @meta{id}.


@c Local Variables:
@c mode: texinfo
@c TeX-master: "vicare-scheme"
@c End:
