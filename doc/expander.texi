@node expander
@chapter Expander internals


@cindex Library @library{vicare expander}
@cindex @library{vicare expander}, library


@value{PRJNAME}'s expander is a development of the expander library
@code{psyntax} written by Abdulaziz Ghuloum and Kent Dybvig and released
to the public under a very liberal license.  @ref{references expander}
for the bibliography on the expansion process.

The library @library{vicare expander} exports bindings that allow
inspection of the expander operations.  To avoid collisions between
syntactic binding names, it is suggested to import it with prefix
@samp{xp.}:

@lisp
(import (prefix (vicare expander) xp.))
@end lisp

@menu
* expander intro::              Introduction to the expansion process.
* expander lexenv::             The lexical environment.
@end menu

@c page
@node expander intro
@section Introduction to the expansion process


While discussing the expander operations, we will always refer to source
code in the form of libraries.  @rnrs{6} also defines top level
programs; however, under @value{PRJNAME}:

@itemize
@item
The process of expanding programs is almost equal to the process of
expanding libraries.  The differences are: a program does not export
syntactic bindings; the top level body of a program intermixes
definitions and expressions, while the top level body of a library
separates definitions and expressions.

@item
The result of expanding a library is equal to the result of expanding a
program.

@item
The output of the expander is the input of the compiler, and such input
is equal when compiling a library and when compiling a program.
@end itemize

@noindent
so if we understand how libraries are expanded, we also understand how
programs are expanded.

@menu
* expander intro times::        Evaluation times.
* expander intro bindings::     Syntactic bindings.
* expander intro lex::          Lexical variables, labels,
                                location gensyms.
@end menu

@c page
@node expander intro times
@subsection Evaluation times


Throughout the code there are several references to different code
evaluation times.  The following library from @bibref{exp1} allows us to
explore what those times mean.

@lisp
(library (times-demo)
  (export
    call-time invoke-time expand-time visit-time compile-time)
  (import (vicare)
    (prefix (srfi :19) srfi.))

  (define call-time
    (lambda ()
      (receive-and-return (S)
          (srfi.date->string (srfi.current-date))
        (printf "call time: ~a\n" S))))

  (define invoke-time
    (let ((t (receive-and-return (S)
                 (srfi.date->string (srfi.current-date))
               (printf "invoke time: ~a\n" S))))
      (lambda () t)))

  (define-syntax expand-time
    (lambda (stx)
      (receive-and-return (S)
          (srfi.date->string (srfi.current-date))
        (printf "expand time: ~a\n" S))))

  (define-syntax visit-time
    (let ((t (receive-and-return (S)
                 (srfi.date->string (srfi.current-date))
               (printf "visit time: ~a\n" S))))
      (lambda (stx) t)))

  (define-syntax compile-time
    (lambda (stx)
      (let-syntax ((t (lambda (stx)
                        (receive-and-return (S)
                            (srfi.date->string (srfi.current-date))
                          (printf "compile time: ~a\n" S)))))
        (t))))

  #| end of library |# )
@end lisp

@c page
@node expander intro bindings
@subsection Syntactic bindings


@cindex Initial environment, definition of
@cindex Syntactic bindings, definition of
@cindex Lexical bindings, definition of
@cindex Syntactic bindings, definition of
@cindex Top level bindings, definition of
@cindex Local bindings, definition of

@cindex Definition of initial environment
@cindex Definition of syntactic bindings
@cindex Definition of lexical bindings
@cindex Definition of syntactic bindings
@cindex Definition of top level bindings
@cindex Definition of local bindings

@cindex bindings, syntactic


A syntactic binding is an association between an identifier and the
result of evaluating an expression; there are different kinds:

@table @dfn
@item primitive syntax bindings
Basic syntactic forms built into the language.  They are
@syntax{lambda}, @syntax{define}, @syntax{let} and similar,
@syntax{define-syntax}, @syntax{letrec-syntax}, @syntax{if},
@syntax{and}, @syntax{or} and all the rest.

@item variable bindings
Associations between identifiers and expressions evaluated at run--time.
They are established by @syntax{define}, @syntax{let}, @syntax{letrec}
and similar.

@item keyword bindings
Associations between identifiers and expressions evaluated at
expand--time.  The identifiers in this role are called @dfn{syntactic
keywords} (not to be confused with keyword objects).  Keyword bindings
are also named @dfn{macros} or just @dfn{syntaxes}.
@end table

@noindent
we see that primitive syntax bindings are like keyword bindings built
into the language.

A syntactic binding descriptor is a pair with the following format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
where @meta{binding-type} is a symbol and the format of
@meta{binding-value} depends on the binding type.

@c ------------------------------------------------------------------------

@subsubheading Identifiers in binding position and reference position

Let's consider the following syntactic form:

@lisp
(let ((a 1))
  a)
@end lisp

@noindent
the @syntax{let} syntax defines a variable binding whose name is
@samp{a}; a variable binding is an association between a name and the
result of evaluating an expression at run--time.

Let's consider the following form:

@lisp
(let-syntax ((a (identifier-syntax 1)))
  a)
@end lisp

@noindent
@syntax{let-syntax} defines a keyword binding whose name is @samp{a}; a
keyword binding is an association between a name and the result of
evaluating an expression at expand--time.

The identifiers @samp{a} in the first argument of @syntax{let} and
@syntax{let-syntax} are in @dfn{binding position}; the identifiers in
the bodies of @syntax{let} and @syntax{let-syntax} are in @dfn{reference
position}.  The identifier in reference position is a reference to the
identifier in binding position: we say that the identifier in reference
position is ``captured'' by the identifier in binding position.

@c ------------------------------------------------------------------------

@subsubheading Lexical environment

The expansion process proceeds from the outer forms to the inner forms.
Given the syntactic form:

@lisp
(let ((a 1))
  (let ((b 2))
    (+ a b)))
@end lisp

@noindent
first the outer @syntax{let} is processed and the syntactic binding for
@samp{a} is established; then the inner @syntax{let} is processed and
the syntactic binding for @samp{b} is established; finally the
expression @code{(+ a b)} is processed in a lexical context in which the
syntactic bindings exist.

The region of the syntactic binding @samp{a} is the inner @syntax{let}
form; notice that the binding for @samp{a} is not visible in the
right--hand side of its definition.  The region of the syntactic binding
@samp{b} is the internal expression.

During the expansion process: syntactic bindings are added to an
internal data structure that collects the associations, keeping track of
nested regions of visibility: the @dfn{lexical environment}.  The
lexical environment is somewhat handled like a stack: while entering
internal expressions, syntactic binding descriptors are pushed on the
stack.

@c ------------------------------------------------------------------------

@subsubheading Initial environment, top level bindings, local bindings

Let's consider the following library:

@lisp
(library (demo)
  (export)
  (import (rnrs (6)))

  (define var 1)

  (define (fun a)
    (let ((b 2))
      (let-syntax ((c (identifier-syntax 3)))
        (display (+ a b c))
        (newline))))

  (define-syntax syn
    (syntax-rules ()
      ((_ ?obj)
       (display ?obj))))

  (import (prefix (vicare posix) px.))
  (display (px.getenv "PATH"))
  (newline)

  #| end of library |# )
@end lisp

@noindent
we introduce the definitions:

@table @dfn
@item initial lexical environment
The syntactic bindings imported by the @clause{import} clause of the
@clause{library} form and by the @syntax{import} syntax in the body of
the library, constitute the initial lexical environment for the
expansion process of the library.

In the example: the initial environment is the set of bindings exported
by the libraries @library{rnrs (6)} and @library{vicare posix}.

@quotation
@strong{NOTE} An @syntax{import} syntax that appears in an internal body
as in:

@lisp
(lambda ()
  (import (srfi :19))
  (do-something))
@end lisp

@noindent
does @strong{not} add bindings to the initial environment: it adds them
to the local lexical environment.
@end quotation

@item top level syntactic bindings
Syntactic bindings defined in the body of the library with
@syntax{define} and @syntax{define-syntax}; the ones defined by
@syntax{define} are variable bindings, the ones defined by
@syntax{define-syntax} are keyword bindings.

Top level bindings are visible in the whole library body: their region
is the whole body.  Top level bindings have indefinite extent: their
values are never garbage collected, they exists for the whole life of
the @value{EXECUTABLE} process.

In the example: @samp{var} and @samp{fun} are top level variables;
@samp{syn} is a top level keyword.

Every identifier in reference position that is not captured by a
syntactic binding definition in the library itself must be captured by a
binding in the initial environment; otherwise an exception is raised
with condition object of type @condition{undefined}.

@item local syntactic bindings
Syntactic bindings defined by a syntax that limits their region of
visibility to a subform of the library body.  Bindings defined by
@syntax{let} and similar syntaxes are local variable bindings, as well
as those defined by @syntax{define} in an internal body.  Bindings
defined by @syntax{let-syntax} and similar syntaxes are local keyword
bindings, as well as those defined by @syntax{define-syntax} in an
internal body.

In the example: @samp{a} and @samp{b} are local variable bindings;
@samp{c} is a local keyword binding.
@end table

@c page
@node expander intro lex
@subsection Lexical variables, labels, location gensyms


Let's consider the library:

@lisp
(library (demo)
  (export this)
  (import (rnrs (6)))
  (define this 8)
  (define that 9)
  (let ((a 1))
    (let ((a 2))
      (list a this that))))
@end lisp

@noindent
and concentrate on the body:

@lisp
(define this 8)
(define that 9)
(let ((a 1))
  (let ((a 2))
    (list a this that)))
@end lisp

This code defines 4 syntactic bindings: @samp{this} and @samp{that} as
top level variable bindings, of which @samp{this} is also exported;
outer @samp{a} as local variable binding; inner @samp{a} as local
variable binding.

The purpose of the expansion process is to transform the input code into
output code expressed in the core language.  After the expansion
process, every syntactic binding is renamed so that its name is unique
in the whole library body.  For example, we can imagine this
pseudo--code:

@lisp
(define lex.this 8)
(define lex.that 9)
(let ((lex.a.1 1))
  (let ((lex.a.2 2))
    ((primitive list) lex.a.2 lex.this lex.that)))
@end lisp

@noindent
notice that the original identifier @func{list}, in reference position,
has been replaced by the symbolic expression @code{(primitive list)}
because it is captured by the core primitive binding of the initial
lexical environment.  The code undergoes the following lexical variable
name substitutions:

@multitable {original name} {lexical variable name}
@headitem original name @tab lexical variable name
@item this @tab lex.this
@item that  @tab lex.that
@item outer a @tab lex.a.1
@item inner a @tab lex.a.2
@end multitable

@noindent
where the @code{lex.*} symbols are gensyms; such gensyms are named
@dfn{lexical gensyms} or @dfn{lex gensyms}.  They uniquely identify a
syntactic binding established in the library.

Renaming bindings is one of the core purposes of the expansion process;
it is performed while visiting the source code as a tree in
breadth--first order.

@c ------------------------------------------------------------------------

@subsubheading Lexical contours and ribs

To distinguish among different bindings with the same name (like the two
local bindings both named @samp{a} in the example) we must distinguish
among different @dfn{lexical contours}: different regions of visibility
for a set of syntactic bindings.

Every @syntax{let} syntax defines a new lexical contour; lexical
contours can be nested by nesting @syntax{let} syntaxes; the library
body is a lexical contour itself.

@quotation
@strong{NOTE} For simplicity, here we ignore the fact that @syntax{let},
in truth, defines 2 lexical contours: one for the bindings established
by its first argument and one for the internal definitions.  In the
example there are no internal definitions, so the internal contour is
not used.
@end quotation

@float Figure,fix:expander-intro-1
@example
 -------------------------------------------------
| (define this 8)              ;top-level contour |
| (define that 9)                                 |
| (let ((a 1))                                    |
|  -----------------------------------------      |
| |                            ;contour 1   |     |
| | (let ((a 2))                            |     |
| |  -------------------------------------  |     |
| | |                          ;contour 2 | |     |
| | | (list a this that)                  | |     |
| |  -------------------------------------  |     |
| |   )                                     |     |
|  -----------------------------------------      |
|   )                                             |
 -------------------------------------------------
@end example
@caption{Picture of lexical contours.}
@end float

An @func{eq?}-unique object is assigned to each lexical contour; such
objects are called @dfn{marks}.  In practise each syntactic binding is
associated to the mark representing its visibility region.  So the
original code is accompanied by the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item this @tab top-mark
@item that @tab top-mark
@item outer a @tab 1-mark
@item inner a @tab 2-mark
@end multitable

@noindent
which are registered in a component of the lexical environment: a record
of type @objtype{rib}.  Every lexical contour is described by a rib; the
rib for the top level contour holds the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item this @tab top-mark
@item that @tab top-mark
@end multitable

@noindent
the rib of the outer @syntax{let} holds the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item outer a @tab 1-mark
@end multitable

@noindent
the rib of the inner @syntax{let} holds the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item inner a @tab 2-mark
@end multitable

@c ------------------------------------------------------------------------

@subsubheading Syntax objects and syntax identifiers

While the code is being visited by the expander: data structures called
@dfn{syntax objects} are created to keep track of the lexical contours.

@enumerate
@item
At first, the whole code is in a syntax object referencing the top rib
structure:

@example
#<syntax-object
   expr=(begin
          (define this 8)
          (define that 9)
          (let ((a 1))
            (let ((a 2))
              (list a this that))))
   rib=#<rib mark=top-mark>>
@end example

@noindent
syntactic bindings established in this contour will get the top-mark;
expressions in the right--hand sides of binding definitions are expanded
in the context of the top-mark.

@item
After the outer contour has been processed, the outer @syntax{let} is in
a syntax object:

@example
#<syntax-object
   expr=(let ((a 1))
          (let ((a 2))
            (list a this that)))
   rib=#<rib mark=1-mark>>
@end example

@noindent
syntactic bindings established in this contour will get the 1-mark;
expressions in the right--hand sides of binding definitions are expanded
in the context of the top-mark.

@item
After the outer @syntax{let} has been processed, the inner @syntax{let}
is in a syntax object:

@example
#<syntax-object
   expr=(let ((a 2))
          (list a this that))
   rib=#<rib mark=2-mark>>
@end example

@noindent
syntactic bindings established in this contour will get the 2-mark;
expressions in the right--hand sides of binding definitions are expanded
in the context of the 1-mark.

@item
After the inner @syntax{let} has been processed, the expression is in a
syntax object:

@example
#<syntax-object
   expr=(list a this that)
   rib=#<rib mark=2-mark>>
@end example

@noindent
the expression is expanded in the context of the 2-mark.
@end enumerate

A syntax object having a syntactic binding name as source code
expression is called @dfn{syntactic identifiers}; an identifier is a
data structure holding the mark of its visibility region/lexical contour
among its fields.

@c ------------------------------------------------------------------------

@subsubheading Label gensyms and ribs

An @func{eq?}-unique object is assigned to each syntactic binding: a
gensym indicated as @dfn{label gensym} or just @dfn{label}; such
associations are also stored in the rib representing a lexical contour:

@multitable {original name} {lexical contour mark} {label}
@headitem original name @tab lexical contour mark @tab label
@item this     @tab top-mark  @tab lab.this
@item that     @tab top-mark  @tab lab.that
@item outer a  @tab 1-mark    @tab lab.a.1
@item inner a  @tab 2-mark    @tab lab.a.2
@end multitable

@noindent
where the symbols @code{lab.*} are gensyms.

@c ------------------------------------------------------------------------

@subsubheading Lexical variable gensyms and the @lexenv{}

The fact that the lex gensyms in the expanded code are syntactic
bindings representing variables is registered in a portion of the
lexical environment indicated as @lexenv{}.  So the expanded code is
accompanied by the association:

@multitable {lab.that} {lexical variables}
@headitem label @tab lexical variables
@item lab.this  @tab lex.this
@item lab.that  @tab lex.that
@item lab.a.1   @tab lex.a.1
@item lab.a.2   @tab lex.a.2
@end multitable

Notice that, after the expansion: the original names of the internal
bindings (those defined by @syntax{let}) do not matter anymore; the
original names of the non--exported top level bindings do not matter
anymore; only the original name of the exported top level bindings is
still important.

@c ------------------------------------------------------------------------

@subsubheading Storage location gensyms and @ExportEnv{}

About the value of syntactic bindings:

@itemize
@item
The value of local variables goes on the Scheme stack and it exists only
while the code is being evaluated.

@item
The value of local keywords goes on the Scheme stack and it exists only
while the code is being expanded.

@item
The value of top level bindings must be stored in some persistent
location, because it must exist for the whole time the library is loaded
in a running @value{PRJNAME} process.
@end itemize

But where is a top level binding value stored?  The answer is: gensyms
are created for the sole purpose of acting as storage locations for top
level bindings; such gensyms are indicated as @dfn{location gensyms} or
@dfn{loc gensyms}.  Under @value{PRJNAME}, symbols are data structures
having a @code{value} slot: such slot has @func{symbol-value} as
accessor and @func{set-symbol-value!} as mutator and it is used as
storage location.

So the expanded code is accompanied by the following association:

@multitable {lab-this} {location gensym}
@headitem label @tab location gensym
@item lab.this  @tab loc.this
@item lab.that  @tab loc.that
@end multitable

@noindent
where the @code{loc.*} symbols are gensyms.  To represent the
association between the top level binding labels (both the exported ones
and the non--exported ones) and their storage location gensyms, the
expander builds a data structure indicated as @ExportEnv{}.

@c ------------------------------------------------------------------------

@subsubheading Exported bindings and @ExportSubst{}

Not all the top level syntactic bindings are exported by a library.  To
list those that are, a data structure is built and indicated as
@ExportSubst{}; such data structure associates the external name of
exported bindings to their label gensym.  For the example library, the
@ExportSubst{} represents the association:

@multitable {lab.this} {external name}
@headitem label @tab external name
@item lab.this  @tab this
@end multitable

If the @clause{export} clause of the @clause{library} form renames a
binding as in:

@example
(export (rename this external-this))
@end example

@noindent
then the @ExportSubst{} represents the association:

@multitable {lab.this} {external name}
@headitem label @tab external name
@item lab.this  @tab external-this
@end multitable

@c page
@node expander lexenv
@section The lexical environment


The lexical environment is a compound data structure with the purpose of
associating syntactic identifiers to label gensyms and label gensyms to
syntactic binding descriptors.  The components are:

@table @strong
@item Lexical context ribs
Objects of type @objtype{rib} that map syntactic identifiers to label
gensyms, keeping track of lexical contours.

@item Primitive syntactic binding's labels
A set of label gensyms associated to the syntactic bindings established
by the boot image; each label references its syntactic binding's
descriptor.

@item Imported syntactic binding's labels
A set of label gensyms associated to the syntactic bindings established
by imported libraries; each label references its syntactic binding's
descriptor.  The boot image's syntactic bindings are a subset of the
imported syntactic bindings.

@item Internal syntactic binding's labels, @lexenv{}
A set of label gensyms associated to the syntactic bindings established
by the library being expanded; these labels are used as keys in an
association list mapping labels to their syntactic binding's
descriptor.  This alist is called @lexenv{}.
@end table

@menu
* expander lexenv descriptors:: Syntactic binding's descriptors.
* expander lexenv primitive::   Primitive syntactic bindings.
* expander lexenv imported::    Imported syntactic bindings.
* expander lexenv internal::    Internal syntactic bindings.
* expander lexenv fluids::      How fluid syntaxes work.
* expander lexenv synonyms::    How synonym syntaxes work.
@end menu

@c page
@node expander lexenv descriptors
@subsection Syntactic binding's descriptors


A syntactic binding's descriptor is a pair with the format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
where @meta{binding-type} is a symbol and the format of
@meta{binding-value} depends on the binding type.

Possible values for @meta{binding-type} are the symbols:

@example
define define-syntax define-alias define-fluid-syntax
library import export module begin set!
let-syntax letrec-syntax stale-when
begin-for-syntax begin-for-syntax

core-macro macro core-prim $core-rtd

global global-macro global-macro! global-ctv

lexical local-macro local-macro! local-ctv
syntax $fluid $module $rtd $synonym
@end example

Every syntactic binding has a unique label gensym associated to it;
during the expansion process, no matter the current lexical context,
given a label gensym we can retrieve the associated binding descriptor.

Under @value{PRJNAME}, symbol objects are data structures with a slot
named @code{value}, accessor @func{symbol-value} and mutator
@func{set-symbol-value!}.  This slot is usually initialised to the
built--in object returned by @code{(unbound-object)}; we can inspect the
state of the slot with @func{symbol-bound?}.  The expander makes use of
this slot in label gensyms:

@itemize
@item
Syntactic bindings imported from libraries, including those established
by the boot image, have the binding descriptor referenced by the
@code{value} slot of their label gensym.

@item
Syntactic bindings established by the library being expanded, have the
association between label gensyms and binding descriptors stored in the
@lexenv{} component of the lexical environment.  The @code{value} slot
of these gensyms is set to the return value of @code{(unbound-object)}.
@end itemize

Given a label gensym we can determine if it is associated to an imported
syntactic binding by inspecting its @code{value} slot: if
@func{symbol-bound?} applied to the label returns @true{}, the binding
is imported; otherwise it was established by the code being expanded.

@c page
@node expander lexenv primitive
@subsection Primitive syntactic bindings


@cindex Library @library{psyntax system $all}
@cindex @library{psyntax system $all}, library


The syntactic bindings established by the boot image are all those
exported by the library @library{psyntax system $all}; this is an
internal library that should not be used for normal operations.
Partitions of these bindings are also exported by the library
@library{vicare} and all those in the hierarchies @library{vicare ---}
and @library{rnrs ---}.

The syntactic bindings established by the boot image have descriptors
defined in, and only in, the file @file{makefile.sps} in
@value{PRJNAME}'s source code tree.  Every boot image syntactic binding
has a label gensym associated to it: the binding's descriptor is stored
in the @code{value} slot of the label.

@c ------------------------------------------------------------------------

@subsubheading Inspecting binding descriptors

We must remember that a syntactic binding's descriptor is a pair with
format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
first let's create an @objtype{environment} object with the system
library:

@lisp
(define env (environment '(psyntax system $all)))
@end lisp

@noindent
then let's look at some descriptors:

@itemize
@item
Primitive function @func{display}:

@lisp
(define-values (label descriptor)
  (environment-binding 'display env))
descriptor              @result{} (core-prim . display)
(symbol-value label)    @result{} (core-prim . display)
(eq? descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the descriptor: @meta{binding-type} is the symbol @samp{core-prim}
and @meta{binding-value} is the symbol @samp{display}, which is the
public name of the primitive function.

@item
Core primitive syntax @syntax{lambda}:

@lisp
(define-values (label descriptor)
  (environment-binding 'lambda env))
descriptor              @result{} (core-macro . lambda)
(symbol-value label)    @result{} (core-macro . lambda)
(eq? descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the descriptor: @meta{binding-type} is the symbol @samp{core-macro}
and @meta{binding-value} is the symbol @samp{lambda}, which is the
public name of the primitive syntax.

@item
Non--core primitive syntax @syntax{let}:

@lisp
(define-values (label descriptor)
  (environment-binding 'let env))
descriptor              @result{} (macro . let)
(symbol-value label)    @result{} (macro . let)
(eq? descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the descriptor: @meta{binding-type} is the symbol @samp{macro} and
@meta{binding-value} is the symbol @samp{let}, which is the public name
of the primitive syntax.

@item
Condition object type @condition{condition}, which is implemented as
@rnrs{6} record type:

@lisp
(define-values (label descriptor)
  (environment-binding '&condition env))
descriptor
@result{} ($core-rtd . (&condition-rtd &condition-rcd))
(symbol-value label)
@result{} ($core-rtd . (&condition-rtd &condition-rcd))
(eq? descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the descriptor: @meta{binding-type} is the symbol @samp{$core-rtd}
and @meta{binding-value} is the list:

@example
(&condition-rtd &condition-rcd)
@end example

@noindent
we can further inspect @code{&condition-rtd} and @code{&condition-rcd}:

@lisp
(receive (label descriptor)
    (environment-binding '&condition-rtd env)
  descriptor)
@result{} (core-prim . &condition-rtd)

(receive (label descriptor)
    (environment-binding '&condition-rcd env)
  descriptor)
@result{} (core-prim . &condition-rcd)
@end lisp
@end itemize

@c ------------------------------------------------------------------------

@subsubheading Public names and labels

If we know the public name of a primitive syntactic binding
(@func{display}, @syntax{lambda}, @syntax{let}, @condition{condition},
@dots{}) we can retrieve the binding's label using @func{system-label}
(@pxref{iklib symbols labels}) and given the label we can retrieve the
binding descriptor using @func{symbol-value} (@pxref{iklib symbols
value}).  Examples:

@lisp
(symbol-value (system-label 'display))
@result{} (core-prim . display)

(symbol-value (system-label 'lambda))
@result{} (core-macro . lambda)

(symbol-value (system-label 'let))
@result{} (core-macro . let)

(symbol-value (system-label '&condition))
@result{} ($core-rtd &condition-rtd &condition-rcd)

(symbol-value (system-label '__who__))
@result{} ($fluid . fluid-label.__who__)
@end lisp

For core primitive functions, record--type descriptors and
record--constructor descriptors:

@itemize
@item
Given the primitive's public name we can retrieve the binding type, the
storage location gensym and so the system value, @ref{iklib symbols
system, System values bound to symbols}.

@item
Given the primitive's label gensym we can retrieve the binding type, the
public name and so the storage location gensym and the system value,
@ref{iklib symbols labels, Retrieving syntactic binding labels}.
@end itemize

Core primitive syntaxes and non--core primitive syntaxes have
implementation integrated in the expander:

@itemize
@item
Given the primitive's public name we can retrieve the binding type and
the label gensym.

@item
Given the primitive's label gensym we can retrieve the binding type and
the public name.
@end itemize

@c ------------------------------------------------------------------------

@subsubheading Primitive binding: integrated syntax

Some syntaxes are built into the expander and do not even have an
internal transformer function.  A syntactic binding representing an
integrated syntax has descriptor with format:

@example
(@meta{name} . ())
@end example

@noindent
where: @meta{binding-type} is @meta{name}, a symbol representing the
public name of the syntax; @meta{binding-value} is null.

Some of these core language syntaxes are: @syntax{define-syntax},
@syntax{define-alias}, @syntax{define-fluid-syntax}, @syntax{module},
@syntax{library}, @syntax{begin}, @syntax{import}, @syntax{export},
@syntax{set!}, @syntax{let-syntax}, @syntax{letrec-syntax},
@syntax{stale-when}, @syntax{begin-for-syntax},
@syntax{eval-for-expand}.

@c ------------------------------------------------------------------------

@subsubheading Primitive binding: core macro

A syntactic binding representing a core syntax with transformer function
implemented by the expander has descriptor with format:

@example
(core-macro . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the
syntax.

The core syntax transformer functions are implemented by the expander in
the module exporting the function @func{core-macro-transformer}, which
is used to map core syntax names to transformer functions.

The implementation of core syntaxes cannot be decomposed into uses of
other syntaxes.  Some of these syntaxes are: @syntax{quote},
@syntax{lambda}, @syntax{case-lambda}, @syntax{let}, @syntax{letrec},
@syntax{letrec*}, @syntax{if}, @syntax{foreign-call},
@syntax{syntax-case}, @syntax{syntax}, @syntax{fluid-let-syntax},
@syntax{internal-body}.

@c ------------------------------------------------------------------------

@subsubheading Primitive binding: non--core macro

A binding representing a non--core syntax with transformer function
implemented by the expander has descriptor with format:

@example
(macro . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the
syntax.  The non--core syntax transformer functions are implemented by
the expander in the module exporting the function
@func{non-core-macro-transformer}, which is used to map non--core syntax
names to transformer functions.

The implementation of non--core syntaxes can be decomposed into uses of
other syntaxes.  Some of these syntaxes are:

@example
define-struct define-record-type define-condition-type
define-enumeration
or and xor
cond case
let* let-values let*-values syntax-rules
quasiquote quasisyntax with-syntax identifier-syntax
let*-syntax
define-syntax-rule define-auxiliary-syntaxes define-syntax*
do when unless while until for returnable
case-define define* case-define* lambda* case-lambda*
define-values receive receive-and-return begin0
include
assert try with-unwind-protection guard
@end example

@c ------------------------------------------------------------------------

@subsubheading Primitive binding: core primitive

A syntactic binding representing a core primitive function, or core
primitive operation, or core primitive record--type descriptor, or core
primitive record--constructor descriptor has syntactic binding's
descriptor with format:

@example
(core-prim . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the core
primitive.

@c ------------------------------------------------------------------------

@subsubheading Primitive binding: core record--type name

A syntactic binding representing @rnrs{6}'s record--type name defined by
the boot image has descriptor with format:

@example
($core-rtd . (@meta{rtd-name} @meta{rcd-name}))
@end example

@noindent
where: @meta{rtd-name} is a symbol representing the public name of the
identifier to which the record--type descriptor was originally bound;
@meta{rcd-name} is a symbol representing the public name of the
identifier to which the default record--constructor descriptor was
originally bound.

For example: these entries are used to represent the predefined @rnrs{6}
condition object types.

@c ------------------------------------------------------------------------

@subsubheading Primitive binding: fluid syntax

A syntactic binding representing a fluid syntax defined by the boot
image has descriptor with format:

@example
($fluid . @meta{fluid-label})
@end example

@noindent
where @meta{fluid-label} is a further label gensym used to redefine the
keyword binding; @ref{expander lexenv fluids, How fluid syntaxes work}.

Some of the fluid syntaxes are: @syntax{__who__}, @syntax{return},
@syntax{continue}, @syntax{break}, @syntax{with}, @syntax{brace},
@syntax{<>}.

@c page
@node expander lexenv imported
@subsection Imported syntactic bindings


The data describing syntactic bindings established by a library is
stored in a @objtype{library} object:

@itemize
@item
If no @clause{rename} clause is used in the @clause{import} clause: the
imported name equals the exported name and it is taken from the
@code{export-subst} field of the @objtype{library} object.  The
@code{export-subst} maps exported names to label gensyms; it is an alist
whose entries have format:

@example
(@meta{exported-name} . @meta{label})
@end example

@item
The syntactic binding's descriptors are taken from the @code{export-env}
field of the @objtype{library} object.  The @code{export-env} maps label
gensyms to their binding descriptors; it is an alist whose entries have
format:

@example
(@meta{label} . @meta{binding-descriptor})
@end example

@item
When the library is interned: a @objtype{library} object is created and
the fields @code{export-subst} and @code{export-env} are used to build
the label gensyms by storing the descriptors in the @code{value} slots
of the gensyms.

@item
When a library is imported: the imported names of syntactic bindings are
associated to their label gensyms in the @objtype{rib} object
representing the current lexical context.
@end itemize

@c ------------------------------------------------------------------------

@subsubheading Inspecting binding descriptors

We must remember that a syntactic binding's descriptor is a pair with
format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
first let's create a library:

@lisp
(library (demo)
  (export var)
  (import (vicare))
  (define var "ciao"))
@end lisp

@noindent
then let's create an @objtype{environment} object with the
@library{demo} library:

@lisp
(define env (environment '(demo)))
@end lisp

@noindent
finally let's look at the descriptor:

@lisp
(define-values (label descriptor)
  (environment-binding 'var env))

(define lex/loc-gensym
  (cddr descriptor))

(print-gensym #f)

descriptor
@result{} (global . (#<library (demo)> . lex/loc.var))

(symbol-value label)
@result{} (global . (#<library (demo)> . lex/loc.var))

(eq? descriptor (symbol-value label))
@result{} #t

(symbol-value lex/loc-gensym)
@result{} "ciao"
@end lisp

@noindent
where @code{lex/loc.var} is both the lexical gensym and the storage
location gensym of the exported variable; we can also import the library
and try to expand some code:

@lisp
(import (demo))
(print-gensym #f)
(expansion-of var)
@result{} lex/loc.var
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Imported binding: variable

A syntactic binding representing an imported variable binding has
descriptor with format:

@example
(global . (@meta{library} . @meta{lex/loc}))
@end example

@noindent
where: @meta{library} is the @objtype{library} object from which the
binding is imported; @meta{lex/loc} is the storage location gensym
containing the variable's value in its @code{value} field.

@quotation
@strong{NOTE} When we are evaluating code in an interaction environment
(for example at the @repl{}): if the variable binding was established by
a previous expression, @meta{library} is the symbol
@samp{*interaction*}.
@end quotation

@c ------------------------------------------------------------------------

@subsubheading Imported binding: non--identifier macro

A syntactic binding representing an imported keyword binding with a
non--variable transformer has descriptor with format:

@example
(global-macro . (@meta{library} . @meta{loc}))
@end example

@noindent
where: @meta{library} is a record of type @objtype{library} describing
the library from which the macro is exported; @meta{loc} is the storage
location gensym containing the transformer function in its @code{value}
field.

Syntactic bindings of this type are established by
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating their right--hand side expression is a function.

@c ------------------------------------------------------------------------

@subsubheading Imported binding: identifier macro

A syntactic binding representing an imported keyword binding with
variable transformer has descriptor with format:

@example
(global-macro! . (@meta{library} . @meta{loc}))
@end example

@noindent
where: @meta{library} is a record of type @objtype{library} describing
the library from which the macro is exported; @meta{loc} is the storage
location gensym containing the transformer function in its @code{value}
field.

Syntactic bindings of this type are established by
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating their right--hand side expression is the return value of a
call to @func{make-variable-transformer}.

@c ------------------------------------------------------------------------

@subsubheading Imported binding: compile--time value

A syntactic binding representing an imported keyword binding associated
to a compile-time value has descriptor with format:

@example
(global-ctv . (@meta{library} . @meta{loc}))
@end example

@noindent
where: @meta{library} is a record of type @objtype{library} describing
the library from which the binding is imported; @meta{loc} is the gensym
containing the actual object in its @code{value} field (but only after
the library has been visited).

Syntactic bindings of this type are established by
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating their right--hand side expression is the return value of a
call to @func{make-compile-time-value}.

@c ------------------------------------------------------------------------

@subsubheading Imported binding: struct--type name

A syntactic binding representing an imported keyword binding associated
to a @value{PRJNAME}'s struct--type name has descriptor with format:

@example
($rtd . @meta{struct-type-descriptor})
@end example

@noindent
where @meta{struct-type-descriptor} is a struct representing the
struct--type descriptor.

@c ------------------------------------------------------------------------

@subsubheading Imported binding: @rnrs{6} record--type name

A syntactic binding representing a keyword binding imported from a
library, but not established by the boot image, associated to a
@rnrs{6}'s record--type name has syntactic binding descriptor with one
of the formats:

@example
($rtd . (@meta{rtd-id} @meta{rcd-id}))
($rtd . (@meta{rtd-id} @meta{rcd-id} . @meta{spec}))
@end example

@noindent
where: @meta{rtd-id} is the syntactic identifier to which the
record--type descriptor is bound; @meta{rcd-id} is the syntactic
identifier to which the default record--constructor descriptor is bound;
@meta{spec} is an instance of record type
@objtype{r6rs-record-type-spec}.

@c ------------------------------------------------------------------------

@subsubheading Imported binding: module interface

A syntactic binding representing an imported keyword binding associated
to the interface of a @syntax{module} syntax has descriptor with format:

@example
($module . @meta{module-interface})
@end example

@noindent
where @meta{module-interface} is a struct of type
@objtype{module-interface}.

Syntactic bindings of this type are established by uses of the syntax
@syntax{module}.

@c ------------------------------------------------------------------------

@subsubheading Imported binding: fluid syntax

A syntactic binding representing an imported keyword binding associated
to a fluid syntax has descriptor with format:

@example
($fluid . @meta{fluid-label})
@end example

@noindent
where @meta{fluid-label} is a further label gensym used to redefine the
keyword binding; @ref{expander lexenv fluids, How fluid syntaxes work}.

Syntactic bindings of this type are established by uses of the syntax
@syntax{define-fluid-syntax}.

@c ------------------------------------------------------------------------

@subsubheading Imported binding: synonym syntax

A syntactic binding representing an imported keyword binding associated
to a synonym syntax has descriptor with format:

@example
($synonym . @meta{synonym-label})
@end example

@noindent
where @meta{synonym-label} is the label gensym associated to the aliased
syntax; @ref{expander lexenv synonyms, How synonym syntaxes work}.

Syntactic bindings of this type are established by
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating their right--hand side expression is the return value of
a call to @func{make-synonym-transformer}.

@c ------------------------------------------------------------------------

@subsubheading Example library

We can use the following example library to toy with imported syntactic
bindings:

@lisp
(library (demo)
  (options visit-upon-loading)
  (export var macro var-macro macro-id
          ctv color <color> da-module fluid synonym)
  (import (vicare))

  (define var "ciao")

  (define-syntax macro
    (lambda (stx) "hello"))

  (define-syntax macro-id
    (identifier-syntax "hello"))

  (define-syntax var-macro
    (make-variable-transformer (lambda (stx) "ohayo")))

  (define-syntax ctv
    (make-compile-time-value 123))

  (define-struct color
    (red green blue))

  (define-record-type <color>
    (fields red green blue))

  (module da-module
      (inner)
    (define inner 123))

  (define-fluid-syntax fluid
    (lambda (stx) "da fluid"))

  (define-syntax synonym
    (make-synonym-transformer #'var))

  #| end of library |# )
@end lisp

@c page
@node expander lexenv internal
@subsection Internal syntactic bindings


The internal syntactic bindings are the ones established by the code
being expanded, both at the top level and in a local context.  The
association between their label gensyms and their descriptors is
maintained in the @lexenv{}.

A @lexenv{} is an alist managed somewhat like a stack; while the
expansion proceeds, visiting the code in breadth--first order: the
@lexenv{} is updated by pushing new entries on the stack.  A @lexenv{}
entry has the following format:

@example
(@meta{label} . @meta{syntactic-binding-descriptor})
@end example

@noindent
where: @meta{label} is a label gensym uniquely associated to a syntactic
binding; @meta{syntactic-binding-descriptor} is a syntactic binding
descriptor.


@defun current-inferior-lexenv
Return an alist representing the current @lexenv{} used at the inferior
expansion level; mutating the returned value leads to undefined
behaviour.  It is to be used from the body of a macro transformer.

As example, to just print the @lexenv{} we can do:

@lisp
(import (vicare))

(define-syntax (print-lexenv stx)
  (import (prefix (vicare expander) xp.))
  (print-gensym #f)
  (pretty-print (xp.current-inferior-lexenv)
                (current-error-port))
  #'(void))

(define a 1)

(print-lexenv)
@end lisp

@noindent
and we will see two entries:

@example
((lab.a            . (lexical . (lex.a . #f)))
 (lab.print-lexenv . (local-macro . (#<procedure> . @meta{sexp}))))
@end example

@noindent
where @meta{sexp} is the symbolic expression representing the
transformer function of @syntax{print-lexenv} fully expanded to the core
language.
@end defun

Top level and local syntactic bindings are represented in the same way
in the @lexenv{}; the difference between them is that top level
syntactic bindings have the association between the source name and the
label gensym stored in the top level @objtype{rib} object.

@c ------------------------------------------------------------------------

@subsubheading Internal binding: variables

A syntactic binding representing a variable binding as created by
@syntax{let} and similar syntaxes, @syntax{lambda}, @syntax{case-lambda}
or @syntax{define}, has descriptor with format:

@example
(lexical . (@meta{lexvar} . @meta{mutated}))
@end example

@noindent
where: @meta{lexvar} is a lexical gensym representing the name of the
lexical variable binding in the expanded code; @meta{mutated} is a
boolean, true if somewhere in the code the value of this binding is
mutated.

We want to keep track of mutated variables because we do not want to
export from a library a mutable variable.

@c ------------------------------------------------------------------------

@subsubheading Internal binding: non--variable macro

A syntactic binding representing a keyword binding with non--variable
transformer has descriptor with format:

@example
(local-macro . (@meta{transformer} . @meta{expanded-expr}))
@end example

@noindent
where: @meta{transformer} is a function implementing the macro
transformer; @meta{expanded-expr} is the expression in fully expanded
code representing the right--hand side of the syntax definition.
@meta{transformer} is the result of compiling and evaluating
@meta{expanded-expr}.

For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

@example
(set! @meta{loc} @meta{expanded-code})
@end example

@noindent
where @meta{loc} is the storage location gensym of the macro.

These syntactic bindings are established by @syntax{define-syntax},
@syntax{let-syntax} and similar, when their right--hand side evaluates
to a function.

@c ------------------------------------------------------------------------

@subsubheading Internal binding: variable macro

A syntactic binding representing a keyword binding with variable
transformer has descriptor with format:

@example
(local-macro! . (@meta{transformer} . @meta{expanded-expr}))
@end example

@noindent
where: @meta{transformer} is a function implementing the macro
transformer; @meta{expanded-expr} is the expression in fully expanded
code representing the right--hand side of the syntax definition.
@meta{transformer} is the result of compiling and evaluating
@meta{expanded-expr}.

For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

@example
(set! @meta{loc} @meta{expanded-code})
@end example

@noindent
where @meta{loc} is the storage location gensym of the macro.

These syntactic bindings are established by @syntax{define-syntax},
@syntax{let-syntax} and similar, when their right--hand side evaluates
to the return value of @func{make-variable-transformer}.

@c ------------------------------------------------------------------------

@subsubheading Internal binding: compile--time value

A syntactic binding representing a keyword binding associated to a
compile--time value has descriptor with format:

@example
(local-ctv . (@meta{object} . @meta{expanded-expr}))
@end example

@noindent
where: @meta{object} is the actual value computed at expand time;
@meta{expanded-expr} is the result of fully expanding the right--hand
side of the syntax definition.  @meta{object} is the result of compiling
and evaluating @meta{expanded-expr}.

For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

@example
(set! @meta{loc} @meta{expanded-code})
@end example

@noindent
where @meta{loc} is the storage location gensym of the macro.

These syntactic bindings are established by @syntax{define-syntax},
@syntax{let-syntax} and similar, when their right--hand side evaluates
to the return value of @func{make-compile-time-value}.

@c ------------------------------------------------------------------------

@subsubheading Internal binding: module interface

A syntactic binding representing a keyword binding associated to the
interface of a @syntax{module} syntax has descriptor with format:

@example
($module . @meta{module-interface})
@end example

@noindent
where @meta{module-interface} is a record of type
@objtype{module-interface}.

Syntactic bindings of this type are established by uses of the syntax
@syntax{module}.

@c ------------------------------------------------------------------------

@subsubheading Internal binding: pattern variable

A syntactic binding representing a keyword binding associated to a
pattern variable, as created by @syntax{syntax-case} and
@syntax{syntax-rules}, has descriptor with format:

@example
(syntax . (@meta{name} . @meta{level}))
@end example

@noindent
where: @meta{name} is the symbol representing the name of the pattern
variable; @meta{level} is a non--negative exact integer representing the
ellipsis nesting level.

The @syntax{syntax-case} patterns below will generate the displayed
syntactic binding descriptors:

@example
?a                      ->  (syntax . (?a . 0))
(?a)                    ->  (syntax . (?a . 0))
(((?a)))                ->  (syntax . (?a . 0))
(?a ...)                ->  (syntax . (?a . 1))
((?a) ...)              ->  (syntax . (?a . 1))
((((?a))) ...)          ->  (syntax . (?a . 1))
((?a ...) ...)          ->  (syntax . (?a . 2))
(((?a ...) ...) ...)    ->  (syntax . (?a . 3))
@end example

@c ------------------------------------------------------------------------

@subsubheading Internal binding: struct--type name

A syntactic binding representing a keyword binding associated to a
@value{PRJNAME}'s struct--type name has descriptor with format:

@example
($rtd . @meta{type-descriptor-struct})
@end example

@noindent
where @meta{type-descriptor-struct} is a struct representing the
struct--type descriptor.

These bindings are established by uses of the syntax
@syntax{define-struct}.

@c ------------------------------------------------------------------------

@subsubheading Internal binding: @rnrs{6} record--type name

A syntactic binding representing a keyword binding associated to a
@rnrs{6}'s record--type name has descriptor with one of the formats:

@example
($rtd . (@meta{rtd-id} @meta{rcd-id}))
($rtd . (@meta{rtd-id} @meta{rcd-id} . @meta{spec}))
@end example

@noindent
where: @meta{rtd-id} is the syntactic identifier to which the
record--type descriptor is bound; @meta{rcd-id} is the syntactic
identifier to which the default record--constructor descriptor is bound;
@meta{spec} is an instance of record type
@objtype{r6rs-record-type-spec}.

These bindings are established by uses of the syntax
@syntax{define-record-type}, @syntax{define-condition-type} and similar.

@c ------------------------------------------------------------------------

@subsubheading Internal binding: fluid syntax

A syntactic binding representing a keyword binding associated to a fluid
syntax has descriptor with format:

@example
($fluid . @meta{fluid-label})
@end example

@noindent
where @meta{fluid-label} is the label gensym associated to the fluid
syntax.

@c ------------------------------------------------------------------------

@subsubheading Internal binding: synonym syntax

A syntactic binding representing a keyword binding associated to a
synonym syntax has descriptor with format:

@example
($synonym . @meta{synonym-label})
@end example

@noindent
where @meta{synonym-label} is the label gensym associated to the synonym
syntax; @ref{expander lexenv synonyms, How synonym syntaxes work}.

@c ------------------------------------------------------------------------

@subsubheading Internal binding: @syntax{begin-for-syntax} code

Each use of @syntax{begin-for-syntax} generates expand--time code; when
this code is defined at the top level: it must become visit code to be
added to compiled libraries.  Whenever a @syntax{begin-for-syntax} use
is expanded the following entry is pushed on the @lexenv{}:

@example
(@meta{unused-label} . (begin-for-syntax . @meta{visit-code}))
@end example

@noindent
where: @meta{unused-label} is a dummy label gensym which is not bound in
the current rib; @meta{visit-code} is a full core language expression
representing the expanded contents of the @syntax{begin-for-syntax} use.

@c ------------------------------------------------------------------------

@subsubheading Displaced lexical bindings

These pairs have a format similar to a @lexenv{} entry representing a
syntactic binding, but they are used to represent a failed search into a
@lexenv{}.

The following special value represents an unbound label:

@example
(displaced-lexical . #f)
@end example

@noindent
this is an ``identifier out of context'' error.

The following special value represents the result of a lexical
environment query with invalid label value (not a symbol):

@example
(displaced-lexical . ())
@end example

@c page
@node expander lexenv fluids
@subsection How fluid syntaxes work


When a fluid syntax's syntactic binding is established by
@syntax{define-fluid-syntax} in the source code of a library or program:

@example
(define-fluid-syntax @meta{lhs} @meta{rhs})
@end example

@noindent
an identifier @meta{lhs} is associated to a main label @meta{label} in
the current rib; an entry is pushed on the @lexenv{}:

@example
(@meta{label} . ($fluid . @meta{fluid-label}))
@end example

@noindent
when querying the @lexenv{} for the binding descriptor associated to
@meta{label}: the descriptor with type @code{$fluid} is always returned,
qualifying the binding as fluid syntax.

At the same time, @syntax{define-fluid-syntax} pushes another entry on
the @lexenv{}:

@example
(@meta{fluid-label} . @meta{syntactic-binding})
@end example

@noindent
where @meta{syntactic-binding} is the concrete binding descriptor
created by expanding and evaluating @meta{rhs} then interpreting its
return value.

Given the identifier @meta{lhs}: we can retrieve the associated
@meta{label} and so the @meta{fluid-label}; then we can ``follow
through'' @meta{fluid-label} to retrieve the actual binding descriptor.

The fluid syntax can be redefined any number of times by using
@syntax{fluid-let-syntax}:

@example
(fluid-let-syntax ((@meta{lhs} @meta{inner-rhs})) . @meta{body})
@end example

@noindent
causing other entries associated to @meta{fluid-label} to be pushed on
the @lexenv{}:

@example
(@meta{fluid-label} . @meta{inner-syntactic-binding})
@end example

@noindent
where @meta{inner-syntactic-binding} is the binding descriptor resulting
from expanding and evaluating @meta{inner-rhs} then interpreting its
return value.

When searching the @lexenv{} for a syntactic binding descriptor matching
the label @meta{fluid-label}: the topmost entry is found, so the binding
appears to be redefined.

@c ------------------------------------------------------------------------

@subsubheading Primitive fluid syntaxes

This is @strong{not} what happens for the primitive fluid syntaxes
exported by the boot image like @syntax{return}, @syntax{break} and
@syntax{continue}.  For these syntaxes the lexical environment of the
boot image includes only the entries:

@example
(@meta{return-label}   . ($fluid .   @meta{return-fluid-label}))
(@meta{break-label}    . ($fluid .    @meta{break-fluid-label}))
(@meta{continue-label} . ($fluid . @meta{continue-fluid-label}))
@end example

@noindent
and there are no entries for the fluid labels @meta{return-fluid-label},
@meta{break-fluid-label} and @meta{continue-fluid-label}.  The keywords
of these fluid syntaxes are bound in the environment, but they are bound
to ``nothing''; trying to follow through the fluid labels to the
concrete binding descriptors will result in the binding descriptor:

@example
(displaced-lexical . #f)
@end example

@noindent
which is interpreted as the error ``keyword identifier out of context''.

Such half--defined fluid syntaxes are fully usable as auxiliary syntaxes
and can be redefined with @syntax{fluid-let-syntax}.  There are
@strong{no} transformer functions for @syntax{return}, @syntax{break},
@syntax{continue} and similar syntaxes.

@c page
@node expander lexenv synonyms
@subsection How synonym syntaxes work


When an synonym syntax binding is established:

@lisp
(define-syntax @meta{lhs} (make-synonym-transformer @meta{id}))
@end lisp

@noindent
an identifier @meta{lhs} is associated to a main label @meta{label} in
the current rib; an entry is pushed on the @lexenv{}:

@example
(@meta{label} . ($synonym . @meta{synonym-label}))
@end example

@noindent
where @meta{synonym-label} is the label bound to the identifier
@meta{id}.  Given the identifier @meta{lhs}: we can retrieve the
associated @meta{label} and so the @meta{synonym-label}; then we can
``follow through'' @meta{synonym-label} to retrieve the actual binding
descriptor associated to @meta{id}.


@c Local Variables:
@c mode: texinfo
@c TeX-master: "vicare-scheme"
@c End:
