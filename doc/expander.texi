@node expander
@chapter Expander internals


@cindex Library @library{vicare expander}
@cindex @library{vicare expander}, library


@value{PRJNAME}'s expander is a development of the expander library
@code{psyntax} written by Abdulaziz Ghuloum and Kent Dybvig and released
to the public under a very liberal license (@pxref{references expander}
for the bibliography on the expansion process).

The library @library{vicare expander} exports bindings that allow
inspection of the expander operations.  To avoid collisions between
syntactic binding names, it is suggested to import it with prefix
@samp{xp::}:

@lisp
(import (prefix (vicare expander) xp::))
@end lisp

@menu
* expander intro::              Introduction to the expansion process.
* expander options::            Initialisation and general configuration.
* expander lexenv::             The lexical environment.
* expander utils::              Miscellaneous utilities.
* expander clauses::            Syntax clauses helpers.
* expander system-labels::      Retrieving syntactic binding labels.
* expander system-identifiers:: Retrieving syntactic binding identifiers.
* expander examples::           Expansion and expander inspection
                                examples.
* expander specs::              Object-type specifications.
@end menu

@c page
@node expander intro
@section Introduction to the expansion process


First some notes on ``languages'' in @value{PRJNAME}'s jargon:

@itemize
@item
The @dfn{expanded language} is a low level Scheme--like language which
is the result of the expansion process: expanding a Scheme library or
program means to transform the input language into a symbolic expression
in the expanded language.

@item
The ``core language'' is a low level Scheme--like language which is the
input recognised by the compiler.
@end itemize

@noindent
at present the expanded language and the core language are equal, but
this might change in the future.

While discussing the expander operations, we will always refer to source
code in the form of libraries.  @rnrs{6} also defines top level
programs; however, under @value{PRJNAME}:

@itemize
@item
The process of expanding programs is almost equal to the process of
expanding libraries.  The differences are: a program does not export
syntactic bindings; the top level body of a program intermixes
definitions and expressions, while the top level body of a library
separates definitions and expressions.

@item
The result of expanding a library is equal to the result of expanding a
program.

@item
The output of the expander is the input of the compiler, and such input
is equal when compiling a library and when compiling a program.
@end itemize

@noindent
so if we understand how libraries are expanded, we also understand how
programs are expanded.

@menu
* expander intro macros::       Core macros, non-core macros,
                                user-defined macros.
* expander intro times::        Evaluation times.
* expander intro bindings::     Syntactic bindings.
* expander intro lex::          Lexical variables, labels,
                                location gensyms.
@end menu

@c page
@node expander intro macros
@subsection Primitive core macros, primitive non--core macros, user--defined macros


A big portion of what the expander does is processing macros; converting
input syntactic forms with format:

@lisp
(@meta{keyword} @meta{subform} @dots{})
@end lisp

@noindent
into some output syntactic forms.  What kind of macros are implemented?
And which part of the expander's source code implements them?

@c ------------------------------------------------------------------------

@subsubheading Primitive core macros

These are basic syntaxes into which all the other macros are expanded;
despite being called ``core'', they are neither part of the expanded
language nor of the core language.  Core macros are split into three
groups, those that can appear in definition--context only:

@example
define             define-syntax
define-alias       define-fluid-syntax
module             library
begin              import
export             set!
stale-when         begin-for-syntax
@end example

@noindent
and maybe others; those that can appear in expression--context only:

@example
foreign-call             quote
syntax-case              syntax
letrec                   letrec*
if                       lambda
case-lambda              fluid-let-syntax
struct-type-descriptor   struct-type-and-struct?
record-type-descriptor   record-constructor-descriptor
type-descriptor          is-a?
splice-first-expand
predicate-procedure-argument-validation
predicate-return-value-validation
@end example

@noindent
and maybe others; those that can appear in both definition--context and
expression--context:

@example
let-syntax               letrec-syntax
@end example

Which part of the expander's source code implements core macros?

@itemize
@item
The implementation of core macros that appear in definition--context is
integrated in the function @func{chi-body*}.  The implementation is
sophisticated because, in a body, syntactic bindings defined by
@syntax{define-syntax} must be processed before syntactic bindings
defined by @syntax{define}, so multiple passes are required.

@item
The implementation of core macros that appear in expression--context
consists of proper transformer functions selected by the function
@func{core-macro-transformer}.  Such transformers are applied to input
forms by the function @func{chi-expr}.

A core transformer function accepts as arguments: a syntax object
representing the input form; values representing the lexical context in
which the input form is present.  A core transformer function returns an
instance of type @class{psi} representing an expanded language
expression.

@item
Macros that can appear in both definition context and expression context
have double implementation: one in the function @func{chi-body*} and one
in the function @func{chi-expr}.
@end itemize

Core macros can establish new syntactic bindings by direct access to the
data structures representing the lexical environment.

@c ------------------------------------------------------------------------

@subsubheading Primitive non--core macros

These are macros that expand themselves into uses of core macros or
other non--core macros; they have a proper transformer function
accepting, as single argument, a syntax object representing the input
form and returning, as single value, a syntax object representing the
output form.  The only difference between a non--core macro and a
user--defined macro is that the former is integrated in the expander.

Non--core macro transformers are selected by the function
@func{non-core-macro-transformer}.  The transformers are applied to
input forms by the function @func{chi-expr}.

@c ------------------------------------------------------------------------

@subsubheading User--defined macros

These are macros defined by @syntax{define-syntax}, @syntax{let-syntax},
@syntax{letrec-syntax}, @syntax{define-fluid-syntax} and their
derivatives.  Such syntaxes expand themselves into uses of core or
non--core macros.  Their transformer functions accept, as single
argument, a syntax object representing the input form and return, as
single value, a syntax object representing the output form.

@c page
@node expander intro times
@subsection Evaluation times


Throughout the code there are several references to different code
evaluation times.  The following library from @bibref{exp1} allows us to
explore what those times mean.

@lisp
(library (times-demo)
  (export
    call-time invoke-time expand-time visit-time compile-time)
  (import (vicare)
    (prefix (srfi :19) srfi.))

  (define call-time
    (lambda ()
      (receive-and-return (S)
          (srfi.date->string (srfi.current-date))
        (printf "call time: ~a\n" S))))

  (define invoke-time
    (let ((t (receive-and-return (S)
                 (srfi.date->string (srfi.current-date))
               (printf "invoke time: ~a\n" S))))
      (lambda () t)))

  (define-syntax expand-time
    (lambda (stx)
      (receive-and-return (S)
          (srfi.date->string (srfi.current-date))
        (printf "expand time: ~a\n" S))))

  (define-syntax visit-time
    (let ((t (receive-and-return (S)
                 (srfi.date->string (srfi.current-date))
               (printf "visit time: ~a\n" S))))
      (lambda (stx) t)))

  (define-syntax compile-time
    (lambda (stx)
      (let-syntax ((t (lambda (stx)
                        (receive-and-return (S)
                            (srfi.date->string (srfi.current-date))
                          (printf "compile time: ~a\n" S)))))
        (t))))

  #| end of library |# )
@end lisp

@c page
@node expander intro bindings
@subsection Syntactic bindings


@cindex Initial environment, definition of
@cindex Syntactic bindings, definition of
@cindex Lexical bindings, definition of
@cindex Syntactic bindings, definition of
@cindex Top level bindings, definition of
@cindex Local bindings, definition of

@cindex Definition of initial environment
@cindex Definition of syntactic bindings
@cindex Definition of lexical bindings
@cindex Definition of syntactic bindings
@cindex Definition of top level bindings
@cindex Definition of local bindings

@cindex bindings, syntactic


A syntactic binding is an association between an identifier and the
result of evaluating an expression; there are different kinds:

@table @dfn
@item primitive syntax bindings
Syntactic forms built into the language, they are called primitive core
macros and primitive non--core macros.  They are @syntax{lambda},
@syntax{define}, @syntax{let} and similar, @syntax{define-syntax},
@syntax{letrec-syntax}, @syntax{if}, @syntax{and}, @syntax{or} and all
the rest.

@item variable bindings
Associations between identifiers and expressions evaluated at run--time.
They are established by @syntax{define}, @syntax{let}, @syntax{letrec}
and similar.

@item keyword bindings
Associations between identifiers and expressions evaluated at
expand--time.  The identifiers in this role are called @dfn{syntactic
keywords} (not to be confused with keyword objects like @samp{#:hello}).
Examples of keyword bindings are @dfn{user--defined macros} (also named
@dfn{user--defined syntaxes}).
@end table

@c ------------------------------------------------------------------------

@subsubheading Identifiers in binding position and reference position

Let's consider the following syntactic form:

@lisp
(let ((a 1))
  a)
@end lisp

@noindent
the @syntax{let} syntax defines a variable binding whose name is
@samp{a}; a variable binding is an association between a name and the
result of evaluating an expression at run--time.

Let's consider the following form:

@lisp
(let-syntax ((a (identifier-syntax 1)))
  a)
@end lisp

@noindent
@syntax{let-syntax} defines a keyword binding whose name is @samp{a}; a
keyword binding is an association between a name and the result of
evaluating an expression at expand--time.

The identifiers @samp{a} in the first argument of @syntax{let} and
@syntax{let-syntax} are in @dfn{binding position}; the identifiers in
the bodies of @syntax{let} and @syntax{let-syntax} are in @dfn{reference
position}.  The identifier in reference position is a reference to the
identifier in binding position: we say that the identifier in reference
position is ``captured'' by the identifier in binding position.

@c ------------------------------------------------------------------------

@subsubheading Lexical environment

The expansion process proceeds from the outer forms to the inner forms.
Given the syntactic form:

@lisp
(let ((a 1))
  (let ((b 2))
    (+ a b)))
@end lisp

@noindent
first the outer @syntax{let} is processed and the syntactic binding for
@samp{a} is established; then the inner @syntax{let} is processed and
the syntactic binding for @samp{b} is established; finally the
expression @code{(+ a b)} is processed in a lexical context in which the
syntactic bindings exist.

The region of the syntactic binding @samp{a} is the inner @syntax{let}
form; notice that the binding for @samp{a} is not visible in the
right--hand side of its definition.  The region of the syntactic binding
@samp{b} is the internal expression.

During the expansion process: syntactic bindings are added to an
internal data structure that collects the associations, keeping track of
nested regions of visibility: the @dfn{lexical environment}.  The
lexical environment is somewhat handled like a stack: while entering
internal expressions, syntactic binding descriptors are pushed on the
stack.

@c ------------------------------------------------------------------------

@subsubheading Initial environment, top level bindings, local bindings

Let's consider the following library:

@lisp
(library (demo)
  (export)
  (import (rnrs (6)))

  (define var 1)

  (define (fun a)
    (let ((b 2))
      (let-syntax ((c (identifier-syntax 3)))
        (display (+ a b c))
        (newline))))

  (define-syntax syn
    (syntax-rules ()
      ((_ ?obj)
       (display ?obj))))

  (import (prefix (vicare posix) px.))
  (display (px.getenv "PATH"))
  (newline)

  #| end of library |# )
@end lisp

@noindent
we introduce the definitions:

@table @dfn
@item initial lexical environment
The syntactic bindings imported by the @clause{import} clause of the
@syntax{library} form and by the @syntax{import} syntax in the body of
the library, constitute the initial lexical environment for the
expansion process of the library.

In the example: the initial environment is the set of bindings exported
by the libraries @library{rnrs (6)} and @library{vicare posix}.

@quotation
@strong{NOTE} An @syntax{import} syntax that appears in an internal body
as in:

@lisp
(lambda ()
  (import (srfi :19))
  (do-something))
@end lisp

@noindent
does @strong{not} add bindings to the initial environment: it adds them
to the local lexical environment.
@end quotation

@item top level syntactic bindings
Syntactic bindings defined in the body of the library with
@syntax{define} and @syntax{define-syntax}; the ones defined by
@syntax{define} are variable bindings, the ones defined by
@syntax{define-syntax} are keyword bindings.

Top level bindings are visible in the whole library body: their region
is the whole body.  Top level bindings have indefinite extent: their
values are never garbage collected, they exists for the whole life of
the @value{EXECUTABLE} process.

In the example: @samp{var} and @samp{fun} are top level variables;
@samp{syn} is a top level keyword.

Every identifier in reference position that is not captured by a
syntactic binding definition in the library itself must be captured by a
binding in the initial environment; otherwise an exception is raised
with condition object of type @condition{undefined}.

@item local syntactic bindings
Syntactic bindings defined by a syntax that limits their region of
visibility to a subform of the library body.  Bindings defined by
@syntax{let} and similar syntaxes are local variable bindings, as well
as those defined by @syntax{define} in an internal body.  Bindings
defined by @syntax{let-syntax} and similar syntaxes are local keyword
bindings, as well as those defined by @syntax{define-syntax} in an
internal body.

In the example: @samp{a} and @samp{b} are local variable bindings;
@samp{c} is a local keyword binding.
@end table

@c page
@node expander intro lex
@subsection Lexical variables, labels, location gensyms


Let's consider the library:

@lisp
(library (demo)
  (export this)
  (import (rnrs (6)))
  (define this 8)
  (define that 9)
  (let ((a 1))
    (let ((a 2))
      (list a this that))))
@end lisp

@noindent
and concentrate on the body:

@lisp
(define this 8)
(define that 9)
(let ((a 1))
  (let ((a 2))
    (list a this that)))
@end lisp

This code defines 4 syntactic bindings: @samp{this} and @samp{that} as
top level variable bindings, of which @samp{this} is also exported;
outer @samp{a} as local variable binding; inner @samp{a} as local
variable binding.

The purpose of the expansion process is to transform the input code into
output code expressed in the core language.  After the expansion
process, every syntactic binding is renamed so that its name is unique
in the whole library body.  For example, we can imagine this
pseudo--code:

@lisp
(define lex.this 8)
(define lex.that 9)
(let ((lex.a.1 1))
  (let ((lex.a.2 2))
    ((primitive list) lex.a.2 lex.this lex.that)))
@end lisp

@noindent
notice that the original identifier @func{list}, in reference position,
has been replaced by the symbolic expression @code{(primitive list)}
because it is captured by the core primitive binding of the initial
lexical environment.  The code undergoes the following lexical variable
name substitutions:

@multitable {original name} {lexical variable name}
@headitem original name @tab lexical variable name
@item this @tab lex.this
@item that  @tab lex.that
@item outer a @tab lex.a.1
@item inner a @tab lex.a.2
@end multitable

@noindent
where the @code{lex.*} symbols are gensyms; such gensyms are named
@dfn{lexical gensyms} or @dfn{lex gensyms}.  They uniquely identify a
syntactic binding established in the library.

Renaming bindings is one of the core purposes of the expansion process;
it is performed while visiting the source code as a tree in
breadth--first order.

@c ------------------------------------------------------------------------

@subsubheading Lexical contours and @rib{} objects

To distinguish among different bindings with the same name (like the two
local bindings both named @samp{a} in the example) we must distinguish
among different @dfn{lexical contours}: different regions of visibility
for a set of syntactic bindings.

Every @syntax{let} syntax defines a new lexical contour; lexical
contours can be nested by nesting @syntax{let} syntaxes; the library
body is a lexical contour itself.

@quotation
@strong{NOTE} For simplicity, here we ignore the fact that @syntax{let},
in truth, defines 2 lexical contours: one for the bindings established
by its first argument and one for the internal definitions.  In the
example there are no internal definitions, so the internal contour is
not used.
@end quotation

@float Figure,fix:expander-intro-1
@example
 -------------------------------------------------
| (define this 8)              ;top-level contour |
| (define that 9)                                 |
| (let ((a 1))                                    |
|  -----------------------------------------      |
| |                            ;contour 1   |     |
| | (let ((a 2))                            |     |
| |  -------------------------------------  |     |
| | |                          ;contour 2 | |     |
| | | (list a this that)                  | |     |
| |  -------------------------------------  |     |
| |   )                                     |     |
|  -----------------------------------------      |
|   )                                             |
 -------------------------------------------------
@end example
@caption{Picture of lexical contours.}
@end float

An @func{eq?}-unique object is assigned to each lexical contour; such
objects are called @dfn{marks}.  In practise each syntactic binding is
associated to the mark representing its visibility region.  So the
original code is accompanied by the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item this @tab src-mark
@item that @tab src-mark
@item outer a @tab 1-mark
@item inner a @tab 2-mark
@end multitable

@noindent
which are registered in a component of the lexical environment: a record
of type @rib{}.  Every lexical contour is described by a @rib{}; the
@rib{} for the top level contour holds the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item this @tab src-mark
@item that @tab src-mark
@end multitable

@noindent
the @rib{} of the outer @syntax{let} holds the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item outer a @tab 1-mark
@end multitable

@noindent
the @rib{} of the inner @syntax{let} holds the associations:

@multitable {original name} {lexical contour mark}
@headitem original name @tab lexical contour mark
@item inner a @tab 2-mark
@end multitable

@c ------------------------------------------------------------------------

@subsubheading Syntax objects and syntax identifiers

While the code is being visited by the expander: data structures called
@dfn{syntax objects} are created to keep track of the lexical contours.

@enumerate
@item
At first, the whole code is in a syntax object referencing the top
@rib{} structure:

@example
#<syntax-object
   expr=(begin
          (define this 8)
          (define that 9)
          (let ((a 1))
            (let ((a 2))
              (list a this that))))
   rib=#<rib mark=src-mark>>
@end example

@noindent
syntactic bindings established in this contour will get the src--mark;
expressions in the right--hand sides of binding definitions are expanded
in the context of the src-mark.

@item
After the outer contour has been processed, the outer @syntax{let} is in
a syntax object:

@example
#<syntax-object
   expr=(let ((a 1))
          (let ((a 2))
            (list a this that)))
   rib=#<rib mark=1-mark>>
@end example

@noindent
syntactic bindings established in this contour will get the 1-mark;
expressions in the right--hand sides of binding definitions are expanded
in the context of the src-mark.

@item
After the outer @syntax{let} has been processed, the inner @syntax{let}
is in a syntax object:

@example
#<syntax-object
   expr=(let ((a 2))
          (list a this that))
   rib=#<rib mark=2-mark>>
@end example

@noindent
syntactic bindings established in this contour will get the 2-mark;
expressions in the right--hand sides of binding definitions are expanded
in the context of the 1-mark.

@item
After the inner @syntax{let} has been processed, the expression is in a
syntax object:

@example
#<syntax-object
   expr=(list a this that)
   rib=#<rib mark=2-mark>>
@end example

@noindent
the expression is expanded in the context of the 2-mark.
@end enumerate

A syntax object having a syntactic binding name as source code
expression is called @dfn{syntactic identifiers}; an identifier is a
data structure holding the mark of its visibility region/lexical contour
among its fields.

@c ------------------------------------------------------------------------

@subsubheading Label gensyms and @rib{} objects

An @func{eq?}-unique object is assigned to each syntactic binding: a
gensym indicated as @dfn{label gensym} or just @dfn{label}; such
associations are also stored in the @rib{} representing a lexical
contour:

@multitable {original name} {lexical contour mark} {label}
@headitem original name @tab lexical contour mark @tab label
@item this     @tab src-mark  @tab lab.this
@item that     @tab src-mark  @tab lab.that
@item outer a  @tab 1-mark    @tab lab.a.1
@item inner a  @tab 2-mark    @tab lab.a.2
@end multitable

@noindent
where the symbols @code{lab.*} are gensyms.

@c ------------------------------------------------------------------------

@subsubheading Lexical variable gensyms and the @lexenv{}

The fact that the lex gensyms in the expanded code are syntactic
bindings representing variables is registered in a portion of the
lexical environment indicated as @lexenv{}.  So the expanded code is
accompanied by the association:

@multitable {lab.that} {lexical variables}
@headitem label @tab lexical variables
@item lab.this  @tab lex.this
@item lab.that  @tab lex.that
@item lab.a.1   @tab lex.a.1
@item lab.a.2   @tab lex.a.2
@end multitable

Notice that, after the expansion: the original names of the internal
bindings (those defined by @syntax{let}) do not matter anymore; the
original names of the non--exported top level bindings do not matter
anymore; only the original name of the exported top level bindings is
still important.

@c ------------------------------------------------------------------------

@subsubheading Storage location gensyms and @GlobalEnv{}

About the value of syntactic bindings:

@itemize
@item
The value of local variables goes on the Scheme stack and it exists only
while the code is being evaluated.

@item
The value of local keywords goes on the Scheme stack and it exists only
while the code is being expanded.

@item
The value of top level bindings must be stored in some persistent
location, because it must exist for the whole time the library is loaded
in a running @value{PRJNAME} process.
@end itemize

But where is a top level binding value stored?  The answer is: gensyms
are created for the sole purpose of acting as storage locations for top
level bindings; such gensyms are indicated as @dfn{location gensyms} or
@dfn{loc gensyms}.  Under @value{PRJNAME}, symbols are data structures
having a @code{value} slot: such slot has @func{symbol-value} as
accessor and @func{set-symbol-value!} as mutator and it is used as
storage location.

So the expanded code is accompanied by the following association:

@multitable {lab-this} {location gensym}
@headitem label @tab location gensym
@item lab.this  @tab loc.this
@item lab.that  @tab loc.that
@end multitable

@noindent
where the @code{loc.*} symbols are gensyms.  To represent the
association between the top level binding labels (both the exported ones
and the non--exported ones) and their storage location gensyms, the
expander builds a data structure indicated as @GlobalEnv{}.

@c ------------------------------------------------------------------------

@subsubheading Exported bindings and @ExportSubst{}

Not all the top level syntactic bindings are exported by a library.  To
list those that are, a data structure is built and indicated as
@ExportSubst{}; such data structure associates the external name of
exported bindings to their label gensym.  For the example library, the
@ExportSubst{} represents the association:

@multitable {lab.this} {external name}
@headitem label @tab external name
@item lab.this  @tab this
@end multitable

If the @clause{export} clause of the @syntax{library} form renames a
binding as in:

@example
(export (rename this external-this))
@end example

@noindent
then the @ExportSubst{} represents the association:

@multitable {lab.this} {external name}
@headitem label @tab external name
@item lab.this  @tab external-this
@end multitable

@c page
@node expander options
@section Initialisation and general configuration


@defun initialise-expander
Initialise expander's internal tables.  It is automatically called by
the functions in the public @api{}.
@end defun

@c page
@node expander lexenv
@section The lexical environment


The lexical environment is a compound data structure with the purpose of
associating syntactic identifiers to label gensyms and label gensyms to
syntactic binding descriptors.  The components are:

@table @strong
@item Lexical context @rib{} objects
Objects of type @rib{} that map syntactic identifiers to label gensyms,
keeping track of lexical contours.

@item Primitive syntactic binding's labels
A set of label gensyms associated to the syntactic bindings established
by the boot image; each label references its syntactic binding's
descriptor.

@item Imported syntactic binding's labels
A set of label gensyms associated to the syntactic bindings established
by imported libraries; each label references its syntactic binding's
descriptor.  The boot image's syntactic bindings are a subset of the
imported syntactic bindings.

@item Internal syntactic binding's labels, @lexenv{}
A set of label gensyms associated to the syntactic bindings established
by the library being expanded; these labels are used as keys in an
association list mapping labels to their syntactic binding's
descriptor.  This alist is called @lexenv{}.
@end table

@menu
* expander lexenv rib::         Lexical contours and @rib{} objects.
* expander lexenv stx::         Wrapped and unwrapped syntax objects.
* expander lexenv descriptors:: Syntactic binding's descriptors.
* expander lexenv prim::        Primitive syntactic bindings.
* expander lexenv imported::    Imported syntactic bindings.
* expander lexenv internal::    Internal syntactic bindings.
* expander lexenv fluids::      How fluid syntaxes work.
* expander lexenv synonyms::    How synonym syntaxes work.
* expander lexenv inspection::  Lexical environment inspection.
@end menu

@c page
@node expander lexenv rib
@subsection Lexical contours and @rib{} objects


A @rib{} is an object constructed at every lexical contour in the source
code to hold informations about the syntactic bindings introduced in
that contour; ``lexical contours'' are, for example, @syntax{let} and
similar syntaxes that can introduce bindings.

The purpose of @rib{} objects is to map syntactic binding's source names
(the symbols as they appear in the source code) to the associated label
gensyms; this map is used when establishing if a syntax object
identifier in reference position is captured by an existing syntactic
binding.

@menu
* expander lexenv rib type::       The @rib{} object type.
* expander lexenv rib extending::  Extending @rib{} objects.
* expander lexenv rib sealing::    Sealing @rib{} objects.
@end menu

@c page
@node expander lexenv rib type
@subsubsection The @rib{} object type


@deftp {Object Type} rib
Disjoint object type representing lexical contours in the expansion
process.  @rib{} objects associate the source name of syntactic bindings
to their label gensyms.

Objects of type @rib{} have the following fields:

@table @code
@item name*
List of symbols representing the source name of syntactic bindings.
When the @rib{} is sealed: the list is converted to a vector.

@item mark**
List of sublists of marks; there is a sublist of marks for every item in
@code{name*}.  When the @rib{} is sealed: the list is converted to a
vector.

@item label*
List of label gensyms uniquely identifying syntactic bindings; there is
a label for each item in @code{name*}.  When the @rib{} is sealed: the
list is converted to a vector.

@item sealed/freq
@false{} or vector of exact integers.  When @false{}: this @rib{} is
extensible: new syntactic bindings can be added to it.  When a vector:
this @rib{} is sealed.  See below for an explanation of the frequency
vector.
@end table
@end deftp

@c page
@node expander lexenv rib extending
@subsubsection Extending @rib{} objects


A non--sealed @rib{} object is extensible: new syntactic bindings can be
added to it.  This happens every time the expander processes internal
definitions in a top--level body or internal body; examples are: the
top--level body of a program; the top--level body of a library; the
@syntax{internal-body} syntax; the internal body of @syntax{lambda}; the
internal body of @syntax{let} and its variants.

Adding an identifier--to--label mapping to an extensible @rib{} is
achieved by prepending items to the field's lists.

For example, an empty extensible @rib{} has fields:

@example
name*  = ()
mark** = ()
label* = ()
@end example

@noindent
adding a syntactic binding to it with source name @samp{ciao}, marks
@samp{(src)} and label @samp{lab.ciao} means mutating the fields to:

@example
name*  = (ciao)
mark** = ((src))
label* = (lab.ciao)
@end example

@noindent
we can think of this operation as ``pushing the syntactic binding's
tuple'':

@example
@{ ciao, (src), lab.ciao @}
@end example

@noindent
on the @rib{}.  Adding another binding with source name @samp{hello},
marks @samp{(src)} and label @samp{lab.hello} means to push the tuple.

@example
@{ hello, (src), lab.hello @}
@end example

@noindent
that is to mutate the fields to:

@example
name*  = (hello     ciao)
mark** = ((src)     (src))
label* = (lab.hello lab.ciao)
@end example

As further example, let's consider the syntactic form:

@lisp
(internal-body
  (define a 1)
  (define b 2)
  (list a b))
@end lisp

@noindent
when starting to expand the internal body: a new @rib{} is created and
added to the metadata of the syntax object representing the body itself;
when each internal definition is encountered, a new entry for the
identifier is added (via side effect) to the @rib{}:

@example
name*  = (b       a)
mark** = ((src)   (src))
label* = (lab.b   lab.a)
@end example

The order in which the syntactic binding's tuples appear in the @rib{}
does not matter: two tuples are different when both the source name's
symbol and the marks are different and it is an error to add twice a
tuple to the same @rib{}.

@c ------------------------------------------------------------------------

@subsubheading Redefining or shadowing syntactic bindings

While it is an error to add twice a syntactic binding's tuple to the
same @rib{}, when expanding syntactic forms at the top--level of an
interaction environment: it is possible to redefine a previously defined
syntactic binding and to shadow a previously imported syntactic binding.

Interaction environment objects (@pxref{iklib environment}) hold a
@rib{} object representing their top--level lexical contour; such @rib{}
holds tuples representing both the syntactic bindings imported from
libraries and the syntactic bindings defined when expanding expressions
at the top--level.

Let's say we are expanding syntactic forms read from the @repl{} (which
uses an interaction environment); if we type:

@example
vicare> (define a 1)
vicare> (define a 2)
@end example

@noindent
after the first @syntax{define} is expanded the tuples in the @rib{}
representing the top--level lexical contour are:

@example
name*  = (a)
mark** = ((src))
label* = (lab.a.1)
@end example

@noindent
and after the second @syntax{define} is expanded the tuples are:

@example
name*  = (a)
mark** = ((src))
label* = (lab.a.2)
@end example

@noindent
we see that the old label gensym has been replaced with a new label
gensym: this causes the syntactic binding to be redefined.

@c page
@node expander lexenv rib sealing
@subsubsection Sealing @rib{} objects


A non--empty @rib{} can be ``sealed'' once all bindings are inserted.
This happens every time a syntax creates a lexical contour with a number
of syntactic bindings that is immediately known; examples are:
@syntax{lambda}, @syntax{let} and its variants.

To seal a @rib{}, we convert the lists @code{name*}, @code{mark**} and
@code{label*} to vectors and insert a frequency vector in the
@code{sealed/freq} field.

The frequency vector is a Scheme vector of fixnums: an optimisation that
allows the @rib{} to reorganise itself by moving frequently used tuples
towards the beginning of the vectors.  This is possible because the
order in which the tuples appear in a @rib{} does not matter.

Let's see how it works.  An unsealed @rib{} holding two syntactic
bindings with source names @samp{a} and @samp{b} and the @code{src}
mark, looks as follows:

@example
name*       = (b       a)
mark**      = ((src)   (src))
label*      = (lab.b   lab.a)
sealed/freq = #f
@end example

@noindent
and right after sealing it:

@example
name*       = #(b       a)
mark**      = #((src)   (src))
label*      = #(lab.b   lab.a)
sealed/freq = #(0       0)
@end example

@noindent
the access frequencies in the @code{sealed/freq} field are initialised
to zero; after accessing once the binding of @samp{b} in the sealed
@rib{}, its frequency is incremented:

@example
name*       = #(b       a)
mark**      = #((src)   (src))
label*      = #(lab.b   lab.a)
sealed/freq = #(1       0)
@end example

@noindent
and after accessing twice the binding of @samp{a} in the sealed @rib{},
the tuples are swapped:

@example
name*       = #(a       b)
mark**      = #((src)   (src))
label*      = #(lab.a   lab.b)
sealed/freq = #(2       1)
@end example

Let's see what happens when there are multiple syntactic bindings with
the same access frequency.  If the scenario before the access is:

@example
name*       = #(f e d c b a)
sealed/freq = #(1 1 1 0 0 0)
@end example

@noindent
and we access @code{a}: first we want the tuple of @code{a} to be moved
in the leftmost position in the group of tuples with frequency equal to
zero:

@example
name*       = #(f e d a b c)
sealed/freq = #(1 1 1 0 0 0)
@end example

@noindent
we do this by swapping tuples in the vectors, in this case we swap the
tuple of @code{a} with the tuple of @code{c}; then we increment its
access frequency, the scenario after the access is:

@example
name*       = #(f e d a b c)
sealed/freq = #(1 1 1 1 0 0)
@end example

@c page
@node expander lexenv stx
@subsection Wrapped and unwrapped syntax objects


Under @value{PRJNAME}, we adopt the following definitions:

@table @dfn
@item Wrapped syntax object
An object of type @stx{}.

@item Unwrapped syntax object
A compound object holding: nulls, pairs, vectors, numbers, strings,
bytevectors, chars, booleans, keywords, would--block objects, unbound
objects, @eof{} objects, broken weak pointer objects, objects of type
@stx{}.
@end table

An unwrapped symbol object @strong{cannot} be part of an unwrapped
syntax object: an attempt to use an unwrapped syntax object holding an
unwrapped symbol will, sooner or later, cause an exception to be raised.


@deftp {Object Type} @aclass{stx}
Disjoint object type representing wrapped syntax objects: source code
expressions associated to meta data representing their lexical contour.

Objects of type @stx{} have the following fields:

@table @code
@item expr
A symbolic expression representing source code, possibly annotated;
these expressions are the ones produced by the Scheme source code
reader.  They can be raw source code expressions or nested hierarchies
of @objtype{annotation} objects returned by @func{get-annotated-datum}
(@pxref{iklib reader fun}).

@item mark*
Null or a proper list of @func{eq?}--unique objects, including the
symbol @samp{src}, used to distinguish between identifiers introduced by
the source code and identifiers introduced by applications of macro
transformers.  Each of these marks can be either a generated mark or an
anti--mark.

Two marks must be @func{eq?}--comparable, so, by default, we use empty
strings as marks and @false{} as anti--mark: their generation is fast.

@item rib*
Null or a proper list of @rib{} objects or @code{shift} symbols.  Every
@rib{} represents a nested lexical contour; a @code{shift} represents
the return from a macro transformer application.

While expanding source code: upon entering a syntactic form representing
a lexical contour, a new @rib{} is added to the syntax object
representing the syntactic form itself, to allow syntactic identifiers
in the form to be captured by the bindings introduced in that contour.

@item annotated-expr*
Null or a proper list of annotated expressions: @false{} or input forms
of macro transformer calls.  This field is used to trace the
transformations a form undergoes when it is processed as macro use.  The
@false{} items are inserted when this instance is processed as input
form of a macro call, but is later discarded.
@end table
@end deftp


The following bindings are exported by the library @library{vicare
expander}.


@defun syntax-object? @var{stx}
Return @true{} if @var{stx} is a wrapped or unwrapped syntax object;
otherwise return @false{}.
@end defun


@defun stx? @var{stx}
Return @true{} if @var{stx} is a wrapped syntax object; else return
@false{}.
@end defun


@defop {Field accessor} @stx{} stx-expr @var{stx}
Return a symbolic expression, possibly annotated.
@end defop


@defop {Field accessor} @stx{} stx-mark* @var{stx}
Return null or a proper list of @func{eq?}--unique objects acting as
lexical contour marks, including the symbol @samp{src}.
@end defop


@defop {Field accessor} @stx{} stx-rib* @var{stx}
Return null or a proper list of @rib{} instances or @code{shift}
symbols.
@end defop


@defop {Field accessor} @stx{} stx-annotated-expr* @var{stx}
Return null or a proper list of annotated expressions: @false{} or input
forms of macro transformer calls.
@end defop

@c ------------------------------------------------------------------------

@subsubheading What are syntax objects

All the syntactic identifiers are @stx{} objects with a symbol in their
@code{expr} field; other objects such as pairs and vectors may be
wrapped or unwrapped.  A wrapped pair is an @stx{} whose @code{expr}
field is a pair:

@example
(syntax (a . b))
@end example

@noindent
an unwrapped pair is a pair whose car and cdr fields are themselves
syntax objects (wrapped or unwrapped):

@example
((syntax a) . (syntax b))
@end example

It makes sense to associate lexical contour informations to syntactic
identifiers, while associating them to datums is useless from the point
of view of expanding source code.  For example, in the following code
the identifiers @samp{var} belong to different lexical contours, and so
have different meanings, while the datum @samp{123} is always the same
in all the lexical contours:

@lisp
(let ((var 123))
  (let ((var 123))
    var))
@end lisp

We can create a syntax object holding a raw expression as follows:

@lisp
(import (vicare))
(define X 1)
(begin-for-syntax
  (datum->syntax #'X 'ciao))
@result{} #<syntactic-identifier expr=ciao mark*=(src)>
@end lisp

@noindent
and we can create a syntax object holding an annotated expression as
follows:

@lisp
(import (vicare))
(define X 1)
(begin-for-syntax
  (let* ((port   (open-string-input-port "(list X)"))
         (datum  (get-annotated-datum port))
         (stx    (datum->syntax #'X datum)))
    datum
    @result{} #[annotation
             expression=#<omitted>
             stripped=(list X)
             textual-position=#[r6rs-record: &source-position
                                   port-id="*string-input-port*"
                                   byte=0
                                   character=0
                                   line=1
                                   column=1]]
    stx)
    @result{} #<syntax
             expr=(list X)
             mark*=(src)
             line=1 column=1 source=*string-input-port*>
@end lisp

@noindent
we can unwrap a syntax object by using @syntax{syntax-case}:

@lisp
(import (vicare))
(define X 1)
(begin-for-syntax
  (let* ((port   (open-string-input-port "(list X)"))
         (datum  (get-annotated-datum port))
         (stx    (datum->syntax #'X datum))
         (stx    (syntax-case stx ()
                   ((?head ?tail)
                    (list #'?head #'?tail)))))
    stx)
@result{} (#<syntactic-identifier expr=list mark*=(src)>
    #<syntactic-identifier expr=X mark*=(src)>)
@end lisp

@c page
@node expander lexenv descriptors
@subsection Syntactic binding's descriptors


A syntactic binding's descriptor is a pair with the format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
where @meta{binding-type} is a symbol and the format of
@meta{binding-value} depends on the binding type.

Every syntactic binding has a unique label gensym associated to it;
during the expansion process, no matter the current lexical context,
given a label gensym we can retrieve the associated binding descriptor.

Under @value{PRJNAME}, symbol objects are data structures with a slot
named @code{value}, accessor @func{symbol-value} and mutator
@func{set-symbol-value!}.  This slot is usually initialised to the
built--in object returned by @code{(unbound-object)}; we can inspect the
state of the slot with @func{symbol-bound?}.  The expander makes use of
this slot in label gensyms:

@itemize
@item
Syntactic bindings imported from libraries, including those established
by the boot image, have the binding descriptor referenced by the
@code{value} slot of their label gensym.

@item
Syntactic bindings established by the library being expanded, have the
association between label gensyms and binding descriptors stored in the
@lexenv{} component of the lexical environment.  The @code{value} slot
of these gensyms is set to the return value of @code{(unbound-object)}.
@end itemize

Given a label gensym we can determine if it is associated to an imported
syntactic binding by inspecting its @code{value} slot: if
@func{symbol-bound?} applied to the label returns @true{}, the binding
is imported; otherwise it was established by the code being expanded.

@c page
@node expander lexenv prim
@subsection Primitive syntactic bindings


@cindex Library @library{psyntax system $all}
@cindex @library{psyntax system $all}, library


The syntactic bindings established by the boot image are all those
exported by the library @library{psyntax system $all}; this is an
internal library that should not be used for normal operations.
Partitions of these bindings are also exported by the library
@library{vicare} and all those in the hierarchies @library{vicare ---}
and @library{rnrs ---}.

The syntactic bindings established by the boot image have descriptors
built by @value{PRJNAME}'s package building infrastructure.  Every boot
image's syntactic binding has a label gensym associated to it: the
binding's descriptor is stored in the @code{value} slot of the label.

@menu
* expander lexenv prim inspect::     Inspecting descriptors.
* expander lexenv prim names::       Public names and labels.
* expander lexenv prim integrated::  Integrated syntaxes.
* expander lexenv prim cmacros::     Core macros.
* expander lexenv prim ncmacros::    Non-core macros.
* expander lexenv prim primitives::  Core primitive functions
                                     and operations.
* expander lexenv prim bio::         Core object-type names.
* expander lexenv prim btd::         Core object-type descriptors.
* expander lexenv prim records::     Core record-type names.
* expander lexenv prim conditions::  Core condition-object
                                     record-type names.
* expander lexenv prim rtd::         Core record-type descriptors.
* expander lexenv prim rcd::         Core record-constructor
                                     descriptors.
* expander lexenv prim fluids::      Fluid syntaxes.
* expander lexenv prim labels::      Core label-type names.
@end menu

@c page
@node expander lexenv prim inspect
@subsubsection Inspecting syntactic binding's descriptors


We must remember that a syntactic binding's descriptor is a pair with
format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
first let's create an @objtype{environment} object with the system
library:

@lisp
(define env (environment '(psyntax system $all)))
@end lisp

@noindent
then let's look at some descriptors:

@itemize
@item
Primitive function @func{display}:

@lisp
(define-values (label descriptor)
  (environment-binding 'display env))
descriptor              @result{} (core-prim . display)
(symbol-value label)    @result{} (core-prim . display)
(eq? descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the descriptor: @meta{binding-type} is the symbol @samp{core-prim}
and @meta{binding-value} is the symbol @samp{display}, which is the
public name of the primitive function.

@item
Core primitive syntax @syntax{lambda}:

@lisp
(define-values (label descriptor)
  (environment-binding 'lambda env))
descriptor              @result{} (core-macro . lambda)
(symbol-value label)    @result{} (core-macro . lambda)
(eq? descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the descriptor: @meta{binding-type} is the symbol @samp{core-macro}
and @meta{binding-value} is the symbol @samp{lambda}, which is the
public name of the primitive syntax.

@item
Non--core primitive syntax @syntax{let}:

@lisp
(define-values (label descriptor)
  (environment-binding 'let env))
descriptor              @result{} (macro . let)
(symbol-value label)    @result{} (macro . let)
(eq? descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the descriptor: @meta{binding-type} is the symbol @samp{macro} and
@meta{binding-value} is the symbol @samp{let}, which is the public name
of the primitive syntax.

@item
Condition object type @condition{condition}, which is implemented as
@rnrs{6} record type:

@lisp
(define-values (label descriptor)
  (environment-binding '&condition env))
descriptor
@result{} (core-object-type-name . (#<record-type-spec> .
  (&condition &condition-rtd &condition-rcd <condition>
     make-simple-condition condition? ())))

(symbol-value label)
@result{} (core-object-type-name . (#<record-type-spec> .
  (&condition &condition-rtd &condition-rcd <condition>
     make-simple-condition condition? ())))

(eq? descriptor (symbol-value label))
@result{} #t
@end lisp

@noindent
in the descriptor: @meta{binding-type} is the symbol
@samp{core-object-type-name} and @meta{binding-value} is the list:

@example
(#<record-type-spec> .
  (&condition &condition-rtd &condition-rcd <condition>
     make-simple-condition condition? ()))
@end example

@noindent
we can further inspect @code{&condition-rtd} and @code{&condition-rcd}:

@lisp
(receive (label descriptor)
    (environment-binding '&condition-rtd env)
  descriptor)
@result{} ($core-rtd . &condition-rtd)

(receive (label descriptor)
    (environment-binding '&condition-rcd env)
  descriptor)
@result{} ($core-rcd . &condition-rcd)
@end lisp
@end itemize

@c page
@node expander lexenv prim names
@subsubsection Public names and labels


If we know the public name of a primitive syntactic binding
(@func{display}, @syntax{lambda}, @syntax{let}, @condition{condition},
@dots{}) we can retrieve the binding's label using @func{system-label}
(@pxref{expander system-labels}) and given the label we can retrieve the
binding descriptor using @func{symbol-value} (@pxref{iklib symbols
value}).  Examples:

@lisp
(symbol-value (system-label 'display))
@result{} (core-prim . display)

(symbol-value (system-label 'lambda))
@result{} (core-macro . lambda)

(symbol-value (system-label 'let))
@result{} (core-macro . let)

(symbol-value (system-label '&condition))
@result{} (core-object-type-name . ---)

(symbol-value (system-label '__who__))
@result{} ($fluid . fluid-label.__who__)
@end lisp

For core primitive functions, record--type descriptors and
record--constructor descriptors:

@itemize
@item
Given the primitive's public name we can retrieve the binding type, the
storage location gensym and so the system value, @ref{compiler sysval,
System values bound to symbols}.

@item
Given the primitive's label gensym we can retrieve the binding type, the
public name and so the storage location gensym and the system value,
@ref{expander system-labels, Retrieving syntactic binding labels}.
@end itemize

Core primitive syntaxes and non--core primitive syntaxes have
implementation integrated in the expander:

@itemize
@item
Given the primitive's public name we can retrieve the binding type and
the label gensym.

@item
Given the primitive's label gensym we can retrieve the binding type and
the public name.
@end itemize

@c page
@node expander lexenv prim integrated
@subsubsection Primitive syntactic bindings: integrated syntax


@cindex @code{integrated-macro}, syntactic binding type
@cindex Syntactic binding types, @code{integrated-macro}


Some syntaxes are built into the expander and do not even have an
internal transformer function.  A syntactic binding representing an
integrated syntax has descriptor with format:

@example
(integrated-macro . @meta{name})
@end example

@noindent
where: @meta{binding-type} is the symbol @samp{integrated-macro};
@meta{binding-value} is @meta{name}, a symbol representing the public
name of the syntax; null.

Some of these core language syntaxes are: @syntax{define-syntax},
@syntax{define-alias}, @syntax{define-fluid-syntax}, @syntax{module},
@syntax{library}, @syntax{begin}, @syntax{import}, @syntax{export},
@syntax{set!}, @syntax{let-syntax}, @syntax{letrec-syntax},
@syntax{stale-when}, @syntax{begin-for-syntax}.

@c page
@node expander lexenv prim cmacros
@subsubsection Primitive syntactic bindings: core macros


@cindex @code{core-macro}, syntactic binding type
@cindex Syntactic binding types, @code{core-macro}


A syntactic binding representing a core syntax with transformer function
implemented by the expander has descriptor with format:

@example
(core-macro . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the
syntax.

The core syntax transformer functions are implemented by the expander in
the module exporting the function @func{core-macro-transformer}, which
is used to map core syntax names to transformer functions.

The implementation of core syntaxes cannot be decomposed into uses of
other syntaxes.  Some of these syntaxes are: @syntax{quote},
@syntax{lambda}, @syntax{case-lambda}, @syntax{let}, @syntax{letrec},
@syntax{letrec*}, @syntax{if}, @syntax{foreign-call},
@syntax{syntax-case}, @syntax{syntax}, @syntax{fluid-let-syntax},
@syntax{internal-body}.

@c page
@node expander lexenv prim ncmacros
@subsubsection Primitive syntactic bindings: non--core macros


@cindex @code{macro}, syntactic binding type
@cindex Syntactic binding types, @code{macro}


A syntactic binding representing a non--core syntax with transformer
function implemented by the expander has descriptor with format:

@example
(macro . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the
syntax.  The non--core syntax transformer functions are implemented by
the expander in the module exporting the function
@func{non-core-macro-transformer}, which is used to map non--core syntax
names to transformer functions.

The implementation of non--core syntaxes can be decomposed into uses of
other syntaxes.  Some of these syntaxes are:

@example
define-struct define-record-type define-condition-type
define-enumeration
or and xor
cond case
let* let-values let*-values syntax-rules
quasiquote quasisyntax with-syntax identifier-syntax
let*-syntax
define-syntax-rule define-auxiliary-syntaxes define-syntax*
do when unless while until for returnable
case-define define* case-define* lambda* case-lambda*
define-values receive receive-and-return begin0
include
assert try with-unwind-protection guard
@end example

@c page
@node expander lexenv prim primitives
@subsubsection Primitive syntactic bindings: core primitive functions and operations


@cindex @code{core-prim}, syntactic binding type
@cindex Syntactic binding types, @code{core-prim}


A syntactic binding representing a core primitive function, or core
primitive operation, or core primitive record--type descriptor, or core
primitive record--constructor descriptor has syntactic binding's
descriptor with format:

@example
(core-prim . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the core
primitive.

@c page
@node expander lexenv prim bio
@subsubsection Primitive syntactic bindings: core object--type names


@cindex @code{$core-type-name}, syntactic binding type
@cindex Syntactic binding types, @code{$core-type-name}


A syntactic binding representing the built--in Scheme object--types
defined by the boot image has descriptor with format:

@example
($core-type-name
  . #(@meta{type-name} @meta{uid-symbol} @meta{parent-name}
      @meta{constructor-name} @meta{type-predicate-name}
      @meta{equality-predicate-name} @meta{comparison-procedure-name}
      @meta{hash-function-name}
      @meta{type-descriptor-name} @meta{methods-avector}))
@end example

@noindent
where the values are:

@table @asis
@item @meta{type-name}
A symbol representing the type name.  For example @class{fixnum}.

@item @meta{uid-symbol}
A unique symbol associated with this object--type.

@item @meta{parent-name}
A symbol representing the parent type of this type, or @false{} if this
type has no parent.

@item @meta{constructor-name}
Either: a symbol representing the public name of this object--type's
constructor function (for example @class{vector} has @func{vector} as
constructor); @false{} if this object--type has no constructor; @true{}
if this object--type has no constructor but the syntax @syntax{new}
is used to validate an already built value:

@lisp
(new <fixnum> 1)        @result{} 1
(new <fixnum> "ciao")   @error{} invalid value
@end lisp

@item @meta{type-predicate-name}
A symbol representing the public name of the object--type's type
predicate function, or @false{} if this type has no type predicate.

@item @meta{equality-predicate-name}
A symbol representing the public name of the object--type's equality
predicate function, or @false{} if this type has no equality predicate.

@item @meta{comparison-procedure-name}
A symbol representing the public name of the object--type's equality
procedure, or @false{} if this type has no equality procedure.

@item @meta{hash-function-name}
A symbol representing the public name of the object--type's hash
function, or @false{} if this type has no hash function.

@item @meta{type-descriptor-name}
A symbol representing the public name of the object--type's run--time
type descriptor; for example @class{fixnum} has @code{<fixnum>-ctd}
(where @samp{ctd} stands for @emph{Core Type Descriptor}).

@item @meta{methods-avector}
An association vector having symbols as both keys and values:

@example
#((@meta{method-name} . @meta{method-implementation-procedure}) ...)
@end example

@noindent
where each key is the name of an object--type's method and each value is
the public name of the method's implementation procedure.
@end table

@c page
@node expander lexenv prim btd
@subsubsection Primitive syntactic bindings: core object--type descriptors


@cindex @code{$core-type-descriptor}, syntactic binding type
@cindex Syntactic binding types, @code{$core-type-descriptor}


A syntactic binding representing a core Scheme object--type descriptor
name has syntactic binding's descriptor with format:

@example
($core-type-descriptor . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the
object--type descriptor.

These objects are run--time descriptors for the built--in Scheme object
types; the type @class{fixnum} has a run--time descriptor named
@samp{<fixnum>-type-descriptor}, which is used (for example) for late
bindings of method calls.

@c page
@node expander lexenv prim records
@subsubsection Primitive Syntactic bindings: core record--type names


@cindex @code{$core-record-type-name}, syntactic binding type
@cindex Syntactic binding types, @code{$core-record-type-name}


A syntactic binding representing @rnrs{6}'s record--type name defined by
the boot image has descriptor with format:

@example
($core-record-type-name
  . (@meta{type-name} @meta{uid}
     @meta{rtd-name} @meta{rcd-name}
     @meta{parent-name}
     @meta{constructor-name} @meta{type-predicate-name}
     @meta{equality-predicate} @meta{comparison-procedure} @meta{hash-function}
     @meta{methods-alist}))
@end example

@noindent
where the values are:

@table @asis
@item @meta{type-name}
A symbol representing the public name of the type.

@item @meta{uid}
A symbol representing a unique identifier for the type.

@item @meta{rtd-name}
A symbol representing the public name of the syntactic identifier to
which the record--type descriptor is bound.

@item @meta{rcd-name}
A symbol representing the public name of the syntactic identifier to
which the default record--constructor descriptor is bound.

@item @meta{parent-name}
@false{} or a symbol representing the public name of the syntactic
identifier bound to the parent's record-type.

@item @meta{constructor-name}
A symbol representing the public name of the syntactic identifier to
which the default constructor is bound.

@item @meta{type-predicate-name}
A symbol representing the public name of the syntactic identifier to
which the type predicate is bound.

@item @meta{equality-predicate}
A symbol representing the public name of the syntactic identifier to
which the equality predicate is bound.

@item @meta{comparison-procedure}
A symbol representing the public name of the syntactic identifier to
which the comparison procedure is bound.

@item @meta{hash-function}
A symbol representing the public name of the syntactic identifier to
which the hash function is bound.

@item @meta{methods-alist}
An alist having: as keys symbols representing method names; as values
symbols representing the public name of the syntactic identifier to
which the method is bound.
@end table

@c page
@node expander lexenv prim conditions
@subsubsection Primitive syntactic bindings: core condition--object record--type names


@cindex @code{$core-condition-object-type-name}, syntactic binding type
@cindex Syntactic binding types, @code{$core-condition-object-type-name}


A syntactic binding representing @rnrs{6}'s condition object
record--type name defined by the boot image has descriptor with one of
the formats:

@example
($core-condition-object-type-name
  . (@meta{type-name} @meta{uid}
     @meta{rtd-name} @meta{rcd-name}
     @meta{parent-name}
     @meta{constructor-name} @meta{type-predicate-name}
     @meta{accessors-alist}))
@end example

@noindent
where the values are:

@table @asis
@item @meta{type-name}
A symbol representing the public name of the type.

@item @meta{uid}
A symbol representing a unique identifier for the type.

@item @meta{rtd-name}
A symbol representing the public name of the syntactic identifier to
which the record--type descriptor is bound.

@item @meta{rcd-name}
A symbol representing the public name of the syntactic identifier to
which the default record--constructor descriptor is bound.

@item @meta{parent-name}
@false{} or a symbol representing the public name of the syntactic
identifier bound to the parent's record-type.

@item @meta{constructor-name}
A symbol representing the public name of the syntactic identifier to
which the default constructor is bound.

@item @meta{type-predicate-name}
A symbol representing the public name of the syntactic identifier to
which the type predicate is bound.

@item @meta{accessors-alist}
An alist having: as keys symbols representing field names; as values
symbols representing the public name of the syntactic identifier to
which the safe field accessor is bound.
@end table

As example, for the definition:

@lisp
(define-condition-type &who
    &condition
  make-who-condition who-condition?
  (who condition-who))
@end lisp

@noindent
the following descriptor is generated:

@example
($core-condition-object-type-name
  . (&who vicare:scheme-type:&who
     &who-rtd &who-rcd &condition
     make-who-condition who-condition?
     ((who condition-who))))
@end example

@c page
@node expander lexenv prim rtd
@subsubsection Primitive syntactic bindings: core record--type descriptors


@cindex @code{$core-rtd}, syntactic binding type
@cindex Syntactic binding types, @code{$core-rtd}


A syntactic binding representing a core record--type descriptor name has
syntactic binding's descriptor with format:

@example
($core-rtd . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the
record--type descriptor.

@c page
@node expander lexenv prim rcd
@subsubsection Primitive syntactic bindings: core record--constructor descriptors


@cindex @code{$core-rcd}, syntactic binding type
@cindex Syntactic binding types, @code{$core-rcd}


A syntactic binding representing a core record--constructor descriptor
name has syntactic binding's descriptor with format:

@example
($core-rcd . @meta{name})
@end example

@noindent
where @meta{name} is a symbol representing the public name of the
record--constructor descriptor.

@c page
@node expander lexenv prim fluids
@subsubsection Primitive syntactic bindings: fluid syntaxes


@cindex @code{$fluid}, syntactic binding type
@cindex Syntactic binding types, @code{$fluid}


A syntactic binding representing a fluid syntax defined by the boot
image has descriptor with format:

@example
($fluid . @meta{fluid-label})
@end example

@noindent
where @meta{fluid-label} is a further label gensym used to redefine the
keyword binding; @ref{expander lexenv fluids, How fluid syntaxes work}.

Some of the fluid syntaxes are: @syntax{__who__}, @syntax{return},
@syntax{continue}, @syntax{break}, @syntax{with}, @syntax{brace},
@syntax{<>}.

@c page
@node expander lexenv prim labels
@subsubsection Core label-type names


@cindex @code{$core-label-type-name}, syntactic binding type
@cindex Syntactic binding types, @code{$core-label-type-name}


A syntactic binding representing a label--type name defined by the boot
image has descriptor with format:

@example
($core-label-type-name
  . (@meta{type-name} @meta{uid}
     @meta{parent-annotation}
     @meta{constructor-name} @meta{destructor-name} @meta{type-predicate-name}
     @meta{equality-predicate} @meta{comparison-procedure} @meta{hash-function}
     @meta{methods-alist}))
@end example

@noindent
where the values are:

@table @asis
@item @meta{type-name}
A symbol representing the public name of the type.

@item @meta{uid}
A symbol representing a unique identifier for the type.

@item @meta{parent-annotation}
A symbolic expression representing the parent's type annotation.

@item @meta{constructor-name}
@false{} or a symbol representing the public name of the syntactic
identifier to which the constructor is bound.

@item @meta{destructor-name}
@false{} or a symbol representing the public name of the syntactic
identifier to which the destructor is bound.

@item @meta{type-predicate-name}
@false{} or a symbol representing the public name of the syntactic
identifier to which the type predicate is bound.

@item @meta{equality-predicate}
@false{} or a symbol representing the public name of the syntactic
identifier to which the equality predicate is bound.

@item @meta{comparison-procedure}
@false{} or a symbol representing the public name of the syntactic
identifier to which the comparison procedure is bound.

@item @meta{hash-function}
@false{} or a symbol representing the public name of the syntactic
identifier to which the hash function is bound.

@item @meta{methods-alist}
An alist having: as keys symbols representing method names; as values
symbols representing the public name of the syntactic identifier to
which the method procedure is bound.
@end table

@c page
@node expander lexenv imported
@subsection Imported syntactic bindings


The data describing syntactic bindings established by a library is
stored in a @objtype{library} object:

@itemize
@item
If no @clause{rename} clause is used in the @clause{import} clause: the
imported name equals the exported name and it is taken from the
@code{export-subst} field of the @objtype{library} object.  The
@code{export-subst} maps exported names to label gensyms; it is an alist
whose entries have format:

@example
(@meta{exported-name} . @meta{label})
@end example

@item
The syntactic binding's descriptors are taken from the @code{global-env}
field of the @objtype{library} object.  The @code{global-env} maps label
gensyms to their binding descriptors; it is an alist whose entries have
format:

@example
(@meta{label} . @meta{binding-descriptor})
@end example

@item
When the library is interned: a @objtype{library} object is created and
the fields @code{export-subst} and @code{global-env} are used to build
the label gensyms by storing the descriptors in the @code{value} slots
of the gensyms.

@item
When a library is imported: the imported names of syntactic bindings are
associated to their label gensyms in the @rib{} object representing the
current lexical context.
@end itemize

@menu
* expander lexenv imported inspect::    Inspecting descriptors.
* expander lexenv imported variables::  Global variables.
* expander lexenv imported nvmacros::   Non-variable macros.
* expander lexenv imported vmacros::    Variable macros.
* expander lexenv imported etv::        Expand-time values.
* expander lexenv imported stn::        Struct-type names.
* expander lexenv imported rtn::        Record-type names.
* expander lexenv imported modules::    Module interfaces.
* expander lexenv imported fluids::     Fluid syntaxes.
* expander lexenv imported synonyms::   Synonym syntaxes.
* expander lexenv imported examples::   Example library.
@end menu

@c page
@node expander lexenv imported inspect
@subsubsection Inspecting descriptors


We must remember that a syntactic binding's descriptor is a pair with
format:

@example
(@meta{binding-type} . @meta{binding-value})
@end example

@noindent
first let's create a library:

@lisp
(library (demo)
  (export var)
  (import (vicare))
  (define var "ciao"))
@end lisp

@noindent
then let's create an @objtype{environment} object with the
@library{demo} library:

@lisp
(define env (environment '(demo)))
@end lisp

@noindent
finally let's look at the descriptor:

@lisp
(define-values (label descriptor)
  (environment-binding 'var env))

(define lex/loc-gensym
  (cddr descriptor))

(print-gensym #f)

descriptor
@result{} (global . (#<library (demo)> . lex/loc.var))

(symbol-value label)
@result{} (global . (#<library (demo)> . lex/loc.var))

(eq? descriptor (symbol-value label))
@result{} #t

(symbol-value lex/loc-gensym)
@result{} "ciao"
@end lisp

@noindent
where @code{lex/loc.var} is both the lexical gensym and the storage
location gensym of the exported variable; we can also import the library
and try to expand some code:

@lisp
(import (demo))
(print-gensym #f)
(expansion-of var)
@result{} lex/loc.var
@end lisp

@c page
@node expander lexenv imported variables
@subsubsection Imported syntactic bindings: global variables


@cindex @code{global}, syntactic binding type
@cindex Syntactic binding types, @code{global}


A syntactic binding representing an imported variable binding has
descriptor with format:

@example
(global . (@meta{library} . @meta{lex/loc}))
@end example

@noindent
where: @meta{library} is the @objtype{library} object from which the
binding is imported; @meta{lex/loc} is the storage location gensym
containing the variable's value in its @code{value} field.

@c page
@node expander lexenv imported nvmacros
@subsubsection Imported syntactic bindings: non--variable macros


@cindex @code{global-macro}, syntactic binding type
@cindex Syntactic binding types, @code{global-macro}


A syntactic binding representing an imported keyword binding with a
non--variable transformer has descriptor with format:

@example
(global-macro . (@meta{library} . @meta{loc}))
@end example

@noindent
where: @meta{library} is a record of type @objtype{library} describing
the library from which the macro is exported; @meta{loc} is the storage
location gensym containing the transformer function in its @code{value}
field.

Syntactic bindings of this type are established by
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating their right--hand side expression is a function.

@c page
@node expander lexenv imported vmacros
@subsubsection Imported syntactic bindings: variable macros


@cindex @code{global-macro!}, syntactic binding type
@cindex Syntactic binding types, @code{global-macro!}


A syntactic binding representing an imported keyword binding with
variable transformer has descriptor with format:

@example
(global-macro! . (@meta{library} . @meta{loc}))
@end example

@noindent
where: @meta{library} is a record of type @objtype{library} describing
the library from which the macro is exported; @meta{loc} is the storage
location gensym containing the transformer function in its @code{value}
field.

Syntactic bindings of this type are established by
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating their right--hand side expression is the return value of a
call to @func{make-variable-transformer}.

@c page
@node expander lexenv imported etv
@subsubsection Imported syntactic bindings: expand--time values


@cindex @code{global-etv}, syntactic binding type
@cindex Syntactic binding types, @code{global-etv}


A syntactic binding representing an imported keyword binding associated
to an expand--time value has descriptor with format:

@example
(global-etv . (@meta{library} . @meta{loc}))
@end example

@noindent
where: @meta{library} is a record of type @objtype{library} describing
the library from which the binding is imported; @meta{loc} is the gensym
containing the actual object in its @code{value} field (but only after
the library has been visited).

Syntactic bindings of this type are established by
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating their right--hand side expression is the return value of a
call to @func{make-expand-time-value}.

@c page
@node expander lexenv imported stn
@subsubsection Imported syntactic bindings: struct--type names


@cindex @code{$struct-type-name}, syntactic binding type
@cindex Syntactic binding types, @code{$struct-type-name}


A syntactic binding representing an imported keyword binding associated
to a @value{PRJNAME}'s struct--type name has descriptor with format:

@example
($struct-type-name . @meta{struct-type-spec})
@end example

@noindent
where @meta{struct-type-descriptor} is an instance of
@class{struct-type-spec}.

@c page
@node expander lexenv imported rtn
@subsubsection Imported syntactic bindings: record--type names


@cindex @code{$record-type-name}, syntactic binding type
@cindex Syntactic binding types, @code{$record-type-name}


A syntactic binding representing a keyword binding imported from a
library, but not established by the boot image, associated to a
@rnrs{6}'s record--type name has syntactic binding descriptor with one
of the formats:

@example
($record-type-name . @meta{record-type-spec})
@end example

@noindent
where @meta{record-type-spec} is a record of type
@objtype{<r6rs-record-type-spec>}.  This record references the syntactic
identifiers bound to the record--type descriptor, the
record--constructor descriptor and other values.

@c page
@node expander lexenv imported modules
@subsubsection Imported syntactic bindings: module interfaces


@cindex @code{$module}, syntactic binding type
@cindex Syntactic binding types, @code{$module}


A syntactic binding representing an imported keyword binding associated
to the interface of a @syntax{module} syntax has descriptor with format:

@example
($module . @meta{module-interface})
@end example

@noindent
where @meta{module-interface} is a struct of type
@objtype{module-interface}.

Syntactic bindings of this type are established by uses of the syntax
@syntax{module}.

@c page
@node expander lexenv imported fluids
@subsubsection Imported syntactic bindings: fluid syntaxes


@cindex @code{$fluid}, syntactic binding type
@cindex Syntactic binding types, @code{$fluid}


A syntactic binding representing an imported keyword binding associated
to a fluid syntax has descriptor with format:

@example
($fluid . @meta{fluid-label})
@end example

@noindent
where @meta{fluid-label} is a further label gensym used to redefine the
keyword binding; @ref{expander lexenv fluids, How fluid syntaxes work}.

Syntactic bindings of this type are established by uses of the syntax
@syntax{define-fluid-syntax}.

@c page
@node expander lexenv imported synonyms
@subsubsection Imported syntactic bindings: synonym syntaxes


@cindex @code{$synonym}, syntactic binding type
@cindex Syntactic binding types, @code{$synonym}


A syntactic binding representing an imported keyword binding associated
to a synonym syntax has descriptor with format:

@example
($synonym . @meta{synonym-label})
@end example

@noindent
where @meta{synonym-label} is the label gensym associated to the aliased
syntax; @ref{expander lexenv synonyms, How synonym syntaxes work}.

Syntactic bindings of this type are established by
@syntax{define-syntax}, @syntax{let-syntax} and similar when the result
of evaluating their right--hand side expression is the return value of
a call to @func{make-synonym-transformer}.

@c page
@node expander lexenv imported examples
@subsubsection Example library


We can use the following example library to toy with imported syntactic
bindings:

@lisp
(library (demo)
  (export var macro var-macro macro-id
          etv color <color> da-module fluid synonym)
  (import (vicare))

  (define var "ciao")

  (define-syntax macro
    (lambda (stx) "hello"))

  (define-syntax macro-id
    (identifier-syntax "hello"))

  (define-syntax var-macro
    (make-variable-transformer (lambda (stx) "ohayo")))

  (define-syntax etv
    (make-expand-time-value 123))

  (define-struct color
    (red green blue))

  (define-record-type <color>
    (fields red green blue))

  (module da-module
      (inner)
    (define inner 123))

  (define-fluid-syntax fluid
    (lambda (stx) "da fluid"))

  (define-syntax synonym
    (make-synonym-transformer #'var))

  #| end of library |# )
@end lisp

@c page
@node expander lexenv internal
@subsection Internal syntactic bindings


The internal syntactic bindings are the ones established by the code
being expanded, both at the top level and in a local context.  The
association between their label gensyms and their descriptors is
maintained in the @lexenv{}.

A @lexenv{} is an alist managed somewhat like a stack; while the
expansion proceeds, visiting the code in breadth--first order: the
@lexenv{} is updated by pushing new entries on the stack.  A @lexenv{}
entry has the following format:

@example
(@meta{label} . @meta{syntactic-binding-descriptor})
@end example

@noindent
where: @meta{label} is a label gensym uniquely associated to a syntactic
binding; @meta{syntactic-binding-descriptor} is a syntactic binding
descriptor.


@defun current-inferior-lexenv
Return an alist representing the current @lexenv{} used at the inferior
expansion level; mutating the returned value leads to undefined
behaviour.  It is to be used from the body of a macro transformer.

As example, to just print the @lexenv{} we can do:

@lisp
(import (vicare))

(define-syntax (print-lexenv stx)
  (import (prefix (vicare expander) xp::))
  (print-gensym #f)
  (pretty-print (xp::current-inferior-lexenv)
                (current-error-port))
  #'(void))

(define a 1)

(print-lexenv)
@end lisp

@noindent
and we will see two entries:

@example
((lab.a            . (lexical . (lex.a . #f)))
 (lab.print-lexenv . (local-macro . (#<procedure> . @meta{sexp}))))
@end example

@noindent
where @meta{sexp} is the symbolic expression representing the
transformer function of @syntax{print-lexenv} fully expanded to the core
language.
@end defun

Top level and local syntactic bindings are represented in the same way
in the @lexenv{}; the difference between them is that top level
syntactic bindings have the association between the source name and the
label gensym stored in the top level @rib{} object.

@menu
* expander lexenv internal variables::  Lexical variables.
* expander lexenv internal nvmacro::    Non-variable macros.
* expander lexenv internal vmacros::    Variable macros.
* expander lexenv internal etv::        Expand-time values.
* expander lexenv internal modules::    Module interfaces.
* expander lexenv internal pvars::      Pattern variables.
* expander lexenv internal stn::        Struct-type names.
* expander lexenv internal rtn::        Record-type names.
* expander lexenv internal fluids::     Fluid syntaxes.
* expander lexenv internal synonym::    Synonym syntaxes.
* expander lexenv internal bfs::        @syntax{begin-for-syntax} code.
* expander lexenv internal displaced::  Displaced syntactic bindings.
@end menu

@c page
@node expander lexenv internal variables
@subsubsection Internal syntactic bindings: lexical variables


@cindex @code{lexical}, syntactic binding type
@cindex Syntactic binding types, @code{lexical}


A syntactic binding representing a variable binding as created by
@syntax{let} and similar syntaxes, @syntax{lambda}, @syntax{case-lambda}
or @syntax{define}, has descriptor with format:

@example
(lexical . (@meta{lexvar} . @meta{assigned}))
@end example

@noindent
where: @meta{lexvar} is a lexical gensym representing the name of the
lexical variable binding in the expanded code; @meta{assigned} is a
boolean, true if somewhere in the code the variable is assigned (that
is: its value is mutated).

We want to keep track of assigned variables because we do not want to
export from a library a mutable variable.

@c page
@node expander lexenv internal nvmacro
@subsubsection Internal syntactic bindings: non--variable macros


@cindex @code{local-macro}, syntactic binding type
@cindex Syntactic binding types, @code{local-macro}


A syntactic binding representing a keyword binding with non--variable
transformer has descriptor with format:

@example
(local-macro . (@meta{transformer} . @meta{expanded-expr}))
@end example

@noindent
where: @meta{transformer} is a function implementing the macro
transformer; @meta{expanded-expr} is the expression in fully expanded
code representing the right--hand side of the syntax definition.
@meta{transformer} is the result of compiling and evaluating
@meta{expanded-expr}.

For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

@example
(set! @meta{loc} @meta{expanded-code})
@end example

@noindent
where @meta{loc} is the storage location gensym of the macro.

These syntactic bindings are established by @syntax{define-syntax},
@syntax{let-syntax} and similar, when their right--hand side evaluates
to a function.

@c page
@node expander lexenv internal vmacros
@subsubsection Internal syntactic bindings: variable macros


@cindex @code{local-macro!}, syntactic binding type
@cindex Syntactic binding types, @code{local-macro!}


A syntactic binding representing a keyword binding with variable
transformer has descriptor with format:

@example
(local-macro! . (@meta{transformer} . @meta{expanded-expr}))
@end example

@noindent
where: @meta{transformer} is a function implementing the macro
transformer; @meta{expanded-expr} is the expression in fully expanded
code representing the right--hand side of the syntax definition.
@meta{transformer} is the result of compiling and evaluating
@meta{expanded-expr}.

For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

@example
(set! @meta{loc} @meta{expanded-code})
@end example

@noindent
where @meta{loc} is the storage location gensym of the macro.

These syntactic bindings are established by @syntax{define-syntax},
@syntax{let-syntax} and similar, when their right--hand side evaluates
to the return value of @func{make-variable-transformer}.

@c page
@node expander lexenv internal etv
@subsubsection Internal syntactic bindings: expand--time values


@cindex @code{local-etv}, syntactic binding type
@cindex Syntactic binding types, @code{local-etv}


A syntactic binding representing a keyword binding associated to an
expand--time value has descriptor with format:

@example
(local-etv . (@meta{object} . @meta{expanded-expr}))
@end example

@noindent
where: @meta{object} is the actual value computed at expand time;
@meta{expanded-expr} is the result of fully expanding the right--hand
side of the syntax definition.  @meta{object} is the result of compiling
and evaluating @meta{expanded-expr}.

For every top level binding of this type, the following symbolic
expression is added to the visit code of the library being expanded:

@example
(set! @meta{loc} @meta{expanded-code})
@end example

@noindent
where @meta{loc} is the storage location gensym of the macro.

These syntactic bindings are established by @syntax{define-syntax},
@syntax{let-syntax} and similar, when their right--hand side evaluates
to the return value of @func{make-expand-time-value}.

@c page
@node expander lexenv internal modules
@subsubsection Internal syntactic bindings: module interfaces


@cindex @code{$module}, syntactic binding type
@cindex Syntactic binding types, @code{$module}


A syntactic binding representing a keyword binding associated to the
interface of a @syntax{module} syntax has descriptor with format:

@example
($module . @meta{module-interface})
@end example

@noindent
where @meta{module-interface} is a record of type
@objtype{module-interface}.

Syntactic bindings of this type are established by uses of the syntax
@syntax{module}.

@c page
@node expander lexenv internal pvars
@subsubsection Internal syntactic bindings: pattern variables


@cindex @code{pattern-variable}, syntactic binding type
@cindex Syntactic binding types, @code{pattern-variable}


A syntactic binding representing a keyword binding associated to a
pattern variable, as created by @syntax{syntax-case} and
@syntax{syntax-rules}, has descriptor with format:

@example
(pattern-variable . (@meta{name} . @meta{level}))
@end example

@noindent
where: @meta{name} is the lexical gensym representing the name of the
pattern variable; @meta{level} is a non--negative exact integer
representing the ellipsis nesting level.

The @syntax{syntax-case} patterns below will generate the displayed
syntactic binding descriptors:

@example
?a                      ->  (pattern-variable . (?a . 0))
(?a)                    ->  (pattern-variable . (?a . 0))
(((?a)))                ->  (pattern-variable . (?a . 0))
(?a ...)                ->  (pattern-variable . (?a . 1))
((?a) ...)              ->  (pattern-variable . (?a . 1))
((((?a))) ...)          ->  (pattern-variable . (?a . 1))
((?a ...) ...)          ->  (pattern-variable . (?a . 2))
(((?a ...) ...) ...)    ->  (pattern-variable . (?a . 3))
@end example

@c page
@node expander lexenv internal stn
@subsubsection Internal syntactic bindings: struct--type names


@cindex @code{$struct-type-name}, syntactic binding type
@cindex Syntactic binding types, @code{$struct-type-name}


A syntactic binding representing a keyword binding associated to a
@value{PRJNAME}'s struct--type name has descriptor with format:

@example
($struct-type-name . @meta{struct-type-spec})
@end example

@noindent
where @meta{struct-type-spec} is an instance of
@class{struct-type-spec}.

These bindings are established by uses of the syntax
@syntax{define-struct}.

@c page
@node expander lexenv internal rtn
@subsubsection Internal syntactic bindings: record--type names


@cindex @code{$record-type-name}, syntactic binding type
@cindex Syntactic binding types, @code{$record-type-name}


A syntactic binding representing a keyword binding associated to a
@rnrs{6}'s record--type name has descriptor with one of the formats:

@example
($record-type-name . @meta{record-type-spec})
@end example

@noindent
where @meta{record-type-spec} is a record of type
@objtype{<r6rs-record-type-spec>}.  This record references the syntactic
identifiers bound to the record--type descriptor, the
record--constructor descriptor and other values.

These syntactic bindings are established by uses of the syntax
@syntax{define-record-type}, @syntax{define-condition-type} and similar.

@c page
@node expander lexenv internal fluids
@subsubsection Internal syntactic bindings: fluid syntaxes


@cindex @code{$fluid}, syntactic binding type
@cindex Syntactic binding types, @code{$fluid}


A syntactic binding representing a keyword binding associated to a fluid
syntax has descriptor with format:

@example
($fluid . @meta{fluid-label})
@end example

@noindent
where @meta{fluid-label} is the label gensym associated to the fluid
syntax.

@c page
@node expander lexenv internal synonym
@subsubsection Internal syntactic bindings: synonym syntaxes


@cindex @code{$synonym}, syntactic binding type
@cindex Syntactic binding types, @code{$synonym}


A syntactic binding representing a keyword binding associated to a
synonym syntax has descriptor with format:

@example
($synonym . @meta{synonym-label})
@end example

@noindent
where @meta{synonym-label} is the label gensym associated to the aliased
syntax; @ref{expander lexenv synonyms, How synonym syntaxes work}.

@c page
@node expander lexenv internal bfs
@subsubsection Internal syntactic bindings: @syntax{begin-for-syntax} code


@cindex @code{begin-for-syntax}, syntactic binding type
@cindex Syntactic binding types, @code{begin-for-syntax}


Each use of @syntax{begin-for-syntax} generates expand--time code; when
this code is defined at the top level: it must become visit code to be
added to compiled libraries.  Whenever a @syntax{begin-for-syntax} use
is expanded the following entry is pushed on the @lexenv{}:

@example
(@meta{unused-label} . (begin-for-syntax . @meta{visit-code}))
@end example

@noindent
where: @meta{unused-label} is a dummy label gensym which is not bound in
the current @rib{}; @meta{visit-code} is a full core language expression
representing the expanded contents of the @syntax{begin-for-syntax} use.

@c page
@node expander lexenv internal displaced
@subsubsection Internal syntactic bindings: displaced syntactic bindings


@cindex @code{displaced-lexical}, syntactic binding type
@cindex Syntactic binding types, @code{displaced-lexical}


These pairs have a format similar to a @lexenv{} entry representing a
syntactic binding, but they are used to represent a failed search into a
@lexenv{}.

The following special value represents an unbound label:

@example
(displaced-lexical . #f)
@end example

@noindent
this is an ``identifier out of context'' error.

The following special value represents the result of a lexical
environment query with invalid label value (not a symbol):

@example
(displaced-lexical . ())
@end example

@c page
@node expander lexenv fluids
@subsection How fluid syntaxes work


When a fluid syntax's syntactic binding is established by
@syntax{define-fluid-syntax} in the source code of a library or program:

@example
(define-fluid-syntax @meta{lhs} @meta{rhs})
@end example

@noindent
an identifier @meta{lhs} is associated to a main label @meta{label} in
the current @rib{}; an entry is pushed on the @lexenv{}:

@example
(@meta{label} . ($fluid . @meta{fluid-label}))
@end example

@noindent
when querying the @lexenv{} for the binding descriptor associated to
@meta{label}: the descriptor with type @code{$fluid} is always returned,
qualifying the binding as fluid syntax.

At the same time, @syntax{define-fluid-syntax} pushes another entry on
the @lexenv{}:

@example
(@meta{fluid-label} . @meta{syntactic-binding})
@end example

@noindent
where @meta{syntactic-binding} is the concrete binding descriptor
created by expanding and evaluating @meta{rhs} then interpreting its
return value.

Given the identifier @meta{lhs}: we can retrieve the associated
@meta{label} and so the @meta{fluid-label}; then we can ``follow
through'' @meta{fluid-label} to retrieve the actual binding descriptor.

The fluid syntax can be redefined any number of times by using
@syntax{fluid-let-syntax}:

@example
(fluid-let-syntax ((@meta{lhs} @meta{inner-rhs})) . @meta{body})
@end example

@noindent
causing other entries associated to @meta{fluid-label} to be pushed on
the @lexenv{}:

@example
(@meta{fluid-label} . @meta{inner-syntactic-binding})
@end example

@noindent
where @meta{inner-syntactic-binding} is the binding descriptor resulting
from expanding and evaluating @meta{inner-rhs} then interpreting its
return value.

When searching the @lexenv{} for a syntactic binding descriptor matching
the label @meta{fluid-label}: the topmost entry is found, so the binding
appears to be redefined.

@c ------------------------------------------------------------------------

@subsubheading Primitive fluid syntaxes

This is @strong{not} what happens for the primitive fluid syntaxes
exported by the boot image like @syntax{return}, @syntax{break} and
@syntax{continue}.  For these syntaxes the lexical environment of the
boot image includes only the entries:

@example
(@meta{return-label}   . ($fluid .   @meta{return-fluid-label}))
(@meta{break-label}    . ($fluid .    @meta{break-fluid-label}))
(@meta{continue-label} . ($fluid . @meta{continue-fluid-label}))
@end example

@noindent
and there are no entries for the fluid labels @meta{return-fluid-label},
@meta{break-fluid-label} and @meta{continue-fluid-label}.  The keywords
of these fluid syntaxes are bound in the environment, but they are bound
to ``nothing''; trying to follow through the fluid labels to the
concrete binding descriptors will result in the binding descriptor:

@example
(displaced-lexical . #f)
@end example

@noindent
which is interpreted as the error ``keyword identifier out of context''.

Such half--defined fluid syntaxes are fully usable as auxiliary syntaxes
and can be redefined with @syntax{fluid-let-syntax}.  There are
@strong{no} transformer functions for @syntax{return}, @syntax{break},
@syntax{continue} and similar syntaxes.

@c page
@node expander lexenv synonyms
@subsection How synonym syntaxes work


When an synonym syntax binding is established:

@lisp
(define-syntax @meta{lhs} (make-synonym-transformer @meta{id}))
@end lisp

@noindent
an identifier @meta{lhs} is associated to a main label @meta{label} in
the current @rib{}; an entry is pushed on the @lexenv{}:

@example
(@meta{label} . ($synonym . @meta{synonym-label}))
@end example

@noindent
where @meta{synonym-label} is the label bound to the identifier
@meta{id}.  Given the identifier @meta{lhs}: we can retrieve the
associated @meta{label} and so the @meta{synonym-label}; then we can
``follow through'' @meta{synonym-label} to retrieve the actual binding
descriptor associated to @meta{id}.

@c page
@node expander lexenv inspection
@subsection Lexical environment inspection


The following syntactic bindings are exported by the library
@library{vicare expander}.


@defun syntactic-identifier->label @var{id}
Given the syntactic identifier @var{id} search its sequence of @rib{}
for a syntactic binding having the same source--name and marks.  If
successful: return the syntactic binding's label gensym; otherwise
return @false{}.

@lisp
(import (vicare) (prefix (vicare expander) xp::))

(xp::syntactic-identifier->label #'display)
@result{} #@{lab.display |PeEZ8c2>r<R&lTRg|@}
@end lisp
@end defun


@defun label->syntactic-binding-descriptor @var{label} @var{lexenv}
Look up the symbol @var{label} in the @var{lexenv} as well as in the
global environment.  If an entry with key @var{label} is found: return
the associated syntactic binding descriptor; if no matching entry is
found, return one of the special descriptors:

@table @code
@item (displaced-lexical . #f)
If the @var{label} is unbound in @var{lexenv}.

@item (displaced-lexical . ())
If the argument @var{label} is invalid.
@end table

If the binding descriptor represents a fluid syntax or synonym syntax:
follow through and return the innermost redefinition of the binding.

@lisp
(import (vicare) (prefix (vicare expander) xp::))

(begin-for-syntax
  (xp::label->syntactic-binding-descriptor
      (xp::syntactic-identifier->label #'display)
      (xp::current-inferior-lexenv)))
@result{} (core-prim . display)

(begin-for-syntax
  (xp::label->syntactic-binding-descriptor
      'label
      (xp::current-inferior-lexenv)))
@result{} (displaced-lexical . #f)

(begin-for-syntax
  (xp::label->syntactic-binding-descriptor
      123
      (xp::current-inferior-lexenv)))
@result{} (displaced-lexical . ())
@end lisp
@end defun


@defun label->syntactic-binding-descriptor/no-indirection
Like @func{label->syntactic-binding-descriptor}, but if the binding
descriptor represents a fluid syntax or a synonym syntax: do
@strong{not} follow through; instead return the binding descriptor of
the fluid or synonym syntax definition.

@lisp
(import (vicare)
   (prefix (vicare expander) xp::))

(define-fluid-syntax flu
  (identifier-syntax 123))

(begin-for-syntax
  (xp::label->syntactic-binding-descriptor
    (xp::syntactic-identifier->label #'flu)
    (xp::current-inferior-lexenv)))
@result{} (local-macro . (?procedure . ?sexp))

(begin-for-syntax
  (xp::label->syntactic-binding-descriptor/no-indirection
    (xp::syntactic-identifier->label #'flu)
    (xp::current-inferior-lexenv)))
@result{} ($fluid . lab.flu)
@end lisp
@end defun

@c page
@node expander utils
@section Miscellaneous utilities


@menu
* expander utils intro::        Introduction to utility functions.
* expander utils id::           Identifiers processing: generic functions.
* expander utils records::      Generating identifiers for records @api{}.
* expander utils structs::      Generating identifiers for structs @api{}.
* expander utils pairs::        Pairs processing.
* expander utils vectors::      Vectors processing.
* expander utils special::      Special processors.
* expander utils unwrap::       Unwrapping syntax objects.
* expander utils inspect::      Inspecting syntax objects.
* expander utils compar::       Comparing syntax objects.
* expander utils expanding::    Expanding forms.
@end menu

@c page
@node expander utils intro
@subsection Introduction to utility functions


Some functions accept an optional argument @var{synner}: when used, it
must be a function accepting 1 or 2 arguments, the first argument being
a string error message and the optional second argument being a subform;
@var{synner} must raise a compound condition object with components:
@condition{who}, @condition{message}, @condition{syntax}.  The
@var{synner} argument is meant to be used as follows:

@example
(define-syntax (my-macro stx)
  (case-define synner
    ((message)
     (synner message #f))
    ((message subform)
     (syntax-violation 'my-macro message stx subform)))
  (syntax-case stx ()
    (pattern body)
    (_
     (synner "invalid syntax"))))
@end example

@c page
@node expander utils id
@subsection Identifiers processing: generic functions


@defun identifier-bound? @var{id}
Return @true{} if the identifier @var{id} is lexically bound; otherwise
return @false{}.

@example
(identifier-bound? #'woppa-woppa-woppa)
@result{} #f

(let ((ciao 123))
  (define-syntax (doit stx)
    (identifier-bound? #'ciao))
  (doit))
@result{} #t

(let ((ciao 123))
  (define-syntax (doit stx)
    (syntax-case stx ()
      ((_ ?id)
       (identifier-bound? #'?id))))
  (doit ciao))
@result{} #t

(let ()
  (define ciao 123)
  (define-syntax (doit stx)
    (syntax-case stx ()
      ((_ ?id)
       (identifier-bound? #'?id))))
  (doit ciao))
@result{} #t

(let ()
  (let-syntax ((ciao (identifier-syntax 123)))
    (define-syntax (doit stx)
      (syntax-case stx ()
        ((_ ?id)
         (identifier-bound? #'?id))))
    (doit ciao)))
@result{} #t
@end example
@end defun


@defun identifier->string @var{id}
Return a string representing the name of the identifier @var{id}.
@end defun


@defun string->identifier @var{ctx} @var{str}
Build and return a new identifier, in the same lexical context of
@var{ctx}, having the string @var{str} as name.
@end defun


@defun identifier-prefix @var{prefix} @var{id}
Build and return a new identifier, in the same lexical context of the
identifier @var{id}, whose string name is the concatenation of
@var{prefix} and @var{id}.  @var{prefix} can be a string, symbol or
identifier.

@example
(import (vicare))

(bound-identifier=? (identifier-prefix "this-" #'that)
                    #'this-that)
@result{} #t
@end example
@end defun


@defun identifier-suffix @var{id} @var{suffix}
Build and return a new identifier, in the same lexical context of the
identifier @var{id}, whose string name is the concatenation of @var{id}
and @var{suffix}.  @var{suffix} can be a string, symbol or identifier.

@example
(bound-identifier=? (identifier-suffix #'this "-that")
                    #'this-that)
@result{} #t
@end example
@end defun


@defun identifier-append @var{ctx} @var{item} @dots{}
Build and return a new identifier, in the same lexical context of the
identifier @var{ctx}, whose string name is the concatenation of the
arguments @var{item}.  Each @var{item} can be a string, symbol or
identifier.

@example
(bound-identifier=? (identifier-append #'this "-that" '-those)
                    #'this-that-those)
@result{} #t
@end example
@end defun


@defun identifier-format @var{ctx} @var{template} @var{item} @dots{}
Build and return a new identifier, in the same lexical context of the
identifier @var{ctx}, whose string name is the result of formatting the
string @var{template} with the arguments @var{item}.  @var{template} can
be a string including the same escape sequences of @func{format} from
@library{vicare} (@pxref{iklib printing, format}).  Each @var{item} can
be a string, symbol or identifier.

@example
(bound-identifier=?
 (identifier-format #'here "~a-~a-~a" #'this "that" 'those)
 #'this-that-those)
@result{} #t
@end example
@end defun


@defun duplicate-identifiers? @var{ids}
@defunx duplicate-identifiers? @var{ids} @var{identifier=}
Search the list of identifiers @var{ids} for duplicate identifiers; at
the first duplicate found, return it; return @false{} if no duplications
are found.

The optional argument @var{identifier=} must be the predicate function
used to compare identifiers; when not given it defaults to
@func{free-identifier=?}.
@end defun


@defun delete-duplicate-identifiers @var{ids}
@defunx delete-duplicate-identifiers @var{ids} @var{identifier=}
Given the list of identifiers @var{ids} remove the duplicate identifiers
and return a proper list of unique identifiers.

The optional argument @var{identifier=} must be the predicate function
used to compare identifiers; when not given it defaults to
@func{free-identifier=?}.
@end defun


@defun identifier-memq @var{id} @var{ids}
@defunx identifier-memq @var{id} @var{ids} @var{identifier=}
Search the list of identifiers @var{ids} for one that matches @var{id}
and return the sublist starting with it; return @false{} if @var{id} is
not present.

The optional argument @var{identifier=} must be the predicate function
used to compare identifiers; when not given it defaults to
@func{free-identifier=?}.
@end defun


@deffn Syntax with-implicits ((@meta{ctx} @meta{symbol} ...) ...) . @meta{body}
Wrapper for @func{with-syntax} which defines the identifiers
@meta{symbol} with the same context of @meta{ctx}.  @meta{ctx} must be
an expression evaluating to an identifier; it is evaluated only once.
@meta{symbol} must be Scheme symbols.

For example:

@example
(syntax-case stx ()
  ((id)
   (identifier? #'id)
   (with-implicits ((#'id x y))
     #'(list x y))))
@end example

@noindent
is equivalent to:

@example
(syntax-case stx ()
  ((id)
   (identifier? #'id)
   (with-syntax ((x (datum->syntax #'id 'x))
                 (y (datum->syntax #'id 'y)))
     #'(list x y))))
@end example

@quotation
@strong{NOTE} This macro is derived from the one documented in the Chez
Scheme User's Guide.
@end quotation
@end deffn

@c page
@node expander utils records
@subsection Generating identifiers for records @api{}


@defun identifier-record-constructor @var{type-id}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default constructor
name for such record type.

@example
(bound-identifier=?
 (identifier-record-constructor #'alpha)
 #'make-alpha)
@result{} #t
@end example
@end defun


@defun identifier-record-predicate @var{type-id}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default predicate
name for such record type.

@example
(bound-identifier=?
 (identifier-record-predicate #'alpha)
 #'alpha?)
@result{} #t
@end example
@end defun


@defun identifier-record-field-accessor @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default accessor name
for the field @var{field-name} of such record type.  @var{field-name}
can be a string, symbol or identifier.

@example
(bound-identifier=?
 (identifier-record-field-accessor #'alpha "one")
 #'alpha-one)
@result{} #t
@end example
@end defun


@defun identifier-record-field-mutator @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default mutator name
for the field @var{field-name} of such record type.  @var{field-name}
can be a string, symbol or identifier.

@example
(bound-identifier=?
 (identifier-record-field-mutator #'alpha "one")
 #'alpha-one-set!)
@result{} #t
@end example
@end defun

@c page
@node expander utils structs
@subsection Generating identifiers for structs @api{}


@defun identifier-struct-constructor @var{type-id}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default constructor name for
such struct type.

@example
(bound-identifier=?
 (identifier-struct-constructor #'alpha)
 #'make-alpha)
@result{} #t
@end example
@end defun


@defun identifier-struct-predicate @var{type-id}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default predicate name for
such struct type.

@example
(bound-identifier=?
 (identifier-struct-predicate #'alpha)
 #'alpha?)
@result{} #t
@end example
@end defun


@defun identifier-struct-field-accessor @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default accessor name for the
field @var{field-name} of such struct type.  @var{field-name} can be a
string, symbol or identifier.

@example
(bound-identifier=?
 (identifier-struct-field-accessor #'alpha "one")
 #'alpha-one)
@result{} #t
@end example
@end defun


@defun identifier-struct-field-mutator @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default mutator name for the
field @var{field-name} of such struct type.  @var{field-name} can be a
string, symbol or identifier.

@example
(bound-identifier=?
 (identifier-struct-field-mutator #'alpha "one")
 #'set-alpha-one!)
@result{} #t
@end example
@end defun

@c page
@node expander utils pairs
@subsection Pairs processing


@defun syntax-car @var{stx}
@defunx syntax-car @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding pair; return a syntax
object representing the car of @var{stx}.

@example
(bound-identifier=? (syntax-car #'(display . write))
                    #'display)
@result{} #t
@end example
@end defun


@defun syntax-cdr @var{stx}
@defunx syntax-cdr @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding pair; return a syntax
object representing the cdr of @var{stx}.

@example
(bound-identifier=? (syntax-cdr #'(display . write))
                    #'write)
@result{} #t
@end example
@end defun


@defun syntax->list @var{stx}
@defunx syntax->list @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding a proper list of items;
return a proper list holding the individual item syntax objects.

@example
(for-all (lambda (obj1 obj2)
           (if (identifier? obj2)
               (bound-identifier=? obj1 obj2)
             (equal? obj1 obj2)))
  (syntax->list #'(display 123 write))
  (list #'display 123 #'write))
@result{} #t
@end example
@end defun


@defun identifiers->list @var{stx}
@defunx identifiers->list @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding a proper list of
identifiers; return a proper list holding the individual identifiers.

@example
(for-all bound-identifier=?
  (identifiers->list #'(display write))
  (list #'display #'write))
@result{} #t
@end example
@end defun


@defun all-identifiers? @var{stx}
Return @true{} if @var{stx} is a syntax object representing the empty
list or a proper list of identifiers, otherwise return @false{}.
@end defun

@c page
@node expander utils vectors
@subsection Vectors processing


@defun syntax->vector @var{stx}
@defunx syntax->vector @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding a vector of items; return
a proper list holding the individual item syntax objects.

@example
(vector-for-all
    (lambda (obj1 obj2)
      (if (identifier? obj2)
          (bound-identifier=? obj1 obj2)
        (equal? obj1 obj2)))
  (syntax->vector #'#(display 123 write))
  (vector #'display 123 #'write))
@result{} #t
@end example
@end defun

@c page
@node expander utils special
@subsection Special processors


@defun parse-logic-predicate-syntax @var{stx}
@defunx parse-logic-predicate-syntax @var{stx} @var{tail-proc}
Given a syntax object @var{stx} parse it as logic predicate expression
with expected format:

@example
@var{stx} = (and @metao{expr} @meta{expr} ...)
    | (or  @metao{expr} @meta{expr} ...)
    | (xor @metao{expr} @meta{expr} ...)
    | (not @meta{expr})
    | @meta{expr}
@end example

@noindent
where @syntax{and}, @syntax{or}, @syntax{xor}, @syntax{not} are the
identifiers exported by @library{vicare}.  If a standalone @meta{expr}
is found: apply the procedure @var{tail-proc} to it gather its single
return value; @var{tail-proc} defaults to the identity function.

Return a syntax object representing the logic predicate with the
standalone expressions replaced by the return values of @var{tail-proc}.

@lisp
(define (tail-proc stx)
  (syntax-case stx ()
    ((?expr0 ?expr ...)
     #`(or #,@@(map (lambda (expr)
                     (parse-logic-predicate-syntax
                        expr tail-proc))
                (syntax->list #'(?expr0 ?expr ...)))))
    (_
     (list #'here stx))))

(define-syntax-rule (doit ?input)
  (parse-logic-predicate-syntax (syntax ?input) tail-proc))

(doit (and 1 2))
@result{} #'(and (here 1) (here 2))

(doit (or 1 2))
@result{} #'(or (here 1) (here 2))

(doit (xor 1 2)
@result{} #'(xor (here 1) (here 2))

(doit (not 1))
@result{} (not (here 1))

(doit (and (xor (not 1) 2)
           (or  (not 3) 4)))
@result{} #'(and (xor (not (here 1)) (here 2))
          (or  (not (here 3)) (here 4)))

(doit (1 2))
@result{} #'(or (here 1) (here 2))
@end lisp
@end defun

@c page
@node expander utils unwrap
@subsection Unwrapping syntax objects


@defun syntax-unwrap @var{stx}
Given a syntax object @var{stx} decompose it and return the
corresponding symbolic expression holding datums and identifiers.  Take
care of returning a proper list when the input is a syntax object
holding a proper list.
@end defun


@defun syntax-replace-id @var{stx} @var{src} @var{dst}
Replace every occurrence of the identifier @var{src} in @var{stx} with
the identifier @var{dst}.  Return the resulting fully unwrapped syntax
object.
@end defun

@c page
@node expander utils inspect
@subsection Inspecting syntax objects


@c @defun quoted-syntax-object? @var{stx}
@c Given a syntax object: return @true{} if it is a list whose car is one
@c among the identifiers @func{quote}, @func{quasiquote}, @func{syntax},
@c @func{quasisyntax}; return @false{} otherwise.
@c @end defun

@c page
@node expander utils compar
@subsection Comparing syntax objects


@defun syntax=? @vari{stx} @varii{stx}
Recursively visit the internals of the given syntax objects and return
@true{} if they are equal; return @false{} otherwise.  Identifiers are
compared with @func{free-identifier=?}.
@end defun


@defun {identifier=symbol?} @var{id} @var{sym}
Return true if the symbol @var{sym} is equal to the symbol name of the
identifier @var{id}.
@end defun

@c page
@node expander utils expanding
@subsection Expanding forms


The following bindings are exported by the library @library{vicare
expander}.


@defun expand-form-to-core-language @var{sexp} @var{env}
Interface to the internal expression expander, it is the expansion
engine used by @rnrs{6}'s @func{eval} function.

@var{sexp} must be a symbolic expression representing a Scheme form;
@var{env} must be an evaluation environment.

Return two values: the result of the expansion as symbolic expression in
the core language; a list of libraries that must be invoked before
evaluating the returned expression.

Example:

@example
(import (vicare)
  (prefix (vicare expander) xp::))

(receive (code libs)
     (xp::expand-form-to-core-language
        '(define (doit x)
           (if (null? x)
               #f
             (doit (cdr x))))
        (environment '(vicare)))
  code)
@result{} (set! loc.doit
     (annotated-case-lambda doit
       ((lex.x)
        (if (annotated-call (null? x)
              (primitive null?) lex.x)
            '#f
        (annotated-call (doit (cdr x))
          loc.doit
          (annotated-call (cdr x) (primitive cdr) lex.x))))))
@end example
@end defun

@c page
@node expander clauses
@section Syntax clauses helpers


When writing definition macros similar to @syntax{define-record-type} it
is quite useful to include in the syntax ``clauses'' that optionally
specify the behaviour of the defined thing.  A list of clauses is a
syntax object with the format:

@example
((@meta{identifier} @meta{thing} ...) ...)
@end example

@noindent
in which @meta{identifier} is meant to be an auxiliary syntax (as
defined by @func{define-auxiliary-syntaxes} or @func{define-syntax}) and
the optional @meta{thing} arguments can represent any symbolic
expression.  The functions documented in this section help in validating
and processing such clauses.

@menu
* expander clauses intro::    Introduction to clauses functions.
* expander clauses utils::    Syntax clauses utilities.
* expander clauses constr::   Syntax clauses constraints.
* expander clauses objects::  Clause specification objects.
@end menu

@c page
@node expander clauses intro
@subsection Introduction to clauses functions


Some functions accept an optional argument @var{synner}: when used, it
must be a function accepting 1 or 2 arguments, the first argument being
a string error message and the optional second argument being a subform;
@var{synner} must raise a compound condition object with components:
@condition{who}, @condition{message}, @condition{syntax}.  The
@var{synner} argument is meant to be used as follows:

@example
(define-syntax (my-macro stx)
  (case-define synner
    ((message)
     (synner message #f))
    ((message subform)
     (syntax-violation 'my-macro message stx subform)))
  (syntax-case stx ()
    (pattern body)
    (_
     (synner "invalid syntax"))))
@end example

@c page
@node expander clauses utils
@subsection Syntax clauses utilities


@defun syntax-clauses-unwrap @var{clauses}
@defunx syntax-clauses-unwrap @var{clauses} @var{synner}
Scan the syntax object @var{clauses} expecting it to represent a list of
clauses; return a new syntax object representing @var{clauses} fully
unwrapped.  The function @var{synner} is invoked if the structure of
@var{clauses} is invalid.
@end defun


@defun syntax-clauses-filter @var{keywords} @var{unwrapped-clauses}
Given a fully unwrapped syntax object @var{unwrapped-clauses} holding a
list of clauses (for example the return value of
@func{syntax-clauses-unwrap}) select the ones having @meta{identifier}
being @func{free-identifier=?} to an identifier in the list
@var{keywords} and return the selected clauses in a fully unwrapped
syntax object holding the list of them; return null if no matching
clause is found.
@end defun


@defun syntax-clauses-remove @var{keywords} @var{unwrapped-clauses}
Given a fully unwrapped syntax object @var{unwrapped-clauses} holding a
list of clauses (for example the return value of
@func{syntax-clauses-unwrap}) remove the ones having @meta{identifier}
being @func{free-identifier=?} to an identifier in the list
@var{keywords} and return the selected clauses in a fully unwrapped
syntax object holding the list of them; return null if no matching
clause is found.
@end defun


@defun syntax-clauses-partition @var{keywords} @var{unwrapped-clauses}
Given a fully unwrapped syntax object @var{unwrapped-clauses} holding a
list of clauses (for example the return value of
@func{syntax-clauses-unwrap}) partition it into: a list of clauses
having @meta{identifier} being @func{free-identifier=?} to an identifier
in the list @var{keywords}, a list of non--matching clauses.  Return the
two lists.

This function can be used to check that a list of clauses only contains
clauses with selected identifiers.
@end defun


@defun syntax-clauses-collapse @var{unwrapped-clauses}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}): collapse the
clauses having equal @meta{identifier} into a single clause and return
the resulting unwrapped syntax object.  Example:

@example
(syntax-clauses-collapse ((#'fields #'a #'b #'c)
                          (#'fields #'d #'e #'f)))
@result{} ((#'fields #'a #'b #'c #'d #'e #'f))
@end example
@end defun

@c page
@node expander clauses constr
@subsection Syntax clauses constraints


@defun syntax-clauses-verify-at-least-once @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-at-least-once @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
all the identifiers in the list @var{keywords} are present at least once
as clause identifiers.  If successful return unspecified values, else
call @var{synner} or raise a @condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-at-most-once @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-at-most-once @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
all the identifiers in the list @var{keywords} are present at most once
as clause identifiers.  If successful return unspecified values, else
call @var{synner} or raise a @condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-exactly-once @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-exactly-once @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
all the identifiers in the list @var{keywords} are present exactly once
as clause identifiers.  If successful return unspecified values, else
call @var{synner} or raise a @condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-mutually-inclusive @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-mutually-inclusive @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that if
one of the identifiers in the list @var{keywords} is present at least
once as clause identifier, then all the others are present too.  If
successful return unspecified values, else call @var{synner} or raise a
@condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-mutually-exclusive @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-mutually-exclusive @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that if
one of the identifiers in the list @var{keywords} is present at least
once as clause identifier, then all the others are @strong{not} present.
If successful return unspecified values, else call @var{synner} or raise
a @condition{syntax} violation exception.
@end defun

@c page
@node expander clauses objects
@subsection Clause specification objects


Clause specification objects are opaque objects, disjoint from all the
other Scheme object types, representing the constraints enforceable on a
syntax clause.


@deftp {Object Type} @aclass{syntax-clause-spec}
Type of objects representing a syntax clause specification.
@end deftp


@defun make-syntax-clause-spec @var{keyword} @var{min-occur} @var{max-occur} @var{min-args} @var{max-args} @var{mutually-inclusive} @var{mutually-exclusive}
@defunx make-syntax-clause-spec @var{keyword} @var{min-occur} @var{max-occur} @var{min-args} @var{max-args} @var{mutually-inclusive} @var{mutually-exclusive} @var{custom-data}
Build and return a new syntax clause specification object.  The
arguments are:

@table @var
@item keyword
An identifier representing the keyword for this clause.

@item min-occur
A non--negative real number representing the allowed minimum number of
occurrences for this clause.  @samp{0} means the clause is optional;
@samp{1} means the clause is mandatory.

@item max-occur
A non--negative real number representing the allowed maximum number of
occurrences for this clause.  @samp{0} means the clause is forbidden;
@samp{1} means the clause must appear at most once; @samp{+inf.0} means
the clause can appear any number of times.

@item min-args
A non--negative real number representing the allowed minimum number of
arguments for this clause.  @samp{0} means the clause can have no
arguments; @samp{1} means the clause must have at least one argument.

@item max-args
A non--negative real number representing the allowed maximum number of
arguments for this clause.  @samp{0} means the clause has no arguments;
@samp{1} means the clause must have at most one arguments; @samp{+inf.0}
means the clause can have any number of arguments.

@item mutually-inclusive
A list identifiers representing clauses keywords that must appear along
with this one.

@item mutually-exclusive
A list identifiers representing clauses keywords that must not appear
along with this one.

@item custom-data
Optional free value available for the user.  It is initialised to
@false{}.
@end table
@end defun


@defun syntax-clause-spec? @var{obj}
Return @true{} if @var{obj} is a syntax clause specification object,
otherwise return @false{}.
@end defun


@defun syntax-clause-spec-keyword @var{spec}
@defunx syntax-clause-spec-min-number-of-occurrences @var{spec}
@defunx syntax-clause-spec-max-number-of-occurrences @var{spec}
@defunx syntax-clause-spec-min-number-of-arguments @var{spec}
@defunx syntax-clause-spec-max-number-of-arguments @var{spec}
@defunx syntax-clause-spec-mutually-inclusive @var{spec}
@defunx syntax-clause-spec-mutually-exclusive @var{spec}
@defunx syntax-clause-spec-custom-data @var{spec}
Accessors for the fields of syntax clause specification objects.
@end defun


@defun syntax-clauses-single-spec @var{spec} @var{unwrapped-clauses}
@defunx syntax-clauses-single-spec @var{spec} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify if
there are clauses conforming to the given specification @var{spec}.

If successful return a (possibly empty) vector of vectors of syntax
objects; else call @var{synner} or raise a @condition{syntax} exception.
The length of the returned vector is the number of clauses from
@var{unwrapped-clauses} conforming to @var{spec}.  Each nested vector
represents the cdr of a clause matching @var{spec}:

@itemize
@item
If a clause has no arguments: the corresponding nested vector is empty.

@item
If a clause has @math{1} argument: the corresponding nested vector has
@math{1} item being the syntax object representing the argument.

@item
If a clause has @math{N} arguments: the corresponding nested vector has
@math{N} items being the syntax objects representing the arguments.
@end itemize

Examples:

@example
(import (vicare))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 1 1 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 456)
                             (d 789))))
@result{} #(#(456))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b)
                             (d 789))))
@result{} #(#())

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4 5 6)
                             (d 789))))
@result{} #(#(4 5 6))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4)
                             (b 5)
                             (b 6)
                             (d 789))))
@result{} #(#(4) #(5) #(6))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4 4.1)
                             (b 5 5.1)
                             (d 789))))
@result{} #(#(4 4.1) #(5 5.1))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4 ciao 6)
                             (d 789))))
@result{} #(#(4 #<syntax-object expr=ciao> 6))
@end example
@end defun


@defun syntax-clauses-fold-specs @var{combine} @var{knil} @var{specs} @var{unwrapped-clauses}
@defunx syntax-clauses-fold-specs @var{combine} @var{knil} @var{specs} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
the clauses conform to the given @var{specs}, which must be a list of
syntax clause specification objects.

Combine the clause arguments with the given @var{knil} in a
@func{fold-left} fashion, if successful return the resulting @var{knil};
if an invalid clause is found call @var{synner} or raise a
@condition{syntax} object.

The operation is conceptually as follows:

@example
(fold-left
    (lambda (knil spec)
      (let ((args (syntax-clauses-single-spec spec
                     @var{unwrapped-clauses} @var{synner})))
        (if (fxzero? (vector-length args))
            knil
          (@var{combine} knil spec args))))
  @var{knil}
  @var{specs})
@end example

@noindent
notice that @var{combine} is called only if a clause from @var{specs} is
present in @var{unwrapped-clauses}; @var{combine} must return the new
value for @var{knil}.
@end defun


@defun syntax-clauses-validate-specs @var{list-of-specs}
Given a list of @objtype{syntax-clause-spec} objects: perform some
validations among them.  If successful return @var{list-of-specs}
itself, otherwise raise an assertion violation.

The following checks are performed:

@itemize
@item
For every identifier listed in the @code{mutually-inclusive} field of
every @objtype{syntax-clause-spec}: check that such identifier is equal,
according to @func{free-identifier=?}, to an identifier in the
@code{keyword} field of another @objtype{syntax-clause-spec} object.

@item
For every identifier listed in the @code{mutually-exclusive} field of
every @objtype{syntax-clause-spec}: check that such identifier is equal,
according to @func{free-identifier=?}, to an identifier in the
@code{keyword} field of another @objtype{syntax-clause-spec} object.
@end itemize
@end defun

@c page
@node expander system-labels
@section Retrieving syntactic binding labels


Every core primitive has a name that is considered part of
@value{PRJNAME}'s core language; such primitive name is the actual
public name of the binding exported by the boot image.  The name of the
function @func{display} is the symbol @code{display}; the name of the
record--type descriptor @code{&condition-rtd} is the symbol
@code{&condition-rtd}.

Every core primitive syntactic binding has a unique @dfn{label} gensym
associated to it; the label is used to map core primitive's syntactic
identifiers to syntactic binding's decriptors in the lexical
environment.

The property list of the name contains a special entry whose value is
the label gensym of the core primitive syntactic binding; we can easily
inspect such situation as follows:

@example
(import (vicare)
  (prefix (vicare expander) xp::))

(getprop 'display (xp::system-label-gensym))
@result{} lab.display

;; extract the lexical environment entry describing DISPLAY
(symbol-value (getprop 'display (xp::system-label-gensym)))
@result{} (core-prim . display)

(xp::system-label 'display)
@result{} lab.display
@end example

We see that the property list contains an entry with key set to the
symbol returned by @func{system-label-gensym}; notice that this key is
different every time we rebuild the boot image.


@defun system-label @var{symbol}
Attempt to extract from @var{symbol} the core primitive syntactic
binding label of which @var{symbol} is the name; if successful return
the label, else return @false{}.
@end defun


@defun system-label-gensym
Return a special gensym used internally to map core primitive names to
their syntactic binding label gensym.
@end defun

@c page
@node expander system-identifiers
@section Retrieving syntactic binding identifiers


Every core primitive has a name that is considered part of
@value{PRJNAME}'s core language; such primitive name is the actual
public name of the binding exported by the boot image.  The name of the
function @func{display} is the symbol @code{display}; the name of the
record--type descriptor @code{&condition-rtd} is the symbol
@code{&condition-rtd}.

Some internal operations generate a syntactic identifier bound to a core
primitive and store it in the property list of the public primitive
name; we can easily inspect such situation as follows:

@example
(import (vicare)
  (prefix (vicare expander) xp::))

(getprop 'procedure? (xp::system-id-gensym))
@result{} #<syntax expr=procedure? ...>

(xp::system-id 'procedure?)
@result{} #<syntax expr=procedure? ...>
@end example

We see that the property list contains an entry with key set to the
return value of @func{system-id-gensym}; notice that this key is
different every time we rebuild the boot image.


@defun system-id @var{symbol}
Attempt to extract from @var{symbol} the bound identifier of which
@var{symbol} is the name; if successful return the label, else return
@false{}.
@end defun


@defun system-id-gensym
Return a special gensym used internally to map core primitive names to
their syntactic binding identifiers.
@end defun

@c page
@node expander examples
@section Expansion and expander inspection examples


@menu
* expander examples intro::     Introduction, prelude and postlude.
* expander examples top-level:: The top--level lexical environment.
* expander examples contours::  Lexical contours inspection.
* expander examples phases::    Expansion and evaluation phases.
@end menu

@c page
@node expander examples intro
@subsection Prelude and postlude


All the examples are given as executable code, but when the output of
the pretty printer is shown: it is edited for readability.

Unless otherwise specified, all the examples are @rnrs{6} programs,
starting with the prelude:

@lisp
(import (vicare)
  (prefix (vicare expander) xp::))

(begin-for-syntax

  (define (id->label id)
    (xp::syntactic-identifier->label id))

  (define (label->descriptor lab)
    (xp::label->syntactic-binding-descriptor lab
      (xp::current-inferior-lexenv)))

  (define (id->descriptor id)
    (label->descriptor (id->label id)))

  (define (id-rib*/no-top id)
    (reverse (cdr (reverse (xp::stx-rib* id)))))

  (define (eq-ribs? id1 id2)
    (eq? (xp::stx-rib* id1) (xp::stx-rib* id2)))

  #| end of BEGIN-FOR-SYNTAX |# )
@end lisp

@noindent
and ending with the postlude:

@lisp
(begin-for-syntax
  (flush-output-port (current-output-port)))
(flush-output-port (current-output-port))
@end lisp

@c page
@node expander examples top-level
@subsection The top--level lexical environment


@cindex Top--level lexical environment


The syntactic bindings established by the @clause{import} clause of
programs and libraries are stored in a @rib{} object; this @rib{}
represents the @dfn{top--level environment} and it is referred to as
@dfn{top--level @rib{}}.  The descriptors of top--level syntactic
bindings are stored in the @code{value} field of their label gensyms.

We can look at a syntactic identifier as follows:

@lisp
(begin-for-syntax
  (pretty-print #'display))
@print{} #<syntactic-identifier expr=display mark*=(src)>
@end lisp

@noindent
we see that: the source--name symbol is @samp{display}; the list of
marks is @samp{(src)}; the list of @rib{} objects is not displayed,
because it is too long.  We can inspect the list of @rib{} objects too:

@lisp
(begin-for-syntax
  (pretty-print (xp::stx-rib* #'display)))
@print{} (#<rib name*=(...) mark**=(...) label*=(...) sealed/freq=#f>)
@end lisp

@noindent
we do not show the full output, because it is really long: the list of
ribs contains a single item being the top--level @rib{} of the program;
this top @rib{} contains a tuple for every syntactic binding imported in
the program.

We can retrieve the elements of syntactic bindings from the top @rib{}:

@lisp
(begin-for-syntax
  (pretty-print (id->label #'display)))
@print{} lab.display

(begin-for-syntax
  (pretty-print (id->descriptor #'display)))
@print{} (core-prim . display)
@end lisp

If we define a lexical variable at the top--level of the program, we can
then query its syntactic binding:

@lisp
(define A 1)

(begin-for-syntax
  (pretty-print (id->label      #'A))
  (pretty-print (id->descriptor #'A)))
@print{} lab.A
@print{} (lexical . (lex.A . #f))
@end lisp

In the following examples: we avoid defining top--level bindings because
printing the top @rib{} is annoying; for this reason we use the function
@func{id-rib*/no-top} which cuts out the top @rib{} from a list of
@rib{} objects (the top @rib{} is always the last item in a list of
ribs).

@c page
@node expander examples contours
@subsection Lexical contours inspection


We will inspect the fields of @stx{} objects and @rib{} objects to
understand how the lexical environment's data structures are used to
represent lexical contours.

We will examine the expansion of nested @syntax{internal-body} uses:
these syntaxes are the simplest because they create a single lexical
contour.  We will inspect the syntactic identifiers and @rib{} objects
from the body of a @syntax{begin-for-syntax} use.

@menu
* expander examples contours single::  Single internal body.
* expander examples contours double::  Double internal body.
* expander examples contours datum::   What @func{datum->syntax} does.
@end menu

@c page
@node expander examples contours single
@subsubsection Single internal body


Let's create a single lexical contour with the syntax
@syntax{internal-body} and compare a top--level binding with a local
binding:

@lisp
(define A 1)
(internal-body
  (define B 2)
  (begin-for-syntax
    (pretty-print (syntax A))
    (pretty-print (syntax B))
    (pretty-print (eq-ribs? (syntax A) (syntax B))))
  (void))
@print{} #<syntactic-identifier expr=A mark*=(src)>
@print{} #<syntactic-identifier expr=B mark*=(src)>
@print{} #t
@end lisp

@noindent
we see that the syntactic identifiers created by @syntax{syntax} in the
@syntax{begin-for-syntax} have the same list of marks and the same list
of @rib{} objects.

Let's see the @rib{} objects:

@lisp
(define A 1)
(internal-body
  (define B 2)
  (begin-for-syntax
    (let ((ribs (xp::stx-rib* #'A)))
      (pretty-print (length ribs))
      (pretty-print ribs)))
  (void))
@print{} 2
@print{} (#<rib name*=(B)     mark**=((src))     label*=(lab.B)>
    #<rib name*=(A ...) mark**=((src) ...) label*=(lab.A ...)>)
@end lisp

@noindent
the list of @rib{} objects in the identifier @samp{(syntax A)} has two
items: the first is the @rib{} associated to @syntax{internal-body}; the
second is the top @rib{}.  We see the internal @rib{} holds a single
tuple describing the syntactic binding for @samp{B}; the syntactic
binding for @samp{A} is in the top @rib{}.

With this layout we can understand what the function @func{id->label}
does in the call:

@lisp
(define A 1)
(internal-body
  (begin-for-syntax
    (pretty-print (id->label #'A)))
  (void))
@print{} lab.A
@end lisp

@noindent
it extracts from its argument the symbol source--name @samp{A}, the list
of marks @samp{(src)} and the list of @rib{} objects, then it scans the
list of @rib{} objects left--to--right looking for a tuple whose
source--name is @func{eq?}  to @samp{A} and whose list of marks is
@func{equal?} to @samp{(src)}; it finds one in the top @rib{}.

This action of looking for a @rib{}'s tuple with the same source--name
and the same marks is the @dfn{syntactic identifier resolution}, and we
say that the tuple @dfn{captures} the identifier.

This is not the whole story: to handle macro expansion we need more than
this; but for lexical contours: building a list of @rib{} objects and
using a single mark is enough.

@c page
@node expander examples contours double
@subsubsection Double internal body


Let's create two nested lexical contours with the syntax
@syntax{internal-body} and inspect the @rib{} objects:

@lisp
(internal-body
  (define A 1)
  (internal-body
    (define B 2)
    (begin-for-syntax
      (pretty-print #'A)
      (pretty-print #'B)
      (pretty-print (eq-ribs? #'A #'B))
      (pretty-print (length (xp::stx-rib* #'A)))
      (pretty-print (id-rib*/no-top #'A)))
    (void)))
@print{} #<syntactic-identifier expr=A mark*=(src)>
@print{} #<syntactic-identifier expr=B mark*=(src)>
@print{} #t
@print{} 3
@print{} (#<rib name*=(B) mark**=((src)) label*=(lab.B)>
    #<rib name*=(A) mark**=((src)) label*=(lab.A)>)
@end lisp

@noindent
we see that:

@itemize
@item
Both @code{#'A} and @code{#'B} have the same marks and @rib{} objects.

@item
@code{#'A} and @code{#'B} build identifiers whose list of @rib{} objects
has @math{3} items: the @rib{} of the internal @syntax{internal-body};
the @rib{} of the external @syntax{internal-body}; the top @rib{}, which
we have cut out using @func{id-rib*/no-top}.

@item
The @rib{} of the internal @syntax{internal-body} comes first in the
list of @rib{} objects and it has the tuple of @samp{B}.

@item
The @rib{} of the external @syntax{internal-body} comes second in the
list of @rib{} objects and it has the tuple of @samp{A}.
@end itemize

It is simple to resolve the identifiers:

@lisp
(internal-body
  (define A 1)
  (internal-body
    (define B 2)
    (begin-for-syntax
      (pretty-print (id->label #'A))
      (pretty-print (id->label #'B))
      (pretty-print (id->descriptor #'A))
      (pretty-print (id->descriptor #'B)))
    (void)))
@print{} lab.A
@print{} lab.B
@print{} (lexical . (lex.A . #f))
@print{} (lexical . (lex.B . #f))
@end lisp

Now let's create two syntactic bindings with the same source name:

@lisp
(internal-body
  (define A 1)
  (internal-body
    (define A 2)
    (begin-for-syntax
      (pretty-print #'A)
      (pretty-print (length (xp::stx-rib* #'A)))
      (pretty-print (id-rib*/no-top #'A)))
    (void)))
@print{} #<syntactic-identifier expr=A mark*=(src)>
@print{} 3
@print{} (#<rib name*=(A) mark**=((src)) label*=(lab.A.2)>
    #<rib name*=(A) mark**=((src)) label*=(lab.A.1)>)
@end lisp

@noindent
we see that both the @rib{} objects in the list of @samp{#'A} have a
tuple with source--name @samp{A} and marks @samp{(src)}, but the @rib{}
of the internal @syntax{internal-body} comes first; so the internal
syntactic binding for @samp{A} is the one that captures the identifier:

@lisp
(internal-body
  (define A 1)
  (internal-body
    (define A 2)
    (begin-for-syntax
      (pretty-print (id->label #'A)))
    (void)))
@print{} lab.A.2
@end lisp

Without describing how macros work, let's see how we can introduce in
the internal body a syntactic identifier that is captured by the
external syntactic binding:

@lisp
(internal-body
  (define A 1)
  (define-syntax (doit stx)
    #'A)
  (internal-body
    (define A 2)
    (pretty-print (doit))))
@print{} 1
@end lisp

@c page
@node expander examples contours datum
@subsubsection What @func{datum->syntax} does


Armed with our understanding of lists of @rib{} objects as
representation of nested lexical contours, we can understand what the
standard procedure @func{datum->syntax} does (@pxref{stdlib syntax-case
conversion, datum->syntax}).  Let's see this example:

@lisp
(internal-body
  (define A 1)
  (begin-for-syntax
    (define B.id (datum->syntax #'A 'B))
    (pretty-print #'A)
    (pretty-print B.id)
    (pretty-print (eq-ribs? #'A B.id)))
  (void))
@print{} #<syntactic-identifier expr=A mark*=(src)>
@print{} #<syntactic-identifier expr=B mark*=(src)>
@print{} #t
@end lisp

@noindent
@func{datum->syntax} builds a new @stx{} using its @var{datum} argument
as symbolic expression and the marks and @rib{} list of its
@var{template-id} argument as wraps.

@func{datum->syntax} does not care if it generates a syntax objects with
unbound identifiers in reference position:

@lisp
(internal-body
  (define A 1)
  (begin-for-syntax
    (define B.id (datum->syntax #'A 'B))
    (pretty-print (id->label      B.id))
    (pretty-print (id->descriptor B.id)))
  (void))
@print{} #f
@print{} (displaced-lexical . ())
@end lisp

@noindent
it is only if we use the generated syntax object as part of the output
form of a macro use that the ``boundness'' matters.

@c page
@node expander examples phases
@subsection Expansion and evaluation phases


@menu
* expander examples phases single::  Single internal body and
                                     different phases.
@end menu

@c page
@node expander examples phases single
@subsubsection Single internal body and different phases


Let's consider the syntactic form:

@lisp
(internal-body
  (begin-for-syntax
    (void))
  (void))
@end lisp

@noindent
the @syntax{internal-body} is expanded at phase 1 and evaluated at phase
0; the @syntax{begin-for-syntax} is expanded at phase 2 and evaluated at
phase 1.  The code in @syntax{begin-for-syntax} is evaluated when the
code in @syntax{internal-body} is expanded.

Let's compare two syntactic identifiers captured by syntactic bindings
established at different expansion phases:

@lisp
(internal-body
  (define A 1)
  (begin-for-syntax
    (define B 1)
    (pretty-print #'A)
    (pretty-print #'B)
    (printf "same ribs? ~a\n" (eq-ribs? #'A #'B))
    (pretty-print (id-rib*/no-top #'A)))
  (void))
@print{} #<syntactic-identifier expr=A mark*=(src)>
@print{} #<syntactic-identifier expr=B mark*=(src)>
@print{} same ribs? #t
@print{} (#<rib name*=(B A) mark**=((src) (src)) label*=(lab.B lab.A)>)
@end lisp

@noindent
let's acknowledge that:

@itemize
@item
The syntactic binding @samp{A} is established when
@syntax{internal-body} is expanded: at phase 1.

@item
The syntactic binding @samp{B} is established when
@syntax{begin-for-syntax} is expanded: at phase 2.

@item
The @stx{} objects representing the syntactic identifiers @samp{(syntax
A)} and @samp{(syntax B)} have the same marks and @rib{} objects.

@item
The @rib{} of @syntax{internal-body} has tuples for both @samp{A} and
@samp{B}.
@end itemize

@noindent
so the expansion/evaluation phases are @strong{not} distinguished in the
@stx{} objects and the @rib{} objects.  Under @value{PRJNAME}: phase 0
has its @lexenv{}; phase 1 and the other phases have their @lexenv{}.

Let's try to resolve the identifiers using the inferior @lexenv{} from
the @syntax{begin-for-syntax}:

@lisp
(internal-body
  (define A 1)
  (begin-for-syntax
    (define B 1)
    (pretty-print (id->label      #'A))
    (pretty-print (id->label      #'B))
    (pretty-print (id->descriptor #'A))
    (pretty-print (id->descriptor #'B)))
  (void))
@print{} lab.A
@print{} lab.B
@print{} (lexical . (lab.A . #f))
@print{} (displaced-lexical . #f)
@end lisp

@noindent
we see that the labels are retrieved correctly from the @rib{} object;
the descriptor of @samp{A} is retrieved from the inferior @lexenv{},
while the label of @samp{B} appears unbound.

To retrieve the descriptor of @samp{B} we do:

@lisp
(internal-body
  (begin-for-syntax
    (define B 1)
    (begin-for-syntax
      (pretty-print (id->label      #'B))
      (pretty-print (id->descriptor #'B))))
  (void))
@print{} lab.B
@print{} (lexical . (lab.B . #f))
@end lisp

@noindent
let's acknowledge that:

@itemize
@item
The code in the external @syntax{begin-for-syntax} is expanded at phase
2 and evaluated at phase 1.  If we evaluate
@func{current-inferior-lexenv} in the body of the external
@syntax{begin-for-syntax}: we retrieve the @lexenv{} holding descriptors
for phase 1.

@item
The code in the internal @syntax{begin-for-syntax} is expanded at phase
3 and evaluated at phase 2.  If we evaluate
@func{current-inferior-lexenv} in the body of the internal
@syntax{begin-for-syntax}: we retrieve the @lexenv{} holding descriptors
for phase 2.
@end itemize

@noindent
for this reason: from the internal @syntax{begin-for-syntax} we are able
to retrieve the descriptor of @samp{B}.

@c page
@node expander specs
@section Object-type specifications


Type specifications are expand--time objects that describe the
characteristics of object--types.  Type specifications are part of the
lexical environment and are contained in syntactic binding's
descriptors.

Every type annotation has an internal representation as type
specification, @typedref{annotations, Type annotations}.  The type
specifications @api{} is exposed mostly for debugging purposes: in
normal operations we are not meant to use it directly.

@menu
* expander specs intro::        Introduction to type specifications.
* expander specs retrieving::   Retrieving type specifications.
* expander specs object::       Base object-type specifications.
* expander specs core::         Core object-type specifications.
* expander specs struct::       Struct object-type specifications.
* expander specs record::       Record object-type specifications.
* expander specs pair::         Pair type specifications.
* expander specs pair-of::      Pair-of type specifications.
* expander specs list::         List type specifications.
* expander specs list-of::      List-of type specifications.
* expander specs vector::       Vector type specifications.
* expander specs vector-of::    Vector-of type specifications.
* expander specs condobj::      Condition-object type specifications.
* expander specs enum::         Enumeration type specifications.
* expander specs hashtable::    Hashtable type specifications.
* expander specs alist::        Association list type specifications.
* expander specs closure::      Closure object type specifications.
* expander specs union::        Union type specifications.
* expander specs intersection:: Intersection type specifications.
* expander specs complement::   Complement type specifications.
* expander specs ancestor::     Ancestor-of type specifications.
* expander specs label::        Label type specifications.
* expander specs interface::    Interface type specifications.
* expander specs signatures::   Type specification signatures.
@end menu

@c page
@node expander specs intro
@subsection Introduction to type specifications


The internal representation of object--types is as hierarchy of
record--types having the type @class{object-type-spec} as base.  The
hierarchy of record--types is:

@example
<object-type-spec>
   |
   +--> <core-type-spec>
   |
   +--> <struct-type-spec>
   |
   +--> <record-type-spec>
   |
   +--> <closure-type-spec>
   |
   +--> <compound-condition-type-spec>
   |
   +--> <union-type-spec>
   |
   +--> <intersection-type-spec>
   |
   +--> <complement-type-spec>
   |
   +--> <ancestor-of-type-spec>
   |
   +--> <pair-type-spec>
   |
   +--> <pair-of-type-spec>
   |
   +--> <list-type-spec>
   |
   +--> <list-of-type-spec> --> <alist-type-spec>
   |
   +--> <vector-type-spec>
   |
   +--> <vector-of-type-spec>
   |
   +--> <hashtable-type-spec>
   |
   +--> <enumeration-type-spec>
   |
   +--> <label-type-spec>
   |
    --> <interface-type-spec>
@end example

At present, all the record--types exposed by the library @library{vicare
expander} are sealed: they cannot be sub--typed by user code.

The type @class{object-type-spec} has a field @code{parent-ots} that is
used to represent the hierarchy of Scheme--level object--types.

All the built-in Scheme object types are represented by instances of
@class{core-type-spec}; so @class{top}, @class{fixnum}, @class{string},
@class{list} et cetera are represented by instances of
@class{core-type-spec}.

@c ------------------------------------------------------------------------

@subsubheading Hierarchy of list types

The hierarchy of list types is as follows:

@example
<list>
   |
   +--> <null>
   |
   +--> (list-of @ameta{type}) --> <null>
   |
    --> <nelist> --> (list @ametao{type} @ameta{type} ...)
@end example

@noindent
notice how @class{null} is considered a sub--type of both @class{list}
and @code{(list-of @ameta{type})} annotations, but @strong{not} of
@code{(list @ametao{type} @ameta{type} ...)}; this special handling is
implemented in the function
@func{object-type-spec.matching-super-and-sub?}.

The type annotations @code{(list-of @ameta{type})} are represented by
instances of @class{list-of-type-spec}.  @code{(list @ametao{type}
@ameta{type} ...)}  annotations are represented by instances of
@class{list-type-spec}, and represent non--empty lists.

@c ------------------------------------------------------------------------

@subsubheading Hierarchy of vector types

The hierarchy of vector types is as follows:

@example
<vector>
   |
   +---> <empty-vector>
   |
   +---> (vector-of @meta{type}) ---> <empty-vector>
   |
    ---> <nevector> ----------> (vector @ametao{type} @meta{type} ...)
@end example

@noindent
notice how @class{empty-vector} is considered a sub--type of both
@class{vector} and @code{(vector-of @ameta{type})} annotations, but
@strong{not} of @code{(vector @ametao{type} @ameta{type} ...)}
annotations; this special handling is implemented in the function
@func{object-type-spec.matching-super-and-sub?}.

The type annotation @code{(vector-of @ameta{type})} annotations are
represented by instances of @class{vector-of-type-spec}.  @code{(vector
@ametao{type} @ameta{type} ...)}  annotations are represented by
instances of @class{vector-type-spec}, and represent non--empty vectors.

@c page
@node expander specs retrieving
@subsection Retrieving type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@defun make-type-specification @var{annotation}
Build and return a new object--type specification object.
@var{annotation} must be a syntax object representing the type
annotation.  This function allows us to define type annotations as
follows:

@lisp
(import (only (psyntax expander)
              make-type-specification))

(define ots
  (make-type-specification #'<string>))
@end lisp
@end defun

@c page
@node expander specs object
@subsection Base object--type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{object-type-spec}
Record--type name of the base type for all the object--type
specifications.  In this documentation, instances of this type used as
arguments to function are indicated as @var{ots}.
@end deftp


@defun object-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of @class{object-type-spec},
otherwise return @false{}.
@end defun


@defun object-type-spec.name @var{ots}
@defunx object-type-spec.type-annotation @var{ots}
Return a syntax object representing the name or the type annotation of
the object--type specification @var{ots}.

For some types the type name and the type annotation are equal, for
example the core type names @class{fixnum}, @class{string}, et cetera
are both type names and type annotations.  For other types they are
distinguished, for example if we define the type:

@lisp
(define-type <list-of-fixnums>
  (list-of <fixnum>))
@end lisp

@noindent
the type name is @class{list-of-fixnums} while the type annotation is
@code{(list-of <fixnum>)}.
@end defun


@defun object-type-spec.uids-list @var{ots}
Return a list of symbols uniquely identifying this type specification.
The head of the list is a symbol associated to this object--type; the
second item in the list is associated to the parent; and so on.
@end defun


@defun object-type-spec.parent-ots
Return @false{} or an instance of @class{object-type-spec} representing
the parent of this object--type.
@end defun


@defun object-type-spec.constructor-stx @var{ots}
Return a boolean value or a syntax object representing a Scheme
expression that, expanded and evaluated at run--time, returns the
default constructor function.

@itemize
@item
When the return value is @false{}: this object--type has no constructor,
so trying to use the syntax @syntax{new} will cause an expand--time
exception.

@item
When the return value is @true{}: this object--type has no constructor,
but requires the object to be supplied in its already--built form to the
syntax @syntax{new}.  For example:

@lisp
(new <fixnum> 123)
@end lisp

@noindent
must expand to an equivalent of:

@lisp
(assert-signature-and-return (<fixnum>) 123)
@end lisp

@item
When this field is a syntax object: the constructor is meant to be used
as:

@lisp
(?constructor ?arg ...)
@end lisp

@noindent
and called explicitly with the syntax @syntax{new}.

The constructor can be a syntax or core operation like
@func{$make-clean-vector} or a closure object like @func{vector} or the
maker of record--types.
@end itemize
@end defun


@defun object-type-spec.destructor-stx @var{ots}
Return @false{} or a syntax object representing a Scheme expression
that, expanded and evaluated at run--time, returns a destructor
function.  The destructor is meant to be used as:

@lisp
(?destructor ?instance)
@end lisp

@noindent
and called explicitly with the @syntax{delete} syntax.
@end defun


@defun object-type-spec.type-predicate-stx @var{ots}
Return @false{} or a syntax object representing a Scheme expression
that, expanded and evaluated at run--time, returns a type predicate for
the object--type @var{ots}.

The predicate is meant to be used as:

@lisp
(@ameta{predicate} @ameta{object})
@end lisp

@noindent
and called explicitly with the @syntax{is-a?} syntax.

The type predicate can be a syntax or core operation or a closure object
like @func{vector?} or the predicate of record--types.
@end defun


@defun object-type-spec.equality-predicate @var{ots}
Return @false{} or a syntax object which, expanded and evaluated at
run--time, returns the equality predicate for this type.
@end defun


@defun object-type-spec.comparison-procedure @var{ots}
Return @false{} or a syntax object which, expanded and evaluated at
run--time, returns the comparison procedure for this type.
@end defun


@defun object-type-spec.applicable-hash-function @var{ots}
Return @false{} or a syntax object representing a Scheme expression
which, expanded and evaluated, returns the hash function for this type.
@end defun


@defun object-type-spec.implemented-interfaces @var{ots}
A (possibly empty) proper list of @class{interface-type-spec} instances
representing the implemented interfaces.
@end defun


@defun object-type-spec.applicable-method-stx @var{ots} @var{method-name}
@var{ots} must an object-type specification record.  @var{method-name}
must be a symbol representing a method name in the object--type
specification.

If @var{method-name} is @func{eq?} to:

@itemize
@item
The name of a public method for @var{OTS}.

@item
The name of a public method for @var{OTS}'s parent.
@end itemize

@noindent
return a syntax object representing a Scheme expression which, expanded
and evaluated at run-time, returns the method's applicable; otherwise
return @false{}.
@end defun


@defun object-type-spec=? @varo{ots} @var{ots} @dots{}
Return @true{} if all the @class{object-type-spec} instances given as
operands are equal to each other; otherwise return @false{}.
@end defun


@defun object-type-spec.ancestor-ots* @var{ots}
Return the, possibly empty, list of @class{object-type-spec} instances
representing the ancestors list of @var{ots}.  @var{ots} itself is
@strong{not} included in the list.

As example, when applied to the object--type specification of
@condition{condition}, the return value is the list of specifications
for:

@lisp
(<record> <struct> <top>)
@end lisp
@end defun


@defun object-type-spec.common-ancestor @vari{ots} @varii{ots}
Search the hierarchies of @vari{ots} and @varii{ots} looking for a
common ancestor.  Return an instance of @class{object-type-spec}
representing the ancestor's @class{ots}.  If no ancestor is found:
return the specification of @class{top}.
@end defun


@defun object-type-spec.matching-super-and-sub? @vari{ots} @varii{ots}
Return @true{} if the specifications given as operands are matching
super--type and sub--type; otherwise return @false{}.

The object--type specifications @vari{ots} @varii{ots} are matching
super--type and sub--type when @vari{ots} can be interpreted as
super--type of @varii{ots}.  For example:

@itemize
@item
When @vari{ots} is a parent of @varii{ots}.

@item
When both @vari{ots} and @varii{ots} represent pair compounds whose car
and cdr are matching super--type and sub--type.

@item
When both @vari{ots} and @varii{ots} represent list compounds whose car
and cdr are matching super--type and sub--type.

@item
When both @vari{ots} and @varii{ots} represent vector compounds whose
car and cdr are matching super--type and sub--type.
@end itemize
@end defun


@defun object-type-spec.compatible-super-and-sub? @vari{ots} @varii{ots}
Return @true{} if the specifications given as operands are compatible
super--type and sub--type; otherwise return @false{}.  This function is
meant to be used when we have already applied
@func{object-type-spec.matching-super-and-sub?} to the same operands and
the result was @false{}.

The operands @vari{ots} and @varii{ots} are compatible as super--type
and sub--type when @varii{ots} is a matching super--type of @vari{ots}.
Whenever @vari{ots} is the type specification of an expected argument
and @varii{ots} is the type specification of a given operand: it makes
sense to consider them ``matching'' at expand--time, but to perform a
further values validation at run--time.
@end defun


@defun object-type-spec.procedure? @var{ots}
Return @true{} if @var{ots} represents the object--type specification of
a closure object; otherwise return @false{}.  This means @var{ots} is
either an instance of @class{closure-type-spec} or it is the
specification of @class{procedure}.
@end defun


@defun object-type-spec.list-sub-type? @var{ots}
Return @true{} if @var{ots} represents the object--type specification of
a list object; otherwise return @false{}.
@end defun


@defun object-type-spec.vector-sub-type? @var{ots}
Return @true{} if @var{ots} represents the object--type specification of
a vector object; otherwise return @false{}.
@end defun

@c page
@node expander specs core
@subsection Core object--type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{core-type-spec}
Name of type specifications for core Scheme objects.  Instances of this
type are the object--type specifications for: @class{fixnum},
@class{flonum}, @class{string}, @class{list}, et cetera.  There may be
multiple instances of this type representing the same Scheme
object--type.

Instances of this type are internally generated and cannot be built by
user code.
@end deftp


@defun core-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of @class{core-type-spec};
otherwise return @false{}.
@end defun


@defun core-type-spec.type-descriptor-id @var{ots}
Return a syntactic identifier bound to the instance of
@class{core-type-descriptor} describing run--time features of the
object--type.
@end defun


@defun core-type-spec.parent-and-child? @vari{ots} @varii{ots}
Return @true{} if @vari{ots} and @varii{ots} represent parent and child
object--types (respectively); otherwise return @false{}.  Return
@false{} if the operands represent the same object--type.
@end defun

@c page
@node expander specs struct
@subsection Struct object--type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{struct-type-spec}
Name of type specifications for @value{PRJNAME}'s struct objects.
Instances of this type are generated by the syntax
@syntax{define-struct}.
@end deftp


@defun struct-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of @class{struct-type-spec};
otherwise return @false{}.
@end defun


@defun struct-type-spec.std @var{ots}
Return the struct--type descriptor object.
@end defun

@c page
@node expander specs record
@subsection Record object--type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{record-type-spec}
Name of type specifications for record--type.  Instances of this type
are generated by the syntax @syntax{define-record-type}.
@end deftp


@defun record-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of @class{record-type-spec};
otherwise return @false{}.
@end defun


@defun record-type-spec.rtd-id @var{ots}
@defunx record-type-spec.rcd-id @var{ots}
Return the syntactic identifier bound to the record--type descriptor or
record--type constructor descriptor.
@end defun


@defun record-type-spec.parent-and-child? @vari{ots} @varii{ots}
Return @true{} if @vari{ots} and @varii{ots} represent parent and child
object--types (respectively); otherwise return @false{}.  Return
@false{} if the operands represent the same object--type.
@end defun

@c page
@node expander specs pair
@subsection Pair type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{pair-type-spec}
Name of type specifications for pairs of heterogeneous values.
@end deftp


@defun make-pair-type-spec @var{car-ots} @var{cdr-ots}
Build and return a new instance of @class{pair-type-spec}.  The
arguments @var{car-ots} and @var{cdr-ots} must be instances of
@class{object-type-spec} representing the car and cdr specifications,
respectively.
@end defun


@defun pair-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of @class{pair-type-spec};
otherwise return @false{}.
@end defun


@defun pair-type-spec.car-ots @var{ots}
@defunx pair-type-spec.cdr-ots @var{ots}
Return instances of @class{object-type-spec} representing the car and
cdr specifications, respectively.
@end defun

@c page
@node expander specs pair-of
@subsection Pair-of type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{pair-of-type-spec}
Name of type specifications for pairs of homogeneous values.
@end deftp


@defun make-pair-of-type-spec @var{item-ots}
Build and return a new instance of @class{pair-of-type-spec}.  The
argument @var{item-ots} must be an instance of @class{object-type-spec}
representing the type specification of both the car and cdr.
@end defun


@defun pair-of-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of @class{pair-of-type-spec};
otherwise return @false{}.
@end defun


@defun pair-of-type-spec.item-ots @var{des}
Return an instance of @class{object-type-spec} representing the type
specification of both the car and cdr.
@end defun

@c page
@node expander specs list
@subsection List type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{list-type-spec}
Name of type specifications for lists of heterogeneous values.
@end deftp


@defun make-list-type-spec @var{item-ots*}
Build and return a new instance of @class{list-type-spec}.  The argument
@var{item-ots*} must be a proper, non--empty list of
@class{object-type-spec} instances representing the type specifications
of the items in the list.
@end defun


@defun list-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{list-type-spec}; otherwise return @false{}.
@end defun


@defun list-type-spec.item-ots* @var{ots}
Return a proper, non--empty list of @class{object-type-spec} instances
representing the type specifications of the items in the list.
@end defun


@defun list-type-spec.length @var{ots}
Return the length of the list, a non--negative exact integer.
@end defun

@c page
@node expander specs list-of
@subsection List-of type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{list-of-type-spec}
Name of type specifications for lists of homogeneous values.
@end deftp


@defun make-list-of-type-spec @var{item-ots}
Build and return a new instance of @class{list-of-type-spec}.  The
argument @var{item-ots} must be an instance of @class{object-type-spec}
representing the type specification of all the items.
@end defun


@defun list-of-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{list-of-type-spec}; otherwise return @false{}.
@end defun


@defun list-of-type-spec.item-ots @var{ots}
Return an instance of @class{object-type-spec} representing the type
specification of all the items.
@end defun

@c page
@node expander specs vector
@subsection Vector type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{vector-type-spec}
Name of type specifications for vectors of heterogeneous values.
@end deftp


@defun make-vector-type-spec @var{item-ots*}
Build and return a new instance of @class{vector-type-spec}.  The
argument @var{item-ots*} must be a proper, non--empty list of
@class{object-type-spec} instances representing the type specifications
of the items in the vector.
@end defun


@defun vector-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{vector-type-spec}; otherwise return @false{}.
@end defun


@defun vector-type-spec.item-ots* @var{ots}
Return a proper, non--empty list of @class{object-type-spec} instances
representing the type specifications of the items in the vector.
@end defun


@defun vector-type-spec.length @var{ots}
Return the length of the vector, a non--negative exact integer.
@end defun

@c page
@node expander specs vector-of
@subsection Vector-of type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{vector-of-type-spec}
Name of type specifications for vectors of homogeneous values.
@end deftp


@defun make-vector-of-type-spec @var{item-ots}
Build and return a new instance of @class{vector-of-type-spec}.  The
argument @var{item-ots} must be an instance of @class{object-type-spec}
representing the type specification of all the items.
@end defun


@defun vector-of-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{vector-of-type-spec}; otherwise return @false{}.
@end defun


@defun vector-of-type-spec.item-ots @var{ots}
Return an instance of @class{object-type-spec} representing the type
specification of all the items.
@end defun

@c page
@node expander specs condobj
@subsection Condition-object type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{compound-condition-type-spec}
Name of type specifications for compound condition objects.
@end deftp


@defun make-compound-condition-type-spec @var{component-ots*}
Build and return a new instance of @class{compound-condition-type-spec}.
The argument @var{component-ots*} must be a non--empty proper list of
@class{object-type-spec} instances representing the type specifications
of the component condition--objects.
@end defun


@defun compound-condition-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{compound-condition-type-spec}; otherwise return @false{}.
@end defun


@defun compound-condition-type-spec.component-ots* @var{ots}
Return a non--empty proper list of @class{object-type-spec} instances
representing the type specifications of the component
condition--objects.
@end defun

@c page
@node expander specs enum
@subsection Enumeration type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{enumeration-type-spec}
Name of type specifications for symbols enumerations.
@end deftp


@defun make-enumeration-type-spec @var{symbols}
Build and return a new instance of @class{enumeration-type-spec}.  The
argument @var{symbols} must be a non--empty proper list of symbols
representing the items in the enumeration.
@end defun


@defun enumeration-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{enumeration-type-spec}; otherwise return @false{}.
@end defun


@defun enumeration-type-spec.symbol* @var{ots}
Return a non--empty proper list of symbols representing the items in the
enumeration.
@end defun


@defun enumeration-type-spec.member? @var{ots} @var{sym}
Return @true{} if the symbol @var{sym} is a member of the enumeration
@var{ots}; otherwise return @false{}.
@end defun

@c page
@node expander specs hashtable
@subsection Hashtable type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{hashtable-type-spec}
Name of type specifications for hashtables.
@end deftp


@defun make-hashtable-type-spec @var{key-ots} @var{val-ots}
Build and return a new instance of @class{hashtable-type-spec}.  The
arguments @var{key-ots} and @var{val-ots} must be instances of
@class{object-type-spec} representing the type specifications of keys
and values, respectively.
@end defun


@defun hashtable-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{hashtable-type-spec}; otherwise return @false{}.
@end defun


@defun hashtable-type-spec.key-ots @var{ots}
@defunx hashtable-type-spec.val-ots @var{ots}
Return instances of @class{object-type-spec} representing the type
specifications of keys and values, respectively.
@end defun

@c page
@node expander specs alist
@subsection Association list type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{alist-type-spec}
Name of type specifications for association lists.
@end deftp


@defun make-alist-type-spec @var{key-ots} @var{val-ots}
Build and return a new instance of @class{alist-type-spec}.  The
arguments @var{key-ots} and @var{val-ots} must be instances of
@class{object-type-spec} representing the type specifications of keys
and values, respectively.
@end defun


@defun alist-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{alist-type-spec}; otherwise return @false{}.
@end defun


@defun alist-type-spec.key-ots @var{ots}
@defunx alist-type-spec.val-ots @var{ots}
Return instances of @class{object-type-spec} representing the type
specifications of keys and values, respectively.
@end defun

@c page
@node expander specs closure
@subsection Closure object type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{closure-type-spec}
Name of type specifications for closure objects.
@end deftp


@defun make-closure-type-spec @var{signature}
Build and return a new instance of @class{closure-type-spec}.  The
argument @var{signature} must be an instance of
@class{case-lambda-signature} representing the type signatures of the
closure's clauses.
@end defun


@defun closure-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{closure-type-spec}; otherwise return @false{}.
@end defun


@defun closure-type-spec.signature @var{des}
Return an instance of @class{case-lambda-signature} representing the
type signatures of the closure's clauses.
@end defun

@c page
@node expander specs union
@subsection Union type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{union-type-spec}
Name of type specifications for unions of type specifications.
@end deftp


@defun union-of-type-specs @varo{ots} @var{ots} @dots{}
Build and return a new instance of @class{object-type-spec} representing
the union between the given type specifications.  The returned value may
or may not be an instance of @class{union-type-spec}.
@end defun


@defun union-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of @class{union-type-spec};
otherwise return @false{}.
@end defun


@defun union-type-spec.item-ots* @var{ots}
Return a non--empty proper list of @class{object-type-spec} instances
representing the optional type specifications.
@end defun

@c page
@node expander specs intersection
@subsection Intersection type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{intersection-type-spec}
Name of type specifications for intersections of type specifications.
@end deftp


@defun intersection-of-type-specs @var{component-ots*}
Build and return a new instance of @class{object-type-spec} representing
the intersection between the given type specifications.  The returned
value may or may not be an instance of @class{intersection-type-spec}.

The argument @var{component-ots*} must be a non--empty proper list of
@class{object-type-spec} instances representing the type specifications.
@end defun


@defun intersection-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{intersection-type-spec}; otherwise return @false{}.
@end defun


@defun intersection-type-spec.item-ots* @var{ots}
Return a non--empty proper list of @class{object-type-spec} instances
representing the mandatory type specifications.
@end defun

@c page
@node expander specs complement
@subsection Complement type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{complement-type-spec}
Name of type specifications for the complement of a type specification.
@end deftp


@defun make-complement-type-spec @var{item-ots}
Build and return a new instance of @class{complement-type-spec}.  The
argument @var{item-ots} must be an instance of @class{object-type-spec}
representing the type specification to be complemented.
@end defun


@defun complement-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{complement-type-spec}; otherwise return @false{}.
@end defun


@defun complement-type-spec.item-ots @var{des}
Return an instance of @class{object-type-spec} representing the type
specification to be complemented.
@end defun

@c page
@node expander specs ancestor
@subsection Ancestor-of type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{ancestor-of-type-spec}
Name of type specifications representing the ancestors of a type
specification.
@end deftp


@defun make-ancestor-of-type-spec @var{ots}
Build and return a new instance of @class{ancestor-of-type-spec}.  The
argument @var{ots} must be an instance of @class{object-type-spec}
representing the type specification of which we want to describe the
ancestors.
@end defun


@defun ancestor-of-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{ancestor-of-type-spec}; otherwise return @false{}.
@end defun


@defun ancestor-of-type-spec.item-ots @var{ots}
Return the type specification of which @var{ots} describes the
ancestors.
@end defun


@defun ancestor-of-type-spec.ancestor-ots* @var{ots}
Return a list of type specifications representing the ancestors.  The
head of the list is the parent type specification.
@end defun

@c page
@node expander specs label
@subsection Label type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{label-type-spec}
Name of type specifications representing a label--type specification
@end deftp


@defun label-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of @class{label-type-spec};
otherwise return @false{}.
@end defun

@c page
@node expander specs interface
@subsection Interface type specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{interface-type-spec}
Name of type specifications representing interface type specifications.
@end deftp


@defun interface-type-spec? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{interface-type-spec}; otherwise return @false{}.
@end defun

@c page
@node expander specs signatures
@subsection Type specification signatures


@menu
* expander specs signatures type::         Type signatures.
* expander specs signatures lambda::       Lambda signature specifications.
* expander specs signatures case-lambda::  Case-lambda signature specifications.
@end menu

@c page
@node expander specs signatures type
@subsubsection Type signatures


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{type-signature}
Type name of objects representing the type of lambda formals.
@end deftp


@defun make-type-signature @var{specs}
Build and return a new instance of @class{type-signature}.  The argument
@var{specs} must be a proper or improper list of
@class{object-type-spec} instances representing the signatures of lambda
formals.
@end defun


@defun type-signature? @var{obj}
Return @true{} if @var{obj} is an instance of @class{type-signature};
otherwise return @false{}.
@end defun


@defun type-signature.object-type-specs @var{des}
Return a proper or improper list of @class{object-type-spec} instances
representing the signatures of lambda formals.
@end defun

@c page
@node expander specs signatures lambda
@subsubsection Lambda signature specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{lambda-signature}
Type name of objects representing the type signature of single lambda
clauses.
@end deftp


@defun make-lambda-signature @var{retvals} @var{argvals}
Build and return a new instance of @class{lambda-signature}.

The argument @var{retvals} must be an instance of @class{type-signature}
representing the types of values returned by this lambda clause.

The argument @var{argvals} must be an instance of @class{type-signature}
representing the types of arguments expected by this lambda clause.
@end defun


@defun lambda-signature? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{lambda-signature}; otherwise return @false{}.
@end defun


@defun lambda-signature.retvals @var{des}
Return an instance of @class{type-signature} representing the types of
values returned by this lambda clause.
@end defun


@defun lambda-signature.argvals @var{des}
Return an instance of @class{type-signature} representing the types of
arguments expected by this lambda clause.
@end defun

@c page
@node expander specs signatures case-lambda
@subsubsection Case-lambda signature specifications


The following syntactic bindings are exported by the library
@library{vicare expander}.


@deftp {Record Type} @aclass{case-lambda-signature}
Type name of objects representing the type signature of a tuple of
lambda clauses.
@end deftp


@defun make-case-lambda-signature @var{clause-signature*}
Build and return a new instance of @class{case-lambda-signature}.  The
argument @var{clause-signature*} must be a non--empty list of
@class{lambda-signature} representing the type specifications of the
single lambda clauses.
@end defun


@defun case-lambda-signature? @var{obj}
Return @true{} if @var{obj} is an instance of
@class{case-lambda-signature}; otherwise return @false{}.
@end defun


@defun case-lambda-signature.clause-signature* @var{des}
Return a non--empty list of @class{lambda-signature} representing the
type specifications of the single lambda clauses.
@end defun


@c Local Variables:
@c mode: texinfo
@c TeX-master: "vicare-scheme"
@c End:
