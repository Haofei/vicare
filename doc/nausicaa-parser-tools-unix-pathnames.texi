@node parser-tools unix-pathnames
@section Parsing Unix file system pathnames


@cindex @library{nausicaa parser-tools unix-pathnames}, library
@cindex Library @library{nausicaa parser-tools unix-pathnames}


The following bindings are exported by the library @library{nausicaa
parser-tools unix-pathnames}; when importing it, it is suggested to
prefix the bindings with @samp{pathnames.} as in:

@example
(import (nausicaa)
  (prefix (nausicaa parser-tools unix-pathnames) pathnames.))
@end example


@defun string/bytevector->pathname-bytevector @var{who} @var{obj}
Convert the string or bytevector @var{obj} to a bytevector
representation of a pathname; when successful return a bytevector, if an
error occurs raise an exception with compound condition object of types:
@condition{unix-pathname-parser-error}, @condition{who},
@condition{message}, @condition{irritants} using @var{who} as value for
the condition object of type @condition{who}.

When @var{obj} is a string: only characters whose Unicode code point is
in the range @math{[1, 255]} are accepted, notice that zero is excluded;
in this case a new bytevector is returned.

When @var{obj} is a bytevector: all the octets are accepted, with the
exception of the octet zero; in this case @var{obj} itself is returned.
@end defun


@defun pathname-bytevector->string @var{who} @var{obj}
Convert the bytevector pathname representation @var{obj} to a string
pathname representation; when successful return a string, if an error
occurs raise an exception with compound condition object of types:
@condition{unix-pathname-parser-error}, @condition{who},
@condition{message}, @condition{irritants} using @var{who} as value for
the condition object of type @condition{who}.

All the octets in the bytevector are considered valid, with the
exception of the octet zero.
@end defun


@defun parse-segment @var{port}
Accumulate bytes from @var{port} while they are valid for a
@code{segment} component; notice that an empty @code{segment} is valid.

If @eof{} or a slash character in @ascii{} coding is read: return a
possibly empty bytevector holding the bytes accumulated so far; the port
position is left pointing to the byte after the last accumulated one.

If an invalid byte is read: an exception is raised using
@func{raise-parser-error} from @library{nausicaa uri pathnames conditions};
the port position is rewind to the one before this function call.
@end defun


@defun parse-segment-nz @var{port}
Accumulate bytes from @var{port} while they are valid for a
@code{segment-nz} component; notice that an empty @code{segment-nz} is
not valid.

If the first read operation returns @eof{} or a slash character in
@ascii{} coding: the port position is restored to the one before this
function call and the return value is false.

If, after at least one valid byte is read, @eof{} or a slash is read:
return a bytevector holding the bytes accumulated so far; the port
position is left pointing to the byte after the last accumulated one.

If an invalid byte is read: an exception is raised using
@func{raise-parser-error} from @library{nausicaa uri pathnames conditions};
the port position is rewind to the one before this function call.
@end defun


@defun parse-slash-and-segment @var{port}
Attempt to read from @var{port} the sequence slash character plus
@code{segment} component; notice that an empty @code{segment} is valid.

If these components are successfully read: return a bytevector holding
the accumulated @code{segment} bytes; if the @code{segment} component is
empty: the returned bytevector is normalised to hold a single byte
representing a dot in @ascii{} coding.  The port position is left
pointing to the byte after the last accumulated byte from the
@code{segment}.

If @eof{} or a valid byte different from slash is read as first byte:
return false; the port position is rewind to the one before this
function call.

If an invalid byte is read: an exception is raised using
@func{raise-parser-error} from @library{nausicaa uri pathnames conditions};
the port position is rewind to the one before this function call.
@end defun


@defun parse-pathname @var{port}
Parse from @var{port} an absolute or relative pathname until @eof{} is
found; return two values: a boolean, true if the pathname is absolute;
false if @eof{} is the first byte read or a, possibly empty, list of
bytevectors representing the segments.  Empty @code{segment} components
are represented by bytevectors holding a single byte representing a dot
in @ascii{} coding.

If an invalid byte is read: an exception is raised using
@func{raise-parser-error} from @library{nausicaa uri pathnames conditions};
the port position is rewind to the one before this function call.
@end defun


@defun normalise-pathname @var{absolute?} @var{segments}
Given a list of bytevectors representing segments: normalise them, as
much as possible, removing segments representing single--dot and
double--dot directory entries; if @var{absolute?} is true: normalise
@var{segments} as an absolute pathname, else normalise it as a relative
pathname.  Return two values:

@enumerate
@item
A boolean, true if some change was made from @var{segments} to the
second returned value; this allows us to detect if a normalised list of
segments when serialised into a bytevector becomes different from the
original bytevector.

@item
When the normalisation succeeds: a new, possibly empty, list of
bytevectors representing the normalisation of @var{segments}.  Absolute
pathname segments can hold neither single--dot nor double--dot segments:
if a double--dot segment cannot be removed, this value is false (and the
first too).

Segments from the original @var{segments} argument are shared with this
returned value.
@end enumerate

Notice that empty input bytevectors are not handled specially: they
should be avoided, but no error is raised and they are @strong{not}
interpreted as equivalent to bytevectors holding a single byte
representing a dot in @ascii{} coding.
@end defun


@defun serialise-segments @var{absolute?} @var{segments}
Given a possibly empty list of bytevectors representing pathname
segments build and return a new bytevector representing the full
pathname; if @var{absolute?} is true: the first byte of the result
represents a slash in @ascii{} coding.

If @var{segments} is empty and @var{absolute?} is true: the returned
value is a bytevector holding a single byte representing a slash in
@ascii{} coding.

If @var{segments} is empty and @var{absolute?} is false: the returned
value is a bytevector holding a single byte representing a dot in
@ascii{} coding.
@end defun

