@node syslib
@chapter Low level, fast, unsafe operations


The bindings documented in this chapter are low level operations inlined
by the compiler; mostly they are defined in the source file
@file{pass-specify-rep-primops.ss}.

They are unsafe because when acting upon wrong arguments will cause
undefined behaviour (probably a crash).  They are also faster than the
public interface exported by @library{vicare} and @library{rnrs}.

@menu
* syslib booleans::             Low level boolean operations.
* syslib symbols::              Low level symbol operations.
* syslib keywords::             Low level keyword operations.
* syslib fixnums::              Low level fixnum operations.
* syslib bignums::              Low level bignum operations.
* syslib flonums::              Low level flonum operations.
* syslib ratnums::              Low level ratnum operations.
* syslib compnums::             Low level compnum operations.
* syslib cflonums::             Low level cflonum operations.
* syslib numerics::             Low level numerics operations.
* syslib chars::                Low level character operations.
* syslib pairs::                Low level pair operations.
* syslib lists::                Low level list operations.
* syslib structs::              System structure operations.
* syslib records::              Low level records operations.
* syslib vectors::              Low level vector operations.
* syslib bytevectors::          Low level bytevector operations.
* syslib strings::              Low level string operations.
* syslib ports::                Low level port structures.
* syslib transcoders::          Low level transcoder operations.
* syslib pointers::             Low level pointer operations.
* syslib hashtables::           Low level hashtable objects operations.
* syslib codes::                Low level code objects operations.
* syslib closures::             Low level closures operations.
* syslib compar::               Comparison procedures.
@end menu

@c page
@node syslib booleans
@section Low level boolean operations


@cindex @library{vicare system $booleans}, library
@cindex Library @library{vicare system $booleans}


The arguments @var{bool} must be booleans.  The following bindings are
exported by the library @library{vicare system booleans}.

@c ------------------------------------------------------------------------

@subsubheading Comparison

@defun {$boolean=} @vari{bool} @varii{bool}
Return @true{} if the arguments are equal; otherwise return @false{}.
@end defun


@defun {$boolean!=} @vari{bool} @varii{bool}
The arguments must be booleans.  Return @true{} if the arguments are
different; otherwise return @false{}.
@end defun


@deffn Procedure {$boolean<} @vari{bool} @varii{bool}
@deffnx Procedure {$boolean>} @vari{bool} @varii{bool}
@deffnx Procedure {$boolean<=} @vari{bool} @varii{bool}
@deffnx Procedure {$boolean>=} @vari{bool} @varii{bool}
Compare the boolean arguments according to the artificial comparison
definition:

@example
#t == #t
#f == #f
#f <  #t
@end example
@end deffn


@defun $boolean-min @vari{bool} @varii{bool}
@defunx $boolean-max @vari{bool} @varii{bool}
Return the minimal or maximal boolean among the arguments.
@end defun

@c page
@node syslib symbols
@section Low level symbol operations


@cindex @library{vicare system $symbols}, library
@cindex Library @library{vicare system $symbols}


The bindings documented in this section are exported by the library
@library{vicare system $symbols}.  For all the bindings: the arguments
@var{sym} must be references to symbol objects; the arguments @var{str}
must be references to string objects.

@menu
* syslib symbols accessors::    Symbol accessors and mutators.
* syslib symbols constructors:: Symbol constructors.
* syslib symbols comparison::   Comparison functions.
* syslib symbols conversion::   Conversion functions.
* syslib symbols plists::       Property lists.
* syslib symbols value::        Values associated to symbols.
* syslib symbols table::        The symbol table.
@end menu

@c page
@node syslib symbols accessors
@subsection Symbol accessors and mutators


@deffn {Unsafe Operation} $symbol-string @var{sym}
@deffnx {Unsafe Operation} $symbol-unique-string @var{sym}
Accessors for the fields of @var{sym}.
@end deffn


@deffn {Unsafe Operation} $set-symbol-string! @var{sym} @var{str}
@deffnx {Unsafe Operation} $set-symbol-unique-string! @var{sym} @var{str}
Mutators for the fields of @var{sym}.
@end deffn

@c page
@node syslib symbols constructors
@subsection Symbol constructors


@deffn {Unsafe Operation} $make-symbol @var{str}
Allocate a new symbol block and initialise the @code{string} field with
@var{str}; return the reference to the symbol block.

The @code{ustring} is initialised to the fixnum zero.  The @code{value}
and @code{proc} fields are initialised to a special machine word value
meaning ``unbound''.  The @code{plist} field is initialised to nil.
@end deffn

@c page
@node syslib symbols comparison
@subsection Comparison functions


@defun $symbol= @vari{sym} @varii{sym}
Return @true{} if the symbol arguments have equal pretty string name
according to @func{$string=}; otherwise return @false{}.
@end defun


@defun $symbol!= @vari{sym} @varii{sym}
The arguments must be symbols.  Return @true{} if the arguments are
different; otherwise return @false{}.
@end defun


@defun $symbol< @vari{sym} @varii{sym}
@defunx $symbol> @vari{sym} @varii{sym}
@defunx $symbol<= @vari{sym} @varii{sym}
@defunx $symbol>= @vari{sym} @varii{sym}
Return @true{} if the symbol arguments have pretty string names
satisfying, respectively: @func{$string<}, @func{$string>},
@func{$string<=}, @func{$string>=}; otherwise return @false{}.
@end defun


@defun $symbol-max @vari{sym} @varii{sym}
@defunx $symbol-min @vari{sym} @varii{sym}
Return the symbol argument having maximal or minimal pretty string name
according to @func{$string-max} and @func{string-min}.
@end defun

@c page
@node syslib symbols conversion
@subsection Conversion functions


@deffn {Unsafe Operation} $string->symbol @var{str}
Return an interned symbol having the string @var{str} as name.
@end deffn


@deffn {Unsafe Operation} $symbol->string @var{sym}
Return the string name of @var{sym}, generating one if needed.
@end deffn

@c page
@node syslib symbols plists
@subsection Property lists


@deffn {Unsafe Operation} $symbol-plist @var{sym}
@deffnx {Unsafe Operation} $set-symbol-plist! @var{sym} @var{ell}
Accessor and mutator for the field @code{plist} of symbol objects.
@end deffn


@deffn {Unsafe Operation} $putprop @var{symbol} @var{key} @var{value}
Add a new property @var{key} with @var{value} to the property list of
@var{symbol}.  @var{key} must be a symbol, @var{value} can be any value.

If @var{key} is already set: the old entry is mutated to reference the
new @var{value}.
@end deffn


@deffn {Unsafe Operation} $getprop @var{symbol} @var{key}
Return the value of the property @var{key} in the property list of
@var{symbol}; if @var{key} is not set return false.  @var{key} must be a
symbol.
@end deffn


@deffn {Unsafe Operation} $remprop @var{symbol} @var{key}
Remove property @var{key} from the list associated to @var{symbol}.
@end deffn


@deffn {Unsafe Operation} $property-list @var{symbol}
Return a new association list representing the property list of
@var{symbol}.  The order of the entries is the same as the property
creation order.
@end deffn

@c page
@node syslib symbols value
@subsection Values associated to symbols


@deffn {Unsafe Operation} $symbol-value @var{sym}
@deffnx {Unsafe Operation} $set-symbol-value! @var{sym} @var{val}
The @code{value} field has multiple purposes:

@itemize
@item
When @var{sym} is the unique identifier of a data structure type: the
@code{value} field holds the @rtd{} of the data structure.

@item
When @var{sym} is a label gensym associated to a syntactic binding
exported by the boot image: @code{value} holds the syntactic binding
descriptor.

@item
When @var{sym} is a label gensym associated to a syntactic binding
imported in the current lexical environment: @code{value} holds the
syntactic binding descriptor.

@item
When @var{sym} is a fresh symbol returned by a call to @func{gensym}: we
can use this field for any purpose we want.
@end itemize

Notice that this field is initialised to the unbound object, so we can
test the value of a newly created symbols with:

@example
($unbound-object? ($symbol-value? @var{sym}))
@end example
@end deffn


@deffn {Unsafe Operation} $unbound-object? @var{obj}
Return @true{} if @var{obj} is the special unbound machine word value,
otherwise return @false{}.
@end deffn


@deffn {Unsafe Operation} $symbol-proc @var{sym}
@deffnx {Unsafe Operation} $set-symbol-proc! @var{sym} @var{proc}
Accessor and mutator for the field @code{proc}.
@end deffn


@deffn {Unsafe Operation} $set-symbol-value/proc! @var{sym} @var{val}
Set both the fields @code{value} and @code{proc} of @var{sym} to
@var{val}.
@end deffn


@deffn {Unsafe Operation} $init-symbol-function! @var{sym} @var{proc}
Still to be documented.
@end deffn


@c page
@node syslib symbols table
@subsection The symbol table


The following bindings are related to the symbol table collecting
interned symbols.


@defun $symbol-table-size
Return the number of interned symbols.
@end defun


@defun $log-symbol-table-status
Write to the current error port a description of the current symbol
table status.  Example:

@example
vicare> (import (vicare system $symbols))
vicare> ($log-symbol-table-status)
Vicare internal symbol table status:
        number of interned symbols: 2962
        number of hash table buckets: 4096

vicare>
@end example
@end defun

@c page
@node syslib keywords
@section Low level keyword operations


@cindex @library{vicare system $keywords}, library
@cindex Library @library{vicare system $keywords}


The arguments @var{key} must be references to keyword objects, the
arguments @var{symb} must be references to symbol objects.  The
following bindings are exported by the library @library{vicare system
$keywords}.


@deffn {Unsafe Operation} $symbol->keyword @var{sym}
@deffnx {Unsafe Operation} $keyword->symbol @var{key}
Convert between a symbol and a keyword.
@end deffn


@deffn {Unsafe Operation} $keyword->string @var{key}
Return the string representation of a keyword.
@end deffn


@deffn {Unsafe Operation} $keyword=? @vari{key} @varii{key}
Return @true{} if the arguments are equal.  A keyword object is equal to
itself; two distinct keyword objects are equal if they have the same
symbol.
@end deffn


@deffn {Unsafe Operation} $keyword-hash @var{keyword}
Return an exact integer suitable to be used as hash value for
@var{keyword} used as key for hashtables.
@end deffn

@c page
@node syslib fixnums
@section Low level fixnum operations


@cindex @library{vicare system $fx}, library
@cindex Library @library{vicare system $fx}


The following bindings are exported by the library @library{vicare
system $fx}.  The arguments to these operations must be fixnums.
@ref{objects fixnums} for details on the representation of fixnums.

@c ------------------------------------------------------------

@subsubheading Predicates

@deffn {Unsafe Operation} $fxzero? @var{fx}
Evaluate to true if @var{fx} is zero.
@end deffn


@deffn {Unsafe Operation} $fxpositive? @var{fx}
@deffnx {Unsafe Operation} $fxnegative? @var{fx}
Evaluate to true if @var{fx} is strictly positive or strictly negative.
@end deffn


@deffn {Unsafe Operation} $fxnonpositive? @var{fx}
@deffnx {Unsafe Operation} $fxnonnegative? @var{fx}
Evaluate to true if @var{fx} is non--positive or non--negative.
@end deffn


@deffn {Unsafe Operation} $fxsign @var{fx}
Return one of the fixnums @code{+1}, @code{-1}, @code{0} representing
the sign of @var{fx}.
@end deffn


@deffn {Unsafe Operation} $fxeven? @var{fx}
@deffnx {Unsafe Operation} $fxodd? @var{fx}
Evaluate to true if @var{fx} is even or odd.
@end deffn

@c ------------------------------------------------------------

@subsubheading Comparison operations

@deffn {Unsafe Operation} $fx= @vari{fx} @varii{fx}
Evaluate to true if the arguments are equal.
@end deffn


@deffn {Unsafe Operation} $fx< @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is less than @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx<= @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is less than or equal to @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx> @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is greater than @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx>= @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is greater than or equal to @varii{fx}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Arithmetic operations

@deffn {Unsafe Operation} $fxadd1 @var{fx}
Increment the operand by one and return the result.
@end deffn


@deffn {Unsafe Operation} $fxsub1 @var{fx}
Decrement the operand by one and return the result.  The result of this
operation is a fixnum, but notice that if @var{fx} is
@code{(least-fixnum)}: the result overflows the fixnum capacity and the
return value is invalid.
@end deffn


@deffn {Unsafe Operation} $fx+ @vari{fx} @varii{fx}
Sum the operands and return the result.  The result of this operatio is
a fixnum, but notice that it could overflow the fixnum capacity.
@end deffn


@deffn {Unsafe Operation} $fx- @var{fx}
@deffnx {Unsafe Operation} $fx- @vari{fx} @varii{fx}
With one operand: return @var{fx} negated.  With two operands: subtract
the operands and return the result.  The result of this operation is a
fixnum, but notice that it could overflow the fixnum capacity and the
return value would be invalid.

Also with a single argument, knowing that @code{(- (least-fixnum))} is a
bignum, if @var{fx} is @code{(least-fixnum)} the result overflows the
fixnum capacity and the return value is invalid.

With two arguments: if @vari{fx} is zero and @varii{fx} is
@code{(least-fixnum)} the result overflows the fixnum capacity and the
return value is invalid.
@end deffn


@deffn {Unsafe Operation} $fx* @vari{fx} @varii{fx}
Multiply the operands and return the result.  The result of this
operation is a fixnum, but notice that if one operand is @code{-1} and
the other is @code{(least-fixnum)}: the result overflows the fixnum
capacity and the return value is invalid.
@end deffn


@deffn {Unsafe Operation} $fxdiv @vari{fx} @varii{fx}
@deffnx {Unsafe Operation} $fxdiv0 @vari{fx} @varii{fx}
@deffnx {Unsafe Operation} $fxmod @vari{fx} @varii{fx}
@deffnx {Unsafe Operation} $fxmod0 @vari{fx} @varii{fx}
@deffnx {Unsafe Operation} $fxdiv-and-mod  @vari{fx} @varii{fx}
@deffnx {Unsafe Operation} $fxdiv0-and-mod0 @vari{fx} @varii{fx}
Perform the number theoretic division.

@example
(import (rnrs)
  (vicare system $fx))

($fxmod +12 +12)        @result{} 0
($fxmod +12 -12)        @result{} 0
($fxmod -12 +12)        @result{} 0
($fxmod -12 -12)        @result{} 0

($fxmod +12 +3)         @result{} 0
($fxmod +12 -3)         @result{} 0
($fxmod -12 +3)         @result{} 0
($fxmod -12 -3)         @result{} 0

($fxmod +12 +4)         @result{} 0
($fxmod +12 -4)         @result{} 0
($fxmod -12 +4)         @result{} 0
($fxmod -12 -4)         @result{} 0

($fxmod +12 +5)         @result{} +2
($fxmod +12 -5)         @result{} +2
($fxmod -12 +5)         @result{} +3
($fxmod -12 -5)         @result{} +3

($fxmod +12 +7)         @result{} +5
($fxmod +12 -7)         @result{} +5
($fxmod -12 +7)         @result{} +2
($fxmod -12 -7)         @result{} +2

($fxmod +12 +24)        @result{} +12
($fxmod +12 -24)        @result{} +12
($fxmod -12 +24)        @result{} +12
($fxmod -12 -24)        @result{} +12

($fxmod +12 +20)        @result{} +12
($fxmod +12 -20)        @result{} +12
($fxmod -12 +20)        @result{} +8
($fxmod -12 -20)        @result{} +8
@end example
@end deffn


@deffn {Unsafe Operation} $fxquotient @vari{fx} @varii{fx}
Compute the quotient between the operands and return the result.  The
result of this operation is a fixnum, but notice that:

@itemize
@item
When @varii{fx} is @code{0}: the result is undefined, most likely the
process will abort.

@item
When @vari{fx} is @code{(least-fixnum)} and @varii{fx} is @code{-1}: the
result will overflow the fixnum capacity, and the return value will be
invalid (the result should be a bignum).
@end itemize
@end deffn


@deffn {Unsafe Operation} $fxmodulo @vari{fx} @varii{fx}
Compute the modulo between the operands and return the result.  The
result of this operation can be a fixnum or bignum.

@example
(import (rnrs)
  (vicare system $fx))

($fxmodulo +12 +12)     @result{} 0
($fxmodulo +12 -12)     @result{} 0
($fxmodulo -12 +12)     @result{} 0
($fxmodulo -12 -12)     @result{} 0

($fxmodulo +12 +3)      @result{} 0
($fxmodulo +12 -3)      @result{} 0
($fxmodulo -12 +3)      @result{} 0
($fxmodulo -12 -3)      @result{} 0

($fxmodulo +12 +4)      @result{} 0
($fxmodulo +12 -4)      @result{} 0
($fxmodulo -12 +4)      @result{} 0
($fxmodulo -12 -4)      @result{} 0

($fxmodulo +12 +5)      @result{} +2
($fxmodulo +12 -5)      @result{} -3
($fxmodulo -12 +5)      @result{} +3
($fxmodulo -12 -5)      @result{} -2

($fxmodulo +12 +7)      @result{} +5
($fxmodulo +12 -7)      @result{} -2
($fxmodulo -12 +7)      @result{} +2
($fxmodulo -12 -7)      @result{} -5

($fxmodulo +12 +24)     @result{} +12
($fxmodulo +12 -24)     @result{} -12
($fxmodulo -12 +24)     @result{} +12
($fxmodulo -12 -24)     @result{} -12

($fxmodulo +12 +20)     @result{} +12
($fxmodulo +12 -20)     @result{}  -8
($fxmodulo -12 +20)     @result{}  +8
($fxmodulo -12 -20)     @result{} -12
@end example
@end deffn


@deffn {Unsafe Operation} $fxabs @var{fx}
Return the absolute value of @var{fx} as a fixnum.  When @var{fx} is
@code{(least-fixnum)}: its absolute value would be a fixnum, in which
case this operation raises an implementation restriction violation.

To compute the general absolute value without overflow we must use
@func{abs} or @func{$abs-fixnum}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bitwise logic operations

@deffn {Unsafe Operation} $fxlognot @var{fx}
Perform the bitwise NOT on the operand and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogand @vari{fx} @varii{fx}
Perform the bitwise AND on the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogor @vari{fx} @varii{fx}
Perform the bitwise inclusive OR on the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogxor @vari{fx} @varii{fx}
Perform the bitwise exclusive OR on the operands and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Other bitwise operations

@deffn {Unsafe Operation} $fxsll @vari{fx} @varii{fx}
Perform bitwise shift left of @vari{fx} by @varii{fx} positions and
return the result.
@end deffn


@deffn {Unsafe Operation} $fxsra @vari{fx} @varii{fx}
Perform bitwise shift right of @vari{fx} by @varii{fx} positions and
return the result.
@end deffn


@deffn {Unsafe Operation} $fxcopy-bit @vari{fx} @varii{fx} @variii{fx}
Unsafe version of @func{fxcopy-bit}.
@end deffn


@deffn {Unsafe Operation} $fxcopy-bit-field @vari{fx} @varii{fx} @variii{fx} @variv{fx}
Unsafe version of @func{fxcopy-bit-field}.
@end deffn


@deffn {Unsafe Operation} $fxrotate-bit-field @vari{fx} @varii{fx} @variii{fx} @variv{fx}
Unsafe version of @func{fxrotate-bit-field}.
@end deffn


@deffn {Unsafe Operation} $fxbit-field @vari{fx} @varii{fx} @variii{fx}
Unsafe version of @func{fxbit-field}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Conversion operations


@deffn {Unsafe Operation} $fixnum->string @var{fx} @var{base}
Return a string object representing @var{fx} in @var{base}.  @var{base}
must be one among: @math{2}, @math{8}, @math{10}, @math{16}.
@end deffn


@deffn {Unsafe Operation} $fixnum->char @var{fx}
Return a new character value whose code point equals @var{fx}.
@end deffn


@deffn {Unsafe Operation} $char->fixnum @var{ch}
Return a fixnum representing the code point of the operand.
@end deffn


@deffn {Unsafe Operation} $fixnum->flonum @var{fx}
Convert the fixnum operand into a flonum and return a reference to the
result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Miscellaneous operations

@deffn {Unsafe Operation} $fxinthash @var{fx}
Evaluate to a fixnum which can be used as hash value.

@quotation
@strong{NOTE}  This appears to be unused in the source.
@end quotation
@end deffn

@c page
@node syslib bignums
@section Low level bignum operations


@cindex @library{vicare system $bignums}, library
@cindex Library @library{vicare system $bignums}


The arguments @var{bn} to these operations must be bignums.  The
following bindings are exported by the library @library{vicare system
$bignums}.  @ref{iklib numerics} for more functions acting on bignums.


@deffn {Unsafe Operation} $bignum-positive? @var{bn}
@deffnx {Unsafe Operation} $bignum-negative? @var{bn}
Evaluate to true if the operand is positive or negative.
@end deffn


@deffn {Unsafe Operation} $bignum-non-positive? @var{bn}
@deffnx {Unsafe Operation} $bignum-non-negative? @var{bn}
Evaluate to true if the operand is non--positive or non--negative.
@end deffn


@deffn {Unsafe Operation} $bignum-even? @var{bn}
@deffnx {Unsafe Operation} $bignum-odd? @var{bn}
Evaluate to true if the operand is even or odd.
@end deffn


@deffn {Unsafe Operation} $bignum-byte-ref @var{bn} @var{fx}
Return a fixnum representing the byte at index @var{fx} in the data of
@var{bn}.
@end deffn


@deffn {Unsafe Operation} $bignum-size @var{bn}
Return a fixnum representing the number of machine words in the data
portion of a bignum memory block.
@end deffn


@deffn {Unsafe Operation} $bignum->flonum @var{bn}
Return a flonum object representing @var{bn} as inexact number.
@end deffn

@c page
@node syslib flonums
@section Low level flonum operations


@cindex @library{vicare system $flonums}, library
@cindex Library @library{vicare system $flonums}


For all the low level operations, the arguments @var{fl} to these
operations must be flonums, the arguments @var{fx} must be fixnums.  The
bindings documented here are exported by the library @library{vicare
system $flonums}.  @ref{iklib numerics} for more functions acting on
flonums.

@menu
* syslib flonums constr::       Flonum constructors.
* syslib flonums inspect::      Binary representation inspection.
* syslib flonums arithmetic::   Arithmetic operations.
* syslib flonums conversion::   Exactness and conversion.
* syslib flonums predicates::   Predicates.
* syslib flonums comparison::   Comparison functions.
* syslib flonums rounding::     Rounding function.
* syslib flonums parts::        Parts function.
* syslib flonums trigon::       Trigonometric operations.
* syslib flonums hyperbol::     Hyperbolic functions.
* syslib flonums log::          Exponentials and logarithms.
* syslib flonums power::        Power operations.
@end menu

@c page
@node syslib flonums constr
@subsection Flonum constructors


@deffn {Unsafe Operation} $make-flonum
Allocate a new flonum memory block and return a reference to it.  Does
not initialise the data area.
@end deffn

@c page
@node syslib flonums inspect
@subsection Binary representation inspection


@deffn {Unsafe Operation} $flonum-u8-ref @var{fl} @var{fx}
Return the octet at index @var{fx} in the data area of @var{fl}.

Notice that the @var{fx} offset is positive, but it represents an offset
from the end of the data area; on a 32-bit platform, the indexes of the
bytes are:

@example
   1st word    2nd word    3rd word    4th word
|-----------|-----------|-----------|-----------|
                        |--|--|--|--|--|--|--|--| bytes
                          7  6  5  4  3  2  1  0  offsets
                        |.......................|
                             IEEE 754 flonum
@end example
@end deffn


@deffn {Unsafe Operation} $flonum-set! @var{fl} @var{fx-index} @var{fx-value}
Store the byte or octet represented by @var{fx-value} at index
@var{fx-index} in the data area of @var{fl}.
@end deffn


@deffn {Unsafe Operation} $flonum-sbe @var{fl}
Return a fixnum@dots{} Still undocumented, read the code look at the
format of @ieee{} double precision flonums.
@end deffn

@c page
@node syslib flonums arithmetic
@subsection Arithmetic operations


@deffn {Unsafe Operation} $fl+ @vari{fl} @varii{fl} @var{fl} @dots{}
@deffnx {Unsafe Operation} $fl* @vari{fl} @varii{fl} @var{fl} @dots{}
@deffnx {Unsafe Operation} $fl/ @vari{fl} @varii{fl} @var{fl} @dots{}
Perform arithmetic operations.
@end deffn


@deffn {Unsafe Operation} $fl- @var{fl}
@deffnx {Unsafe Operation} $fl- @vari{fl} @varii{fl} @var{fl} @dots{}
With one operand: return @var{fl} negated.  With two operands: subtract
the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fldiv @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $flmod @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fldiv0 @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $flmod0 @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fldiv-and-mod @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fldiv0-and-mod0 @vari{fl} @varii{fl}
Implement the number--theoretic integer divisions.
@end deffn

@c page
@node syslib flonums conversion
@subsection Exactness and conversion


@deffn {Unsafe Operation} $flonum->exact @var{fl}
Rationalize the operand and return the result.
@end deffn


@deffn {Unsafe Operation} $fixnum->flonum @var{fx}
Convert the fixnum operand into a flonum and return a reference to the
result.
@end deffn

@c page
@node syslib flonums predicates
@subsection Predicates


@deffn {Unsafe Operation} $flnan? @var{fl}
Return @true{} if the operand is a representation of not--a--number;
otherwise return @false{}.
@end deffn


@deffn {Unsafe Operation} $flinfinite? @var{fl}
Return @true{} if the operand is a representation of infinity:
@code{+inf.0} or @code{-inf.0}; otherwise return @false{}.
@end deffn


@deffn {Unsafe Operation} $flzero? @var{fl}
Return true if the operand is zero.  Notice that the return value will
be true for both @code{+0.0} or @code{-0.0}.
@end deffn


@deffn {Unsafe Operation} $flzero?/positive @var{fl}
@deffnx {Unsafe Operation} $flzero?/negative @var{fl}
Return true if the operand is @code{+0.0} or @code{-0.0}, respectively.
@end deffn


@deffn {Unsafe Operation} $flpositive? @var{fl}
Return true if the operand is strictly positive.  This predicate fails
when applied to @code{+0.0}; to check for positivity including
@code{+0.0} we must use:

@example
(or ($flzero?/positive @var{fl}) ($fl> @var{fl} +0.0))
@end example
@end deffn


@deffn {Unsafe Operation} $flnegative? @var{fl}
Return true if the operand is strictly negative.  This predicate fails
when applied to @code{-0.0}; to check for negativity including
@code{-0.0} we must use:

@example
(or ($flzero?/negative @var{fl}) ($fl< @var{fl} -0.0))
@end example
@end deffn


@deffn {Unsafe Operation} $flnonpositive? @var{fl}
Return @true{} if the operand is non--positive.  This predicate returns
@false{} when applied to @code{-0.0}.
@end deffn


@deffn {Unsafe Operation} $flnonnegative? @var{fl}
Return @true{} if the operand is non--negative.  This predicate returns
@false{} when applied to @code{+0.0}.
@end deffn


@deffn {Unsafe Operation} $fleven? @var{fl}
Return true if the operand is even.
@end deffn


@deffn {Unsafe Operation} $flodd? @var{fl}
Return true if the operand is odd.
@end deffn


@deffn {Unsafe Operation} $flonum-integer? @var{fl}
Return true if the operand is integer.
@end deffn


@deffn {Unsafe Operation} $flonum-rational? @var{fl}
Return true if the operand is rational.  All the flonums are rational
with the exception of infinities and not--a--number.
@end deffn

@c page
@node syslib flonums comparison
@subsection Comparison functions


@deffn {Unsafe Operation} $fl= @vari{fl} @varii{fl} @var{fl} @dots{}
@deffnx {Unsafe Operation} $fl< @vari{fl} @varii{fl} @var{fl} @dots{}
@deffnx {Unsafe Operation} $fl<= @vari{fl} @varii{fl} @var{fl} @dots{}
@deffnx {Unsafe Operation} $fl> @vari{fl} @varii{fl} @var{fl} @dots{}
@deffnx {Unsafe Operation} $fl>= @vari{fl} @varii{fl} @var{fl} @dots{}
Perform comparison operations.
@end deffn


@deffn {Unsafe Operation} $fl!= @vari{fl} @varii{fl} @var{fl} @dots{}
The arguments must be flonums.  Return @true{} if the arguments are all
different: no two arguments are equal; otherwise return @false{}.  When
applied to a single argument: return @false{}.  This operation does
@strong{not} distinguish between @code{+0.0} and @code{-0.0}.
@end deffn


@deffn {Unsafe Operation} $flmax @vari{fl} @varii{fl} . @var{fl}
Return the maximum between the operands.
@end deffn


@deffn {Unsafe Operation} $flmin @vari{fl} @varii{fl} . @var{fl}
Return the minimum between the operands.
@end deffn

@c page
@node syslib flonums rounding
@subsection Rounding function


@deffn {Unsafe Operation} $flround @var{fl}
Return the closest integral flonum to the operand, rounding to even when
@var{fl} represents a number halfway between two integers.
@end deffn


@deffn {Unsafe Operation} $flfloor @var{fl}
Return the largest integral flonum not larger than the operand.
@end deffn


@deffn {Unsafe Operation} $flceiling @var{fl}
Return the smallest integral flonum not larger than the operand.
@end deffn


@deffn {Unsafe Operation} $fltruncate @var{fl}
Return the integral flonum closest to the operand whose absolute value
is not larger than the absolute value of the operand itself.
@end deffn

@c page
@node syslib flonums parts
@subsection Parts function


@deffn {Unsafe Operation} $flnumerator @var{fl}
@deffnx {Unsafe Operation} $fldenominator @var{fl}
Return the numerator or denominator of the operand.
@end deffn


@deffn {Unsafe Operation} $flabs @var{fl}
Return the absolute value of the operand.
@end deffn

@c page
@node syslib flonums trigon
@subsection Trigonometric operations



@deffn {Unsafe Operation} $flsin @var{fl}
@deffnx {Unsafe Operation} $flcos @var{fl}
@deffnx {Unsafe Operation} $fltan @var{fl}
Return the sine, cosine and tangent of the operand.
@end deffn


@deffn {Unsafe Operation} $flasin @var{fl}
@deffnx {Unsafe Operation} $flacos @var{fl}
@deffnx {Unsafe Operation} $flatan @var{fl}
@deffnx {Unsafe Operation} $flatan @vari{fl} @varii{fl}
Return the arcsine, arccosine and arctangent of the operand.  When
@func{$flatan} is applied to two arguments, it returns an equivalent of:

@example
(angle (make-rectangular @varii{fl} @vari{fl}))
@end example
@end deffn


@deffn {Unsafe Operation} $flatan2 @vari{fl} @varii{fl}
Return an equivalent of:

@example
(angle (make-rectangular @varii{fl} @vari{fl}))
@end example
@end deffn

@c page
@node syslib flonums hyperbol
@subsection Hyperbolic functions


@defun $flsinh @var{fl}
@defunx $flcosh @var{fl}
@defunx $fltanh @var{fl}
Compute the hyperbolic functions.  Return flonum objects.
@end defun


@defun $flasinh @var{fl}
@defunx $flacosh @var{fl}
@defunx $flatanh @var{fl}
Compute the inverse hyperbolic functions.  Return flonum objects.
@end defun

@c page
@node syslib flonums log
@subsection Exponentials and logarithms


@deffn {Unsafe Operation} $flcbrt @var{fl}
Return the real cube root function of @var{fl}.
@end deffn


@deffn {Unsafe Operation} $flexp @var{fl}
Return the base @math{e} exponential of the operand.
@end deffn


@deffn {Unsafe Operation} $fllog @var{fl}
@deffnx {Unsafe Operation} $fllog @vari{fl} @varii{fl}
When applied to one argument: return the natural logarithm of the
operand.  For non--negative @var{fl} the return value is a numeric
flonum; for negative @var{fl} the return value is not--a--number.  See
also @func{$log-flonum} to compute the logarithm of negative flonums as
a complex number.

When applied to two arguments: return the base--@varii{fl} logarithm of
@vari{fl}.
@end deffn


@deffn {Unsafe Operation} $fllog2 @vari{fl} @varii{fl}
Return the base--@varii{fl} logarithm of @vari{fl}.
@end deffn


@deffn {Unsafe Operation} $flexpm1 @var{fl}
Return an equivalent of @math{exp(@var{fl}) - 1}.
@end deffn


@deffn {Unsafe Operation} $fllog1p @var{fl}
Return an equivalent of @math{log(1 + @var{fl})}.
@end deffn


@deffn {Unsafe Operation} $flhypot @vari{fl} @varii{fl}
Compute the Euclidean distance function: @math{\sqrt(X*X+Y*Y)}.
@glibcref{Exponents and Logarithms, hypot}.
@end deffn

@c page
@node syslib flonums power
@subsection Power operations


@deffn {Unsafe Operation} $flexpt @vari{fl} @varii{fl}
Return @vari{fl} raised to the power of @varii{fl}.
@end deffn


@deffn {Unsafe Operation} $flsqrt @var{fl}
Return the square root of the operand.
@end deffn


@deffn {Unsafe Operation} $flsquare @var{fl}
Return the square of @var{fl}: @var{fl} times @var{fl}.
@end deffn


@deffn {Unsafe Operation} $flcube @var{fl}
Return the cube of @var{fl}: @var{fl} times @var{fl} times @var{fl}.
@end deffn

@c page
@node syslib ratnums
@section Low level ratnum operations


@cindex @library{vicare system $ratnums}, library
@cindex Library @library{vicare system $ratnums}


The arguments @var{rat} to these operations must be ratnums, the
arguments @var{num} and @var{den} must be references to either fixnums
or bignums.  The following bindings are exported by the library
@library{vicare system $ratnums}.  @ref{iklib numerics} for more
functions acting on ratnums.


@deffn {Unsafe Operation} $make-ratnum @var{num} @var{den}
Allocate a new ratnum memory block, store @var{num} as reference to the
numerator and @var{den} as reference to the denominator; return a
reference to the ratnum.

The following conditions must be met, else the returned value will be
invalid:

@itemize
@item
@var{num} and @var{den} must be exact integers.

@item
@var{num} and @var{den} must be non--zero.

@item
@var{den} must be strictly positive.

@item
@var{num} and @var{den} must have greatest common divisor equal to
@code{1} (that is: they cannot be simplified).
@end itemize
@end deffn


@deffn {Unsafe Operation} $ratnum-n @var{rat}
@deffnx {Unsafe Operation} $ratnum-num @var{rat}
Return the reference to the numerator.
@end deffn


@deffn {Unsafe Operation} $ratnum-d @var{rat}
@deffnx {Unsafe Operation} $ratnum-den @var{rat}
Return the reference to the denominator.
@end deffn


@deffn {Unsafe Operation} $ratnum->flonum @var{rat}
Return a flonum object representing @var{rat} as inexact number.
@end deffn


@deffn {Unsafe Operation} $ratnum-positive? @var{rat}
@deffnx {Unsafe Operation} $ratnum-negative? @var{rat}
Return @true{} if @var{rat} is, respectively, positive or negative;
otherwise return @false{}.
@end deffn


@deffn {Unsafe Operation} $ratnum-non-positive? @var{rat}
@deffnx {Unsafe Operation} $ratnum-non-negative? @var{rat}
Return @true{} if @var{rat} is, respectively, non--positive or
non--negative; otherwise return @false{}.
@end deffn

@c page
@node syslib compnums
@section Low level compnum operations


@cindex @library{vicare system $compnums}, library
@cindex Library @library{vicare system $compnums}


The arguments @var{cn} to these operations must be compnums, the
arguments @var{num} must be references to either fixnums, bignums or
flonums.  The following bindings are exported by the library
@library{vicare system $compnums}.  @ref{iklib numerics} for more
functions acting on compnums.


@deffn {Unsafe Operation} $make-compnum @vari{num} @varii{num}
Allocate a new compnum memory block, store @vari{num} as reference to
the real part and @varii{num} as reference to the imaginary part.
Return a reference to the compnum.
@end deffn


@deffn {Unsafe Operation} $make-rectangular @var{rep} @var{imp}
Return a real numebr, a new compnum or a new cflonum; @var{rep} and
@var{imp} can be any combination of real numbers.  If @var{imp} is exact
zero: the returned value is @var{rep}, a real.
@end deffn


@deffn {Unsafe Operation} $compnum-real @var{cn}
Return the reference to the real part.
@end deffn


@deffn {Unsafe Operation} $compnum-imag @var{cn}
Return the reference to the imaginary part.
@end deffn


@deffn {Unsafe Operation} $compnum->cflonum @var{cn}
Return the inexact representation of a compnum as a cflonum.
@end deffn

@c page
@node syslib cflonums
@section Low level cflonum operations


@cindex @library{vicare system $compnums}, library
@cindex Library @library{vicare system $compnums}


The arguments @var{cmp} to these operations must be cflonums, the
arguments @var{fl} must be references to flonums.  The following
bindings are exported by the library @library{vicare system $compnums}.
@ref{iklib numerics} for more functions acting on cflonums.


@deffn {Unsafe Operation} $make-cflonum @vari{fl} @varii{fl}
Allocate a new cflonum memory block, store @vari{fl} as reference to the
real part and @varii{fl} as reference to the imaginary part.  Return a
reference to the cflonum.
@end deffn


@deffn {Unsafe Operation} $cflonum-real @var{cmp}
Return the reference to the real part.
@end deffn


@deffn {Unsafe Operation} $cflonum-imag @var{cmp}
Return the reference to the imaginary part.
@end deffn

@c page
@node syslib numerics
@section Low level numerics operations


@cindex @library{vicare system $numerics}, library
@cindex Library @library{vicare system $numerics}


The library @library{vicare system $numerics} export bindings for low
level operations on numbers.

@menu
* syslib numerics neg::         Numbers negation.
* syslib numerics inv::         Numbers inversion.
* syslib numerics add1::        Exact integers increment.
* syslib numerics sub1::        Exact integers decrement.
* syslib numerics add::         Numbers addition.
* syslib numerics sub::         Numbers subtraction.
* syslib numerics mul::         Numbers multiplication.
* syslib numerics div::         Numbers division.
* syslib numerics square::      Squaring of numbers.
* syslib numerics cube::        Cube of numbers.
* syslib numerics gcd::         Greatest common divisor.
* syslib numerics lcm::         Least common multiple.
* syslib numerics quorem::      Quotient and remainder.
* syslib numerics quotient::    Quotient between numbers.
* syslib numerics remainder::   Remainder between numbers.
* syslib numerics modulo::      Modulo between numbers.
* syslib numerics max::         Maximum between numbers.
* syslib numerics min::         Minimum between numbers.
* syslib numerics abs::         Absolute value of real numbers.
* syslib numerics sign::        Sign of real numbers.
* syslib numerics numerator::   Numerator of real numbers.
* syslib numerics denominator:: Denominator of real numbers.
* syslib numerics exact::       Conversion to exact number.
* syslib numerics inexact::     Conversion to inexact number.
* syslib numerics expt::        Raising numbers to power.
* syslib numerics sqrt::        Square root of numbers.
* syslib numerics cbrt::        Cubic root of numbers.
* syslib numerics log::         Logarithms of numbers.
* syslib numerics exp::         Exponentials of numbers.
* syslib numerics sin::         Trigonometric sine.
* syslib numerics cos::         Trigonometric cosine.
* syslib numerics tan::         Trigonometric tangent.
* syslib numerics asin::        Trigonometric arc sine.
* syslib numerics acos::        Trigonometric arc cosine.
* syslib numerics atan::        Trigonometric arc tangent.
* syslib numerics sinh::        Hyperbolic sine.
* syslib numerics cosh::        Hyperbolic cosine.
* syslib numerics tanh::        Hyperbolic tangent.
* syslib numerics asinh::       Hyperbolic arc sine.
* syslib numerics acosh::       Hyperbolic arc cosine.
* syslib numerics atanh::       Hyperbolic arc tangent.
* syslib numerics conjugate::   Complex conjugate.
* syslib numerics magnitude::   Magnitude of complex numbers.
* syslib numerics angle::       Angle of complex numbers.
* syslib numerics bitnot::      Bitwise logic not.
* syslib numerics bitand::      Bitwise logic and.
* syslib numerics bitior::      Bitwise logic inclusive or.
* syslib numerics bitxor::      Bitwise logic exclusive or.
* syslib numerics floor::       Floor rounding.
* syslib numerics ceiling::     Ceiling rounding.
* syslib numerics truncate::    Truncate rounding.
* syslib numerics round::       Round rounding.
@end menu

@c page
@node syslib numerics neg
@subsection Negation negation


@deffn {Unsafe Operation} $neg-number @var{num}
Negate any number object and return the result.
@end deffn


@deffn {Unsafe Operation} $neg-fixnum @var{fx}
Negate a fixnum; return a fixnum or a bignum, the latter when @var{fx}
is @code{(least-fixnum)}.
@end deffn


@deffn {Unsafe Operation} $neg-bignum @var{bn}
Negate a bignum; return a bignum or a fixnum, the latter when @var{bn}
is equal to @code{(- (least-fixnum))}.
@end deffn


@deffn {Unsafe Operation} $neg-flonum @var{fl}
Negate a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $neg-ratnum @var{rt}
Negate a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $neg-compnum @var{cn}
Negate a compnum and return the result as a compunm.
@end deffn


@deffn {Unsafe Operation} $neg-cflonum @var{cfl}
Negate a cflonum and return the result as cflonum.
@end deffn

@c page
@node syslib numerics inv
@subsection Numbers inversion


If the operand is zero: the following operations raise an exception.


@deffn {Unsafe Operation} $inv-number @var{num}
Compute the inverse of any number object and return the result.
@end deffn


@deffn {Unsafe Operation} $inv-fixnum @var{fx}
Compute the inverse of a fixnum and return the result as a fixnum or
ratnum.  A fixnum is returned if @var{fx} is @code{+1} or @code{-1}.
@end deffn


@deffn {Unsafe Operation} $inv-bignum @var{bn}
Compute the inverse of a bignum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $inv-flonum @var{fl}
Compute the inverse of a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $inv-ratnum @var{rt}
Compute the inverse of a ratnum and return the result as a fixnum,
bignum or ratnum.  A fixnum or bignum is returned when the numerator of
@var{rt} is @code{+1} or @code{-1}.
@end deffn


@deffn {Unsafe Operation} $inv-compnum @var{cn}
Compute the inverse of a compnum and return the result as a compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $inv-cflonum @var{cfl}
Compute the inverse of a cflonum and return the result as a cflonum.
@end deffn

@c page
@node syslib numerics add1
@subsection Exact integers increment


@deffn {Unsafe Operation} $add1-integer @var{N}
Increment by @math{1} the fixnum or bignum @var{N} and return the
result.
@end deffn


@deffn {Unsafe Operation} $add1-bignum @var{N}
Increment by @math{1} the bignum @var{N} and return the result.
@end deffn


@deffn {Unsafe Operation} $add1-fixnum @var{N}
Increment by @math{1} the fixnum @var{N} and return the result.
@end deffn

@c page
@node syslib numerics sub1
@subsection Exact integers decrement


@deffn {Unsafe Operation} $sub1-integer @var{N}
Decrement by @math{1} the fixnum or bignum @var{N} and return the
result.
@end deffn


@deffn {Unsafe Operation} $sub1-bignum @var{N}
Decrement by @math{1} the bignum @var{N} and return the result.
@end deffn


@deffn {Unsafe Operation} $sub1-fixnum @var{N}
Decrement by @math{1} the fixnum @var{N} and return the result.
@end deffn

@c page
@node syslib numerics add
@subsection Numbers addition


@deffn {Unsafe Operation} $add-number-number @vari{num} @varii{num}
Add any couple of numbers and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as second operand


@deffn {Unsafe Operation} $add-fixnum-number @var{fx} @var{num}
Add a fixnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $add-bignum-number @var{bn} @var{num}
Add a bignum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $add-flonum-number @var{fl} @var{num}
Add a flonum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-number @var{rt} @var{num}
Add a ratnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $add-compnum-number @var{cn} @var{num}
Add a compnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-number @var{cfl} @var{num}
Add a cflonum with a number and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as first operand


@deffn {Unsafe Operation} $add-number-fixnum @var{num} @var{fx}
Add any number with a fixnum and return the result.
@end deffn


@deffn {Unsafe Operation} $add-number-bignum @var{num} @var{bn}
Add any number with a bignum and return the result.
@end deffn


@deffn {Unsafe Operation} $add-number-flonum @var{num} @var{fl}
Add any number with a flonum and return the result.
@end deffn


@deffn {Unsafe Operation} $add-number-ratnum @var{num} @var{rt}
Add any number with a ratnum and return the result.
@end deffn


@deffn {Unsafe Operation} $add-number-compnum @var{num} @var{cn}
Add any number with a compnum and return the result.
@end deffn


@deffn {Unsafe Operation} $add-number-cflonum @var{num} @var{cfl}
Add any number with a cflonum and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first operand


@deffn {Unsafe Operation} $add-fixnum-fixnum @vari{fx} @varii{fx}
Add a fixnum with a fixnum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $add-fixnum-bignum @var{fx} @var{bn}
Add a fixnum with a bignum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $add-fixnum-flonum @var{fx} @var{fl}
Add a fixnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-fixnum-ratnum @var{fx} @var{rt}
Add a fixnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $add-fixnum-compnum @var{fx} @var{cn}
Add a fixnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-fixnum-cflonum @var{fx} @var{cfl}
Add a fixnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first operand


@deffn {Unsafe Operation} $add-bignum-fixnum @var{bn} @var{fx}
Add a bignum with a fixnum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $add-bignum-bignum @vari{bn} @varii{bn}
Add a bignum with a bignum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $add-bignum-flonum @var{bn} @var{fl}
Add a bignum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-bignum-ratnum @var{bn} @var{rt}
Add a bignum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $add-bignum-compnum @var{bn} @var{cn}
Add a bignum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-bignum-cflonum @var{bn} @var{cfl}
Add a bignum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first operand


@deffn {Unsafe Operation} $add-flonum-fixnum @var{fl} @var{fx}
Add a flonum with a fixnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-flonum-bignum @var{fl} @var{bn}
Add a flonum with a bignum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-flonum-flonum @vari{fl} @varii{fl}
Add a flonum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-flonum-ratnum @var{fl} @var{rt}
Add a flonum with a ratnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-flonum-compnum @var{fl} @var{cn}
Add a flonum with a compnum and return the result as a compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $add-flonum-cflonum @var{fl} @var{cfl}
Add a flonum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first operand


@deffn {Unsafe Operation} $add-ratnum-fixnum @var{rt} @var{fx}
Add a ratnum with a fixnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-bignum @var{rt} @var{bn}
Add a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-flonum @var{rt} @var{fl}
Add a ratnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-ratnum @vari{rt} @varii{rt}
Add a ratnum with a ratnum and return the result as a fixnum, bignum or
ratnum.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-compnum @var{rt} @var{cn}
Add a ratnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-cflonum @var{rt} @var{cfl}
Add a ratnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Compnum as first operand


@deffn {Unsafe Operation} $add-compnum-fixnum @var{cn} @var{fx}
Add a compnum with a fixnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-compnum-bignum @var{cn} @var{bn}
Add a compnum with a bignum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-compnum-ratnum @var{cn} @var{rt}
Add a compnum with a ratnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-compnum-compnum @vari{cn} @varii{cn}
Add a compnum with a compnum and return the result as a number (not
necessarily a compnum).
@end deffn


@deffn {Unsafe Operation} $add-compnum-flonum @var{cn} @var{fl}
Add a compnum with a flonum and return the result as a compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $add-compnum-cflonum @var{cn} @var{cfl}
Add a compnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Cflonum as first operand


@deffn {Unsafe Operation} $add-cflonum-fixnum @var{cfl} @var{fx}
Add a cflonum with a fixnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-bignum @var{cfl} @var{bn}
Add a cflonum with a bignum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-ratnum @var{cfl} @var{rt}
Add a cflonum with a ratnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-flonum @var{cfl} @var{fl}
Add a cflonum with a flonum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-compnum @var{cfl} @var{cn}
Add a cflonum with a compnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-cflonum @vari{cfl} @varii{cfl}
Add a cflonum with a cflonum and return the result as a cflonum.
@end deffn

@c page
@node syslib numerics sub
@subsection Numbers subtraction


@deffn {Unsafe Operation} $sub-number-number @vari{num} @varii{num}
Subtract any couple of numbers and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as second operand


@deffn {Unsafe Operation} $sub-fixnum-number @var{fx} @var{num}
Subtract a fixnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-number @var{bn} @var{num}
Subtract a bignum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-number @var{fl} @var{num}
Subtract a flonum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-number @var{rt} @var{num}
Subtract a ratnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-number @var{cn} @var{num}
Subtract a compnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-number @var{cfl} @var{num}
Subtract a cflonum with a number and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as first operand


@deffn {Unsafe Operation} $sub-number-fixnum @var{num} @var{fx}
Subtract any number with a fixnum and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-number-bignum @var{num} @var{bn}
Subtract any number with a bignum and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-number-flonum @var{num} @var{fl}
Subtract any number with a flonum and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-number-ratnum @var{num} @var{rt}
Subtract any number with a ratnum and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-number-compnum @var{num} @var{cn}
Subtract any number with a compnum and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-number-cflonum @var{num} @var{cfl}
Subtract any number with a cflonum and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first operand


@deffn {Unsafe Operation} $sub-fixnum-fixnum @vari{fx} @varii{fx}
Subtract a fixnum with a fixnum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $sub-fixnum-bignum @var{fx} @var{bn}
Subtract a fixnum with a bignum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $sub-fixnum-flonum @var{fx} @var{fl}
Subtract a fixnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-fixnum-ratnum @var{fx} @var{rt}
Subtract a fixnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $sub-fixnum-compnum @var{fx} @var{cn}
Subtract a fixnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-fixnum-cflonum @var{fx} @var{cfl}
Subtract a fixnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first operand


@deffn {Unsafe Operation} $sub-bignum-fixnum @var{bn} @var{fx}
Subtract a bignum with a fixnum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-bignum @vari{bn} @varii{bn}
Subtract a bignum with a bignum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-flonum @var{bn} @var{fl}
Subtract a bignum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-ratnum @var{bn} @var{rt}
Subtract a bignum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-compnum @var{bn} @var{cn}
Subtract a bignum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-cflonum @var{bn} @var{cfl}
Subtract a bignum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first operand


@deffn {Unsafe Operation} $sub-flonum-fixnum @var{fl} @var{fx}
Subtract a flonum with a fixnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-bignum @var{fl} @var{bn}
Subtract a flonum with a bignum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-flonum @vari{fl} @varii{fl}
Subtract a flonum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-ratnum @var{fl} @var{rt}
Subtract a flonum with a ratnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-compnum @var{fl} @var{cn}
Subtract a flonum with a compnum and return the result as a compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-cflonum @var{fl} @var{cfl}
Subtract a flonum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first operand


@deffn {Unsafe Operation} $sub-ratnum-fixnum @var{rt} @var{fx}
Subtract a ratnum with a fixnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-bignum @var{rt} @var{bn}
Subtract a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-flonum @var{rt} @var{fl}
Subtract a ratnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-ratnum @vari{rt} @varii{rt}
Subtract a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-compnum @var{rt} @var{cn}
Subtract a ratnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-cflonum @var{rt} @var{cfl}
Subtract a ratnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Compnum as first operand


@deffn {Unsafe Operation} $sub-compnum-fixnum @var{cn} @var{fx}
Subtract a compnum with a fixnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-bignum @var{cn} @var{bn}
Subtract a compnum with a bignum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-ratnum @var{cn} @var{rt}
Subtract a compnum with a ratnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-compnum @vari{cn} @varii{cn}
Subtract a compnum with a compnum and return the result as a number (not
necessarily a compnum).
@end deffn


@deffn {Unsafe Operation} $sub-compnum-flonum @var{cn} @var{fl}
Subtract a compnum with a flonum and return the result as a compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-cflonum @var{cn} @var{cfl}
Subtract a compnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Cflonum as first operand


@deffn {Unsafe Operation} $sub-cflonum-fixnum @var{cfl} @var{fx}
Subtract a cflonum with a fixnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-bignum @var{cfl} @var{bn}
Subtract a cflonum with a bignum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-ratnum @var{cfl} @var{rt}
Subtract a cflonum with a ratnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-flonum @var{cfl} @var{fl}
Subtract a cflonum with a flonum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-compnum @var{cfl} @var{cn}
Subtract a cflonum with a compnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-cflonum @vari{cfl} @varii{cfl}
Subtract a cflonum with a cflonum and return the result as a cflonum.
@end deffn

@c page
@node syslib numerics mul
@subsection Numbers multiplication


@deffn {Unsafe Operation} $mul-number-number @vari{num} @varii{num}
Multiply any couple of numbers and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as second operand


@deffn {Unsafe Operation} $mul-fixnum-number @var{fx} @var{num}
Multiply a fixnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-number @var{bn} @var{num}
Multiply a bignum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-number @var{fl} @var{num}
Multiply a flonum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-number @var{rt} @var{num}
Multiply a ratnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-number @var{cn} @var{num}
Multiply a compnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-number @var{cfl} @var{num}
Multiply a cflonum with a number and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as first operand


@deffn {Unsafe Operation} $mul-number-fixnum @var{num} @var{fx}
Multiply any number with a fixnum and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-number-bignum @var{num} @var{bn}
Multiply any number with a bignum and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-number-flonum @var{num} @var{fl}
Multiply any number with a flonum and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-number-ratnum @var{num} @var{rt}
Multiply any number with a ratnum and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-number-compnum @var{num} @var{cn}
Multiply any number with a compnum and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-number-cflonum @var{num} @var{cfl}
Multiply any number with a cflonum and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first operand


@deffn {Unsafe Operation} $mul-fixnum-fixnum @vari{fx} @varii{fx}
Multiply a fixnum with a fixnum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $mul-fixnum-bignum @var{fx} @var{bn}
Multiply a fixnum with a bignum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $mul-fixnum-flonum @var{fx} @var{fl}
Multiply a fixnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-fixnum-ratnum @var{fx} @var{rt}
Multiply a fixnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $mul-fixnum-compnum @var{fx} @var{cn}
Multiply a fixnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-fixnum-cflonum @var{fx} @var{cfl}
Multiply a fixnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first operand


@deffn {Unsafe Operation} $mul-bignum-fixnum @var{bn} @var{fx}
Multiply a bignum with a fixnum and return the result as a bignum.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-bignum @vari{bn} @varii{bn}
Multiply a bignum with a bignum and return the result as a bignum.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-flonum @var{bn} @var{fl}
Multiply a bignum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-ratnum @var{bn} @var{rt}
Multiply a bignum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-compnum @var{bn} @var{cn}
Multiply a bignum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-cflonum @var{bn} @var{cfl}
Multiply a bignum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first operand


@deffn {Unsafe Operation} $mul-flonum-fixnum @var{fl} @var{fx}
Multiply a flonum with a fixnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-bignum @var{fl} @var{bn}
Multiply a flonum with a bignum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-flonum @vari{fl} @varii{fl}
Multiply a flonum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-ratnum @var{fl} @var{rt}
Multiply a flonum with a ratnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-compnum @var{fl} @var{cn}
Multiply a flonum with a compnum and return the result as cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-cflonum @var{fl} @var{cfl}
Multiply a flonum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first operand


@deffn {Unsafe Operation} $mul-ratnum-fixnum @var{rt} @var{fx}
Multiply a ratnum with a fixnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-bignum @var{rt} @var{bn}
Multiply a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-flonum @var{rt} @var{fl}
Multiply a ratnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-ratnum @vari{rt} @varii{rt}
Multiply a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-compnum @var{rt} @var{cn}
Multiply a ratnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-cflonum @var{rt} @var{cfl}
Multiply a ratnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Compnum as first operand


@deffn {Unsafe Operation} $mul-compnum-fixnum @var{cn} @var{fx}
Multiply a compnum with a fixnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-bignum @var{cn} @var{bn}
Multiply a compnum with a bignum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-ratnum @var{cn} @var{rt}
Multiply a compnum with a ratnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-compnum @vari{cn} @varii{cn}
Multiply a compnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-flonum @var{cn} @var{fl}
Multiply a compnum with a flonum and return the result as cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-cflonum @var{cn} @var{cfl}
Multiply a compnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Cflonum as first operand


@deffn {Unsafe Operation} $mul-cflonum-fixnum @var{cfl} @var{fx}
Multiply a cflonum with a fixnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-bignum @var{cfl} @var{bn}
Multiply a cflonum with a bignum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-ratnum @var{cfl} @var{rt}
Multiply a cflonum with a ratnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-flonum @var{cfl} @var{fl}
Multiply a cflonum with a flonum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-compnum @var{cfl} @var{cn}
Multiply a cflonum with a compnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-cflonum @vari{cfl} @varii{cfl}
Multiply a cflonum with a cflonum and return the result as a cflonum.
@end deffn

@c page
@node syslib numerics div
@subsection Numbers division


@deffn {Unsafe Operation} $div-number-number @vari{num} @varii{num}
Divide any couple of numbers and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as second operand


@deffn {Unsafe Operation} $div-fixnum-number @var{fx} @var{num}
Divide a fixnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $div-bignum-number @var{bn} @var{num}
Divide a bignum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $div-flonum-number @var{fl} @var{num}
Divide a flonum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-number @var{rt} @var{num}
Divide a ratnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $div-compnum-number @var{cn} @var{num}
Divide a compnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-number @var{cfl} @var{num}
Divide a cflonum with a number and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as first operand


@deffn {Unsafe Operation} $div-number-fixnum @var{num} @var{fx}
Divide any number with a fixnum and return the result.
@end deffn


@deffn {Unsafe Operation} $div-number-bignum @var{num} @var{bn}
Divide any number with a bignum and return the result.
@end deffn


@deffn {Unsafe Operation} $div-number-flonum @var{num} @var{fl}
Divide any number with a flonum and return the result.
@end deffn


@deffn {Unsafe Operation} $div-number-ratnum @var{num} @var{rt}
Divide any number with a ratnum and return the result.
@end deffn


@deffn {Unsafe Operation} $div-number-compnum @var{num} @var{cn}
Divide any number with a compnum and return the result.
@end deffn


@deffn {Unsafe Operation} $div-number-cflonum @var{num} @var{cfl}
Divide any number with a cflonum and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first operand


@deffn {Unsafe Operation} $div-fixnum-fixnum @vari{fx} @varii{fx}
Divide a fixnum with a fixnum and return the result as a fixnum or
ratnum.
@end deffn


@deffn {Unsafe Operation} $div-fixnum-bignum @var{fx} @var{bn}
Divide a fixnum with a bignum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $div-fixnum-flonum @var{fx} @var{fl}
Divide a fixnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-fixnum-ratnum @var{fx} @var{rt}
Divide a fixnum with a ratnum and return the result as fixnum, bignum or
ratnum.
@end deffn


@deffn {Unsafe Operation} $div-fixnum-compnum @var{fx} @var{cn}
Divide a fixnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-fixnum-cflonum @var{fx} @var{cfl}
Divide a fixnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first operand


@deffn {Unsafe Operation} $div-bignum-fixnum @var{bn} @var{fx}
Divide a bignum with a fixnum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-bignum-bignum @vari{bn} @varii{bn}
Divide a bignum with a bignum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-bignum-flonum @var{bn} @var{fl}
Divide a bignum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-bignum-ratnum @var{bn} @var{rt}
Divide a bignum with a ratnum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-bignum-compnum @var{bn} @var{cn}
Divide a bignum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-bignum-cflonum @var{bn} @var{cfl}
Divide a bignum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first operand


@deffn {Unsafe Operation} $div-flonum-fixnum @var{fl} @var{fx}
Divide a flonum with a fixnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-flonum-bignum @var{fl} @var{bn}
Divide a flonum with a bignum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-flonum-flonum @vari{fl} @varii{fl}
Divide a flonum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-flonum-ratnum @var{fl} @var{rt}
Divide a flonum with a ratnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-flonum-compnum @var{fl} @var{cn}
Divide a flonum with a compnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-flonum-cflonum @var{fl} @var{cfl}
Divide a flonum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first operand


@deffn {Unsafe Operation} $div-ratnum-fixnum @var{rt} @var{fx}
Divide a ratnum with a fixnum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-bignum @var{rt} @var{bn}
Divide a ratnum with a ratnum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-flonum @var{rt} @var{fl}
Divide a ratnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-ratnum @vari{rt} @varii{rt}
Divide a ratnum with a ratnum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-compnum @var{rt} @var{cn}
Divide a ratnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-cflonum @var{rt} @var{cfl}
Divide a ratnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Compnum as first operand


@deffn {Unsafe Operation} $div-compnum-fixnum @var{cn} @var{fx}
Divide a compnum with a fixnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-compnum-bignum @var{cn} @var{bn}
Divide a compnum with a bignum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-compnum-ratnum @var{cn} @var{rt}
Divide a compnum with a ratnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-compnum-compnum @vari{cn} @varii{cn}
Divide a compnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-compnum-flonum @var{cn} @var{fl}
Divide a compnum with a flonum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-compnum-cflonum @var{cn} @var{cfl}
Divide a compnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Cflonum as first operand


@deffn {Unsafe Operation} $div-cflonum-fixnum @var{cfl} @var{fx}
Divide a cflonum with a fixnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-bignum @var{cfl} @var{bn}
Divide a cflonum with a bignum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-ratnum @var{cfl} @var{rt}
Divide a cflonum with a ratnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-flonum @var{cfl} @var{fl}
Divide a cflonum with a flonum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-compnum @var{cfl} @var{cn}
Divide a cflonum with a compnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-cflonum @vari{cfl} @varii{cfl}
Divide a cflonum with a cflonum and return the result as a cflonum.
@end deffn

@c page
@node syslib numerics square
@subsection Numbers squaring


To compute the square of any number just use @func{square}; to compute
the square of a flonum use @func{flsquare} or @func{$flsquare}.


@deffn {Unsafe Operation} $square-fixnum @var{fx}
Compute the square of a fixnum and return the result as fixnum or
bignum.
@end deffn


@deffn {Unsafe Operation} $square-bignum @var{bn}
Compute the square of a bignum and return the result as bignum.
@end deffn


@deffn {Unsafe Operation} $square-ratnum @var{rt}
Compute the square of a ratnum and return the result as ratnum.
@end deffn


@deffn {Unsafe Operation} $square-compnum @var{cn}
Compute the square of a compnum and return the result as compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $square-cflonum @var{cfl}
Compute the square of a cflonum and return the result as cflonum.
@end deffn

@c page
@node syslib numerics cube
@subsection Cube of numbers


To compute the cube of any number just use @func{cube}; to compute the
cube of a flonum use @func{flcube} or @func{$flcube}.


@deffn {Unsafe Operation} $cube-fixnum @var{fx}
Compute the cube of a fixnum and return the result as fixnum or
bignum.
@end deffn


@deffn {Unsafe Operation} $cube-bignum @var{bn}
Compute the cube of a bignum and return the result as bignum.
@end deffn


@deffn {Unsafe Operation} $cube-ratnum @var{rt}
Compute the cube of a ratnum and return the result as ratnum.
@end deffn


@deffn {Unsafe Operation} $cube-compnum @var{cn}
Compute the cube of a compnum and return the result as compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $cube-cflonum @var{cfl}
Compute the cube of a cflonum and return the result as cflonum.
@end deffn

@c page
@node syslib numerics gcd
@subsection Greatest common divisor


@deffn {Unsafe Operation} $gcd-number @var{x}
Return the greatest common divisor of standalone @var{x}, an exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-number-number @vari{x} @varii{x}
Return the greatest common divisor between any couple of exact or
inexact integers; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exact or inexact integer as second argument


@deffn {Unsafe Operation} $gcd-fixnum-number @var{fx} @var{x}
Return the greatest common divisor between a fixnum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-bignum-number @var{bn} @var{x}
Return the greatest common divisor between a bignum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-flonum-number @var{fl} @var{x}
Return the greatest common divisor between a flonum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exact or inexact integer as first argument


@deffn {Unsafe Operation} $gcd-number-fixnum @var{x} @var{fx}
Return the greatest common divisor between any exact or inexact integer
and a fixnum; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-number-bignum @var{x} @var{bn}
Return the greatest common divisor between any exact or inexact integer
and a bignum; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-number-flonum @var{x} @var{fl}
Return the greatest common divisor between any exact or inexact integer
and a flonum; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $gcd-fixnum-fixnum @vari{fx} @varii{fx}
Return the greatest common divisor between a fixnum and a fixnum; return
a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $gcd-fixnum-bignum @var{fx} @var{bn}
Return the greatest common divisor between a fixnum and a bignum; return
a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $gcd-fixnum-flonum @var{fx} @var{fl}
Return the greatest common divisor between a fixnum and a flonum; return
a flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $gcd-bignum-fixnum @var{bn} @var{fx}
Return the greatest common divisor between a bignum and a fixnum; return
a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $gcd-bignum-bignum @vari{bn} @varii{bn}
Return the greatest common divisor between a bignum and a bignum; return
a bignum.
@end deffn


@deffn {Unsafe Operation} $gcd-bignum-flonum @var{bn} @var{fl}
Return the greatest common divisor between a bignum and a flonum; return
a flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $gcd-flonum-fixnum @var{fl} @var{fx}
Return the greatest common divisor between a flonum and a fixnum; return
a flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-flonum-bignum @var{fl} @var{bn}
Return the greatest common divisor between a flonum and a bignum; return
a flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-flonum-flonum @vari{fl} @varii{fl}
Return the greatest common divisor between a flonum and a flonum; return
a flonum.
@end deffn

@c page
@node syslib numerics lcm
@subsection Least common multiple


@deffn {Unsafe Operation} $lcm-number @var{x}
Return the least common multiple of standalone @var{x}, an exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-number-number @vari{x} @varii{x}
Return the least common multiple between any couple of exact and inexact
integers; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exact or inexact integer as second argument


@deffn {Unsafe Operation} $lcm-fixnum-number @var{fx} @var{x}
Return the least common multiple between a fixnum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-bignum-number @var{bn} @var{x}
Return the least common multiple between a bignum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-flonum-number @var{fl} @var{x}
Return the least common multiple between a flonum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exact or inexact integer as first argument


@deffn {Unsafe Operation} $lcm-number-fixnum @var{x} @var{fx}
Return the least common multiple between any exact or inexact integer
and a fixnum; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-number-bignum @var{x} @var{bn}
Return the least common multiple between any exact or inexact integer
and a bignum; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-number-flonum @var{x} @var{fl}
Return the least common multiple between any exact or inexact integer
and a flonum; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $lcm-fixnum-fixnum @vari{fx} @varii{fx}
Return the least common multiple between a fixnum and a fixnum; return a
fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $lcm-fixnum-bignum @var{fx} @var{bn}
Return the least common multiple between a fixnum and a bignum; return a
fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $lcm-fixnum-flonum @var{fx} @var{fl}
Return the least common multiple between a fixnum and a flonum; return a
flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $lcm-bignum-fixnum @var{bn} @var{fx}
Return the least common multiple between a bignum and a fixnum; return a
fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $lcm-bignum-bignum @vari{bn} @varii{bn}
Return the least common multiple between a bignum and a bignum; return a
bignum.
@end deffn


@deffn {Unsafe Operation} $lcm-bignum-flonum @var{bn} @var{fl}
Return the least common multiple between a bignum and a flonum; return a
flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $lcm-flonum-fixnum @var{fl} @var{fx}
Return the least common multiple between a flonum and a fixnum; return a
flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-flonum-bignum @var{fl} @var{bn}
Return the least common multiple between a flonum and a bignum; return a
flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-flonum-flonum @vari{fl} @varii{fl}
Return the least common multiple between a flonum and a flonum; return a
flonum.
@end deffn

@c page
@node syslib numerics quorem
@subsection Quotient and remainder


These functions perform the integer division between exact and inexact
numbers and return two values: the quotient and the remainder.  For all
the functions: the second argument must be non--zero.

Note that considering:

@example
(quotient+remainder X Y)
@end example

@noindent
according to @rnrs{6}:

@example
(define (sign n)
  (cond ((negative? n) -1)
        ((positive? n) 1)
        (else 0)))

(define (quotient n1 n2)
  (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

(define (remainder n1 n2)
  (* (sign n1) (mod (abs n1) (abs n2))))

(define (modulo n1 n2)
  (* (sign n2) (mod (* (sign n2) n1) (abs n2))))
@end example

@noindent
so we have:

@example
sign(quotient)  = sign(X) * sign(Y)
sign(remainder) = sign(X)
sign(modulo)    = sign(Y)
@end example

@c ------------------------------------------------------------

@subsubheading Any number as first argument


@deffn {Unsafe Operation} $quotient+remainder-number-fixnum @var{num} @var{fx}
Perform the integer division between any exact or inexact integer and a
fixnum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-number-bignum @var{num} @var{bn}
Perform the integer division between any exact or inexact integer and a
bignum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-number-flonum @var{num} @var{fl}
Perform the integer division between any exact or inexact integer and a
flonum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $quotient+remainder-fixnum-number @var{fx} @var{num}
Perform the integer division between a fixnum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-bignum-number @var{bn} @var{num}
Perform the integer division between a bignum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-flonum-number @var{fl} @var{num}
Perform the integer division between a flonum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $quotient+remainder-fixnum-fixnum @vari{fx} @varii{fx}
Perform the integer division between a fixnum and a fixnum; return a
fixnum or bignum as quotient, return a fixnum as remainder.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-fixnum-bignum @var{fx} @var{bn}
Perform the integer division between a fixnum and a bignum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-fixnum-flonum @var{fx} @var{fl}
Perform the integer division between a fixnum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $quotient+remainder-bignum-fixnum @var{bn} @var{fx}
Perform the integer division between a bignum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-bignum-bignum @vari{bn} @varii{bn}
Perform the integer division between a bignum and a bignum; return
fixnums or bignums.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-bignum-flonum @var{bn} @var{fl}
Perform the integer division between a bignum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $quotient+remainder-flonum-fixnum @var{fl} @var{fx}
Perform the integer division between a flonum and a fixnum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-flonum-bignum @var{fl} @var{bn}
Perform the integer division between a flonum and a bignum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-flonum-flonum @vari{fl} @varii{fl}
Perform the integer division between a flonum and a flonum; return
flonums.
@end deffn

@c page
@node syslib numerics quotient
@subsection Quotient between numbers


These functions perform the integer division between exact and inexact
numbers and return the quotient.  For all the functions: the second
argument must be non--zero.  @ref{syslib numerics quorem} for more
details on the operations.

@c ------------------------------------------------------------

@subsubheading Any number as first argument


@deffn {Unsafe Operation} $quotient-number-fixnum @var{num} @var{fx}
Perform the integer division between any exact or inexact integer and a
fixnum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient-number-bignum @var{num} @var{bn}
Perform the integer division between any exact or inexact integer and a
bignum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient-number-flonum @var{num} @var{fl}
Perform the integer division between any exact or inexact integer and a
flonum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $quotient-fixnum-number @var{fx} @var{num}
Perform the integer division between a fixnum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient-bignum-number @var{bn} @var{num}
Perform the integer division between a bignum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient-flonum-number @var{fl} @var{num}
Perform the integer division between a flonum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $quotient-fixnum-fixnum @vari{fx} @varii{fx}
Perform the integer division between a fixnum and a fixnum; return a
fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $quotient-fixnum-bignum @var{fx} @var{bn}
Perform the integer division between a fixnum and a bignum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $quotient-fixnum-flonum @var{fx} @var{fl}
Perform the integer division between a fixnum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $quotient-bignum-fixnum @var{bn} @var{fx}
Perform the integer division between a bignum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $quotient-bignum-bignum @vari{bn} @varii{bn}
Perform the integer division between a bignum and a bignum; return
fixnums or bignums.
@end deffn


@deffn {Unsafe Operation} $quotient-bignum-flonum @var{bn} @var{fl}
Perform the integer division between a bignum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $quotient-flonum-fixnum @var{fl} @var{fx}
Perform the integer division between a flonum and a fixnum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $quotient-flonum-bignum @var{fl} @var{bn}
Perform the integer division between a flonum and a bignum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $quotient-flonum-flonum @vari{fl} @varii{fl}
Perform the integer division between a flonum and a flonum; return
flonums.
@end deffn

@c page
@node syslib numerics remainder
@subsection Remainder between numbers


These functions perform the integer division between exact and inexact
numbers and return the remainder.  For all the functions: the second
argument must be non--zero.  @ref{syslib numerics quorem} for more
details on the operations.

@c ------------------------------------------------------------

@subsubheading Any number as first argument


@deffn {Unsafe Operation} $remainder-number-fixnum @var{num} @var{fx}
Perform the integer division between any exact or inexact integer and a
fixnum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $remainder-number-bignum @var{num} @var{bn}
Perform the integer division between any exact or inexact integer and a
bignum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $remainder-number-flonum @var{num} @var{fl}
Perform the integer division between any exact or inexact integer and a
flonum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $remainder-fixnum-number @var{fx} @var{num}
Perform the integer division between a fixnum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $remainder-bignum-number @var{bn} @var{num}
Perform the integer division between a bignum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $remainder-flonum-number @var{fl} @var{num}
Perform the integer division between a flonum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $remainder-fixnum-fixnum @vari{fx} @varii{fx}
Perform the integer division between a fixnum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $remainder-fixnum-bignum @var{fx} @var{bn}
Perform the integer division between a fixnum and a bignum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $remainder-fixnum-flonum @var{fx} @var{fl}
Perform the integer division between a fixnum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $remainder-bignum-fixnum @var{bn} @var{fx}
Perform the integer division between a bignum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $remainder-bignum-bignum @vari{bn} @varii{bn}
Perform the integer division between a bignum and a bignum; return
fixnums or bignums.
@end deffn


@deffn {Unsafe Operation} $remainder-bignum-flonum @var{bn} @var{fl}
Perform the integer division between a bignum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $remainder-flonum-fixnum @var{fl} @var{fx}
Perform the integer division between a flonum and a fixnum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $remainder-flonum-bignum @var{fl} @var{bn}
Perform the integer division between a flonum and a bignum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $remainder-flonum-flonum @vari{fl} @varii{fl}
Perform the integer division between a flonum and a flonum; return
flonums.
@end deffn

@c page
@node syslib numerics modulo
@subsection Modulo between numbers


These functions perform the integer division between exact and inexact
numbers and return the modulo.  For all the functions: the second
argument must be non--zero.  @ref{syslib numerics quorem} for more
details on the operations.

@c ------------------------------------------------------------

@subsubheading Any number as first argument


@deffn {Unsafe Operation} $modulo-number-fixnum @var{num} @var{fx}
Perform the integer division between any exact or inexact integer and a
fixnum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $modulo-number-bignum @var{num} @var{bn}
Perform the integer division between any exact or inexact integer and a
bignum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $modulo-number-flonum @var{num} @var{fl}
Perform the integer division between any exact or inexact integer and a
flonum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $modulo-fixnum-number @var{fx} @var{num}
Perform the integer division between a fixnum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $modulo-bignum-number @var{bn} @var{num}
Perform the integer division between a bignum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $modulo-flonum-number @var{fl} @var{num}
Perform the integer division between a flonum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $modulo-fixnum-fixnum @vari{fx} @varii{fx}
Perform the integer division between a fixnum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $modulo-fixnum-bignum @var{fx} @var{bn}
Perform the integer division between a fixnum and a bignum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $modulo-fixnum-flonum @var{fx} @var{fl}
Perform the integer division between a fixnum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $modulo-bignum-fixnum @var{bn} @var{fx}
Perform the integer division between a bignum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $modulo-bignum-bignum @vari{bn} @varii{bn}
Perform the integer division between a bignum and a bignum; return
fixnums or bignums.
@end deffn


@deffn {Unsafe Operation} $modulo-bignum-flonum @var{bn} @var{fl}
Perform the integer division between a bignum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $modulo-flonum-fixnum @var{fl} @var{fx}
Perform the integer division between a flonum and a fixnum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $modulo-flonum-bignum @var{fl} @var{bn}
Perform the integer division between a flonum and a bignum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $modulo-flonum-flonum @vari{fl} @varii{fl}
Perform the integer division between a flonum and a flonum; return
flonums.
@end deffn

@c page
@node syslib numerics max
@subsection Maximum between numbers


Notice that if one of the operands is @code{+nan.0} the result is
@code{+nan.0}.


@subsubheading Any number as first argument


@deffn {Unsafe Operation} $max-number-fixnum @var{num} @var{fx}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-number-bignum @var{num} @var{bn}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-number-ratnum @var{num} @var{rt}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-number-flonum @var{num} @var{fl}
Return the maximum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $max-fixnum-number @var{fx} @var{num}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-bignum-number @var{bn} @var{num}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-flonum-number @var{fl} @var{num}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-ratnum-number @var{rt} @var{num}
Return the maximum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $max-fixnum-fixnum @vari{fx} @varii{fx}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-fixnum-bignum @var{fx} @var{bn}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-fixnum-flonum @var{fx} @var{fl}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-fixnum-ratnum @var{fx} @var{rt}
Return the maximum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $max-bignum-fixnum @var{bn} @var{fx}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-bignum-bignum @vari{bn} @varii{bn}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-bignum-ratnum @var{bn} @var{rt}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-bignum-flonum @var{bn} @var{fl}
Return the maximum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $max-flonum-fixnum @var{fl} @var{fx}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-flonum-bignum @var{fl} @var{bn}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-flonum-ratnum @var{fl} @var{rt}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-flonum-flonum @vari{fl} @varii{fl}
Return the maximum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first argument


@deffn {Unsafe Operation} $max-ratnum-fixnum @var{rt} @var{fx}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-ratnum-bignum @var{rt} @var{bn}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-ratnum-ratnum @vari{rt} @varii{rt}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-ratnum-flonum @var{rt} @var{fl}
Return the maximum between the arguments.
@end deffn

@c page
@node syslib numerics min
@subsection Minimum between numbers


Notice that if one of the operands is @code{+nan.0} the result is
@code{+nan.0}.


@subsubheading Any number as first argument


@deffn {Unsafe Operation} $min-number-fixnum @var{num} @var{fx}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-number-bignum @var{num} @var{bn}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-number-ratnum @var{num} @var{rt}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-number-flonum @var{num} @var{fl}
Return the minimum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $min-fixnum-number @var{fx} @var{num}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-bignum-number @var{bn} @var{num}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-flonum-number @var{fl} @var{num}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-ratnum-number @var{rt} @var{num}
Return the minimum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $min-fixnum-fixnum @vari{fx} @varii{fx}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-fixnum-bignum @var{fx} @var{bn}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-fixnum-flonum @var{fx} @var{fl}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-fixnum-ratnum @var{fx} @var{rt}
Return the minimum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $min-bignum-fixnum @var{bn} @var{fx}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-bignum-bignum @vari{bn} @varii{bn}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-bignum-ratnum @var{bn} @var{rt}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-bignum-flonum @var{bn} @var{fl}
Return the minimum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $min-flonum-fixnum @var{fl} @var{fx}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-flonum-bignum @var{fl} @var{bn}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-flonum-ratnum @var{fl} @var{rt}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-flonum-flonum @vari{fl} @varii{fl}
Return the minimum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first argument


@deffn {Unsafe Operation} $min-ratnum-fixnum @var{rt} @var{fx}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-ratnum-bignum @var{rt} @var{bn}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-ratnum-ratnum @vari{rt} @varii{rt}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-ratnum-flonum @var{rt} @var{fl}
Return the minimum between the arguments.
@end deffn

@c page
@node syslib numerics abs
@subsection Absolute value of real numbers


@deffn {Unsafe Operation} $abs-fixnum @var{fx}
Compute the absolute value of a fixnum; return a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $abs-bignum @var{bn}
Compute the absolute value of a bignum; return a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $abs-flonum @var{fl}
Compute the absolute value of a flonum; return a flonum.
@end deffn


@deffn {Unsafe Operation} $abs-ratnum
Compute the absolute value of a ratnum; return a ratnum.
@end deffn

@c page
@node syslib numerics sign
@subsection Sign of real numbers


@deffn {Unsafe Operation} $sign-fixnum @var{fx}
Return a fixnum representing the sign of @var{fx}: @code{+1} for
positive, @code{-1} for negative, @code{0} for zero.
@end deffn


@deffn {Unsafe Operation} $sign-bignum @var{bn}
Return a fixnum representing the sign of @var{bn}: @code{+1} for
positive, @code{-1} for negative.  Bignums do not represent zero.
@end deffn


@deffn {Unsafe Operation} $sign-flonum @var{fl}
Return a flonum representing the sign of @var{fx}: @code{+1.0} for
positive, including @code{+0.0} and @code{+inf.0}; @code{-1.0} for
negative, including @code{-0.0} and @code{-inf.0}; @code{+nan.0} for
not--a--number.
@end deffn


@deffn {Unsafe Operation} $sign-ratnum @var{rt}
Return a fixnum representing the sign of the numerator of @var{rt}:
@code{+1} for positive, @code{-1} for negative.  Ratnums do not
represent zero.
@end deffn

@c page
@node syslib numerics numerator
@subsection Numerator of real numbers


@deffn {Unsafe Operation} $numerator-fixnum @var{fx}
This is an identity function: return @var{fx} itself.
@end deffn


@deffn {Unsafe Operation} $numerator-bignum @var{bn}
This is an identity function: return @var{bn} itself.
@end deffn


@deffn {Unsafe Operation} $numerator-flonum @var{fl}
Return the numerator of @var{fl} as flonum.  This is an alias for
@func{$flnumerator}.
@end deffn


@deffn {Unsafe Operation} $numerator-ratnum @var{rt}
Return the numerator of @var{rt}: a fixnum or bignum.
@end deffn

@c page
@node syslib numerics denominator
@subsection Denominator of real numbers


@deffn {Unsafe Operation} $denominator-fixnum @var{fx}
Always return the fixnum @code{1}.
@end deffn


@deffn {Unsafe Operation} $denominator-bignum @var{bn}
Always return the fixnum @code{1}.
@end deffn


@deffn {Unsafe Operation} $denominator-flonum @var{fl}
Return the denominator of @var{fl} as flonum.  This is an alias for
@func{$fldenominator}.
@end deffn


@deffn {Unsafe Operation} $denominator-ratnum @var{rt}
Return the denominator of @var{rt}: a positive fixnum or bignum.
@end deffn

@c page
@node syslib numerics exact
@subsection Conversion to exact number


@deffn {Unsafe Operation} $exact-fixnum @var{fx}
This is an identity function: always return @var{fx}.
@end deffn


@deffn {Unsafe Operation} $exact-bignum @var{bn}
This is an identity function: always return @var{bn}.
@end deffn


@deffn {Unsafe Operation} $exact-flonum @var{fl}
If @var{fl} is an integer flonum: return the corresponding exact
integer, a fixnum or bignum.  Otherwise raise an exception.
@end deffn


@deffn {Unsafe Operation} $exact-ratnum @var{rt}
This is an identity function: always return @var{rt}.
@end deffn


@deffn {Unsafe Operation} $exact-compnum @var{cn}
Attempt to convert the compnum @var{cn} into the corresponding exact
compnum.  If either the real or the imaginary parts are not integers:
raise an exception.
@end deffn


@deffn {Unsafe Operation} $exact-cflonum @var{cfl}
Attempt to convert the cflonum @var{cfl} into the corresponding exact
compnum.  If either the real or the imaginary parts are not integers:
raise an exception.
@end deffn

@c page
@node syslib numerics inexact
@subsection Conversion to inexact number


@deffn {Unsafe Operation} $inexact-fixnum @var{fx}
Convert the fixnum @var{fx} into the corresponding flonum.
@end deffn


@deffn {Unsafe Operation} $inexact-bignum @var{bn}
Convert the bignum @var{bn} into the corresponding flonum.
@end deffn


@deffn {Unsafe Operation} $inexact-flonum @var{fl}
This is an identity function: always return @var{fl}.
@end deffn


@deffn {Unsafe Operation} $inexact-ratnum @var{rt}
Convert the ratnum @var{rt} into the corresponding flonum.
@end deffn


@deffn {Unsafe Operation} $inexact-compnum @var{cn}
Convert the compnum @var{cn} into the corresponding cflonum.
@end deffn


@deffn {Unsafe Operation} $inexact-cflonum @var{cfl}
This is an identity function: always return @var{cfl}.
@end deffn

@c page
@node syslib numerics expt
@subsection Raising numbers to power


@menu
* syslib numerics expt any::            Any number as first argument.
* syslib numerics expt zero::           Exact zero exponent.
* syslib numerics expt posi::           Positive fixnum exponent.
* syslib numerics expt nega::           Negative fixnum exponent.
* syslib numerics expt fixnums::        Fixnum as first argument.
* syslib numerics expt bignums::        Bignum as first argument.
* syslib numerics expt ratnums::        Ratnum as first argument.
* syslib numerics expt flonums::        Flonum as first argument.
* syslib numerics expt compnums::       Compnum as first argument.
* syslib numerics expt cflonums::       Cflonum as first argument.
@end menu

@c page
@node syslib numerics expt any
@subsubsection Any number as first argument


@deffn {Unsafe Operation} $expt-number-fixnum @var{num} @var{fx}
Compute @var{num} raised to the power @var{fx}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $expt-number-bignum @var{num} @var{bn}
Compute @var{num} raised to the power @var{bn}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $expt-number-flonum @var{num} @var{fl}
Compute @var{num} raised to the power @var{fl}; return an unspecified
inexact number object.
@end deffn


@deffn {Unsafe Operation} $expt-number-ratnum @var{num} @var{rt}
Compute @var{num} raised to the power @var{rt}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $expt-number-compnum @var{num} @var{cn}
Compute @var{num} raised to the power @var{cn}; return an unspecified
number object, but most likely a complex number.
@end deffn


@deffn {Unsafe Operation} $expt-number-cflonum @var{num} @var{cfl}
Compute @var{num} raised to the power @var{cfl}; return an unspecified
inexact complex number object.
@end deffn

@c page
@node syslib numerics expt zero
@subsubsection Exact zero exponent


@deffn {Unsafe Operation} $expt-number-zero-fixnum @var{num}
Compute @var{num} raised to the power of exact zero; return an
unspecified number object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-zero-fixnum @var{fx}
Compute @var{fx} raised to the power of exact zero; return a fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-zero-fixnum @var{fl}
Compute @var{fl} raised to the power of exact zero; return a flonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-zero-fixnum @var{cn}
Compute @var{cn} raised to the power of exact zero; return an
unspecified number object.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-zero-fixnum @var{cfl}
Compute @var{cfl} raised to the power of exact zero; return a cflonum.
@end deffn

@c page
@node syslib numerics expt posi
@subsubsection Positive fixnum exponent


@deffn {Unsafe Operation} $expt-number-positive-fixnum @var{num} @var{fx}
Compute @var{num} raised to the power of positive @var{fx}; return an
unspecified number object.  @var{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-positive-fixnum @vari{fx} @varii{fx}
Compute @vari{fx} raised to the power of positive @varii{fx}; return an
exact number object.  @varii{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-positive-fixnum @var{bn} @var{fx}
Compute @var{bn} raised to the power of positive @var{fx}; return an
exact number object.  @var{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-positive-fixnum @var{rt} @var{fx}
Compute @var{rt} raised to the power of positive @var{fx}; return an
exact number object.  @var{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-positive-fixnum @var{fl} @var{fx}
Compute @var{fl} raised to the power of positive @var{fx}; return an
inexact number object.  @var{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-positive-fixnum @var{cn} @var{fx}
Compute @var{cn} raised to the power of positive @var{fx}; return a
cflonum.  @var{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-positive-fixnum @var{cfl} @var{fx}
Compute @var{cfl} raised to the power of positive @var{fx}; return a
cflonum.  @var{fx} must be a positive fixnum.
@end deffn

@c page
@node syslib numerics expt nega
@subsubsection Negative fixnum exponent


@deffn {Unsafe Operation} $expt-number-negative-fixnum @var{num} @var{fx}
Compute @var{num} raised to the power of negative @var{fx}; return an
unspecified number object.  @var{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-negative-fixnum @vari{fx} @varii{fx}
Compute @vari{fx} raised to the power of negative @varii{fx}; return an
exact number object.  @varii{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-negative-fixnum @var{bn} @var{fx}
Compute @var{bn} raised to the power of negative @var{fx}; return an
exact number object.  @var{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-negative-fixnum @var{rt} @var{fx}
Compute @var{rt} raised to the power of negative @var{fx}; return an
exact number object.  @var{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-negative-fixnum @var{fl} @var{fx}
Compute @var{fl} raised to the power of negative @var{fx}; return an
inexact number object.  @var{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-negative-fixnum @var{cn} @var{fx}
Compute @var{cn} raised to the power of negative @var{fx}; return a
cflonum.  @var{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-negative-fixnum @var{cfl} @var{fx}
Compute @var{cfl} raised to the power of negative @var{fx}; return a
cflonum.  @var{fx} must be a negative fixnum.
@end deffn

@c page
@node syslib numerics expt fixnums
@subsubsection Fixnum as first argument


@deffn {Unsafe Operation} $expt-fixnum-fixnum @vari{fx} @varii{fx}
Compute @vari{fx} raised to the power @varii{fx}; return an exact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-bignum @var{fx} @var{bn}
Compute @var{fx} raised to the power @var{bn}; return an exact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-ratnum @var{fx} @var{rt}
Compute @var{fx} raised to the power @var{rt}; return an exact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-flonum @var{fx} @var{fl}
Compute @var{fx} raised to the power @var{fl}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-compnum @var{fx} @var{cn}
Compute @var{fx} raised to the power @var{cn}; return a complex number
object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-cflonum @var{fx} @var{cfl}
Compute @var{fx} raised to the power @var{cfl}; return an inexact
complex number object.
@end deffn

@c page
@node syslib numerics expt bignums
@subsubsection Bignum as first argument


@deffn {Unsafe Operation} $expt-bignum-fixnum @var{bn} @var{fx}
Compute @var{bn} raised to the power of @var{fx}; return an exact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-bignum @vari{bn} @varii{bn}
Raise an implementation restriction violation.
@ignore
Compute @vari{bn} raised to the power @varii{bn}; return an exact number
object.
@end ignore
@end deffn


@deffn {Unsafe Operation} $expt-bignum-ratnum @var{bn} @var{rt}
Compute @var{bn} raised to the power @var{rt}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-flonum @var{bn} @var{fl}
Compute @var{bn} raised to the power @var{fl}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-compnum @var{bn} @var{cn}
Compute @var{bn} raised to the power @var{cn}; return an inexact complex
number object.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-cflonum @var{bn} @var{cfl}
Compute @var{bn} raised to the power @var{cfl}; return an inexact
complex number object.
@end deffn

@c page
@node syslib numerics expt ratnums
@subsubsection Ratnum as first argument


@deffn {Unsafe Operation} $expt-ratnum-fixnum @var{rt} @var{fx}
Compute @var{rt} raised to the power of @var{fx}; return an exact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-bignum @var{rt} @var{bn}
Compute @var{rt} raised to the power @var{bn}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-ratnum @vari{rt} @varii{rt}
Compute @vari{rt} raised to the power @varii{rt}; return an inexact
number object.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-flonum @var{rt} @var{fl}
Compute @var{rt} raised to the power @var{fl}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-compnum @var{rt} @var{cn}
Compute @var{rt} raised to the power @var{cn}; return an inexact complex
number object.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-cflonum @var{rt} @var{cfl}
Compute @var{rt} raised to the power @var{cfl}; return an inexact
complex number object.
@end deffn

@c page
@node syslib numerics expt flonums
@subsubsection Flonum as first argument


@deffn {Unsafe Operation} $expt-flonum-fixnum @var{fl} @var{fx}
Compute @var{fl} raised to the power of @var{fx}; return an inexact
number object.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-bignum @var{fl} @var{bn}
Compute @var{fl} raised to the power @var{bn}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-ratnum @var{fl} @var{rt}
Compute @var{fl} raised to the power @var{rt}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-flonum @vari{fl} @varii{fl}
Compute @vari{fl} raised to the power @varii{fl}; return an inexact
number object.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-compnum @var{fl} @var{cn}
Compute @var{fl} raised to the power @var{cn}; return an inexact complex
number object.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-cflonum @var{fl} @var{cfl}
Compute @var{fl} raised to the power @var{cfl}; return an inexact
complex number object.
@end deffn

@c page
@node syslib numerics expt compnums
@subsubsection Compnum as first argument


@deffn {Unsafe Operation} $expt-compnum-fixnum @var{cn} @var{fx}
Compute @var{cn} raised to the power of @var{fx}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-bignum @var{cn} @var{bn}
Compute @var{cn} raised to the power @var{bn}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-ratnum @var{cn} @var{rt}
Compute @var{cn} raised to the power @var{rt}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-flonum @var{cn} @var{fl}
Compute @var{cn} raised to the power @var{fl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-compnum @vari{cn} @varii{cn}
Compute @vari{cn} raised to the power @varii{cn}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-cflonum @var{cn} @var{cfl}
Compute @var{cn} raised to the power @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics expt cflonums
@subsubsection Cflonum as first argument


@deffn {Unsafe Operation} $expt-cflonum-fixnum @var{cfl} @var{fx}
Compute @var{cfl} raised to the power of @var{fx}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-bignum @var{cfl} @var{bn}
Compute @var{cfl} raised to the power @var{bn}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-ratnum @var{cfl} @var{rt}
Compute @var{cfl} raised to the power @var{rt}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-flonum @var{cfl} @var{fl}
Compute @var{cfl} raised to the power @var{fl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-compnum @var{cfl} @var{cn}
Compute @var{cfl} raised to the power @var{cfl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-cflonum @vari{cfl} @varii{cfl}
Compute @vari{cfl} raised to the power @varii{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics sqrt
@subsection Square root of numbers


@deffn {Unsafe Operation} $sqrt-fixnum @var{fx}
Compute the principal square root of @var{fx}; return an unspecified
number object.

@example
($sqrt-fixnum 0)       @result{} 0

($sqrt-fixnum +1)      @result{} +1
($sqrt-fixnum -1)      @result{} +1i

($sqrt-fixnum +4)      @result{} +2
($sqrt-fixnum -4)      @result{} +2i

($sqrt-fixnum +5)      @result{} 2.23606797749979
($sqrt-fixnum -5)      @result{} 0.0+2.23606797749979i
@end example
@end deffn


@deffn {Unsafe Operation} $sqrt-bignum @var{bn}
Compute the principal square root of @var{bn}; return an unspecified
number object.

@example
(define SMALLEST-POSITIVE-BIGNUM (-    (least-fixnum)))
(define SMALLEST-NEGATIVE-BIGNUM (+ -1 (least-fixnum)))

(define BN1 (+ +1  SMALLEST-POSITIVE-BIGNUM))
(define BN2 (+ +10 SMALLEST-POSITIVE-BIGNUM))
(define BN3 (+ -1  SMALLEST-NEGATIVE-BIGNUM))
(define BN4 (+ -10 SMALLEST-NEGATIVE-BIGNUM))

;; on a 32-bit host
($sqrt-bignum BN1)      @result{} 23170.475027499975
($sqrt-bignum BN2)      @result{} 23170.47522171265
($sqrt-bignum BN3)      @result{} 0.0+23170.475049079163i
($sqrt-bignum BN4)      @result{} 0.0+23170.47524329184i
@end example
@end deffn


@deffn {Unsafe Operation} $sqrt-ratnum @var{rt}
Compute the principal square root of @var{rt}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $sqrt-flonum @var{fl}
Compute the principal square root of @var{fl}; return a flonum, compnum
or cflonum.

@example
($sqrt-flonum +0.0)     @result{} +0.0
($sqrt-flonum -0.0)     @result{} +0.0i

($sqrt-flonum +4.0)     @result{} +2.0
($sqrt-flonum -4.0)     @result{} +2.0i

($sqrt-flonum +1.0)     @result{} +1.0
($sqrt-flonum -1.0)     @result{} +1.0i

($sqrt-flonum +5.0)     @result{} 2.23606797749979
($sqrt-flonum -5.0)     @result{} 0.0+2.23606797749979i

($sqrt-flonum +inf.0)   @result{} +inf.0
($sqrt-flonum -inf.0)   @result{} +inf.0i

($sqrt-flonum +nan.0)   @result{} +nan.0
@end example
@end deffn


@deffn {Unsafe Operation} $sqrt-compnum @var{cn}
Compute the principal square root of @var{cn}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $sqrt-cflonum @var{cfl}
Compute the principal square root of @var{cfl}; return a cflonum.
@end deffn

@c ------------------------------------------------------------


@deffn {Unsafe Operation} $exact-integer-sqrt-fixnum @var{fx}
Return two non--negative exact integer objects being the root and the
residual of @var{fx}.
@end deffn


@deffn {Unsafe Operation} $exact-integer-sqrt-bignum @var{bn}
Return two non--negative exact integer objects being the root and the
residual of @var{bn}.
@end deffn

@c page
@node syslib numerics cbrt
@subsection Cubic root of numbers


@deffn {Unsafe Operation} $cbrt-fixnum @var{fx}
Compute the principal cubic root of @var{fx}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $cbrt-bignum @var{bn}
Compute the principal cubic root of @var{bn}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $cbrt-ratnum @var{rt}
Compute the principal cubic root of @var{rt}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $cbrt-flonum @var{fl}
Compute the principal cubic root of @var{fl}; return a flonum, compnum
or cflonum.
@end deffn


@deffn {Unsafe Operation} $cbrt-compnum @var{cn}
Compute the principal cubic root of @var{cn}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $cbrt-cflonum @var{cfl}
Compute the principal cubic root of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics log
@subsection Logarithms of numbers


@deffn {Unsafe Operation} $log-fixnum @var{fx}
Compute the natural logarithm of @var{fx}; return a fixnum, flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $log-bignum @var{bn}
Compute the natural logarithm of @var{fl}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $log-flonum @var{fl}
Compute the natural logarithm of @var{fl}; return a flonum or cflonum.
This function computes the result also when @var{fl} is a negative
flonum, whose logarithm is a complex number; this makes it different
from @func{$fllog}.
@end deffn


@deffn {Unsafe Operation} $log-ratnum @var{rt}
Compute the natural logarithm of @var{rt}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $log-compnum @var{cn}
Compute the natural logarithm of @var{cn}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $log-cflonum @var{cfl}
Compute the natural logarithm of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics exp
@subsection Exponentials of numbers


@deffn {Unsafe Operation} $exp-fixnum @var{fx}
Compute the base @math{e} exponential of @var{fx}; return a fixnum or
flonum.
@end deffn


@deffn {Unsafe Operation} $exp-bignum @var{bn}
Compute the base @math{e} exponential of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $exp-ratnum @var{rt}
Compute the base @math{e} exponential of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $exp-flonum @var{fl}
Compute the base @math{e} exponential of @var{fl}; return a flonum.
This is just an alias for @func{$flexp}.
@end deffn


@deffn {Unsafe Operation} $exp-compnum @var{cn}
Compute the base @math{e} exponential of @var{cn}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $exp-cflonum @var{cfl}
Compute the base @math{e} exponential of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics sin
@subsection Trigonometric sine


@deffn {Unsafe Operation} $sin-fixnum @var{fx}
Compute the trigonometric sine of @var{fx}; return a fixnum or flonum.
@end deffn


@deffn {Unsafe Operation} $sin-bignum @var{bn}
Compute the trigonometric sine of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $sin-ratnum @var{rt}
Compute the trigonometric sine of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $sin-flonum @var{fl}
Compute the trigonometric sine of @var{fl}; return a flonum.  This is an
alias for @func{$flsin}.
@end deffn


@deffn {Unsafe Operation} $sin-cflonum @var{cfl}
Compute the trigonometric sine of @var{cfl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $sin-compnum @var{cn}
Compute the trigonometric sine of @var{cn}; return a cflonum.
@end deffn

@c page
@node syslib numerics cos
@subsection Trigonometric cosine


@deffn {Unsafe Operation} $cos-fixnum @var{fx}
Compute the trigonometric cosine of @var{fx}; return a fixnum or flonum.
@end deffn


@deffn {Unsafe Operation} $cos-bignum @var{bn}
Compute the trigonometric cosine of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $cos-ratnum @var{rt}
Compute the trigonometric cosine of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $cos-flonum @var{fl}
Compute the trigonometric cosine of @var{fl}; return a flonum.  This is
an alias for @func{$flcos}.
@end deffn


@deffn {Unsafe Operation} $cos-cflonum @var{cfl}
Compute the trigonometric cosine of @var{cfl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $cos-compnum @var{cn}
Compute the trigonometric cosine of @var{cn}; return a cflonum.
@end deffn

@c page
@node syslib numerics tan
@subsection Trigonometric tangent


@deffn {Unsafe Operation} $tan-fixnum @var{fx}
Compute the trigonometric tangent of @var{fx}; return a fixnum or
flonum.
@end deffn


@deffn {Unsafe Operation} $tan-bignum @var{bn}
Compute the trigonometric tangent of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $tan-ratnum @var{rt}
Compute the trigonometric tangent of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $tan-flonum @var{fl}
Compute the trigonometric tangent of @var{fl}; return a flonum.  This is
an alias for @func{$fltan}.
@end deffn


@deffn {Unsafe Operation} $tan-cflonum @var{cfl}
Compute the trigonometric tangent of @var{cfl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $tan-compnum @var{cn}
Compute the trigonometric tangent of @var{cn}; return a cflonum.
@end deffn

@c page
@node syslib numerics asin
@subsection Trigonometric arc sine


@deffn {Unsafe Operation} $asin-fixnum @var{fx}
Compute the trigonometric arc sine of @var{fx}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $asin-bignum @var{bn}
Compute the trigonometric arc sine of @var{bn}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $asin-ratnum @var{rt}
Compute the trigonometric arc sine of @var{rt}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $asin-flonum @var{fl}
Compute the trigonometric arc sine of @var{fl}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $asin-cflonum @var{cfl}
Compute the trigonometric arc sine of @var{fl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $asin-compnum @var{cn}
Compute the trigonometric arc sine of @var{fl}; return a number object.
@end deffn

@c page
@node syslib numerics acos
@subsection Trigonometric arc cosine


@deffn {Unsafe Operation} $acos-fixnum @var{fx}
Compute the trigonometric arc cosine of @var{fx}; return a flonum or
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acos-bignum @var{bn}
Compute the trigonometric arc cosine of @var{bn}; return a flonum or
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acos-ratnum @var{rt}
Compute the trigonometric arc cosine of @var{rt}; return a flonum or
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acos-flonum @var{fl}
Compute the trigonometric arc cosine of @var{fl}; return a flonum or
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acos-cflonum @var{cfl}
Compute the trigonometric arc cosine of @var{fl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $acos-compnum @var{cn}
Compute the trigonometric arc cosine of @var{fl}; return a number
object.
@end deffn

@c page
@node syslib numerics atan
@subsection Trigonometric arc tangent


@deffn {Unsafe Operation} $atan2-real-real @var{imp} @var{rep}
Compute the principal value of the trigonometric arc tangent of flonum
@var{imp} over flonum @var{rep} using the signs of the arguments to
determine the quadrant of the result:

@example
\alpha = \atan (@var{imp}/@var{rep})
@end example

@noindent
in other words compute the angle @math{\alpha} such that:

@example
               \sin(\alpha)   @var{imp}
\tan(\alpha) = ------------ = ---
               \cos(\alpha)   @var{rep}
@end example

@noindent
in yet other words compute the angle of the complex number having the
flonum @var{rep} as real part and the flonum @var{imp} as imaginary
part:

@example
(angle (make-rectangular @var{rep} @var{imp}))
@end example

@noindent
return a flonum.  This operation is implemented using the @posix{}
function @cfunc{atan2}.
@end deffn


@deffn {Unsafe Operation} $atan-fixnum @var{fx}
Compute the trigonometric arc tangent of @var{fx}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $atan-bignum @var{bn}
Compute the trigonometric arc tangent of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $atan-ratnum @var{rt}
Compute the trigonometric arc tangent of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $atan-flonum @var{fl}
Compute the trigonometric arc tangent of @var{fl}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $atan-cflonum @var{cfl}
Compute the trigonometric arc tangent of @var{fl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $atan-compnum @var{cn}
Compute the trigonometric arc tangent of @var{fl}; return a number
object.
@end deffn

@c page
@node syslib numerics sinh
@subsection Hyperbolic sine


@deffn {Unsafe Operation} $sinh-fixnum @var{fx}
Compute the hyperbolic sine of @var{fx}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $sinh-bignum @var{bn}
Compute the hyperbolic sine of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $sinh-ratnum @var{rt}
Compute the hyperbolic sine of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $sinh-flonum @var{fl}
Compute the hyperbolic sine of @var{fl}; return a flonum.  This is an
alias for @func{$flsinh}.
@end deffn


@deffn {Unsafe Operation} $sinh-compnum @var{cn}
Compute the hyperbolic sine of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $sinh-cflonum @var{cfl}
Compute the hyperbolic sine of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics cosh
@subsection Hyperbolic cosine


@deffn {Unsafe Operation} $cosh-fixnum @var{fx}
Compute the hyperbolic cosine of @var{fx}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $cosh-bignum @var{bn}
Compute the hyperbolic cosine of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $cosh-ratnum @var{rt}
Compute the hyperbolic cosine of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $cosh-flonum @var{fl}
Compute the hyperbolic cosine of @var{fl}; return a flonum.  This is an
alias for @func{$flcosh}.
@end deffn


@deffn {Unsafe Operation} $cosh-compnum @var{cn}
Compute the hyperbolic cosine of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $cosh-cflonum @var{cfl}
Compute the hyperbolic cosine of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics tanh
@subsection Hyperbolic tangent


@deffn {Unsafe Operation} $tanh-fixnum @var{fx}
Compute the hyperbolic tangent of @var{fx}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $tanh-bignum @var{bn}
Compute the hyperbolic tangent of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $tanh-ratnum @var{rt}
Compute the hyperbolic tangent of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $tanh-flonum @var{fl}
Compute the hyperbolic tangent of @var{fl}; return a flonum.  This is an
alias for @func{$fltanh}.
@end deffn


@deffn {Unsafe Operation} $tanh-compnum @var{cn}
Compute the hyperbolic tangent of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $tanh-cflonum @var{cfl}
Compute the hyperbolic tangent of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics asinh
@subsection Hyperbolic arc sine


@deffn {Unsafe Operation} $asinh-fixnum @var{fx}
Compute the inverse hyperbolic sine of @var{fx}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $asinh-bignum @var{bn}
Compute the inverse hyperbolic sine of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $asinh-ratnum @var{rt}
Compute the inverse hyperbolic sine of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $asinh-flonum @var{fl}
Compute the inverse hyperbolic sine of @var{fl}; return a flonum.  This
is an alias for @func{$flsinh}.
@end deffn


@deffn {Unsafe Operation} $asinh-compnum @var{cn}
Compute the inverse hyperbolic sine of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $asinh-cflonum @var{cfl}
Compute the inverse hyperbolic sine of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics acosh
@subsection Hyperbolic arc cosine


@deffn {Unsafe Operation} $acosh-fixnum @var{fx}
Compute the inverse hyperbolic cosine of @var{fx}; return a flonum,
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acosh-bignum @var{bn}
Compute the inverse hyperbolic cosine of @var{bn}; return a flonum,
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acosh-ratnum @var{rt}
Compute the inverse hyperbolic cosine of @var{rt}; return a flonum,
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acosh-flonum @var{fl}
Compute the inverse hyperbolic cosine of @var{fl}; return a flonum,
compnum or cflonum.  This is different from @func{$flacosh} whose return
value is a flonum begin @code{+nan.0} when the operand is out of the
domain for real numbers.
@end deffn


@deffn {Unsafe Operation} $acosh-compnum @var{cn}
Compute the inverse hyperbolic cosine of @var{cn}; return a number
object.
@end deffn


@deffn {Unsafe Operation} $acosh-cflonum @var{cfl}
Compute the inverse hyperbolic cosine of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics atanh
@subsection Hyperbolic arc tangent


@deffn {Unsafe Operation} $atanh-fixnum @var{fx}
Compute the inverse hyperbolic tangent of @var{fx}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $atanh-bignum @var{bn}
Compute the inverse hyperbolic tangent of @var{bn}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $atanh-ratnum @var{rt}
Compute the inverse hyperbolic tangent of @var{rt}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $atanh-flonum @var{fl}
Compute the inverse hyperbolic tangent of @var{fl}; return a flonum or
cflonum.  This is different from @func{$flatanh} whose return value is a
flonum begin @code{+nan.0} when the operand is out of the domain for
real numbers.
@end deffn


@deffn {Unsafe Operation} $atanh-compnum @var{cn}
Compute the inverse hyperbolic tangent of @var{cn}; return a number
object.
@end deffn


@deffn {Unsafe Operation} $atanh-cflonum @var{cfl}
Compute the inverse hyperbolic tangent of @var{cfl}; return a cflonum.
@end deffn


@c page
@node syslib numerics conjugate
@subsection Complex conjugate


@deffn {Unsafe Operation} $complex-conjugate-compnum @var{cn}
Return a number object representing the complex conjugate of @var{cn}.
@end deffn


@deffn {Unsafe Operation} $complex-conjugate-cflonum @var{cfl}
Return a cflonum representing the complex conjugate of @var{cfl}.
@end deffn

@c page
@node syslib numerics magnitude
@subsection Magnitude of complex numbers


@deffn {Unsafe Operation} $magnitude-fixnum @var{fx}
Compute the magnitude of @var{fx}; return a fixnum.
@end deffn


@deffn {Unsafe Operation} $magnitude-bignum @var{bn}
Compute the magnitude of @var{bn}; return a bignum.
@end deffn


@deffn {Unsafe Operation} $magnitude-ratnum @var{rt}
Compute the magnitude of @var{rt}; return a ratnum.
@end deffn


@deffn {Unsafe Operation} $magnitude-flonum @var{fl}
Compute the magnitude of @var{fl}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $magnitude-compnum @var{cn}
Compute the magnitude of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $magnitude-cflonum @var{cfl}
Compute the magnitude of @var{cfl}; return a flonum.
@end deffn

@c page
@node syslib numerics angle
@subsection Angle of complex numbers


@deffn {Unsafe Operation} $angle-fixnum @var{fx}
Compute the angle of @var{fx}; return a fixnum or flonum.
@end deffn


@deffn {Unsafe Operation} $angle-bignum @var{bn}
Compute the angle of @var{bn}; return a fixnum or flonum.
@end deffn


@deffn {Unsafe Operation} $angle-ratnum @var{rt}
Compute the angle of @var{rt}; return a fixnum or flonum.
@end deffn


@deffn {Unsafe Operation} $angle-flonum @var{fl}
Compute the angle of @var{fl}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $angle-compnum @var{cn}
Compute the angle of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $angle-cflonum @var{cfl}
Compute the angle of @var{cfl}; return a flonum.
@end deffn

@c page
@node syslib numerics bitnot
@subsection Bitwise logic not


@deffn {Unsafe Operation} $bitwise-not-fixnum @var{fx}
Apply the bitwise NOT operation to @var{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-not-bignum @var{bn}
Apply the bitwise NOT operation to @var{bn}.
@end deffn

@c page
@node syslib numerics bitand
@subsection Bitwise logic and


@deffn {Unsafe Operation} $bitwise-and-fixnum-number @var{fx} @var{num}
Apply the bitwise AND operation to the fixnum @var{fx} and the exact
integer object @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-and-bignum-number @var{bn} @var{num}
Apply the bitwise AND operation to the bignum @var{bn} and the exact
integer @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-and-fixnum-fixnum @vari{fx} @varii{fx}
Apply the bitwise AND operation to the fixnum @vari{fx} and the fixnum
@varii{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-and-fixnum-bignum @var{fx} @var{bn}
Apply the bitwise AND operation to the fixnum @var{fx} and the bignum
@var{bn}.
@end deffn


@deffn {Unsafe Operation} $bitwise-and-bignum-fixnum @var{bn} @var{fx}
Apply the bitwise AND operation to the bignum @var{bn} and the fixnum
@var{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-and-bignum-bignum @vari{bn} @varii{bn}
Apply the bitwise AND operation to the bignum @vari{bn} and the bignum
@varii{bn}.
@end deffn

@c page
@node syslib numerics bitior
@subsection Bitwise logic inclusive or


@deffn {Unsafe Operation} $bitwise-ior-fixnum-number @var{fx} @var{num}
Apply the bitwise inclusive OR operation to the fixnum @var{fx} and the
exact integer object @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-ior-bignum-number @var{bn} @var{num}
Apply the bitwise inclusive OR operation to the bignum @var{bn} and the
exact integer @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-ior-fixnum-fixnum @vari{fx} @varii{fx}
Apply the bitwise inclusive OR operation to the fixnum @vari{fx} and the
fixnum @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-ior-fixnum-bignum @var{fx} @var{bn}
Apply the bitwise inclusive OR operation to the fixnum @var{fx} and the
bignum @var{bn}.
@end deffn


@deffn {Unsafe Operation} $bitwise-ior-bignum-fixnum @var{bn} @var{fx}
Apply the bitwise inclusive OR operation to the bignum @var{bn} and the
fixnum @var{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-ior-bignum-bignum @vari{bn} @varii{bn}
Apply the bitwise inclusive OR operation to the bignum @vari{bn} and the
bignum @varii{bn}.
@end deffn

@c page
@node syslib numerics bitxor
@subsection Bitwise logic exclusive or


@deffn {Unsafe Operation} $bitwise-xor-fixnum-number @var{fx} @var{num}
Apply the bitwise exclusive OR operation to the fixnum @var{fx} and the
exact integer object @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-xor-bignum-number @var{bn} @var{num}
Apply the bitwise exclusive OR operation to the bignum @var{bn} and the
exact integer @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-xor-fixnum-fixnum @vari{fx} @varii{fx}
Apply the bitwise exclusive OR operation to the fixnum @vari{fx} and the
fixnum @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-xor-fixnum-bignum @var{fx} @var{bn}
Apply the bitwise exclusive OR operation to the fixnum @var{fx} and the
bignum @var{bn}.
@end deffn


@deffn {Unsafe Operation} $bitwise-xor-bignum-fixnum @var{bn} @var{fx}
Apply the bitwise exclusive OR operation to the bignum @var{bn} and the
fixnum @var{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-xor-bignum-bignum @vari{bn} @varii{bn}
Apply the bitwise exclusive OR operation to the bignum @vari{bn} and the
bignum @varii{bn}.
@end deffn

@c page
@node syslib numerics floor
@subsection Floor rounding


@deffn {Unsafe Operation} $floor-fixnum @var{FX}
Rounding as defined by @func{floor}.  This is an identity function,
returning @var{N} itself.
@end deffn


@deffn {Unsafe Operation} $floor-bignum @var{BN}
Rounding as defined by @func{floor}.  This is an identity function,
returning @var{N} itself.
@end deffn


@deffn {Unsafe Operation} $floor-flonum @var{FL}
Rounding as defined by @func{floor}.  Return a flonum.
@end deffn


@deffn {Unsafe Operation} $floor-ratnum @var{RN}
Rounding as defined by @func{floor}.  Return an exact integer.
@end deffn

@c page
@node syslib numerics ceiling
@subsection Ceiling rounding


@deffn {Unsafe Operation} $ceiling-fixnum @var{FX}
Rounding as defined by @func{ceiling}.  This is an identity function,
returning @var{N} itself.
@end deffn


@deffn {Unsafe Operation} $ceiling-bignum @var{BN}
Rounding as defined by @func{ceiling}.  This is an identity function,
returning @var{N} itself.
@end deffn


@deffn {Unsafe Operation} $ceiling-flonum @var{FL}
Rounding as defined by @func{ceiling}.  Return a flonum.
@end deffn


@deffn {Unsafe Operation} $ceiling-ratnum @var{RN}
Rounding as defined by @func{ceiling}.  Return an exact integer.
@end deffn

@c page
@node syslib numerics truncate
@subsection Truncate rounding


@deffn {Unsafe Operation} $truncate-fixnum @var{FX}
Rounding as defined by @func{truncate}.  This is an identity function,
returning @var{N} itself.
@end deffn


@deffn {Unsafe Operation} $truncate-bignum @var{BN}
Rounding as defined by @func{truncate}.  This is an identity function,
returning @var{N} itself.
@end deffn


@deffn {Unsafe Operation} $truncate-flonum @var{FL}
Rounding as defined by @func{truncate}.  Return a flonum.
@end deffn


@deffn {Unsafe Operation} $truncate-ratnum @var{RN}
Rounding as defined by @func{truncate}.  Return an exact integer.
@end deffn

@c page
@node syslib numerics round
@subsection Round rounding


@deffn {Unsafe Operation} $round-fixnum @var{FX}
Rounding as defined by @func{round}.  This is an identity function,
returning @var{N} itself.
@end deffn


@deffn {Unsafe Operation} $round-bignum @var{BN}
Rounding as defined by @func{round}.  This is an identity function,
returning @var{N} itself.
@end deffn


@deffn {Unsafe Operation} $round-flonum @var{FL}
Rounding as defined by @func{round}.  Return a flonum.
@end deffn


@deffn {Unsafe Operation} $round-ratnum @var{RN}
Rounding as defined by @func{round}.  Return an exact integer.
@end deffn

@c page
@node syslib chars
@section Low level character operations


@cindex @library{vicare system $chars}, library
@cindex Library @library{vicare system $chars}


The arguments @var{ch} to these operations must be characters, the
arguments @var{fx} must be fixnums in the range @code{[0, #x10FFFF]} but
not in the range @code{[#xD800, #xDFFF]}.  The following bindings are
exported by the library @library{vicare system $chars}.

@c ------------------------------------------------------------------------

@subsubheading Comparison

@deffn {Unsafe Operation} $char= @vari{ch} @varii{ch}
Evaluate to true if the operands are equal.
@end deffn


@deffn {Unsafe Operation} $char!= @vari{ch} @varii{ch}
The arguments must be characters.  Return @true{} if the arguments are
different; otherwise return @false{}.
@end deffn


@deffn {Unsafe Operation} $char< @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is less than @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char<= @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is less than or equal to @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char> @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is greater than @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char>= @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is greater than or equal to
@varii{ch}.
@end deffn


@defun $chmin @vari{ch} @varii{ch}
@defunx $chmax @vari{ch} @varii{ch}
Return the minimum or maximum character among the arguments.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Conversion

@deffn {Unsafe Operation} $fixnum->char @var{fx}
Return a new character value whose code point equals @var{fx}.
@end deffn


@deffn {Unsafe Operation} $char->fixnum @var{ch}
Return a fixnum representing the code point of the operand.
@end deffn

@c page
@node syslib pairs
@section Low level pair operations


@cindex @library{vicare system $pairs}, library
@cindex Library @library{vicare system $pairs}


The arguments @var{P} to these operations must be pairs.  The following
bindings are exported by the library @library{vicare system $pairs}.
@ref{objects pairs} for details of pair representation.


@deffn {Unsafe Operation} $car @var{P}
Return the car of the operand.
@end deffn


@deffn {Unsafe Operation} $cdr @var{P}
Return the cdr of the operand.
@end deffn


@deffn {Unsafe Operation} $set-car! @var{P} @var{value}
Store @var{value} in the car location of @var{P}.
@end deffn


@deffn {Unsafe Operation} $set-cdr! @var{P} @var{value}
Store @var{value} in the cdr location of @var{P}.
@end deffn

@c page
@node syslib lists
@section Low level list operations


@cindex @library{vicare system $lists}, library
@cindex Library @library{vicare system $lists}


The following bindings are exported by the library @library{vicare
system $lists}.


@deffn {Unsafe Operation} $length @var{ell}
Assume @var{ell} is a proper list, null included: compute and return the
length of @var{ell}.
@end deffn

@c page
@node syslib structs
@section System structure operations


@menu
* syslib structs safe::         High level structure operations.
* syslib structs unsafe::       Low level structure operations.
@end menu

@c page
@node syslib structs safe
@subsection High level structure operations


@cindex @library{vicare system structs}, library
@cindex Library @library{vicare system structs}


A @value{PRJNAME}'s struct is a record object, lighter than records as
defined by @rnrs{6}.  @ref{objects structs} for more informations on the
internals of structs.

@menu
* syslib structs safe define::  Defining struct types.
* syslib structs safe using::   Using struct types.
* syslib structs safe inspect:: Inspecting struct types.
* syslib structs safe printer:: Struct printer customisation.
* syslib structs safe final::   Finalisation of structs.
* syslib structs safe data::    Inspecting data structures.
@end menu

@c page
@node syslib structs safe define
@subsubsection Defining structure types


@deffn Syntax define-struct @meta{type-name} (@meta{field} @dots{})
@deffnx Syntax define-struct @meta{type-name} (@meta{field} @dots{}) (nongenerative @meta{uid})
@deffnx Syntax define-struct (@meta{type-name} @meta{constructor} @meta{predicate}) (@meta{field} @dots{})
@deffnx Syntax define-struct (@meta{type-name} @meta{constructor} @meta{predicate}) (@meta{field} @dots{}) (nongenerative @meta{uid})
@deffnx {Auxiliary Syntax} nongenerative
Define a new struct type.  This macro is embedded in the expander.

@meta{type-name} must be a symbol representing the name of the structure; it
is used to build names for the constructor, predicate, field accessors
and mutators.  When @meta{constructor} is used: it must be an identifier
representing the name of the constructor.  When @meta{predicate} is
used: it must be an identifier representing the name of the predicate.

The @meta{field} values must be either symbols representing the names of
the fields or @syntax{brace} forms representing the name and type of
fields:

@lisp
(brace @meta{field-name} @meta{tag})
@end lisp

@noindent
they are used to build names for the accessors and mutators.

When the @clause{nongenerative} clause is used: @meta{uid} must be a
symbol uniquely identifying the struct type.  Multiple definitions of
struct type using the same @meta{uid} must have the same type name and
field names, and represent the same type definition.  See
@func{make-struct-type} for more details.

The following definition:

@example
(define-struct color
  (red green blue))
@end example

@noindent
expands to the definition of the following syntactic bindings:

@table @code
@item color
A syntactic identifier representing the type name.  When the tagged
language is enabled, we can use this identifier to tag a variable
syntactic binding:

@lisp
(define @{O color@}
  (make-color 1 2 3))

(O red)         @result{} 1
(O green)       @result{} 2
(O blue)        @result{} 3
@end lisp

We can use the identifier as argument for the @syntax{is-a?} syntax:

@lisp
(is-a? (make-color 1 2 3) color)        @result{} #t
(is-a? "ciao" color)                    @result{} #f
@end lisp

When the identifier is used in macro keyword position with the syntax:

@example
(@meta{type-name} (@meta{expr} ...))
@end example

@noindent
the form is expanded to the application of the constructor to the
results of evaluating the @meta{expr} arguments:

@example
(color (1 2 3)) @result{} #["color" red=1 green=2 blue=3]
@end example

@item make-color @var{red} @var{green} @var{blue}
A structure constructor accepting as much arguments as there are fields.
The constructor makes use of the @func{$struct} low level operation.

@item color? @var{obj}
A predicate to distinguish between references to @code{color} structures
and other values.  This predicate makes use of the @func{$struct/rtd?}
low level operation.

@item color-red @var{stru}
@itemx color-green @var{stru}
@itemx color-blue @var{stru}
Accessor functions for the fields of the structure.  These accessors
make use of the @func{$struct/rtd?} low level operation to validate the
argument and if successful they use @func{$struct-ref} to extract the
value; if the argument is of invalid type: an assertion violation is
raised.

@item set-color-red! @var{stru} @var{red}
@itemx set-color-green! @var{stru} @var{green}
@itemx set-color-blue! @var{stru} @var{blue}
Mutator functions for the fields of the structure.  These mutators make
use of the @func{$struct/rtd?} low level operation to validate the
argument @var{stru} and if successful they use @func{$struct-set!} to
set the value; if the argument @var{stru} is of invalid type: an
assertion violation is raised.

@item $color-red @var{stru}
@itemx $color-green @var{stru}
@itemx $color-blue @var{stru}
Unsafe accessor syntaxes for the fields of the structure.  These
accessors do not validate the arguments and expand directly to a use of
@func{$struct-ref} to extract the value; if the argument is invalid: the
behaviour is undefined.

@item $set-color-red! @var{stru} @var{red}
@itemx $set-color-green! @var{stru} @var{green}
@itemx $set-color-blue! @var{stru} @var{blue}
Unsafe mutator syntaxes for the fields of the structure.  These mutators
do not validate the arguments and expand directly to a use of
@func{$struct-set!} to set the value; if the argument @var{stru} is
invalid: the behaviour is undefined.
@end table
@end deffn


@defun make-struct-type @var{type-name} @var{fields}
@defunx make-struct-type @var{type-name} @var{fields} @var{uid}
Build and return a new struct--type descriptor.  @var{type-name} must be
a string representing the type name.  @var{fields} must be a list of
symbols representing the field names.

The optional @var{uid} argument must be a symbol uniquely identifying
this type; when not supplied, a symbol is automatically generated.  The
@code{value} field of the symbol object @var{uid} is set to the newly
created @rtd{}; if @var{uid} already has a symbol value: such value must
be a struct descriptor equal to the newly created @rtd{}.

The use of a @var{uid} allows us to define a unique struct type in
different libraries without sharing the definition by importing
syntactic bindings.  For example, we can define a struct type in a
library and import the definition in other libraries:

@example
(library (one)
  (export
    make-color color?
    color-red color-green color-blue)
  (import (vicare))
  (define-struct color
    (red green blue)))

(library (two)
  (export C)
  (import (vicare) (one))
  (define C (make-color 1 2 3)))

(library (three)
  (export)
  (import (vicare) (one) (two))
  (display (color-red C)))
@end example

@noindent
but, by specifying a @var{uid}, we can also do:

@example
(library (two)
  (export C)
  (import (vicare))
  (define-struct color
    (red green blue)
    (nongenerative the-color))
  (define C
    (make-color 1 2 3)))

(library (three)
  (export)
  (import (vicare))
  (define-struct color
    (red green blue)
    (nongenerative the-color))
  (display (color-red C)))
@end example

@noindent
and everything will work as before.
@end defun

@c page
@node syslib structs safe using
@subsubsection Using structure types


@deffn Syntax struct-type-descriptor @meta{type-name}
Evaluate to the type descriptor of the data structure @meta{type-name}, which
must be the first argument to a previous use of @func{define-struct}.
@end deffn


@defun struct-type-descriptor? @var{obj}
Return @true{} if @var{obj} is a struct--type descriptor, otherwise
return @false{}.  This predicate returns @false{} when applied to
@rnrs{6} record--type descriptors.
@end defun


@defun struct-type-constructor @var{std}
Return a constructor function for struct of type defined by the type
descriptor @var{std}.  The returned constructor accepts as many
arguments as there are fields specified by @var{std} and it returns a
new struct instance.

@lisp
(define duo-std
  (make-struct-type "duo" '(one two)))

(define make-duo
  (struct-type-constructor duo-std))

(make-duo 1 2)  @result{} #[struct duo one=1 two=2]
@end lisp
@end defun


@defun struct-type-predicate @var{std}
Return a predicate function for structs of type defined by the type
descriptor @var{std}.

@lisp
(define duo-std
  (make-struct-type "duo" '(one two)))

(define make-duo
  (struct-type-constructor duo-std))

(define duo?
  (struct-type-predicate duo-std))

(duo? (make-duo 1 2))   @result{} #t
@end lisp
@end defun


@defun struct-type-field-accessor @var{std} @var{index/name}
@defunx struct-type-field-mutator @var{std} @var{index/name}
Return an accessor or mutator function for the field at @var{index/name}
of structs of type defined by the type descriptor @var{std}.
@var{index/name} can be a field index or a symbol representing a field
name.

@example
(define-struct color
  (red green blue))

(define stru
  (make-color 1 2 3))

((struct-type-field-accessor (struct-type-descriptor color) 'red)
 stru)
@result{} 1

((struct-type-field-accessor (struct-type-descriptor color) 0)
 stru)
@result{} 1
@end example
@end defun


@defun struct-type-field-method @var{std} @var{index/name}
Return a ``method'' function for the field at @var{index/name} of
structs of type defined by the type descriptor @var{std}.
@var{index/name} can be a field index or a symbol representing a field
name.  When the method function is applied to @math{1} argument: it
behaves like a field accessor.  When the method function is applied to
@math{2} arguments: it behaves like a field mutator.

@example
(define-struct color
  (red green blue))

(define stru
  (make-color 1 2 3))

(define red-method
  (struct-type-field-method (struct-type-descriptor color) 'red))

(red-method stru)       @result{} 1
(red-method stru 11)
(red-method stru)       @result{} 11
@end example
@end defun

@c page
@node syslib structs safe inspect
@subsubsection Inspecting struct types


@defun struct-type-name @var{std}
Return a string representing the name of structs of type @var{std}.
@end defun


@defun struct-type-symbol @var{std}
Return a symbol uniquely identifying the struct type @var{std}.
@end defun


@defun struct-type-field-names @var{std}
Return a list of symbols representing the names of fields in structs of
type @var{std}.
@end defun

@c page
@node syslib structs safe printer
@subsubsection Structs printer customisation


@value{PRJNAME}'s built--in Scheme objects writer can print structs just
fine, handling cyclic references and shared objects:

@lisp
(import (vicare))
(print-graph #t)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(define-struct duo (one two))

;; simple struct
(display (make-duo 1 2))
@print{} #[struct duo one=1 two=2]

;; struct with shared object
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (display B))
@print{} #[struct duo one=#0=#[struct duo one=1 two=2] two=#0#]

;; struct with cyclic reference to itself
(let ((A (make-duo 1 (void))))
  (set-duo-two! A A)
  (display A))
@print{} #0=#[struct duo one=1 two=#0#]
@end lisp

The Scheme objects writer is able to differentiate between
@func{display}, @func{write} and @func{pretty-print} printing.  When
printing structs, the built--in writer makes @strong{no} difference
between printing with @func{display} and @func{write}; it does it
differently when printing with @func{pretty-print}:

@lisp
(import (vicare))
(print-graph #t)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(define-struct duo (one two))

;; simple struct
(pretty-print (make-duo 1 2))
@print{} (struct duo (one 1) (two 2))

;; struct with shared object
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (pretty-print B))
@print{} (struct duo (one #0=(struct duo (one 1) (two 2))) (two #0#))

;; struct with cyclic reference to itself
(let ((A (make-duo 1 (void))))
  (set-duo-two! A A)
  (pretty-print A))
@print{} #0=(struct duo (one 1) (two #0#))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Custom printers

Sometimes, we need to print a struct with a customised representation.
For example keyword objects (@pxref{iklib keywords, Keyword objects})
are structs with a custom printer function:

@lisp
(display #:ciao)        @result{} #:ciao
@end lisp

For every struct type it is possible to set a custom printer function;
it accepts @math{3} arguments: the struct to be printed; a textual
output port into which to write a string representation of the struct in
the style of @func{display}, @func{write} or @func{pretty-print}; a
sub--printer function to be optionally used to print component objects.
The sub--printer function accepts as single argument the object to
print; it allows us to interface with the shared objects printer that
handles shared and cyclic references.

As example, the following code defines a custom printer, making use of
the parameter @func{printer-printing-style} to differentiate the style:

@lisp
(import (vicare))
(print-graph #t)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(define-struct duo (one two))

(define (duo-printer stru port sub-printer)
  (case (printer-printing-style)
    ((display)
     (display "#@{duo " port)
     (sub-printer (duo-one stru))
     (display " " port)
     (sub-printer (duo-two stru))
     (display "@}" port))
    ((write)
     (display "(" port)
     ;;By using the sub-printer: we make this sexp shared too.
     (sub-printer '(struct-constructor
                      (struct-type-descriptor duo)))
     (display " " port)
     (sub-printer (duo-one stru))
     (display " " port)
     (sub-printer (duo-two stru))
     (display ")" port))
    ((pretty-print)
     (sub-printer `(struct duo
                           #:one ,(duo-one stru)
                           #:two ,(duo-two stru))))))

(set-struct-type-printer! (struct-type-descriptor duo)
                          duo-printer)

(define O
  (make-duo 1 2))

(display O)
@print{} #@{duo 1 2@}"

(write O)
@print{} ((struct-constructor (struct-type-descriptor duo)) 1 2)

(pretty-print O)
@print{} (struct duo #:one 1 #:two 2)

;; shared object, display
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (display B))
@print{} #@{duo #0=#@{duo 1 2@} #0#@}

;; shared object, write
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (write B))
@print{} (#0=(struct-constructor (struct-type-descriptor duo)) \
  #1=(#0# 1 2) #1#)
@end lisp


@defun set-struct-type-printer! @var{std} @var{printer}
Select the procedure @var{printer} as printer for structs of type
@var{std}; if @var{printer} is @false{}, instances of type @var{std}
make use of the built--in Scheme objects printer.  Return the old
printer function or @false{} if no printer function was set for this
@var{std}.
@end defun


@defun struct-type-printer @var{std}
Return @false{} or a function previously set as custom struct printer
for instances of struct type @var{std}.  When the return value is
@false{}: instances of type @var{std} make use of the built--in Scheme
objects printer.
@end defun

@c page
@node syslib structs safe final
@subsubsection Finalisation of structs


@cindex Automatic finalisation of structs
@cindex Structs, automatic finalisation
@cindex Structs, destructors
@cindex Finalisation of structs
@cindex Destructors for structs


@value{PRJNAME} allows structs to be finalised either explicitly or
automatically by the garbage collector, by applying a destructor
function to them; here is how automatic finalisation works:

@example
vicare> (define-struct duo (one two))
vicare> (set-struct-type-destructor! (struct-type-descriptor duo)
   (lambda (stru)
     (printf "destroying ~s\n" stru)))
vicare> (make-duo 1 2)
$1 = (struct duo (one 1) (two 2))
vicare> (collect)
destroying #[struct duo one=1 two=2]
vicare>
@end example

A destructor function is associated to a struct--type by registering it
in the struct--type descriptor.  After a destructor is set in the
descriptor: new instances of the struct--type are registered, upon
creation, into an internal guardian, @ref{iklib guardians} for details;
whenever such structs are garbage collected: the guardian applies the
destructor to them.

When the destructor is called by the garbage collector: exceptions
raised by it are catched with @syntax{guard} and discarded; destructor
functions should take care of exceptions by themselves.

It is possible for a destructor function to be applied multiple times to
the same struct: once a destructor is set in the descriptor, it can be
explicitly applied to structs and later applied again by the garbage
collector.  Destructor functions must be written in such a way that
multiple applications are not a problem.  For example, it is usually
possible, upon destruction, to reset some struct fields to the void
object: when the destructor detects a field set to void, it knows that
the struct has already been finalised.


@defun set-struct-type-destructor! @var{std} @var{destructor}
Select the procedure @var{destructor} as destructor for data structs of
type @var{std}; return the old destructor function or @false{} if no
destructor was set for @var{std}.  The destructor accepts a single
argument being the struct instance to finalise; the destructor can
return unspecified values.
@end defun


@defun struct-type-destructor @var{std}
Return @false{} or a procedure being the destructor for instances of
@var{std}.
@end defun


@deffn Parameter struct-guardian-logger
@cindex Parameter @func{struct-guardian-logger}
Select data structs destruction logging mode for debugging purposes.
When a struct is finalised by the garbage collector, using the
destructor registered in the @rtd{}:

@itemize
@item
If this parameter is set to @false{}: no additional actions are
performed.

@item
If this parameter is set to @true{}: the function
@func{struct-guardian-log} is used to log the operations to the textual
output port returned by @code{current-error-port}.

@item
If this parameter is set to a procedure: such procedure is used to log
the operations in a user selected way.
@end itemize

See the documentation of @func{struct-guardian-log} for the calling
protocol of the logger functions.
@end deffn


@defun struct-guardian-log @var{struct} @var{exception} @var{action}
Built in logger function to be used to log struct finalisation
operations by the garbage collector.  @var{struct} is the instance to be
finalised; @var{exception} is @false{} or an object raised by the struct
destructor; @var{action} is one of the symbols:
@code{before-destruction}, @code{after-destruction}, @code{exception}.

When this function is used as value for the parameter
@func{struct-guardian-logger}:

@itemize
@item
The function is called whenever a struct is registered for destruction
with @var{action} set to the symbol @code{registration} and
@var{exception} set to @false{}.

@item
The function is called just before the struct is finalised with
@var{action} set to the symbol @code{before-destruction} and
@var{exception} set to @false{}.

@item
The function is called right after the struct has been finalised with
@var{action} set to the symbol @code{after-destruction} and
@var{exception} set to @false{}.

@item
If an exception is raised by the destructor: such exception is catched
and this function is called with @var{action} set to @code{exception}
and @var{exception} set to the raised object.
@end itemize

The current implementation is the following:

@smallexample
(define (struct-guardian-log S E action)
  (case action
    ((registration)
     (fprintf (current-error-port)
              "*** Vicare debug: struct guardian: registered struct:\n\
               ***\t~s\n" S))
    ((before-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: before destruction:\n\
        ***\t~s\n" S))
    ((after-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: after destruction:\n\
        ***\t~s\n" S))
    ((exception)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: exception:\n\
        ***\t~s\n\
        ***\t~s\n" S E))
    (else
     (assertion-violation 'struct-guardian-log
       "invalid action in struct destruction process" S action))))
@end smallexample
@end defun

@c page
@node syslib structs safe data
@subsubsection Inspecting data structures


@defun struct? @var{stru}
@defunx struct? @var{stru} @var{std}
When no @var{std} argument is given: return true if @var{stru} is a data
structure.  When @var{std} is given: return true if @var{stru} is a data
structure and it is of type @var{std}, which must be a struct type
descriptor.
@end defun


@defun struct-and-std? @var{stru} @var{std}
Return @true{} if @var{stru} is a struct with struct--type descriptor
equal to @var{std}; otherwise return @false{}.  Raise an error if
@var{std} is not a struct--type descriptor.
@end defun


@defun struct-std @var{stru}
Return the struct--type descriptor of the data structure @var{stru}.
Notice that this function works with both Vicare's structs and @rnrs{6}
records.
@end defun


@defun struct-length @var{stru}
Return the number of fields in the data structure @var{stru}.  Notice
that this function works with both Vicare's structs and @rnrs{6}
records.
@end defun


@defun struct-field-names @var{stru}
Return a list of symbols representing the field names of the structure
@var{stru}.
@end defun


@defun struct-name @var{stru}
Return a string representing the name of the data structure @var{stru}.
Notice that this function works with both Vicare's structs and @rnrs{6}
records.
@end defun


@defun struct-printer @var{stru}
Return @false{} or the procedure being the printer function for the data
structure @var{stru}.
@end defun


@defun struct-destructor @var{stru}
Return @false{} or the procedure being the destructor function for the
data structure @var{stru}.
@end defun


@defun struct-ref @var{stru} @var{index}
Return the value of field at @var{index} in the data structure
@var{stru}.
@end defun


@defun struct-set! @var{stru} @var{index} @var{value}
Store @var{value} in the field at @var{index} in the data structure
@var{stru}.
@end defun


@defun struct-and-std-ref @var{stru} @var{index} @var{std}
Check that @var{stru} is a struct of type @var{std}, then return the
value of field at @var{index} in the data structure @var{stru}.
@end defun


@defun struct-and-std-set! @var{stru} @var{index} @var{std} @var{value}
Check that @var{stru} is a struct of type @var{std}, store @var{value}
in the field at @var{index} in the data structure @var{stru}.
@end defun


@defun struct=? @var{stru} @dots{}
All the arguments must be structs.  Return @true{} if all the arguments
have the same @rtd{} and equal field values according to @func{eqv?}.
When applied to a single argument: return @true{}.  Note that this
function also works when applied to @rnrs{6} records.
@end defun


@defun struct!=? @var{stru} @dots{}
All the arguments must be structs.  Return @true{} if the arguments are
all different: no two arguments are equal; otherwise return @false{}.
When applied to a single argument: return @false{}.
@end defun


@defun struct-reset! @var{stru}
Reset to void all the fields of a structure.
@end defun

@c page
@node syslib structs unsafe
@subsection Low level structure operations


@cindex @library{vicare system $structs}, library
@cindex Library @library{vicare system $structs}


The arguments @var{stru} to these operations must be references to data
structures, the arguments @var{std} must be references to structure type
descriptors, the arguments @var{fx} must be fixnums of appropriate
value.  The following bindings are exported by the library
@library{vicare system $structs}.


@deffn {Unsafe Operation} base-rtd
Return a reference to the type descriptor used as type for all the type
descriptors.
@end deffn


@deffn {Unsafe Operation} $struct? @var{obj}
Evaluate to true if @var{obj} is the reference to a structure.
@end deffn


@deffn {Unsafe Operation} $struct/rtd? @var{stru} @var{std}
Evaluate to true if @var{stru} is a structure of type @var{std}.
@end deffn


@deffn {Unsafe Operation} $make-struct @var{std} @var{fx}
Allocate a new data structure of type @var{std} capable of holding
@var{fx} words and return a reference to it.

@quotation
@strong{NOTE} This operation initialises only the @code{std} field,
leaving all the other fields set to a machine word with all the bits set
to @code{1}.  We must be careful not to trigger a garbage collection
before those fields are initialised with valid values, else the
behaviour is undefined.
@end quotation
@end deffn


@deffn {Unsafe Operation} $make-clean-struct @var{std}
Allocate a new data structure of type @var{std} and reset all the fields
to the fixnum zero.
@end deffn


@deffn {Unsafe Operation} $struct-std @var{stru}
Return a reference to the type descriptor of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct-ref @var{stru} @var{fx}
Return the value in the field at index @var{fx} of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct-set! @var{stru} @var{fx} @var{value}
Store @var{value} in the field at index @var{fx} of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct @var{std} @var{value} ...
Allocate a new data structure of type @var{std} capable of holding as
many words as given @var{value} arguments and initialise the fields with
such values.  Return a reference to the structure.
@end deffn

@c ------------------------------------------------------------

@subsubheading Operations on struct type descriptors


@deffn {Unsafe Operation} $std-std @var{std}
@deffnx {Unsafe Operation} $set-std-std! @var{std} @var{new-std}
Given a struct type descriptor return its struct type descriptor or set
a new type descriptor.
@end deffn


@deffn {Unsafe Operation} $std-name @var{std}
@deffnx {Unsafe Operation} $set-std-name! @var{std} @var{new-name}
Given a struct type descriptor return its name as a string or set a new
name.
@end deffn


@deffn {Unsafe Operation} $std-length @var{std}
@deffnx {Unsafe Operation} $set-std-length! @var{std} @var{new-len}
Given a struct type descriptor return a non--negative fixnum
representing the number of fields or set a new number of fields.
@end deffn


@deffn {Unsafe Operation} $std-fields @var{std}
@deffnx {Unsafe Operation} $set-std-fields! @var{std} @var{fields}
Given a struct type descriptor return a list of symbols representing the
field names or set a new list of field names.
@end deffn


@deffn {Unsafe Operation} $std-printer @var{std}
@deffnx {Unsafe Operation} $set-std-printer! @var{std} @var{new-printer}
Given a struct type descriptor return its printer function or set a new
printer function.
@end deffn


@deffn {Unsafe Operation} $std-symbol @var{std}
@deffnx {Unsafe Operation} $set-std-symbol! @var{std} @var{new-uid}
Given a struct type descriptor return its @uid{} symbol or set a new
@uid{} symbol.  When setting a new struct @uid{} we must store the
struct type descriptor in the @code{value} slot of the @uid{}.
@end deffn


@deffn {Unsafe Operation} $std-destructor @var{std}
@deffnx {Unsafe Operation} $set-std-destructor! @var{std} @var{new-destr}
Given a struct type descriptor return @false{} or its destructor
function or set a new destructor function.
@end deffn

@c page
@node syslib records
@section Low level recordure operations


@cindex @library{vicare system $records}, library
@cindex Library @library{vicare system $records}


The arguments @var{reco} to these operations must be references to
records, the arguments @var{rtd} must be references to record--type
descriptors, the arguments @var{fx} must be fixnums of appropriate
value.  The following bindings are exported by the library
@library{vicare system $records}.


@deffn {Unsafe Operation} $record= @vari{reco} @varii{reco}
Return @true{} if the arguments are equal field by field according to
@func{equal?}; otherwise return @false{}.
@end deffn


@deffn {Unsafe Operation} $record-ref @var{reco} @var{fx}
Return the value of the field at absolute index @var{fx} for the record
@var{reco}.
@end deffn


@deffn {Unsafe Operation} $record-and-rtd? @var{reco} @var{rtd}
Return @true{} if the record @var{reco} is of type @var{rtd}; otherwise
return @false{}.
@end deffn


@deffn {Unsafe Operation} $record-constructor @var{rtd}
Return the constructor function for records of type @var{rtd}.
@end deffn


@deffn {Unsafe Operation} $record-destructor @var{rtd}
Return @false{} or the destructor function for records of type
@var{rtd}.
@end deffn


@deffn {Unsafe Operation} $record-printer @var{reco}
Return @false{} or the printer function for records of the same type of
@var{reco}.
@end deffn


@deffn {Unsafe Operation} $record-equality-predicate @var{reco}
Return @false{} or the equality predicate of records of the same type as
@var{reco}.
@end deffn


@deffn {Unsafe Operation} $record-comparison-procedure @var{reco}
Return @false{} or the comparison procedure of records of the same type
as @var{reco}.
@end deffn


@deffn {Unsafe Operation} $record-hash-function @var{reco}
Return @false{} or the hash function of records of the same type as
@var{reco}.
@end deffn


@deffn {Unsafe Operation} $record-method-retriever @var{reco}
Return @false{} or the method retriever procedure of records of the same
type as @var{reco}.
@end deffn


@deffn {Unsafe Operation} $record-type-destructor-set! @var{rtd} @var{proc}
@deffnx {Unsafe Operation} $record-type-destructor @var{rtd}
Setter and getter for destructor functions for records of type
@var{rtd}.
@end deffn


@deffn {Unsafe Operation} $record-type-printer-set! @var{rtd} @var{proc}
@deffnx {Unsafe Operation} $record-type-printer @var{rtd}
Setter and getter for printer functions for records of type @var{rtd}.
@end deffn


@deffn {Unsafe Operation} $record-type-equality-predicate-set! @var{rtd} @var{proc}
@deffnx {Unsafe Operation} $record-type-equality-predicate @var{rtd}
Setter and getter for equality predicates for records of type @var{rtd}.
@end deffn


@deffn {Unsafe Operation} $record-type-comparison-procedure-set! @var{rtd} @var{proc}
@deffnx {Unsafe Operation} $record-type-comparison-procedure @var{rtda}
Setter and getter for comparison procedures for records of type
@var{rtd}.
@end deffn


@deffn {Unsafe Operation} $record-type-hash-function-set! @var{rtd} @var{proc}
@deffnx {Unsafe Operation} $record-type-hash-function @var{rtd}
Setter and getter for hash functions for records of type @var{rtd}.
@end deffn


@deffn {Unsafe Operation} $record-type-method-retriever-set! @var{rtd} @var{proc}
@deffnx {Unsafe Operation} $record-type-method-retriever @var{rtd}
Setter and getter for method retriever procedures for records of type
@var{rtd}.
@end deffn

@c page
@node syslib vectors
@section Low level vector operations


@cindex @library{vicare system $vectors}, library
@cindex Library @library{vicare system $vectors}


@menu
* syslib vectors makers::       Vector constructors.
* syslib vectors inspect::      Inspecting vectors.
* syslib vectors access::       Accessors and mutators.
* syslib vectors mapping::      Mapping over vectors.
* syslib vectors copying::      Copying between vectors.
* syslib vectors conversion::   Converting between vectors
                                and other object types.
@end menu

@c page
@node syslib vectors makers
@subsection Vector constructors


The arguments @var{vec} to these operations must be fixnums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the library @library{vicare system $vectors}.


@deffn {Unsafe Operation} $make-vector @var{fx}
Allocate and return a new vector value of @var{fx} elements.

@quotation
@strong{NOTE} This operation does not initialise the data area, leaving
the items set to whatever is on the Scheme heap; this is bad for garbage
collection if the newly built vector is moved before the items are
initialised to correct Scheme values.  We should use the
@func{$make-clean-vector} function.
@end quotation
@end deffn


@deffn {Unsafe Operation} $make-clean-vector @var{fx}
Allocate and return a new vector value of @var{fx} elements; initialise
all the slots to the fixnum zero.
@end deffn


@deffn {Unsafe Operation} $subvector @var{src.vec} @var{src.start} @var{src.end}
Return a new vector holding items from @var{src.vec} from
@var{src.start} inclusive to @var{src.end} exclusive.
@end deffn

@c page
@node syslib vectors inspect
@subsection Inspecting vectors


The arguments @var{vec} to these operations must be fixnums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the library @library{vicare system $vectors}.


@deffn {Unsafe Operation} $vector-length @var{vec}
Evaluate to a fixnum representing the numbe of values in @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-empty? @var{vec}
Return @true{} if the vector @var{vec} has zero length, otherwise return
@false{}.
@end deffn


@deffn {Unsafe Operation} $vectors-of-same-length? @varo{vec} @var{vec} @dots{}
Return @true{} if all the vector arguments have the same length;
otherwise return @false{}.
@end deffn

@c page
@node syslib vectors access
@subsection Accessors and mutators


The arguments @var{vec} to these operations must be fixnums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the library @library{vicare system $vectors}.


@deffn {Unsafe Operation} $vector-ref @var{vec} @var{fx}
Return the value at index @var{fx} in @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-set! @var{vec} @var{fx} @var{value}
Store @var{value} at index @var{fx} in @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-set-void! @var{vec} @var{fx}
Store the void value at index @var{fx} in @var{vec}.
@end deffn

@c page
@node syslib vectors mapping
@subsection Mapping over vectors


The arguments @var{vec} to these operations must be fixnums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the library @library{vicare system $vectors}.


@deffn {Unsafe Operation} $vector-map1 @var{func} @var{vec}
Like @func{vector-map}, but for only one vector argument: build and
return a new vector having the same size of @var{vec} and items equal to
the result of applying @var{func} to the items of @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-for-each1 @var{func} @var{vec}
Like @func{vector-for-each}, but for only one vector argument: apply
@var{func} to all the items of @var{vec} and discard the return values.
@end deffn


@deffn {Unsafe Operation} $vector-for-all1 @var{func} @var{vec}
Like @func{vector-for-all}, but for only one vector argument: return
true if @var{func} returns true for all the items in @var{vec}.  If the
application of @var{func} to the items of @var{vec} returns true up to
the penultimate item, the last application is performed as tail call.
@end deffn


@deffn {Unsafe Operation} $vector-for-exists1 @var{func} @var{vec}
Like @func{vector-exists}, but for only one vector argument: return
@false{} if @var{func} returns @false{} for all the items in @var{vec}.
If the application of @var{func} to the items of @var{vec} returns
@false{} up to the penultimate item, the last application is performed
as tail call.
@end deffn

@c page
@node syslib vectors copying
@subsection Copying between vectors


The arguments @var{vec} to these operations must be fixnums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the library @library{vicare system $vectors}.


@deffn {Unsafe Operation} $vector-self-copy-forwards! @var{vec} @var{src.start} @var{dst.start} @var{count}
Copy @var{count} items of @var{vec} from @var{src.start} inclusive to
@var{vec} itself starting at @var{dst.start} inclusive.  The copy
happens forwards, so it is suitable for the case @var{src.start} greater
than @var{dst.start}.
@end deffn


@deffn {Unsafe Operation} $vector-self-copy-backwards! @var{vec} @var{src.end} @var{dst.end} @var{count}
Copy @var{count} items of @var{vec} from @var{src.end} exclusive to
@var{vec} itself starting at @var{dst.end} exclusive.  The copy happens
backwards, so it is suitable for the case @var{src.end} less than
@var{dst.end}.
@end deffn


@deffn {Unsafe Operation} $vector-copy-source-range! src.vec src.start src.end dst.vec dst.start
Copy items from @var{src.vec} to @var{dst.vec}; return @var{dst.vec}.
Copy the items from the source slots from index @var{src.start}
(inclusive) to @var{src.end} (exclusive), in the destination slots
starting at index @var{dst.start}.
@end deffn


@deffn {Unsafe Operation} $vector-copy-source-count! @var{src.vec} @var{src.start} @var{dst.vec} @var{dst.start} @var{count}
Copy @var{count} items from @var{src.vec} to @var{dst.vec}; return
@var{dst.vec}.  Copy the items the source slots at index @var{src.start}
inclusive, to the destination slots at index @var{dst.start} inclusive.
@end deffn

@c page
@node syslib vectors conversion
@subsection Converting between vectors and other object types


The arguments @var{vec} to these operations must be fixnums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the library @library{vicare system $vectors}.


@deffn {Unsafe Operation} $fill-vector-from-list! @var{vec} @var{start} @var{ls}
Fill the vector @var{vec} with items from the proper list @var{ls},
starting at index @var{start}.
@end deffn

@c page
@node syslib bytevectors
@section Low level bytevector operations


@cindex @library{vicare system $bytevectors}, library
@cindex Library @library{vicare system $bytevectors}


The low--level bindings are exported by the library @library{vicare
system $bytevectors}.

@menu
* syslib bytevectors constructors::  Constructors.
* syslib bytevectors predicates::    Predicates.
* syslib bytevectors comparison::    Comparison.
* syslib bytevectors inspection::    Inspection.
* syslib bytevectors accessors::     Accessors and mutators.
* syslib bytevectors copying::       Copying.
* syslib bytevectors concatenating:: Concatenating.
* syslib bytevectors encodings::     Encodings.
@end menu

@c page
@node syslib bytevectors constructors
@subsection Constructors


@deffn {Unsafe Operation} $make-bytevector @var{fx}
Allocate a new bytevector capable of holding @var{fx} bytes and return a
reference to it.  @var{fx} must be a non--negative fixnum.
@end deffn


@defun $subbytevector-u8 @var{bv} @var{start} @var{end}
@defunx $subbytevector-s8 @var{bv} @var{start} @var{end}
Build and return a new bytevector holding octets or bytes from the
bytevector @var{bv} starting from index @var{start} inclusive to index
@var{end} exclusive.
@end defun


@defun $subbytevector-u8/count @var{bv} @var{start} @var{count}
@defunx $subbytevector-s8/count @var{bv} @var{start} @var{count}
Build and return a new bytevector holding @var{count} octets or bytes
from the bytevector @var{bv} starting from index @var{start} inclusive.
@end defun

@c page
@node syslib bytevectors predicates
@subsection Predicates


@deffn {Unsafe Operation} $bytevector-empty? @var{bv}
Return @true{} if the bytevector @var{bv} has zero length, otherwise
return @false{}.
@end deffn

@c page
@node syslib bytevectors comparison
@subsection Comparison


@defun $bytevector= @vari{bv} @varii{bv}
Return @true{} if the bytevector arguments are equal, byte by byte;
otherwise return @false{}.
@end defun


@defun $bytevector!= @vari{bv} @varii{bv}
The arguments must be bytevectors.  Return @true{} if the arguments are
different; otherwise return @false{}.
@end defun


@defun $bytevector-u8< @vari{bv} @varii{bv}
@defunx $bytevector-u8> @vari{bv} @varii{bv}
@defunx $bytevector-u8<= @vari{bv} @varii{bv}
@defunx $bytevector-u8>= @vari{bv} @varii{bv}
These procedures are the extensions to bytevectors of the corresponding
orderings on unsigned fixnums; the bytevectors are compared octet by
octet.
@end defun


@defun $bytevector-s8< @vari{bv} @varii{bv}
@defunx $bytevector-s8> @vari{bv} @varii{bv}
@defunx $bytevector-s8<= @vari{bv} @varii{bv}
@defunx $bytevector-s8>= @vari{bv} @varii{bv}
These procedures are the extensions to bytevectors of the corresponding
orderings on signed fixnums; the bytevectors are compared byte by byte.
@end defun


@defun $bytevector-u8-max @vari{bv} @varii{bv}
@defunx $bytevector-u8-min @vari{bv} @varii{bv}
Return the maximal or minimal bytevector argument according to
@func{$bytevector-u8<}.
@end defun


@defun $bytevector-s8-max @vari{bv} @varii{bv}
@defunx $bytevector-s8-min @vari{bv} @varii{bv}
Return the maximal or minimal bytevector argument according to
@func{$bytevector-s8<}.
@end defun

@c page
@node syslib bytevectors inspection
@subsection Inspection


@deffn {Unsafe Operation} $bytevector-length @var{bv}
Return a fixnum representing the number of bytes in the bytevector
@var{bv}.
@end deffn

@c page
@node syslib bytevectors accessors
@subsection Accessors and mutators


@menu
* syslib bytevectors accessors 8-bit::   8-bit setters and getters.
* syslib bytevectors accessors 16-bit::  16-bit setters and getters.
* syslib bytevectors accessors 32-bit::  32-bit setters and getters.
* syslib bytevectors accessors 64-bit::  64-bit setters and getters.
* syslib bytevectors accessors single::  Single-precision @ieee{} flonum
                                         setters and getters.
* syslib bytevectors accessors double::  Double-precision @ieee{} flonum
                                         setters and getters.
@end menu

@c page
@node syslib bytevectors accessors 8-bit
@subsubsection 8-bit setters and getters


For these operations: the argument @var{bv} is a bytevector object; the
argument @var{fx-idx} is a non--negative fixnum representing an index in
the bytevector; @var{fx-val} is a fixnum representing a value to be
stored in a bytevector.


@deffn {Unsafe Operation} $bytevector-u8-ref @var{bv} @var{fx-idx}
Return a fixnum representing the octet at offset @var{fx-idx} in
@var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-s8-ref @var{bv} @var{fx-idx}
Return a fixnum representing the byte at offset @var{fx-idx} in
@var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-set! @var{bv} @var{fx-idx} @var{fx-value}
@deffnx {Unsafe Operation} $bytevector-u8-set! @var{bv} @var{fx-idx} @var{fx-value}
@deffnx {Unsafe Operation} $bytevector-s8-set! @var{bv} @var{fx-idx} @var{fx-value}
Store the octet or byte @var{fx-value} at index @var{fx-idx} of
@var{bv}.
@end deffn

@c page
@node syslib bytevectors accessors 16-bit
@subsubsection 16-bit setters and getters


About 16-bit words, we have to remember the following memory layouts:

@example
           |            | lowest memory | highest memory
endianness |    word    | location      | location
-----------+------------+---------------+--------------
  little   |   #xHHLL   |     LL        |     HH
   big     |   #xHHLL   |     HH        |     LL
@end example

For these operations: the argument @var{bv} is a bytevector object; the
argument @var{fx-idx} is a non--negative fixnum representing an octet
index in the bytevector; @var{fx-val} is a fixnum representing a value
to be stored in a bytevector.

@quotation
@strong{NOTE} For these operations: the index @var{fx-idx} does
@strong{not} need to be aligned to a multiple of @math{2}.
@end quotation


@defun $bytevector-u16l-ref @var{bv} @var{fx-idx}
@defunx $bytevector-u16l-set! @var{bv} @var{fx-idx} @var{fx-val}
Setter and getter for unsigned little--endian 16-bit words.
@end defun


@defun $bytevector-u16b-ref @var{bv} @var{fx-idx}
@defunx $bytevector-u16b-set! @var{bv} @var{fx-idx} @var{fx-val}
Setter and getter for unsigned big--endian 16-bit words.
@end defun


@defun $bytevector-u16n-ref @var{bv} @var{fx-idx}
@defunx $bytevector-u16n-set! @var{bv} @var{fx-idx} @var{fx-val}
Setter and getter for unsigned native--endian 16-bit words.
@end defun


@defun $bytevector-s16l-ref @var{bv} @var{fx-idx}
@defunx $bytevector-s16l-set! @var{bv} @var{fx-idx} @var{fx-val}
Setter and getter for signed little--endian 16-bit words.
@end defun


@defun $bytevector-s16b-ref @var{bv} @var{fx-idx}
@defunx $bytevector-s16b-set! @var{bv} @var{fx-idx} @var{fx-val}
Setter and getter for signed big--endian 16-bit words.
@end defun


@defun $bytevector-s16n-ref @var{bv} @var{fx-idx}
@defunx $bytevector-s16n-set! @var{bv} @var{fx-idx} @var{fx-val}
Setter and getter for signed native--endian 16-bit words.
@end defun


@defun $bytevector-u16-ref @var{bv} @var{fx-idx} @var{endianness}
@defunx $bytevector-u16-set! @var{bv} @var{fx-idx} @var{fx-val} @var{endianness}
Setter and getter for unsigned 16-bit words.  @var{endianness} must be a
symbol among: @samp{big}, @samp{little}, @samp{native}.
@end defun


@defun $bytevector-s16-ref @var{bv} @var{fx-idx} @var{endianness}
@defunx $bytevector-s16-set! @var{bv} @var{fx-idx} @var{fx-val} @var{endianness}
Setter and getter for signed 16-bit words.  @var{endianness} must be a
symbol among: @samp{big}, @samp{little}, @samp{native}.
@end defun

@c page
@node syslib bytevectors accessors 32-bit
@subsubsection 32-bit setters and getters


About 32-bit words, we have to remember the following memory layouts:

@example
                          lowest memory ------------> highest memory
endianness |    word    | 1st byte | 2nd byte | 3rd byte | 4th byte
-----------+------------+----------+----------+----------+----------
  little   | #xAABBCCDD |   DD     |    CC    |    BB    |    AA
   big     | #xAABBCCDD |   AA     |    BB    |    CC    |    DD
bit offset |            |    0     |     8    |    16    |    24
@end example

For these operations: the argument @var{bv} is a bytevector object; the
argument @var{fx-idx} is a non--negative fixnum representing an octet
index in the bytevector; @var{ei-val} is a fixnum or bignum representing
a value to be stored in a bytevector.

@quotation
@strong{NOTE} For these operations: the index @var{fx-idx} does
@strong{not} need to be aligned to a multiple of @math{4}.
@end quotation


@defun $bytevector-u32l-ref @var{bv} @var{fx-idx}
@defunx $bytevector-u32l-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for unsigned little--endian 32-bit words.
@end defun


@defun $bytevector-u32b-ref @var{bv} @var{fx-idx}
@defunx $bytevector-u32b-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for unsigned big--endian 32-bit words.
@end defun


@defun $bytevector-u32n-ref @var{bv} @var{fx-idx}
@defunx $bytevector-u32n-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for unsigned native--endian 32-bit words.
@end defun


@defun $bytevector-s32l-ref @var{bv} @var{fx-idx}
@defunx $bytevector-s32l-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for signed little--endian 32-bit words.
@end defun


@defun $bytevector-s32b-ref @var{bv} @var{fx-idx}
@defunx $bytevector-s32b-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for signed big--endian 32-bit words.
@end defun


@defun $bytevector-s32n-ref @var{bv} @var{fx-idx}
@defunx $bytevector-s32n-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for signed native--endian 32-bit words.
@end defun


@defun $bytevector-u32-ref @var{bv} @var{fx-idx} @var{endianness}
@defunx $bytevector-u32-set! @var{bv} @var{fx-idx} @var{ei-val} @var{endianness}
Setter and getter for unsigned 32-bit words.  @var{endianness} must be a
symbol among: @samp{big}, @samp{little}, @samp{native}.
@end defun


@defun $bytevector-s32-ref @var{bv} @var{fx-idx} @var{endianness}
@defunx $bytevector-s32-set! @var{bv} @var{fx-idx} @var{ei-val} @var{endianness}
Setter and getter for signed 32-bit words.  @var{endianness} must be a
symbol among: @samp{big}, @samp{little}, @samp{native}.
@end defun

@c page
@node syslib bytevectors accessors 64-bit
@subsubsection 64-bit setters and getters


About 64-bit words, we have to remember the following memory layouts:

@example
                                     lowest memory ------------> highest memory
endianness |         word        | 1st | 2nd | 3rd | 4th | 5th | 6th | 7th | 8th
-----------+---------------------+-----+-----+-----+-----+-----+-----+-----+-----
  little   | #xAABBCCDD EEFFGGHH | HH  | GG  | FF  | EE  | DD  | CC  | BB  | AA
   big     | #xAABBCCDD EEFFGGHH | AA  | BB  | CC  | DD  | EE  | FF  | GG  | HH
bit offset |                     |  0  |  8  | 16  | 24  | 32  | 40  | 48  | 56
@end example

For these operations: the argument @var{bv} is a bytevector object; the
argument @var{fx-idx} is a non--negative fixnum representing an octet
index in the bytevector; @var{ei-val} is a fixnum or bignum representing
a value to be stored in a bytevector.

@quotation
@strong{NOTE} For these operations: the index @var{fx-idx} does
@strong{not} need to be aligned to a multiple of @math{8}.
@end quotation


@defun $bytevector-u64l-ref @var{bv} @var{fx-idx}
@defunx $bytevector-u64l-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for unsigned little--endian 64-bit words.
@end defun


@defun $bytevector-u64b-ref @var{bv} @var{fx-idx}
@defunx $bytevector-u64b-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for unsigned big--endian 64-bit words.
@end defun


@defun $bytevector-u64n-ref @var{bv} @var{fx-idx}
@defunx $bytevector-u64n-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for unsigned native--endian 64-bit words.
@end defun


@defun $bytevector-s64l-ref @var{bv} @var{fx-idx}
@defunx $bytevector-s64l-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for signed little--endian 64-bit words.
@end defun


@defun $bytevector-s64b-ref @var{bv} @var{fx-idx}
@defunx $bytevector-s64b-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for signed big--endian 64-bit words.
@end defun


@defun $bytevector-s64n-ref @var{bv} @var{fx-idx}
@defunx $bytevector-s64n-set! @var{bv} @var{fx-idx} @var{ei-val}
Setter and getter for signed native--endian 64-bit words.
@end defun


@defun $bytevector-u64-ref @var{bv} @var{fx-idx} @var{endianness}
@defunx $bytevector-u64-set! @var{bv} @var{fx-idx} @var{ei-val} @var{endianness}
Setter and getter for unsigned 64-bit words.  @var{endianness} must be a
symbol among: @samp{big}, @samp{little}, @samp{native}.
@end defun


@defun $bytevector-s64-ref @var{bv} @var{fx-idx} @var{endianness}
@defunx $bytevector-s64-set! @var{bv} @var{fx-idx} @var{ei-val} @var{endianness}
Setter and getter for signed 64-bit words.  @var{endianness} must be a
symbol among: @samp{big}, @samp{little}, @samp{native}.
@end defun

@c page
@node syslib bytevectors accessors single
@subsubsection Single--precision @ieee{} flonum setters and getters


For these operations: the argument @var{bv} is a bytevector object; the
argument @var{fx-idx} is a non--negative fixnum representing an octet
index in the bytevector; @var{fl} is a flonum representing a value to be
stored in a bytevector.

@quotation
@strong{NOTE} For these operations: the index @var{fx-idx} does
@strong{not} need to be aligned to a multiple of @math{4}.
@end quotation


@defun $bytevector-ieee-single-big-ref @var{bv} @var{fx-idx}
@defunx $bytevector-ieee-single-big-set! @var{bv} @var{fx-idx} @var{fl}
Setter and getter for single--precision @ieee{} flonums under big
endianness.
@end defun


@defun $bytevector-ieee-single-little-ref @var{bv} @var{fx-idx}
@defunx $bytevector-ieee-single-little-set! @var{bv} @var{fx-idx} @var{fl}
Setter and getter for single--precision @ieee{} flonums under little
endianness.
@end defun


@deffn {Unsafe Operation} $bytevector-ieee-single-native-ref @var{bv} @var{fx-idx}
@deffnx {Unsafe Operation} $bytevector-ieee-single-native-set! @var{bv} @var{fx-idx} @var{fl}
Setter and getter for single--precision @ieee{} flonums under native
endianness.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-single-nonnative-ref @var{bv} @var{fx-idx}
@deffnx {Unsafe Operation} $bytevector-ieee-single-nonnative-set! @var{bv} @var{fx-idx} @var{fl}
Setter and getter for single--precision @ieee{} flonums under
non--native endianness.
@end deffn


@defun $bytevector-ieee-single-ref @var{bv} @var{fx-idx} @var{endianness}
@defunx $bytevector-ieee-single-set! @var{bv} @var{fx-idx} @var{ei-val} @var{endianness}
Setter and getter for single--precision @ieee{} flonums.
@var{endianness} must be a symbol among: @samp{big}, @samp{little},
@samp{native}.
@end defun

@c page
@node syslib bytevectors accessors double
@subsubsection Double--precision @ieee{} flonum setters and getters


For these operations: the argument @var{bv} is a bytevector object; the
argument @var{fx-idx} is a non--negative fixnum representing an octet
index in the bytevector; @var{fl} is a flonum representing a value to be
stored in a bytevector.

@quotation
@strong{NOTE} For these operations: the index @var{fx-idx} does
@strong{not} need to be aligned to a multiple of @math{8}.
@end quotation


@defun $bytevector-ieee-double-big-ref @var{bv} @var{fx-idx}
@defunx $bytevector-ieee-double-big-set! @var{bv} @var{fx-idx} @var{fl}
Setter and getter for double--precision @ieee{} flonums under big
endianness.
@end defun


@defun $bytevector-ieee-double-little-ref @var{bv} @var{fx-idx}
@defunx $bytevector-ieee-double-little-set! @var{bv} @var{fx-idx} @var{fl}
Setter and getter for double--precision @ieee{} flonums under little
endianness.
@end defun


@deffn {Unsafe Operation} $bytevector-ieee-double-native-ref @var{bv} @var{fx-idx}
@deffnx {Unsafe Operation} $bytevector-ieee-double-native-set! @var{bv} @var{fx-idx} @var{fl}
Setter and getter for double--precision @ieee{} flonums under native
endianness.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-double-nonnative-ref @var{bv} @var{fx-idx}
@deffnx {Unsafe Operation} $bytevector-ieee-double-nonnative-set! @var{bv} @var{fx-idx} @var{fl}
Setter and getter for double--precision @ieee{} flonums under
non--native endianness.
@end deffn


@defun $bytevector-ieee-double-ref @var{bv} @var{fx-idx} @var{endianness}
@defunx $bytevector-ieee-double-set! @var{bv} @var{fx-idx} @var{ei-val} @var{endianness}
Setter and getter for double--precision @ieee{} flonums.
@var{endianness} must be a symbol among: @samp{big}, @samp{little},
@samp{native}.
@end defun

@c page
@node syslib bytevectors copying
@subsection Copying


For these operations, the arguments have the following meaning:

@table @var
@item src.bv
The source bytevector.

@item src.start
A non--negative fixnum representing the inclusive start index in the
source bytevector @var{src.bv}.

@item src.end
A non--negative fixnum representing the exclusive end index in the
source bytevector @var{src.bv}.

@item dst.bv
The destination bytevector.

@item dst.start
A non--negative fixnum representing the inclusive start index in the
destination bytevector @var{dst.bv}.

@item dst.end
A non--negative fixnum representing the exclusive end index in the
destination bytevector @var{src.bv}.
@end table


@defun $bytevector-copy @var{bv}
Build and return a copy of the bytevector @var{bv}.
@end defun


@defun {$bytevector-copy!} @var{src.bv} @var{src.start} @var{dst.bv} @var{dst.start} @var{src.end}
Copy the bytes of @var{src.bv} from @var{src.start} inclusive to
@var{src.end} exclusive, to @var{dst.bv} starting at @var{dst.start}
inclusive.
@end defun


@defun $bytevector-copy!/count @var{src.bv} @var{src.start} @var{dst.bv} @var{dst.start} @var{count}
Copy @var{count} bytes from @var{src.bv} starting at @var{src.start}
inclusive to @var{dst.bv} starting at @var{dst.start} inclusive.
@end defun


@defun $bytevector-self-copy-forwards!/count @var{bv} @var{src.start} @var{dst.start} @var{count}
Copy @var{count} bytes of @var{bv} from @var{src.start} inclusive
to @var{bv} itself starting at @var{dst.start} inclusive.  The copy
happens forwards, so it is suitable for the case:

@example
@var{src.start} > @var{dst.start}
@end example
@end defun


@defun $bytevector-self-copy-backwards!/count @var{bv} @var{src.start} @var{dst.start} @var{count}
Copy @var{count} bytes of @var{bv} from @var{src.start} inclusive
to @var{bv} itself starting at @var{dst.start} inclusive.  The copy
happens backwards, so it is suitable for the case:

@example
@var{src.start} < @var{dst.start}
@end example
@end defun

@c page
@node syslib bytevectors concatenating
@subsection Concatenating


@defun $bytevector-total-length @var{init-fx} @var{bvs}
Given the list of bytevectors @var{bvs}: compute the total length of the
bytevectors, add it to the fixnum @var{init-fx} and return the result.
If @var{init-fx} is zero: the returned value is the total length of the
bytevectors in @var{bvs}.  The returned value may or may not be in the
range of the maximum bytevector size: it may or may not be a fixnum.
@end defun


@defun $bytevector-concatenate @var{total-len-fx} @var{bvs}
Concatenate the bytevectors in the list @var{bvs}, return the result.
The resulting bytevector must have length represented by the
non--negative fixnum @var{total-len-fx}.
@end defun


@defun $bytevector-reverse-and-concatenate @var{total-len-fx} @var{bvs}
Reverse the list of bytevectors @var{bvs} and concatenate its items;
return the result.  The resulting bytevector must have length
represented by the non--negative fixnum @var{total-len-fx}.
@end defun

@c page
@node syslib bytevectors encodings
@subsection Encodings


@defun $octets-encoded-bytevector? @var{bv}
Always return @true{}.
@end defun


@defun $ascii-encoded-bytevector? @var{bv}
Return @true{} if @var{bv} can be interpreted as an @ascii{} encoded
string, otherwise return @false{}.  An octet @var{chi} is considered an
@ascii{} code point if:

@example
(<= #x00 @var{chi} #x7F)      @result{} #t
@end example
@end defun


@defun $latin1-encoded-bytevector? @var{bv}
Return @true{} if @var{bv} can be interpreted as a Latin-1 encoded
string, otherwise return @false{}.  An octet @var{chi} is considered a
Latin1 code point if:

@example
(or (<= #x20 @var{chi} #x7E)
    (<= #xA0 @var{chi} #xFF))
@result{} #t
@end example
@end defun


@defun $uri-encode @var{bv}
@defunx $uri-decode @var{bv}
Encode or decode a bytevector @var{bv} according to @rfc{} 3986 @uri{}
percent encoding; return a bytevector.  All the octets are encoded
except the ones having the following @ascii{} representation:

@example
ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
-._~
@end example
@end defun


@defun $uri-normalise-encoding @var{bv}
Given a bytevector @var{bv} encoded according to to @rfc{} 3986 @uri{}
percent encoding: return an encoded and normalised bytevector, octets
that are encoded but should not are decoded.
@end defun


@defun $uri-encoded-bytevector? @var{bv}
@defunx $percent-encoded-bytevector? @var{bv}
Return @true{} if the argument is a correctly percent--encoded
bytevector according to @rfc{} 3986.
@end defun


@defun $base64->bytevector @var{bv}
@defunx $bytevector->base64 @var{bv}
Convert to and from a Scheme bytevector containing octets and a Scheme
bytevector containing the @ascii{} Base64 representation of the octets.
If an error occurs in the conversion: the return value is @false{}.
@end defun

@c page
@node syslib strings
@section Low level string operations


@cindex @library{vicare system $strings}, library
@cindex Library @library{vicare system $strings}


The arguments @var{str} to these operations must be references to
strings, the arguments @var{fx} must be fixnums in the appropriate
range, the arguments @var{ch} must be characters.  The following
bindings are exported by the library @library{vicare system $strings}.

@c ------------------------------------------------------------------------

@subsubheading Constructors

@deffn {Unsafe Operation} $make-string @var{fx}
Allocate a new string capable of holding @var{fx} characters and return
a reference to it.
@end deffn


@deffn {Unsafe Operation} $string @var{ch} @dots{}
Allocate a new string and initialise it with the given characters.
@end deffn


@defun $string-copy @var{str}
Build and return a newly allocated string holding the same characters of
@var{str}.
@end defun


@defun {$string-copy!} @var{src.str} @var{src.start} @var{dst.str} @var{dst.start} @var{src.end}
Copy the characters of @var{src.str} from @var{src.start} inclusive to
@var{src.end} exclusive, to @var{dst.str} starting at @var{dst.start}
inclusive.
@end defun


@defun $string-copy!/count @var{src.str} @var{src.start} @var{dst.str} @var{dst.start} @var{count}
Copy @var{count} characters from @var{src.str} starting at
@var{src.start} inclusive to @var{dst.str} starting at @var{dst.start}
inclusive.
@end defun


@defun $string-self-copy-forwards!/count @var{str} @var{src.start} @var{dst.start} @var{count}
Copy @var{count} characters of @var{str} from @var{src.start} inclusive
to @var{str} itself starting at @var{dst.start} inclusive.  The copy
happens forwards, so it is suitable for the case @code{@var{src.start} >
@var{dst.start}}.
@end defun


@defun $string-self-copy-backwards!/count @var{str} @var{src.start} @var{dst.start} @var{count}
Copy @var{count} characters of @var{str} from @var{src.start} inclusive
to @var{str} itself starting at @var{dst.start} inclusive.  The copy
happens backwards, so it is suitable for the case @code{@var{src.start}
< @var{dst.start}}.
@end defun


@defun $substring @var{str} @var{start} @var{end}
Build and return a newly allocated string holding the range of character
between @var{start} (inclusive) and @var{end} (exclusive).
@end defun


@defun $string-concatenate @var{total-len} @var{strs}
Concatenate the strings in the list @var{strs}, return the result.  The
resulting string must have length @var{total-len}.  Assume the arguments
have been already validated.
@end defun


@defun $string-reverse-and-concatenate @var{total-len} @var{strs}
Reverse the list of strings @var{strs} and concatenate its items; return
the result.  The resulting string must have length @var{total-len}.
Assume the arguments have been already validated.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Accessors and mutators

@deffn {Unsafe Operation} $string-ref @var{str} @var{fx}
Return the character at offset @var{fx} in @var{str}.
@end deffn


@deffn {Unsafe Operation} $string-set! @var{str} @var{fx} @var{ch}
Store @var{ch} at index @var{fx} of @var{str}.
@end deffn


@defun $string-fill! @var{str} @var{start} @var{end} @var{fill}
Fill the positions in @var{str} from @var{start} inclusive to @var{end}
exclusive with @var{fill}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Inspection

@deffn {Unsafe Operation} $string-length @var{str}
Return a fixnum representing the length of the operand.
@end deffn


@defun $string-total-length @var{init-len} @var{strs}
Given the list of strings @var{strs}: compute the total length of the
strings, add it to @var{init-len} and return the result.  If
@var{init-len} is zero: the returned value is the total length of the
strings in @var{strs}.  The returned value may or may not be in the
range of the maximum string size.
@end defun


@deffn {Unsafe Operations} $string-empty? @var{str}
Return @true{} if the string @var{str} is empty, otherwise return
@false{}.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Comparison


@deffn {Unsafe Operation} $string= @vari{str} @varii{str}
Return @true{} if @vari{str} and @varii{str} represent the same string;
otherwise return @false{}.
@end deffn


@defun $string!=? @vari{str} @varii{str}
The arguments must be booleans.  Return @true{} if the arguments are
different; otherwise return @false{}.
@end defun


@deffn {Unsafe Operation} $string< @vari{str} @varii{str}
@deffnx {Unsafe Operation} $string> @vari{str} @varii{str}
@deffnx {Unsafe Operation} $string<= @vari{str} @varii{str}
@deffnx {Unsafe Operation} $string>= @vari{str} @varii{str}
Dyadic lexicographic comparison functions for strings.  Return @true{}
if @vari{str} and @varii{str} compare as the name implies; otherwise
return @false{}.
@end deffn


@defun $string-max @vari{str} @varii{str}
@defunx $string-min @vari{str} @varii{str}
Return the maximal or minimal string argument according to
@func{$string<}.
@end defun

@c ------------------------------------------------------------

@subsubheading Conversion function

@deffn {Unsafe Operation} $fixnum->string @var{fx} @var{base}
Return a string object representing @var{fx} in @var{base}.  @var{base}
must be one among: @math{2}, @math{8}, @math{10}, @math{16}.
@end deffn


@defun $string->latin1 @var{string}
@defunx $latin1->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
Latin-1 encoding of the characters.  If a character in @var{string} is
out of range: raise an exception; this validation is @strong{not}
removed when arguments validation is disabled.
@end defun


@defun $string->octets @var{string}
@defunx $octets->string @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector holding the
raw octets encoding of the characters.  Octets are converted to
characters with @func{$fixnum->char}; characters are converted to octets
with @func{$char->fixnum}.  Raise an exception if the conversion is not
possible; this validation is @strong{not} removed when arguments
validation is disabled.
@end defun


@defun $string->ascii @var{string}
@defunx $ascii->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
@ascii{} encoding of the characters.  If a character in @var{string} is
out of range: raise an exception; this validation is @strong{not}
removed when arguments validation is disabled.
@end defun


@defun $octets-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as an octets encoded
string, otherwise return @false{}.  A character is considered
octets--encoded if its integer representation @var{chi} satisfies:

@example
(<= 0 @var{chi} 255)      @result{} #t
@end example
@end defun


@defun $ascii-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as an @ascii{} encoded
string, otherwise return @false{}.  A character is considered an
@ascii{} code point if its integer representation @var{chi} satisfies:

@example
(<= #x00 @var{chi} #x7F)      @result{} #t
@end example
@end defun


@defun $latin1-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as a Latin1 encoded
string, otherwise return @false{}.  A character in the string is
considered a Latin1 code point if its integer representation @var{chi}
satisfies:

@example
(or (<= #x20 @var{chi} #x7E)
    (<= #xA0 @var{chi} #xFF))
@result{} #t
@end example
@end defun


@defun $string-base64->bytevector @var{string}
@defunx $bytevector->string-base64 @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector.  The input
string contains the @ascii{} Base64 representation of the octets.  The
output string contains the @ascii{} Base64 representation of octets.  If
an error occurs in the conversion: an exception is raised.
@end defun


@defun $uri-encoded-string? @var{string}
@defunx $percent-encoded-string? @var{string}
Return @true{} if the argument is correctly percent--encoded string
according to @rfc{} 3986.  This means every character in the string is
associated to a character in the @ascii{} encoding and additionally the
constraints of @rfc{} 3986 are satisfied.

If the characters in @var{string} are invalid: raise an exception; this
validation is @strong{not} removed when arguments validation is
disabled.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Miscellaneous functions

@deffn {Unsafe Operation} $interned-strings
Return a vector holding the currently interned strings.
@end deffn

@c page
@node syslib ports
@section Low level port structures


@cindex @library{vicare system $io}, library
@cindex Library @library{vicare system $io}


The following bindings are exported by the library @library{vicare
system $io}.


@defun port? @var{obj}
Return true if @var{obj} is the reference to a port structure; return
false otherwise.
@end defun


@deffn {Unsafe Operation} $make-port @var{attrs} @var{idx} @var{sz} @var{buf} @var{tr} @var{id} @var{read} @var{write} @var{getp} @var{setp} @var{cl} @var{cookie}
Allocate a new port structure, initialise its fields with the arguments,
return a reference to it.
@end deffn


@deffn {Unsafe Operation} $port-index @var{port}
@deffnx {Unsafe Operation} $port-size @var{port}
@deffnx {Unsafe Operation} $port-buffer @var{port}
@deffnx {Unsafe Operation} $port-transcoder @var{port}
@deffnx {Unsafe Operation} $port-id @var{port}
@deffnx {Unsafe Operation} $port-read! @var{port}
@deffnx {Unsafe Operation} $port-write! @var{port}
@deffnx {Unsafe Operation} $port-get-position @var{port}
@deffnx {Unsafe Operation} $port-set-position! @var{port}
@deffnx {Unsafe Operation} $port-close @var{port}
@deffnx {Unsafe Operation} $port-cookie @var{port}
Accessors for the fields of a port structure.
@end deffn


@deffn {Unsafe Operation} $port-attrs @var{port}
Given a port value: return a fixnum representing the port attributes.
@end deffn


@deffn {Safe Operation} $port-tag @var{port}
Extract from a port reference a fixnum representing the port attributes;
if the argument is not a port reference the return value is zero.
@end deffn


@deffn {Unsafe Operation} $set-port-index! @var{port} @var{new-index}
Mutator for the buffer index field.
@end deffn


@deffn {Unsafe Operation} $set-port-size! @var{port} @var{new-used-size}
Mutator for the buffer used size field.
@end deffn


@deffn {Unsafe Operation} $set-port-attrs! @var{port} @var{new-attrs}
Mutator for the port attributes.
@end deffn

@c page
@node syslib transcoders
@section Low level transcoder operations


@cindex @library{vicare system $transcoders}, library
@cindex Library @library{vicare system $transcoders}


The arguments @var{tran} to these operations must be transcoders, the
arguments @var{fx} must be fixnums in the appropriate range.  The
following bindings are exported by the library @library{vicare system
$transcoders}.


@deffn {Unsafe Operation} $data->transcoder @var{fx}
Encode @var{fx} as payload bits of a transcoder word and return the
resulting transcoder.
@end deffn


@deffn {Unsafe Operation} $transcoder->data @var{tran}
Extract the payload bits from a transcoder and return them as fixnum.
@end deffn


@deffn {Unsafe Operation} $transcoder= @vari{tran} @varii{tran}
@deffnx {Unsafe Operation} $transcoder!= @vari{tran} @varii{tran}
@deffnx {Unsafe Operation} $transcoder< @vari{tran} @varii{tran}
@deffnx {Unsafe Operation} $transcoder> @vari{tran} @varii{tran}
@deffnx {Unsafe Operation} $transcoder<= @vari{tran} @varii{tran}
@deffnx {Unsafe Operation} $transcoder>= @vari{tran} @varii{tran}
Compare the given transcoders and return @true{} or @false{}.
@end deffn


@deffn {Unsafe Operation} $transcoder-min @vari{tran} @varii{tran}
@deffnx {Unsafe Operation} $transcoder-max @vari{tran} @varii{tran}
Return the minimum or maximum transcoder among the arguments.
@end deffn

@c page
@node syslib pointers
@section Low level pointer operations


@cindex @library{vicare system $pointers}, library
@cindex Library @library{vicare system $pointers}


In the following definitions the @var{ptr} arguments must be pointer
objects.  The following bindings are exported by the library
@library{vicare system $pointers}.

@c ------------------------------------------------------------------------

@subsubheading Comparison


@deffn {Unsafe Operation} $pointer= @vari{ptr} @varii{ptr}
Return @true{} if @vari{ptr} and @varii{ptr} are equal, else return
@false{}.
@end deffn


@defun $pointer!=? @vari{ptr} @varii{ptr}
The arguments must be pointers.  Return @true{} if the arguments are
different; otherwise return @false{}.
@end defun


@deffn {Unsafe Operation} $pointer< @vari{ptr} @varii{ptr}
@deffnx {Unsafe Operation} $pointer> @vari{ptr} @varii{ptr}
@deffnx {Unsafe Operation} $pointer<= @vari{ptr} @varii{ptr}
@deffnx {Unsafe Operation} $pointer>= @vari{ptr} @varii{ptr}
Dyadic lexicographic comparison functions for pointers.  Return @true{}
if @vari{ptr} and @varii{ptr} compare as the name implies; otherwise
return @false{}.
@end deffn


@defun $pointer-max @vari{ptr} @varii{ptr}
@defunx $pointer-min @vari{ptr} @varii{ptr}
Return the maximal or minimal pointer argument according to
@func{$pointer<}.
@end defun

@c page
@node syslib hashtables
@section Low level hashtable objects operations


@cindex @library{vicare system $hashtables}, library
@cindex Library @library{vicare system $hashtables}


The following bindings are exported by the library @library{vicare
system $hashtables}.


@deffn {Unsafe Operation} $string-hash @var{string}
@deffnx {Unsafe Operation} $string-hash @var{string} @var{max-len}
Return an integer hash value for @var{string}, based on its current
contents.  This hash function is suitable for use with @func{string=?}
as an equivalence function.

About the @var{max-len} argument:

@itemize
@item
When @var{max-len} is a non--negative fixnum: it is the maximum number
of characters to use to compute the hash value, starting from the
beginning of @var{string}.  If the length of @var{string} is greater
than @var{max-len}: only the first @var{max-len} characters are used.
If the length of @var{string} is less than or equal to @var{max-len}:
all the bytes in @var{string} are used.

@item
When @var{max-len} is @false{} or not used: if the length of
@var{string} is greater than @math{64} characters, only the first
@math{64} bytes are used to compute the hash.

@item
When @var{max-len} is @true{}: all the bytes in @var{string} are used.
@end itemize

@strong{NOTE} When the hash value is computed using a number of
characters @math{N} less than the string length: applications
@strong{must not} assume that two strings having the first @math{N}
characters equal will have the same hash value.
@end deffn


@deffn {Unsafe Operation} $string-ci-hash @var{string}
@deffnx {Unsafe Operation} $string-ci-hash @var{string} @var{max-len}
Return an integer hash value for @var{string} based on its current
contents, ignoring case.  This hash function is suitable for use with
@func{string-ci=?} as an equivalence function.

The optional argument @var{max-len} is used as in @func{$string-hash}.
@end deffn


@deffn {Unsafe Operation} $symbol-hash @var{symbol}
Return an integer hash value for @var{symbol}.
@end deffn


@deffn {Unsafe Operation} $bytevector-hash @var{bytevector}
@deffnx {Unsafe Operation} $bytevector-hash @var{bytevector} @var{max-len}
Return an integer hash value for @var{bytevector}, based on its current
contents.  This hash function is suitable for use with
@func{bytevector=?} as an equivalence function.

About the @var{max-len} argument:

@itemize
@item
When @var{max-len} is a non--negative fixnum: it is the maximum number
of bytes to use to compute the hash value, starting from the beginning
of @var{bv}.  If the length of @var{bv} is greater than @var{max-len}:
only the first @var{max-len} bytes are used.  If the length of @var{bv}
is less than or equal to @var{max-len}: all the bytes in @var{bv} are
used.

@item
When @var{max-len} is @false{} or not present: if the length of @var{bv}
is greater than @math{256} bytes, only the first @math{256} bytes are
used to compute the hash.

@item
When @var{max-len} is @true{}: all the bytes in @var{bv} are used.
@end itemize

@strong{NOTE} When the hash value is computed using a number of bytes
@math{N} less than the bytevector length: applications @strong{must not}
assume that two bytevectors having the first @math{N} bytes equal will
have the same hash value.
@end deffn


@deffn {Unsafe Operation} $vector-hash @var{vec}
@deffnx {Unsafe Operation} $vector-hash @var{vec} @var{max-len}
Return a non--negative fixnum representing the hash value for @var{vec},
based on its current contents.  When creating hash tables using vectors
as keys: this hash function is suitable for use with @func{vector=?}  as
an equivalence function.

About the @var{max-len} argument:

@itemize
@item
When @var{max-len} is a non--negative fixnum: it is the maximum number
of items to use to compute the hash value, starting from the beginning
of @var{vec}.  If the length of @var{vec} is greater than @var{max-len}:
only the first @var{max-len} items are used.  If the length of @var{vec}
is less than or equal to @var{max-len}: all the items in @var{vec} are
used.

@item
When @var{max-len} is @false{} or not present: if the length of
@var{vec} is greater than @math{3} items, only the first @math{3} items
are used to compute the hash.

@item
When @var{max-len} is @true{}: all the items in @var{vec} are used.
@end itemize

@strong{NOTE} When the hash value is computed using a number of items
@math{N} less than the vector length: applications @strong{must not}
assume that two vectors having the first @math{N} items equal will have
the same hash value.
@end deffn


@deffn {Unsafe Operation} $list-hash @var{ell}
@deffnx {Unsafe Operation} $list-hash @var{ell} @var{max-len}
Return a non--negative fixnum representing the hash value for @var{ell},
based on its current contents.  When creating hash tables using lists
as keys: this hash function is suitable for use with @func{list=?}  as
an equivalence function.

About the @var{max-len} argument:

@itemize
@item
When @var{max-len} is a non--negative fixnum: it is the maximum number
of items to use to compute the hash value, starting from the beginning
of @var{ell}.  If the length of @var{ell} is greater than @var{max-len}:
only the first @var{max-len} items are used.  If the length of @var{ell}
is less than or equal to @var{max-len}: all the items in @var{ell} are
used.

@item
When @var{max-len} is @false{} or not present: if the length of
@var{ell} is greater than @math{3} items, only the first @math{3} items
are used to compute the hash.

@item
When @var{max-len} is @true{}: all the items in @var{ell} are used.
@end itemize

@strong{NOTE} When the hash value is computed using a number of items
@math{N} less than the list length: applications @strong{must not}
assume that two lists having the first @math{N} items equal will have
the same hash value.
@end deffn


@deffn {Unsafe Operation} $pair-hash @var{pair}
@deffnx {Unsafe Operation} $ipair-hash @var{ipair}
Hash function for pairs and immutable pairs.
@end deffn


@deffn {Unsafe Operation} $char-hash @var{ch}
@deffnx {Unsafe Operation} $char-ci-hash @var{ch}
Compute and return the hash value.
@end deffn


@deffn {Unsafe Operation} $fixnum-hash @var{fx}
Compute and return the hash value.
@end deffn


@deffn {Unsafe Operation} $bignum-hash @var{bn}
Compute and return the hash value.
@end deffn


@deffn {Unsafe Operation} $exact-integer-hash @var{ei}
Compute and return the hash value.
@end deffn


@deffn {Unsafe Operation} $ratnum-hash @var{rn}
Compute and return the hash value.
@end deffn


@deffn {Unsafe Operation} $flonum-hash @var{fl}
Compute and return the hash value.
@end deffn


@deffn {Unsafe Operation} $cflonum-hash @var{cfl}
Compute and return the hash value.
@end deffn


@deffn {Unsafe Operation} $compnum-hash @var{cn}
Compute and return the hash value.
@end deffn


@deffn {Unsafe Operation} $transcoder-hash @var{tran}
Compute and return the hash value.
@end deffn


@deffn {Unsafe Operation} $enum-set-hash @var{es}
Hash function for enumeration sets.
@end deffn


@deffn {Unsafe Operation} $promise-hash @var{prom}
Hash function for promise objects.
@end deffn


@deffn {Unsafe Operation} $record-hash @var{reco}
@deffnx {Unsafe Operation} $struct-hash @var{stru}
Compute and return the hash value.

@quotation
@strong{NOTE} The result returned by these hash functions depends on the values in the fields, so:
it will change if the fields are mutated.
@end quotation
@end deffn


@deffn {Unsafe Operation} $hashtable-type-descriptor @var{table}
@deffnx {Unsafe Operation} $hashtable-type-descriptor-set! @var{table} @var{des}
Setter and getter for the hashtable run--time type descriptor.
@var{des} must be an instance of @class{hashtable-type-descr}.
@end deffn

@c page
@node syslib codes
@section Low level code objects operations


@cindex @library{vicare system $codes}, library
@cindex Library @library{vicare system $codes}


In the following definitions: the @var{code} arguments must be code
objects.  The following bindings are exported by the library
@library{vicare system $codes}.


@defun code? @var{obj}
Return @true{} if @var{obj} is a code object.
@end defun


@deffn {Primitive Operation} $code-freevars @var{code}
Return a fixnum representing the number of free variables referenced by
@var{code}.
@end deffn


@deffn {Primitive Operation} $code-reloc-vector @var{code}
Return the relocation vector of @var{code}.  The relocation vector is a
Scheme vector, @ref{objects codes reloc}.
@end deffn


@deffn {Primitive Operation} $code-size @var{code}
Return a fixnum representing the number of bytes used in the data area
of @var{code}.
@end deffn


@deffn {Primitive Operation} $code-annotation @var{code}
Return an object used as annotation for @var{code}.  The default value
for the annotation is @false{}.
@end deffn


@deffn {Primitive Operation} $code->closure @var{code}
Return a closure object wrapping @var{code}.
@end deffn


@deffn {Primitive Operation} $code-ref @var{code} @var{index}
Return the byte at @var{index} in the data area of @var{code}.
@end deffn


@deffn {Primitive Operation} $code-set! @var{code} @var{index} @var{octet}
Store @var{octet} at @var{index} in the data area of @var{code}.  Both
@var{index} and @var{octet} must be fixnums; @var{octet} must be in the
range @math{[0, 255]}.
@end deffn


@deffn {Primitive Operation} $set-code-annotation @var{code} @var{obj}
Store @var{obj} in the annotation field of @var{code}.
@end deffn


@defun code-reloc-vector->sexp @var{code}
Extract the relocation vector from @var{code} and compose a symbolic
expression representing its fields; return the symbolic expression.
@var{code} must be a code object or a closure object or a vector object.
@end defun

@c page
@node syslib closures
@section Low level closures operations


@cindex @library{vicare system $codes}, library
@cindex Library @library{vicare system $codes}


In the following definitions the @var{closure} arguments must be closure
objects.  The following bindings are exported by the library
@library{vicare system $codes}.


@deffn {Primitive Operation} $closure-code @var{closure}
Return the code object wrapped by the @var{closure}.
@end deffn


@deffn {Primitive Operation} $cpref @var{closure} @var{idx}
Evaluate to the contents of the word at index @var{idx} (a non--negative
fixnum) in the array of free variables in the @var{closure} memory
block.

To know at run time how many free variables are associated to
@var{closure} we have to inspect the associated code object.
@end deffn

@c ------------------------------------------------------------

@subsubheading Annotating closure objects


Annotated procedures exists for debugging purposes, they allow the
association of an arbitrary annotation object to a function.

@example
(import (rnrs)
  (vicare system $codes))

(define (the-proc)
  123)

(define the-annotated
  ($make-annotated-procedure 456 the-proc))

(the-annotated)                         @result{} 123
($annotated-procedure-annotation)       @result{} 456
@end example


@defun $make-annotated-procedure @var{annotation} @var{clo}
Build and return a new closure object wrapping the closure object
@var{clo} and just adding an @var{annotation} object to it.  When such
annotated closure is applied: it applies @var{clo} to the arguments.

@var{annotation} can be any Scheme object.
@end defun


@defun $annotated-procedure-annotation @var{clo}
Given a closure object @var{clo} being an annotated procedure created by
@func{$make-annotated-procedure}: return the annotation object.
@end defun

@c page
@node syslib compar
@section Comparison procedures


@cindex @library{vicare system comparison-procedures}, library
@cindex Library @library{vicare system comparison-procedures}


The library @library{vicare system comparison-procedures} defines
comparison procedures or the core object--types.  When applied to two
values @var{A} and @var{B} of the same type, a comparison procedure
returns a fixnum:

@table @samp
@item -1
If @var{A} is less than @var{B}.

@item 0
If @var{A} is equal to @var{B}.

@item +1
If @var{A} is greater than @var{B}.
@end table


The following syntactic binding are exported by the library
@library{vicare system comparison-procedures}.


@defun make-comparison-procedure @var{type-pred} @var{equal-to} @var{less-than}
Build and return a comparison procedure using the equality predicate
@var{equal-to} and the ``less than'' predicate @var{less-than}.  The
arguments of the comparison procedures are validated using the type
predicate @var{type-pred}.

@lisp
(define compar-fx
  (make-comparison-procedure fixnum? fx=? fx<?))

(compar-fx -1 +1)       @result{} -1
(compar-fx +1 +1)       @result{}  0
(compar-fx +1 -1)       @result{} +1
@end lisp
@end defun


@menu
* syslib compar numerics::      Numeric comparison procedures.
* syslib compar textual::       Textual comparison procedures.
* syslib compar misc::          Miscellaneous comparison procedures.
@end menu

@c page
@node syslib compar numerics
@subsection Numeric comparison procedures


The following syntactic binding are exported by the library
@library{vicare system comparison-procedures}.


@defun compar-fixnum @var{A} @var{B}
Comparison procedure for fixnums.
@end defun


@defun compar-bignum @var{A} @var{B}
Comparison procedure for bignums.
@end defun


@defun compar-exact-integer @var{A} @var{B}
Comparison procedure for exact integers (fixnums and bignums).
@end defun


@defun compar-ratnum @var{A} @var{B}
Comparison procedure for ratnums.
@end defun


@defun compar-exact-real @var{A} @var{B}
Comparison procedure for exact reals (fixnums, bignum, ratnums).
@end defun


@defun compar-flonum @var{A} @var{B}
Comparison procedure for flonums.
@end defun


@defun compar-real @var{A} @var{B}
Comparison procedure for reals (fixnums, bignums, ratnums, flonums).
@end defun

@c page
@node syslib compar textual
@subsection Textual comparison procedures


The following syntactic binding are exported by the library
@library{vicare system comparison-procedures}.


@defun compar-char @var{A} @var{B}
Comparison procedure for characters.
@end defun


@defun compar-string @var{A} @var{B}
Comparison procedure for strings.
@end defun


@defun compar-string-ci @var{A} @var{B}
Comparison procedure for strings, using case--insensitive functions.
@end defun


@defun compar-symbol @var{A} @var{B}
Comparison procedure for symbols.
@end defun

@c page
@node syslib compar misc
@subsection Miscellaneous comparison procedures


The following syntactic binding are exported by the library
@library{vicare system comparison-procedures}.


@defun compar-boolean @var{A} @var{B}
Comparison procedure for booleans.  @true{} is considered greater than
@false{}.
@end defun


@defun compar-true @var{A} @var{B}
@defunx compar-false @var{A} @var{B}
Comparison procedure for booleans true and false.  The arguments must
be, respectively, both @true{} or both @false{}; when the arguments are
correct, the return value is always the fixnum zero.
@end defun


@defun compar-transcoder @var{A} @var{B}
Comparison procedure for transcoders.  Comparison is performed on the
internal representation as exact integers.
@end defun


@defun compar-pointer @var{A} @var{B}
Comparison procedure for pointers.
@end defun

@c end of file
