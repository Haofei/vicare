@node syslib
@chapter Low level, fast, unsafe operations


The bindings documented in this chapter are low level operations inlined
by the compiler; mostly they are defined in the source file
@file{pass-specify-rep-primops.ss}.

They are unsafe because when acting upon wrong arguments will cause
undefined behaviour (probably a crash).  They are also faster than the
public interface exported by @library{vicare} and @library{rnrs}.

@menu
* syslib symbols::              Low level symbol operations.
* syslib keywords::             Low level keyword operations.
* syslib fixnums::              Low level fixnum operations.
* syslib bignums::              Low level bignum operations.
* syslib flonums::              Low level flonum operations.
* syslib ratnums::              Low level ratnum operations.
* syslib compnums::             Low level compnum operations.
* syslib cflonums::             Low level cflonum operations.
* syslib numerics::             Low level numerics operations.
* syslib chars::                Low level character operations.
* syslib pairs::                Low level pair operations.
* syslib lists::                Low level list operations.
* syslib structs::              Low level structure operations.
* syslib vectors::              Low level vector operations.
* syslib bytevectors::          Low level bytevector operations.
* syslib strings::              Low level string operations.
* syslib ports::                Low level port structures.
* syslib transcoders::          Low level transcoder operations.
* syslib pointers::             Low level pointer operations.
* syslib hashtables::           Low level hashtable objects operations.
* syslib codes::                Low level code objects operations.
* syslib closures::             Low level closures operations.
* syslib compiler::             Low level interface to the compiler.
@end menu

@c page
@node syslib symbols
@section Low level symbol operations


@cindex @library{vicare system $symbols}, library
@cindex Library @library{vicare system $symbols}


The arguments @var{sym} must be references to symbol blocks, the
arguments @var{str} must be references to strings.  The following
bindings are exported by the library @library{vicare system $symbols}.


@deffn {Unsafe Operation} $make-symbol @var{str}
Allocate a new symbol block and initialise the @code{string} field with
@var{str}; return the reference to the symbol block.

The @code{ustring} is initialised to the fixnum zero.  The @code{value}
and @code{proc} fields are initialised to a special machine word value
meaning ``unbound''.  The @code{plist} field is initialised to nil.
@end deffn


@deffn {Unsafe Operation} $string->symbol @var{str}
Return an interned symbol having the string @var{str} as name.
@end deffn


@deffn {Unsafe Operation} $symbol->string @var{sym}
Return the string name of @var{sym}, generating one if needed.
@end deffn


@deffn {Unsafe Operation} $symbol-string @var{sym}
@deffnx {Unsafe Operation} $symbol-unique-string @var{sym}
@deffnx {Unsafe Operation} $symbol-plist @var{sym}
Accessors for the fields of @var{sym}.
@end deffn


@deffn {Unsafe Operation} $set-symbol-string! @var{sym} @var{str}
@deffnx {Unsafe Operation} $set-symbol-unique-string! @var{sym} @var{str}
@deffnx {Unsafe Operation} $set-symbol-plist! @var{sym} @var{ell}
Mutators for the fields of @var{sym}.
@end deffn


@deffn {Unsafe Operation} $symbol-value @var{sym}
@deffnx {Unsafe Operation} $set-symbol-value! @var{sym} @var{val}
The @code{value} field has multiple purposes:

@itemize
@item
When @var{sym} is the unique identifier of a data structure type: the
@code{value} field holds the @rtd{} of the data structure.

@item
When @var{sym} is a label gensym associated to a syntactic binding
exported by the boot image: @code{value} holds the syntactic binding
descriptor.

@item
When @var{sym} is a label gensym associated to a syntactic binding
imported in the current lexical environment: @code{value} holds the
syntactic binding descriptor.

@item
When @var{sym} is a fresh symbol returned by a call to @func{gensym}: we
can use this field for any purpose we want.
@end itemize

Notice that this field is initialised to the unbound object, so we can
test the value of a newly created symbols with:

@example
($unbound-object? ($symbol-value? @var{sym}))
@end example
@end deffn


@deffn {Unsafe Operation} $unbound-object? @var{obj}
Return @true{} if @var{obj} is the special unbound machine word value,
otherwise return @false{}.
@end deffn


@deffn {Unsafe Operation} $symbol-proc @var{sym}
@deffnx {Unsafe Operation} $set-symbol-proc! @var{sym} @var{proc}
Accessor and mutator for the field @code{proc}.
@end deffn


@deffn {Unsafe Operation} $set-symbol-value/proc! @var{sym} @var{val}
Set both the fields @code{value} and @code{proc} of @var{sym} to
@var{val}.
@end deffn


@deffn {Low-level Operation} top-level-value @var{loc}
Expect the argument to be a loc gensym associated to a binding; extract
the value from the slot @code{value} of the symbol object and return it.
If the value is the unbound object: raise an exception.

This primitive function is also implemented as primitive operation.

This function has a specific purpose: to retrieve the value of a binding
defined in a previously evaluated expression in the context of an
interaction environment; we have to know the internals of the expander
to understand it.  Let's say we are evaluating expressions at the
@repl{}; first we do:

@example
vicare> (define a 1)
@end example

@noindent
the expander creates a new top level binding in the interaction
environment; such interaction environment bindings are special in that
they have a single gensym to serve both as lex gensym and loc gensym;
the expander transforms the input form into the core language form:

@example
(set! lex.a 1)
@end example

@noindent
where @code{lex.a} is both the lex gensym and the loc gensym associated
to the binding; the compiler transforms the core language expression
into:

@example
($init-symbol-value! lex.a 1)
@end example

@noindent
which, compiled and evaluated, will store the value in the @code{value}
field of the gensym @code{lex.a}.

Later we do:

@example
vicare> a
@end example

@noindent
the expander finds the binding in the interaction environment and
transforms the variable reference into the core language expression:

@example
lex.a
@end example

@noindent
the compiler then transforms the core language variable reference into:

@example
(top-level-value 'lex.a)
@end example

@noindent
which, compiled and evaluated, will return the binding's value.

The same processing happens when we evaluate multiple expressions with
EVAL in the context of the same interaction environment.
@end deffn


@deffn {Low--level Operation} top-level-bound? @var{loc}
Return @true{} if the symbol object @var{loc} has a proper value in its
@code{value} field; return @false{} if the field @code{value} is set to
the unbound object.
@end deffn


@deffn {Low--level Operation} set-top-level-value! @var{loc} @var{value}
This function can be used to set a new object in a @var{loc} gensym, so
that it can be later retrieved by @func{top-level-value}.  This function
exists for completeness, but it is not really used by the compiler.
@end deffn


@deffn {Low--level Operation} reset-symbol-proc! @var{symb}
Still to be documented.
@end deffn


@deffn {Unsafe Operation} $init-symbol-function! @var{sym} @var{proc}
Still to be documented.
@end deffn


The following bindings are related to the symbol table collecting
interned symbols.


@defun $symbol-table-size
Return the number of interned symbols.
@end defun


@defun $log-symbol-table-status
Write to the current error port a description of the current symbol
table status.  Example:

@example
vicare> (import (vicare system $symbols))
vicare> ($log-symbol-table-status)
Vicare internal symbol table status:
        number of interned symbols: 2962
        number of hash table buckets: 4096

vicare>
@end example
@end defun

@c ------------------------------------------------------------

@subsubheading Property lists


@deffn {Unsafe Operation} $putprop @var{symbol} @var{key} @var{value}
Add a new property @var{key} with @var{value} to the property list of
@var{symbol}.  @var{key} must be a symbol, @var{value} can be any value.

If @var{key} is already set: the old entry is mutated to reference the
new @var{value}.
@end deffn


@deffn {Unsafe Operation} $getprop @var{symbol} @var{key}
Return the value of the property @var{key} in the property list of
@var{symbol}; if @var{key} is not set return false.  @var{key} must be a
symbol.
@end deffn


@deffn {Unsafe Operation} $remprop @var{symbol} @var{key}
Remove property @var{key} from the list associated to @var{symbol}.
@end deffn


@deffn {Unsafe Operation} $property-list @var{symbol}
Return a new association list representing the property list of
@var{symbol}.  The order of the entries is the same as the property
creation order.
@end deffn

@c page
@node syslib keywords
@section Low level keyword operations


@cindex @library{vicare system $keywords}, library
@cindex Library @library{vicare system $keywords}


The arguments @var{key} must be references to keyword objects, the
arguments @var{symb} must be references to symbol objects.  The
following bindings are exported by the library @library{vicare system
$keywords}.


@deffn {Unsafe Operation} $symbol->keyword @var{sym}
@deffnx {Unsafe Operation} $keyword->symbol @var{key}
Convert between a symbol and a keyword.
@end deffn


@deffn {Unsafe Operation} $keyword->string @var{key}
Return the string representation of a keyword.
@end deffn


@deffn {Unsafe Operation} $keyword=? @vari{key} @varii{key}
Return @true{} if the arguments are equal.  A keyword object is equal to
itself; two distinct keyword objects are equal if they have the same
symbol.
@end deffn


@deffn {Unsafe Operation} $keyword-hash @var{keyword}
Return an exact integer suitable to be used as hash value for
@var{keyword} used as key for hashtables.
@end deffn

@c page
@node syslib fixnums
@section Low level fixnum operations


@cindex @library{vicare system $fx}, library
@cindex Library @library{vicare system $fx}


The following bindings are exported by the library @library{vicare
system $fx}.  The arguments to these operations must be fixnums.
@ref{objects fixnums} for details on the representation of fixnums.

@c ------------------------------------------------------------

@subsubheading Predicates

@deffn {Unsafe Operation} $fxzero? @var{fx}
Evaluate to true if @var{fx} is zero.
@end deffn


@deffn {Unsafe Operation} $fxpositive? @var{fx}
@deffnx {Unsafe Operation} $fxnegative? @var{fx}
Evaluate to true if @var{fx} is strictly positive or strictly negative.
@end deffn


@deffn {Unsafe Operation} $fxnonpositive? @var{fx}
@deffnx {Unsafe Operation} $fxnonnegative? @var{fx}
Evaluate to true if @var{fx} is non--positive or non--negative.
@end deffn


@deffn {Unsafe Operation} $fxsign @var{fx}
Return one of the fixnums @code{+1}, @code{-1}, @code{0} representing
the sign of @var{fx}.
@end deffn


@deffn {Unsafe Operation} $fxeven? @var{fx}
@deffnx {Unsafe Operation} $fxodd? @var{fx}
Evaluate to true if @var{fx} is even or odd.
@end deffn

@c ------------------------------------------------------------

@subsubheading Comparison operations

@deffn {Unsafe Operation} $fx= @vari{fx} @varii{fx}
Evaluate to true if the arguments are equal.
@end deffn


@deffn {Unsafe Operation} $fx< @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is less than @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx<= @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is less than or equal to @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx> @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is greater than @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx>= @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is greater than or equal to @varii{fx}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Arithmetic operations

@deffn {Unsafe Operation} $fxadd1 @var{fx}
Increment the operand by one and return the result.
@end deffn


@deffn {Unsafe Operation} $fxsub1 @var{fx}
Decrement the operand by one and return the result.  The result of this
operation is a fixnum, but notice that if @var{fx} is
@code{(least-fixnum)}: the result overflows the fixnum capacity and the
return value is invalid.
@end deffn


@deffn {Unsafe Operation} $fx+ @vari{fx} @varii{fx}
Sum the operands and return the result.  The result of this operatio is
a fixnum, but notice that it could overflow the fixnum capacity.
@end deffn


@deffn {Unsafe Operation} $fx- @var{fx}
@deffnx {Unsafe Operation} $fx- @vari{fx} @varii{fx}
With one operand: return @var{fx} negated.  With two operands: subtract
the operands and return the result.  The result of this operation is a
fixnum, but notice that it could overflow the fixnum capacity and the
return value would be invalid.

Also with a single argument, knowing that @code{(- (least-fixnum))} is a
bignum, if @var{fx} is @code{(least-fixnum)} the result overflows the
fixnum capacity and the return value is invalid.

With two arguments: if @vari{fx} is zero and @varii{fx} is
@code{(least-fixnum)} the result overflows the fixnum capacity and the
return value is invalid.
@end deffn


@deffn {Unsafe Operation} $fx* @vari{fx} @varii{fx}
Multiply the operands and return the result.  The result of this
operation is a fixnum, but notice that if one operand is @code{-1} and
the other is @code{(least-fixnum)}: the result overflows the fixnum
capacity and the return value is invalid.
@end deffn


@deffn {Unsafe Operation} $fxdiv @vari{fx} @varii{fx}
@deffnx {Unsafe Operation} $fxdiv0 @vari{fx} @varii{fx}
@deffnx {Unsafe Operation} $fxmod @vari{fx} @varii{fx}
@deffnx {Unsafe Operation} $fxmod0 @vari{fx} @varii{fx}
@deffnx {Unsafe Operation} $fxdiv-and-mod  @vari{fx} @varii{fx}
@deffnx {Unsafe Operation} $fxdiv0-and-mod0 @vari{fx} @varii{fx}
Perform the number theoretic division.

@example
(import (rnrs)
  (vicare system $fx))

($fxmod +12 +12)        @result{} 0
($fxmod +12 -12)        @result{} 0
($fxmod -12 +12)        @result{} 0
($fxmod -12 -12)        @result{} 0

($fxmod +12 +3)         @result{} 0
($fxmod +12 -3)         @result{} 0
($fxmod -12 +3)         @result{} 0
($fxmod -12 -3)         @result{} 0

($fxmod +12 +4)         @result{} 0
($fxmod +12 -4)         @result{} 0
($fxmod -12 +4)         @result{} 0
($fxmod -12 -4)         @result{} 0

($fxmod +12 +5)         @result{} +2
($fxmod +12 -5)         @result{} +2
($fxmod -12 +5)         @result{} +3
($fxmod -12 -5)         @result{} +3

($fxmod +12 +7)         @result{} +5
($fxmod +12 -7)         @result{} +5
($fxmod -12 +7)         @result{} +2
($fxmod -12 -7)         @result{} +2

($fxmod +12 +24)        @result{} +12
($fxmod +12 -24)        @result{} +12
($fxmod -12 +24)        @result{} +12
($fxmod -12 -24)        @result{} +12

($fxmod +12 +20)        @result{} +12
($fxmod +12 -20)        @result{} +12
($fxmod -12 +20)        @result{} +8
($fxmod -12 -20)        @result{} +8
@end example
@end deffn


@deffn {Unsafe Operation} $fxquotient @vari{fx} @varii{fx}
Compute the quotient between the operands and return the result.  The
result of this operation is a fixnum, but notice that:

@itemize
@item
When @varii{fx} is @code{0}: the result is undefined, most likely the
process will abort.

@item
When @vari{fx} is @code{(least-fixnum)} and @varii{fx} is @code{-1}: the
result will overflow the fixnum capacity, and the return value will be
invalid (the result should be a bignum).
@end itemize
@end deffn


@deffn {Unsafe Operation} $fxmodulo @vari{fx} @varii{fx}
Compute the modulo between the operands and return the result.  The
result of this operation can be a fixnum or bignum.

@example
(import (rnrs)
  (vicare system $fx))

($fxmodulo +12 +12)     @result{} 0
($fxmodulo +12 -12)     @result{} 0
($fxmodulo -12 +12)     @result{} 0
($fxmodulo -12 -12)     @result{} 0

($fxmodulo +12 +3)      @result{} 0
($fxmodulo +12 -3)      @result{} 0
($fxmodulo -12 +3)      @result{} 0
($fxmodulo -12 -3)      @result{} 0

($fxmodulo +12 +4)      @result{} 0
($fxmodulo +12 -4)      @result{} 0
($fxmodulo -12 +4)      @result{} 0
($fxmodulo -12 -4)      @result{} 0

($fxmodulo +12 +5)      @result{} +2
($fxmodulo +12 -5)      @result{} -3
($fxmodulo -12 +5)      @result{} +3
($fxmodulo -12 -5)      @result{} -2

($fxmodulo +12 +7)      @result{} +5
($fxmodulo +12 -7)      @result{} -2
($fxmodulo -12 +7)      @result{} +2
($fxmodulo -12 -7)      @result{} -5

($fxmodulo +12 +24)     @result{} +12
($fxmodulo +12 -24)     @result{} -12
($fxmodulo -12 +24)     @result{} +12
($fxmodulo -12 -24)     @result{} -12

($fxmodulo +12 +20)     @result{} +12
($fxmodulo +12 -20)     @result{}  -8
($fxmodulo -12 +20)     @result{}  +8
($fxmodulo -12 -20)     @result{} -12
@end example
@end deffn


@deffn {Unsafe Operation} $fxabs @var{fx}
Return the absolute value of @var{fx} as a fixnum.  When @var{fx} is
@code{(least-fixnum)}: its absolute value would be a fixnum, in which
case this operation raises an implementation restriction violation.

To compute the general absolute value without overflow we must use
@func{abs} or @func{$abs-fixnum}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bitwise logic operations

@deffn {Unsafe Operation} $fxlognot @var{fx}
Perform the bitwise NOT on the operand and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogand @vari{fx} @varii{fx}
Perform the bitwise AND on the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogor @vari{fx} @varii{fx}
Perform the bitwise inclusive OR on the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogxor @vari{fx} @varii{fx}
Perform the bitwise exclusive OR on the operands and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Other bitwise operations

@deffn {Unsafe Operation} $fxsll @vari{fx} @varii{fx}
Perform bitwise shift left of @vari{fx} by @varii{fx} positions and
return the result.
@end deffn


@deffn {Unsafe Operation} $fxsra @vari{fx} @varii{fx}
Perform bitwise shift right of @vari{fx} by @varii{fx} positions and
return the result.
@end deffn


@deffn {Unsafe Operation} $fxcopy-bit @vari{fx} @varii{fx} @variii{fx}
Unsafe version of @func{fxcopy-bit}.
@end deffn


@deffn {Unsafe Operation} $fxcopy-bit-field @vari{fx} @varii{fx} @variii{fx} @variv{fx}
Unsafe version of @func{fxcopy-bit-field}.
@end deffn


@deffn {Unsafe Operation} $fxrotate-bit-field @vari{fx} @varii{fx} @variii{fx} @variv{fx}
Unsafe version of @func{fxrotate-bit-field}.
@end deffn


@deffn {Unsafe Operation} $fxbit-field @vari{fx} @varii{fx} @variii{fx}
Unsafe version of @func{fxbit-field}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Conversion operations


@deffn {Unsafe Operation} $fixnum->string @var{fx} @var{base}
Return a string object representing @var{fx} in @var{base}.  @var{base}
must be one among: @math{2}, @math{8}, @math{10}, @math{16}.
@end deffn


@deffn {Unsafe Operation} $fixnum->char @var{fx}
Return a new character value whose code point equals @var{fx}.
@end deffn


@deffn {Unsafe Operation} $char->fixnum @var{ch}
Return a fixnum representing the code point of the operand.
@end deffn


@deffn {Unsafe Operation} $fixnum->flonum @var{fx}
Convert the fixnum operand into a flonum and return a reference to the
result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Miscellaneous operations

@deffn {Unsafe Operation} $fxinthash @var{fx}
Evaluate to a fixnum which can be used as hash value.

@quotation
@strong{NOTE}  This appears to be unused in the source.
@end quotation
@end deffn

@c page
@node syslib bignums
@section Low level bignum operations


@cindex @library{vicare system $bignums}, library
@cindex Library @library{vicare system $bignums}


The arguments @var{bn} to these operations must be bignums.  The
following bindings are exported by the library @library{vicare system
$bignums}.  @ref{iklib numerics} for more functions acting on bignums.


@deffn {Unsafe Operation} $bignum-positive? @var{bn}
@deffnx {Unsafe Operation} $bignum-negative? @var{bn}
Evaluate to true if the operand is positive or negative.
@end deffn


@deffn {Unsafe Operation} $bignum-non-positive? @var{bn}
@deffnx {Unsafe Operation} $bignum-non-negative? @var{bn}
Evaluate to true if the operand is non--positive or non--negative.
@end deffn


@deffn {Unsafe Operation} $bignum-even? @var{bn}
@deffnx {Unsafe Operation} $bignum-odd? @var{bn}
Evaluate to true if the operand is even or odd.
@end deffn


@deffn {Unsafe Operation} $bignum-byte-ref @var{bn} @var{fx}
Return a fixnum representing the byte at index @var{fx} in the data of
@var{bn}.
@end deffn


@deffn {Unsafe Operation} $bignum-size @var{bn}
Return a fixnum representing the number of machine words in the data
portion of a bignum memory block.
@end deffn


@deffn {Unsafe Operation} $bignum->flonum @var{bn}
Return a flonum object representing @var{bn} as inexact number.
@end deffn

@c page
@node syslib flonums
@section Low level flonum operations


@cindex @library{vicare system $flonums}, library
@cindex Library @library{vicare system $flonums}


The arguments @var{fl} to these operations must be flonums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the library @library{vicare system $flonums}.  @ref{iklib numerics}
for more functions acting on flonums.


@deffn {Unsafe Operation} $make-flonum
Allocate a new flonum memory block and return a reference to it.  Does
not initialise the data area.
@end deffn

@c ------------------------------------------------------------

@subsubheading Binary representation inspection


@deffn {Unsafe Operation} $flonum-u8-ref @var{fl} @var{fx}
Return the octet at index @var{fx} in the data area of @var{fl}.

Notice that the @var{fx} offset is positive, but it represents an offset
from the end of the data area; on a 32-bit platform, the indexes of the
bytes are:

@example
   1st word    2nd word    3rd word    4th word
|-----------|-----------|-----------|-----------|
                        |--|--|--|--|--|--|--|--| bytes
                          7  6  5  4  3  2  1  0  offsets
                        |.......................|
                             IEEE 754 flonum
@end example
@end deffn


@deffn {Unsafe Operation} $flonum-set! @var{fl} @var{fx-index} @var{fx-value}
Store the byte or octet represented by @var{fx-value} at index
@var{fx-index} in the data area of @var{fl}.
@end deffn


@deffn {Unsafe Operation} $flonum-sbe @var{fl}
Return a fixnum@dots{} Still undocumented, read the code look at the
format of @ieee{} double precision flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Arithmetic operations


@deffn {Unsafe Operation} $fl+ @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl* @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl/ @vari{fl} @varii{fl}
Perform arithmetic operations.
@end deffn


@deffn {Unsafe Operation} $fl- @var{fl}
@deffnx {Unsafe Operation} $fl- @vari{fl} @varii{fl}
With one operand: return @var{fl} negated.  With two operands: subtract
the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fldiv @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $flmod @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fldiv0 @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $flmod0 @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fldiv-and-mod @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fldiv0-and-mod0 @vari{fl} @varii{fl}
Implement the number--theoretic integer divisions.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exactness and conversion


@deffn {Unsafe Operation} $flonum->exact @var{fl}
Rationalize the operand and return the result.
@end deffn


@deffn {Unsafe Operation} $fixnum->flonum @var{fx}
Convert the fixnum operand into a flonum and return a reference to the
result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Predicates


@deffn {Unsafe Operation} $flzero? @var{fl}
Return true if the operand is zero.  Notice that the return value will
be true for both @code{+0.0} or @code{-0.0}.
@end deffn


@deffn {Unsafe Operation} $flzero?/positive @var{fl}
@deffnx {Unsafe Operation} $flzero?/negative @var{fl}
Return true if the operand is @code{+0.0} or @code{-0.0}, respectively.
@end deffn


@deffn {Unsafe Operation} $flpositive? @var{fl}
Return true if the operand is strictly positive.  This predicate fails
when applied to @code{+0.0}; to check for positivity including
@code{+0.0} we must use:

@example
(or ($flzero?/positive @var{fl}) ($fl> @var{fl} +0.0))
@end example
@end deffn


@deffn {Unsafe Operation} $flnegative? @var{fl}
Return true if the operand is strictly negative.  This predicate fails
when applied to @code{-0.0}; to check for negativity including
@code{-0.0} we must use:

@example
(or ($flzero?/negative @var{fl}) ($fl< @var{fl} -0.0))
@end example
@end deffn


@deffn {Unsafe Operation} $flnonpositive? @var{fl}
Return @true{} if the operand is non--positive.  This predicate returns
@false{} when applied to @code{-0.0}.
@end deffn


@deffn {Unsafe Operation} $flnonnegative? @var{fl}
Return @true{} if the operand is non--negative.  This predicate returns
@false{} when applied to @code{+0.0}.
@end deffn


@deffn {Unsafe Operation} $fleven? @var{fl}
Return true if the operand is even.
@end deffn


@deffn {Unsafe Operation} $flodd? @var{fl}
Return true if the operand is odd.
@end deffn


@deffn {Unsafe Operation} $flonum-integer? @var{fl}
Return true if the operand is integer.
@end deffn


@deffn {Unsafe Operation} $flonum-rational? @var{fl}
Return true if the operand is rational.  All the flonums are rational
with the exception of infinities and not--a--number.
@end deffn

@c ------------------------------------------------------------

@subsubheading Rounding


@deffn {Unsafe Operation} $flround @var{fl}
Return the closest integral flonum to the operand, rounding to even when
@var{fl} represents a number halfway between two integers.
@end deffn


@deffn {Unsafe Operation} $flfloor @var{fl}
Return the largest integral flonum not larger than the operand.
@end deffn


@deffn {Unsafe Operation} $flceiling @var{fl}
Return the smallest integral flonum not larger than the operand.
@end deffn


@deffn {Unsafe Operation} $fltruncate @var{fl}
Return the integral flonum closest to the operand whose absolute value
is not larger than the absolute value of the operand itself.
@end deffn

@c ------------------------------------------------------------

@subsubheading Parts


@deffn {Unsafe Operation} $flnumerator @var{fl}
@deffnx {Unsafe Operation} $fldenominator @var{fl}
Return the numerator or denominator of the operand.
@end deffn


@deffn {Unsafe Operation} $flabs @var{fl}
Return the absolute value of the operand.
@end deffn

@c ------------------------------------------------------------

@subsubheading Trigonometric operations


@deffn {Unsafe Operation} $flsin @var{fl}
@deffnx {Unsafe Operation} $flcos @var{fl}
@deffnx {Unsafe Operation} $fltan @var{fl}
Return the sine, cosine and tangent of the operand.
@end deffn


@deffn {Unsafe Operation} $flasin @var{fl}
@deffnx {Unsafe Operation} $flacos @var{fl}
@deffnx {Unsafe Operation} $flatan @var{fl}
Return the arcsine, arccosine and arctangent of the operand.
@end deffn


@deffn {Unsafe Operation} $flatan2 @vari{fl} @varii{fl}
Return an equivalent of:

@example
(angle (make-rectangular @varii{fl} @vari{fl}))
@end example
@end deffn

@c ------------------------------------------------------------

@subsubheading Hyperbolic functions


@defun $flsinh @var{fl}
@defunx $flcosh @var{fl}
@defunx $fltanh @var{fl}
Compute the hyperbolic functions.  Return flonum objects.
@end defun


@defun $flasinh @var{fl}
@defunx $flacosh @var{fl}
@defunx $flatanh @var{fl}
Compute the inverse hyperbolic functions.  Return flonum objects.
@end defun

@c ------------------------------------------------------------

@subsubheading Exponentials and logarithms


@deffn {Unsafe Operation} $flcbrt @var{fl}
Return the real cube root function of @var{fl}.
@end deffn


@deffn {Unsafe Operation} $flexp @var{fl}
Return the base @math{e} exponential of the operand.
@end deffn


@deffn {Unsafe Operation} $fllog @var{fl}
Return the natural logarithm of the operand.  For non--negative @var{fl}
the return value is a numeric flonum; for negative @var{fl} the return
value is not--a--number.  See also @func{$log-flonum} to compute the
logarithm of negative flonums as a complex number.
@end deffn


@deffn {Unsafe Operation} $fllog2 @vari{fl} @varii{fl}
Return the base--@varii{fl} logarithme of @vari{fl}.
@end deffn


@deffn {Unsafe Operation} $flexpm1 @var{fl}
Return an equivalent of @math{exp(@var{fl}) - 1}.
@end deffn


@deffn {Unsafe Operation} $fllog1p @var{fl}
Return an equivalent of @math{log(1 + @var{fl})}.
@end deffn


@deffn {Unsafe Operation} $flhypot @vari{fl} @varii{fl}
Compute the Euclidean distance function: @math{\sqrt(X*X+Y*Y)}.
@glibcref{Exponents and Logarithms, hypot}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Power operations


@deffn {Unsafe Operation} $flexpt @vari{fl} @varii{fl}
Return @vari{fl} raised to the power of @varii{fl}.
@end deffn


@deffn {Unsafe Operation} $flsqrt @var{fl}
Return the square root of the operand.
@end deffn


@deffn {Unsafe Operation} $flsquare @var{fl}
Return the square of @var{fl}: @var{fl} times @var{fl}.
@end deffn


@deffn {Unsafe Operation} $flcube @var{fl}
Return the cube of @var{fl}: @var{fl} times @var{fl} times @var{fl}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Comparison operations


@deffn {Unsafe Operation} $fl= @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl< @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl<= @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl> @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl>= @vari{fl} @varii{fl}
Perform comparison operations
@end deffn


@deffn {Unsafe Operation} $flmax @vari{fl} @varii{fl}
Return the maximum between the operands.
@end deffn


@deffn {Unsafe Operation} $flmin @vari{fl} @varii{fl}
Return the minimum between the operands.
@end deffn

@c page
@node syslib ratnums
@section Low level ratnum operations


@cindex @library{vicare system $ratnums}, library
@cindex Library @library{vicare system $ratnums}


The arguments @var{rat} to these operations must be ratnums, the
arguments @var{num} and @var{den} must be references to either fixnums
or bignums.  The following bindings are exported by the library
@library{vicare system $ratnums}.  @ref{iklib numerics} for more
functions acting on ratnums.


@deffn {Unsafe Operation} $make-ratnum @var{num} @var{den}
Allocate a new ratnum memory block, store @var{num} as reference to the
numerator and @var{den} as reference to the denominator; return a
reference to the ratnum.

The following conditions must be met, else the returned value will be
invalid:

@itemize
@item
@var{num} and @var{den} must be exact integers.

@item
@var{num} and @var{den} must be non--zero.

@item
@var{den} must be strictly positive.

@item
@var{num} and @var{den} must have greatest common divisor equal to
@code{1} (that is: they cannot be simplified).
@end itemize
@end deffn


@deffn {Unsafe Operation} $ratnum-n @var{rat}
@deffnx {Unsafe Operation} $ratnum-num @var{rat}
Return the reference to the numerator.
@end deffn


@deffn {Unsafe Operation} $ratnum-d @var{rat}
@deffnx {Unsafe Operation} $ratnum-den @var{rat}
Return the reference to the denominator.
@end deffn


@deffn {Unsafe Operation} $ratnum->flonum @var{rat}
Return a flonum object representing @var{rat} as inexact number.
@end deffn


@deffn {Unsafe Operation} $ratnum-positive? @var{rat}
@deffnx {Unsafe Operation} $ratnum-negative? @var{rat}
Return @true{} if @var{rat} is, respectively, positive or negative;
otherwise return @false{}.
@end deffn


@deffn {Unsafe Operation} $ratnum-non-positive? @var{rat}
@deffnx {Unsafe Operation} $ratnum-non-negative? @var{rat}
Return @true{} if @var{rat} is, respectively, non--positive or
non--negative; otherwise return @false{}.
@end deffn

@c page
@node syslib compnums
@section Low level compnum operations


@cindex @library{vicare system $compnums}, library
@cindex Library @library{vicare system $compnums}


The arguments @var{cn} to these operations must be compnums, the
arguments @var{num} must be references to either fixnums, bignums or
flonums.  The following bindings are exported by the library
@library{vicare system $compnums}.  @ref{iklib numerics} for more
functions acting on compnums.


@deffn {Unsafe Operation} $make-compnum @vari{num} @varii{num}
Allocate a new compnum memory block, store @vari{num} as reference to
the real part and @varii{num} as reference to the imaginary part.
Return a reference to the compnum.
@end deffn


@deffn {Unsafe Operation} $make-rectangular @var{rep} @var{imp}
Return a real numebr, a new compnum or a new cflonum; @var{rep} and
@var{imp} can be any combination of real numbers.  If @var{imp} is exact
zero: the returned value is @var{rep}, a real.
@end deffn


@deffn {Unsafe Operation} $compnum-real @var{cn}
Return the reference to the real part.
@end deffn


@deffn {Unsafe Operation} $compnum-imag @var{cn}
Return the reference to the imaginary part.
@end deffn


@deffn {Unsafe Operation} $compnum->cflonum @var{cn}
Return the inexact representation of a compnum as a cflonum.
@end deffn

@c page
@node syslib cflonums
@section Low level cflonum operations


@cindex @library{vicare system $compnums}, library
@cindex Library @library{vicare system $compnums}


The arguments @var{cmp} to these operations must be cflonums, the
arguments @var{fl} must be references to flonums.  The following
bindings are exported by the library @library{vicare system $compnums}.
@ref{iklib numerics} for more functions acting on cflonums.


@deffn {Unsafe Operation} $make-cflonum @vari{fl} @varii{fl}
Allocate a new cflonum memory block, store @vari{fl} as reference to the
real part and @varii{fl} as reference to the imaginary part.  Return a
reference to the cflonum.
@end deffn


@deffn {Unsafe Operation} $cflonum-real @var{cmp}
Return the reference to the real part.
@end deffn


@deffn {Unsafe Operation} $cflonum-imag @var{cmp}
Return the reference to the imaginary part.
@end deffn

@c page
@node syslib numerics
@section Low level numerics operations


@cindex @library{vicare system $numerics}, library
@cindex Library @library{vicare system $numerics}


The library @library{vicare system $numerics} export bindings for low
level operations on numbers.

@menu
* syslib numerics neg::         Numbers negation.
* syslib numerics inv::         Numbers inversion.
* syslib numerics add1::        Exact integers increment.
* syslib numerics sub1::        Exact integers decrement.
* syslib numerics add::         Numbers addition.
* syslib numerics sub::         Numbers subtraction.
* syslib numerics mul::         Numbers multiplication.
* syslib numerics div::         Numbers division.
* syslib numerics square::      Squaring of numbers.
* syslib numerics cube::        Cube of numbers.
* syslib numerics gcd::         Greatest common divisor.
* syslib numerics lcm::         Least common multiple.
* syslib numerics quorem::      Quotient and remainder.
* syslib numerics quotient::    Quotient between numbers.
* syslib numerics remainder::   Remainder between numbers.
* syslib numerics modulo::      Modulo between numbers.
* syslib numerics max::         Maximum between numbers.
* syslib numerics min::         Minimum between numbers.
* syslib numerics abs::         Absolute value of real numbers.
* syslib numerics sign::        Sign of real numbers.
* syslib numerics expt::        Raising numbers to power.
* syslib numerics sqrt::        Square root of numbers.
* syslib numerics cbrt::        Cubic root of numbers.
* syslib numerics log::         Logarithms of numbers.
* syslib numerics exp::         Exponentials of numbers.
* syslib numerics sin::         Trigonometric sine.
* syslib numerics cos::         Trigonometric cosine.
* syslib numerics tan::         Trigonometric tangent.
* syslib numerics asin::        Trigonometric arc sine.
* syslib numerics acos::        Trigonometric arc cosine.
* syslib numerics atan::        Trigonometric arc tangent.
* syslib numerics sinh::        Hyperbolic sine.
* syslib numerics cosh::        Hyperbolic cosine.
* syslib numerics tanh::        Hyperbolic tangent.
* syslib numerics asinh::       Hyperbolic arc sine.
* syslib numerics acosh::       Hyperbolic arc cosine.
* syslib numerics atanh::       Hyperbolic arc tangent.
* syslib numerics conjugate::   Complex conjugate.
* syslib numerics magnitude::   Magnitude of complex numbers.
* syslib numerics angle::       Angle of complex numbers.
* syslib numerics bitnot::      Bitwise logic not.
* syslib numerics bitand::      Bitwise logic and.
* syslib numerics bitior::      Bitwise logic inclusive or.
* syslib numerics bitxor::      Bitwise logic exclusive or.
@end menu

@c page
@node syslib numerics neg
@subsection Negation negation


@deffn {Unsafe Operation} $neg-number @var{num}
Negate any number object and return the result.
@end deffn


@deffn {Unsafe Operation} $neg-fixnum @var{fx}
Negate a fixnum; return a fixnum or a bignum, the latter when @var{fx}
is @code{(least-fixnum)}.
@end deffn


@deffn {Unsafe Operation} $neg-bignum @var{bn}
Negate a bignum; return a bignum or a fixnum, the latter when @var{bn}
is equal to @code{(- (least-fixnum))}.
@end deffn


@deffn {Unsafe Operation} $neg-flonum @var{fl}
Negate a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $neg-ratnum @var{rt}
Negate a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $neg-compnum @var{cn}
Negate a compnum and return the result as a compunm.
@end deffn


@deffn {Unsafe Operation} $neg-cflonum @var{cfl}
Negate a cflonum and return the result as cflonum.
@end deffn

@c page
@node syslib numerics inv
@subsection Numbers inversion


If the operand is zero: the following operations raise an exception.


@deffn {Unsafe Operation} $inv-number @var{num}
Compute the inverse of any number object and return the result.
@end deffn


@deffn {Unsafe Operation} $inv-fixnum @var{fx}
Compute the inverse of a fixnum and return the result as a fixnum or
ratnum.  A fixnum is returned if @var{fx} is @code{+1} or @code{-1}.
@end deffn


@deffn {Unsafe Operation} $inv-bignum @var{bn}
Compute the inverse of a bignum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $inv-flonum @var{fl}
Compute the inverse of a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $inv-ratnum @var{rt}
Compute the inverse of a ratnum and return the result as a fixnum,
bignum or ratnum.  A fixnum or bignum is returned when the numerator of
@var{rt} is @code{+1} or @code{-1}.
@end deffn


@deffn {Unsafe Operation} $inv-compnum @var{cn}
Compute the inverse of a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $inv-cflonum @var{cfl}
Compute the inverse of a cflonum and return the result as a cflonum.
@end deffn

@c page
@node syslib numerics add1
@subsection Exact integers increment


@deffn {Unsafe Operation} $add1-integer @var{N}
Increment by @math{1} the fixnum or bignum @var{N} and return the
result.
@end deffn


@deffn {Unsafe Operation} $add1-bignum @var{N}
Increment by @math{1} the bignum @var{N} and return the result.
@end deffn


@deffn {Unsafe Operation} $add1-fixnum @var{N}
Increment by @math{1} the fixnum @var{N} and return the result.
@end deffn

@c page
@node syslib numerics sub1
@subsection Exact integers decrement


@deffn {Unsafe Operation} $sub1-integer @var{N}
Decrement by @math{1} the fixnum or bignum @var{N} and return the
result.
@end deffn


@deffn {Unsafe Operation} $sub1-bignum @var{N}
Decrement by @math{1} the bignum @var{N} and return the result.
@end deffn


@deffn {Unsafe Operation} $sub1-fixnum @var{N}
Decrement by @math{1} the fixnum @var{N} and return the result.
@end deffn

@c page
@node syslib numerics add
@subsection Numbers addition


@deffn {Unsafe Operation} $add-number-number @vari{num} @varii{num}
Add any couple of numbers and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as second operand


@deffn {Unsafe Operation} $add-fixnum-number @var{fx} @var{num}
Add a fixnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $add-bignum-number @var{bn} @var{num}
Add a bignum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $add-flonum-number @var{fl} @var{num}
Add a flonum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-number @var{rt} @var{num}
Add a ratnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $add-compnum-number @var{cn} @var{num}
Add a compnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-number @var{cfl} @var{num}
Add a cflonum with a number and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as first operand


@deffn {Unsafe Operation} $add-number-fixnum @var{num} @var{fx}
Add any number with a fixnum and return the result.
@end deffn


@deffn {Unsafe Operation} $add-number-bignum @var{num} @var{bn}
Add any number with a bignum and return the result.
@end deffn


@deffn {Unsafe Operation} $add-number-flonum @var{num} @var{fl}
Add any number with a flonum and return the result.
@end deffn


@deffn {Unsafe Operation} $add-number-ratnum @var{num} @var{rt}
Add any number with a ratnum and return the result.
@end deffn


@deffn {Unsafe Operation} $add-number-compnum @var{num} @var{cn}
Add any number with a compnum and return the result.
@end deffn


@deffn {Unsafe Operation} $add-number-cflonum @var{num} @var{cfl}
Add any number with a cflonum and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first operand


@deffn {Unsafe Operation} $add-fixnum-fixnum @vari{fx} @varii{fx}
Add a fixnum with a fixnum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $add-fixnum-bignum @var{fx} @var{bn}
Add a fixnum with a bignum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $add-fixnum-flonum @var{fx} @var{fl}
Add a fixnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-fixnum-ratnum @var{fx} @var{rt}
Add a fixnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $add-fixnum-compnum @var{fx} @var{cn}
Add a fixnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-fixnum-cflonum @var{fx} @var{cfl}
Add a fixnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first operand


@deffn {Unsafe Operation} $add-bignum-fixnum @var{bn} @var{fx}
Add a bignum with a fixnum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $add-bignum-bignum @vari{bn} @varii{bn}
Add a bignum with a bignum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $add-bignum-flonum @var{bn} @var{fl}
Add a bignum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-bignum-ratnum @var{bn} @var{rt}
Add a bignum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $add-bignum-compnum @var{bn} @var{cn}
Add a bignum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-bignum-cflonum @var{bn} @var{cfl}
Add a bignum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first operand


@deffn {Unsafe Operation} $add-flonum-fixnum @var{fl} @var{fx}
Add a flonum with a fixnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-flonum-bignum @var{fl} @var{bn}
Add a flonum with a bignum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-flonum-flonum @vari{fl} @varii{fl}
Add a flonum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-flonum-ratnum @var{fl} @var{rt}
Add a flonum with a ratnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-flonum-compnum @var{fl} @var{cn}
Add a flonum with a compnum and return the result as a compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $add-flonum-cflonum @var{fl} @var{cfl}
Add a flonum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first operand


@deffn {Unsafe Operation} $add-ratnum-fixnum @var{rt} @var{fx}
Add a ratnum with a fixnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-bignum @var{rt} @var{bn}
Add a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-flonum @var{rt} @var{fl}
Add a ratnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-ratnum @vari{rt} @varii{rt}
Add a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-compnum @var{rt} @var{cn}
Add a ratnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-ratnum-cflonum @var{rt} @var{cfl}
Add a ratnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Compnum as first operand


@deffn {Unsafe Operation} $add-compnum-fixnum @var{cn} @var{fx}
Add a compnum with a fixnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-compnum-bignum @var{cn} @var{bn}
Add a compnum with a bignum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-compnum-ratnum @var{cn} @var{rt}
Add a compnum with a ratnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-compnum-compnum @vari{cn} @varii{cn}
Add a compnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $add-compnum-flonum @var{cn} @var{fl}
Add a compnum with a flonum and return the result as a compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $add-compnum-cflonum @var{cn} @var{cfl}
Add a compnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Cflonum as first operand


@deffn {Unsafe Operation} $add-cflonum-fixnum @var{cfl} @var{fx}
Add a cflonum with a fixnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-bignum @var{cfl} @var{bn}
Add a cflonum with a bignum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-ratnum @var{cfl} @var{rt}
Add a cflonum with a ratnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-flonum @var{cfl} @var{fl}
Add a cflonum with a flonum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-compnum @var{cfl} @var{cn}
Add a cflonum with a compnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $add-cflonum-cflonum @vari{cfl} @varii{cfl}
Add a cflonum with a cflonum and return the result as a cflonum.
@end deffn

@c page
@node syslib numerics sub
@subsection Numbers subtraction


@deffn {Unsafe Operation} $sub-number-number @vari{num} @varii{num}
Subtract any couple of numbers and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as second operand


@deffn {Unsafe Operation} $sub-fixnum-number @var{fx} @var{num}
Subtract a fixnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-number @var{bn} @var{num}
Subtract a bignum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-number @var{fl} @var{num}
Subtract a flonum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-number @var{rt} @var{num}
Subtract a ratnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-number @var{cn} @var{num}
Subtract a compnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-number @var{cfl} @var{num}
Subtract a cflonum with a number and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as first operand


@deffn {Unsafe Operation} $sub-number-fixnum @var{num} @var{fx}
Subtract any number with a fixnum and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-number-bignum @var{num} @var{bn}
Subtract any number with a bignum and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-number-flonum @var{num} @var{fl}
Subtract any number with a flonum and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-number-ratnum @var{num} @var{rt}
Subtract any number with a ratnum and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-number-compnum @var{num} @var{cn}
Subtract any number with a compnum and return the result.
@end deffn


@deffn {Unsafe Operation} $sub-number-cflonum @var{num} @var{cfl}
Subtract any number with a cflonum and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first operand


@deffn {Unsafe Operation} $sub-fixnum-fixnum @vari{fx} @varii{fx}
Subtract a fixnum with a fixnum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $sub-fixnum-bignum @var{fx} @var{bn}
Subtract a fixnum with a bignum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $sub-fixnum-flonum @var{fx} @var{fl}
Subtract a fixnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-fixnum-ratnum @var{fx} @var{rt}
Subtract a fixnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $sub-fixnum-compnum @var{fx} @var{cn}
Subtract a fixnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-fixnum-cflonum @var{fx} @var{cfl}
Subtract a fixnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first operand


@deffn {Unsafe Operation} $sub-bignum-fixnum @var{bn} @var{fx}
Subtract a bignum with a fixnum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-bignum @vari{bn} @varii{bn}
Subtract a bignum with a bignum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-flonum @var{bn} @var{fl}
Subtract a bignum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-ratnum @var{bn} @var{rt}
Subtract a bignum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-compnum @var{bn} @var{cn}
Subtract a bignum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-bignum-cflonum @var{bn} @var{cfl}
Subtract a bignum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first operand


@deffn {Unsafe Operation} $sub-flonum-fixnum @var{fl} @var{fx}
Subtract a flonum with a fixnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-bignum @var{fl} @var{bn}
Subtract a flonum with a bignum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-flonum @vari{fl} @varii{fl}
Subtract a flonum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-ratnum @var{fl} @var{rt}
Subtract a flonum with a ratnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-compnum @var{fl} @var{cn}
Subtract a flonum with a compnum and return the result as a compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-flonum-cflonum @var{fl} @var{cfl}
Subtract a flonum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first operand


@deffn {Unsafe Operation} $sub-ratnum-fixnum @var{rt} @var{fx}
Subtract a ratnum with a fixnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-bignum @var{rt} @var{bn}
Subtract a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-flonum @var{rt} @var{fl}
Subtract a ratnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-ratnum @vari{rt} @varii{rt}
Subtract a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-compnum @var{rt} @var{cn}
Subtract a ratnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-ratnum-cflonum @var{rt} @var{cfl}
Subtract a ratnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Compnum as first operand


@deffn {Unsafe Operation} $sub-compnum-fixnum @var{cn} @var{fx}
Subtract a compnum with a fixnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-bignum @var{cn} @var{bn}
Subtract a compnum with a bignum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-ratnum @var{cn} @var{rt}
Subtract a compnum with a ratnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-compnum @vari{cn} @varii{cn}
Subtract a compnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-flonum @var{cn} @var{fl}
Subtract a compnum with a flonum and return the result as a compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-compnum-cflonum @var{cn} @var{cfl}
Subtract a compnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Cflonum as first operand


@deffn {Unsafe Operation} $sub-cflonum-fixnum @var{cfl} @var{fx}
Subtract a cflonum with a fixnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-bignum @var{cfl} @var{bn}
Subtract a cflonum with a bignum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-ratnum @var{cfl} @var{rt}
Subtract a cflonum with a ratnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-flonum @var{cfl} @var{fl}
Subtract a cflonum with a flonum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-compnum @var{cfl} @var{cn}
Subtract a cflonum with a compnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $sub-cflonum-cflonum @vari{cfl} @varii{cfl}
Subtract a cflonum with a cflonum and return the result as a cflonum.
@end deffn

@c page
@node syslib numerics mul
@subsection Numbers multiplication


@deffn {Unsafe Operation} $mul-number-number @vari{num} @varii{num}
Multiply any couple of numbers and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as second operand


@deffn {Unsafe Operation} $mul-fixnum-number @var{fx} @var{num}
Multiply a fixnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-number @var{bn} @var{num}
Multiply a bignum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-number @var{fl} @var{num}
Multiply a flonum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-number @var{rt} @var{num}
Multiply a ratnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-number @var{cn} @var{num}
Multiply a compnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-number @var{cfl} @var{num}
Multiply a cflonum with a number and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as first operand


@deffn {Unsafe Operation} $mul-number-fixnum @var{num} @var{fx}
Multiply any number with a fixnum and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-number-bignum @var{num} @var{bn}
Multiply any number with a bignum and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-number-flonum @var{num} @var{fl}
Multiply any number with a flonum and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-number-ratnum @var{num} @var{rt}
Multiply any number with a ratnum and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-number-compnum @var{num} @var{cn}
Multiply any number with a compnum and return the result.
@end deffn


@deffn {Unsafe Operation} $mul-number-cflonum @var{num} @var{cfl}
Multiply any number with a cflonum and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first operand


@deffn {Unsafe Operation} $mul-fixnum-fixnum @vari{fx} @varii{fx}
Multiply a fixnum with a fixnum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $mul-fixnum-bignum @var{fx} @var{bn}
Multiply a fixnum with a bignum and return the result as a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $mul-fixnum-flonum @var{fx} @var{fl}
Multiply a fixnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-fixnum-ratnum @var{fx} @var{rt}
Multiply a fixnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $mul-fixnum-compnum @var{fx} @var{cn}
Multiply a fixnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-fixnum-cflonum @var{fx} @var{cfl}
Multiply a fixnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first operand


@deffn {Unsafe Operation} $mul-bignum-fixnum @var{bn} @var{fx}
Multiply a bignum with a fixnum and return the result as a bignum.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-bignum @vari{bn} @varii{bn}
Multiply a bignum with a bignum and return the result as a bignum.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-flonum @var{bn} @var{fl}
Multiply a bignum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-ratnum @var{bn} @var{rt}
Multiply a bignum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-compnum @var{bn} @var{cn}
Multiply a bignum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-bignum-cflonum @var{bn} @var{cfl}
Multiply a bignum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first operand


@deffn {Unsafe Operation} $mul-flonum-fixnum @var{fl} @var{fx}
Multiply a flonum with a fixnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-bignum @var{fl} @var{bn}
Multiply a flonum with a bignum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-flonum @vari{fl} @varii{fl}
Multiply a flonum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-ratnum @var{fl} @var{rt}
Multiply a flonum with a ratnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-compnum @var{fl} @var{cn}
Multiply a flonum with a compnum and return the result as cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-flonum-cflonum @var{fl} @var{cfl}
Multiply a flonum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first operand


@deffn {Unsafe Operation} $mul-ratnum-fixnum @var{rt} @var{fx}
Multiply a ratnum with a fixnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-bignum @var{rt} @var{bn}
Multiply a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-flonum @var{rt} @var{fl}
Multiply a ratnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-ratnum @vari{rt} @varii{rt}
Multiply a ratnum with a ratnum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-compnum @var{rt} @var{cn}
Multiply a ratnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-ratnum-cflonum @var{rt} @var{cfl}
Multiply a ratnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Compnum as first operand


@deffn {Unsafe Operation} $mul-compnum-fixnum @var{cn} @var{fx}
Multiply a compnum with a fixnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-bignum @var{cn} @var{bn}
Multiply a compnum with a bignum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-ratnum @var{cn} @var{rt}
Multiply a compnum with a ratnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-compnum @vari{cn} @varii{cn}
Multiply a compnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-flonum @var{cn} @var{fl}
Multiply a compnum with a flonum and return the result as cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-compnum-cflonum @var{cn} @var{cfl}
Multiply a compnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Cflonum as first operand


@deffn {Unsafe Operation} $mul-cflonum-fixnum @var{cfl} @var{fx}
Multiply a cflonum with a fixnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-bignum @var{cfl} @var{bn}
Multiply a cflonum with a bignum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-ratnum @var{cfl} @var{rt}
Multiply a cflonum with a ratnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-flonum @var{cfl} @var{fl}
Multiply a cflonum with a flonum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-compnum @var{cfl} @var{cn}
Multiply a cflonum with a compnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $mul-cflonum-cflonum @vari{cfl} @varii{cfl}
Multiply a cflonum with a cflonum and return the result as a cflonum.
@end deffn

@c page
@node syslib numerics div
@subsection Numbers division


@deffn {Unsafe Operation} $div-number-number @vari{num} @varii{num}
Divide any couple of numbers and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as second operand


@deffn {Unsafe Operation} $div-fixnum-number @var{fx} @var{num}
Divide a fixnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $div-bignum-number @var{bn} @var{num}
Divide a bignum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $div-flonum-number @var{fl} @var{num}
Divide a flonum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-number @var{rt} @var{num}
Divide a ratnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $div-compnum-number @var{cn} @var{num}
Divide a compnum with a number and return the result.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-number @var{cfl} @var{num}
Divide a cflonum with a number and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Generic number as first operand


@deffn {Unsafe Operation} $div-number-fixnum @var{num} @var{fx}
Divide any number with a fixnum and return the result.
@end deffn


@deffn {Unsafe Operation} $div-number-bignum @var{num} @var{bn}
Divide any number with a bignum and return the result.
@end deffn


@deffn {Unsafe Operation} $div-number-flonum @var{num} @var{fl}
Divide any number with a flonum and return the result.
@end deffn


@deffn {Unsafe Operation} $div-number-ratnum @var{num} @var{rt}
Divide any number with a ratnum and return the result.
@end deffn


@deffn {Unsafe Operation} $div-number-compnum @var{num} @var{cn}
Divide any number with a compnum and return the result.
@end deffn


@deffn {Unsafe Operation} $div-number-cflonum @var{num} @var{cfl}
Divide any number with a cflonum and return the result.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first operand


@deffn {Unsafe Operation} $div-fixnum-fixnum @vari{fx} @varii{fx}
Divide a fixnum with a fixnum and return the result as a fixnum or
ratnum.
@end deffn


@deffn {Unsafe Operation} $div-fixnum-bignum @var{fx} @var{bn}
Divide a fixnum with a bignum and return the result as a ratnum.
@end deffn


@deffn {Unsafe Operation} $div-fixnum-flonum @var{fx} @var{fl}
Divide a fixnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-fixnum-ratnum @var{fx} @var{rt}
Divide a fixnum with a ratnum and return the result as fixnum, bignum or
ratnum.
@end deffn


@deffn {Unsafe Operation} $div-fixnum-compnum @var{fx} @var{cn}
Divide a fixnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-fixnum-cflonum @var{fx} @var{cfl}
Divide a fixnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first operand


@deffn {Unsafe Operation} $div-bignum-fixnum @var{bn} @var{fx}
Divide a bignum with a fixnum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-bignum-bignum @vari{bn} @varii{bn}
Divide a bignum with a bignum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-bignum-flonum @var{bn} @var{fl}
Divide a bignum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-bignum-ratnum @var{bn} @var{rt}
Divide a bignum with a ratnum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-bignum-compnum @var{bn} @var{cn}
Divide a bignum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-bignum-cflonum @var{bn} @var{cfl}
Divide a bignum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first operand


@deffn {Unsafe Operation} $div-flonum-fixnum @var{fl} @var{fx}
Divide a flonum with a fixnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-flonum-bignum @var{fl} @var{bn}
Divide a flonum with a bignum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-flonum-flonum @vari{fl} @varii{fl}
Divide a flonum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-flonum-ratnum @var{fl} @var{rt}
Divide a flonum with a ratnum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-flonum-compnum @var{fl} @var{cn}
Divide a flonum with a compnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-flonum-cflonum @var{fl} @var{cfl}
Divide a flonum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first operand


@deffn {Unsafe Operation} $div-ratnum-fixnum @var{rt} @var{fx}
Divide a ratnum with a fixnum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-bignum @var{rt} @var{bn}
Divide a ratnum with a ratnum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-flonum @var{rt} @var{fl}
Divide a ratnum with a flonum and return the result as a flonum.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-ratnum @vari{rt} @varii{rt}
Divide a ratnum with a ratnum and return the result as a fixnum, bignum
or ratnum.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-compnum @var{rt} @var{cn}
Divide a ratnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-ratnum-cflonum @var{rt} @var{cfl}
Divide a ratnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Compnum as first operand


@deffn {Unsafe Operation} $div-compnum-fixnum @var{cn} @var{fx}
Divide a compnum with a fixnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-compnum-bignum @var{cn} @var{bn}
Divide a compnum with a bignum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-compnum-ratnum @var{cn} @var{rt}
Divide a compnum with a ratnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-compnum-compnum @vari{cn} @varii{cn}
Divide a compnum with a compnum and return the result as a compnum.
@end deffn


@deffn {Unsafe Operation} $div-compnum-flonum @var{cn} @var{fl}
Divide a compnum with a flonum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-compnum-cflonum @var{cn} @var{cfl}
Divide a compnum with a cflonum and return the result as a cflonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Cflonum as first operand


@deffn {Unsafe Operation} $div-cflonum-fixnum @var{cfl} @var{fx}
Divide a cflonum with a fixnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-bignum @var{cfl} @var{bn}
Divide a cflonum with a bignum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-ratnum @var{cfl} @var{rt}
Divide a cflonum with a ratnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-flonum @var{cfl} @var{fl}
Divide a cflonum with a flonum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-compnum @var{cfl} @var{cn}
Divide a cflonum with a compnum and return the result as a cflonum.
@end deffn


@deffn {Unsafe Operation} $div-cflonum-cflonum @vari{cfl} @varii{cfl}
Divide a cflonum with a cflonum and return the result as a cflonum.
@end deffn

@c page
@node syslib numerics square
@subsection Numbers squaring


To compute the square of any number just use @func{square}; to compute
the square of a flonum use @func{flsquare} or @func{$flsquare}.


@deffn {Unsafe Operation} $square-fixnum @var{fx}
Compute the square of a fixnum and return the result as fixnum or
bignum.
@end deffn


@deffn {Unsafe Operation} $square-bignum @var{bn}
Compute the square of a bignum and return the result as bignum.
@end deffn


@deffn {Unsafe Operation} $square-ratnum @var{rt}
Compute the square of a ratnum and return the result as ratnum.
@end deffn


@deffn {Unsafe Operation} $square-compnum @var{cn}
Compute the square of a compnum and return the result as compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $square-cflonum @var{cfl}
Compute the square of a cflonum and return the result as cflonum.
@end deffn

@c page
@node syslib numerics cube
@subsection Cube of numbers


To compute the cube of any number just use @func{cube}; to compute the
cube of a flonum use @func{flcube} or @func{$flcube}.


@deffn {Unsafe Operation} $cube-fixnum @var{fx}
Compute the cube of a fixnum and return the result as fixnum or
bignum.
@end deffn


@deffn {Unsafe Operation} $cube-bignum @var{bn}
Compute the cube of a bignum and return the result as bignum.
@end deffn


@deffn {Unsafe Operation} $cube-ratnum @var{rt}
Compute the cube of a ratnum and return the result as ratnum.
@end deffn


@deffn {Unsafe Operation} $cube-compnum @var{cn}
Compute the cube of a compnum and return the result as compnum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $cube-cflonum @var{cfl}
Compute the cube of a cflonum and return the result as cflonum.
@end deffn

@c page
@node syslib numerics gcd
@subsection Greatest common divisor


@deffn {Unsafe Operation} $gcd-number @var{x}
Return the greatest common divisor of standalone @var{x}, an exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-number-number @vari{x} @varii{x}
Return the greatest common divisor between any couple of exact or
inexact integers; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exact or inexact integer as second argument


@deffn {Unsafe Operation} $gcd-fixnum-number @var{fx} @var{x}
Return the greatest common divisor between a fixnum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-bignum-number @var{bn} @var{x}
Return the greatest common divisor between a bignum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-flonum-number @var{fl} @var{x}
Return the greatest common divisor between a flonum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exact or inexact integer as first argument


@deffn {Unsafe Operation} $gcd-number-fixnum @var{x} @var{fx}
Return the greatest common divisor between any exact or inexact integer
and a fixnum; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-number-bignum @var{x} @var{bn}
Return the greatest common divisor between any exact or inexact integer
and a bignum; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-number-flonum @var{x} @var{fl}
Return the greatest common divisor between any exact or inexact integer
and a flonum; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $gcd-fixnum-fixnum @vari{fx} @varii{fx}
Return the greatest common divisor between a fixnum and a fixnum; return
a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $gcd-fixnum-bignum @var{fx} @var{bn}
Return the greatest common divisor between a fixnum and a bignum; return
a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $gcd-fixnum-flonum @var{fx} @var{fl}
Return the greatest common divisor between a fixnum and a flonum; return
a flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $gcd-bignum-fixnum @var{bn} @var{fx}
Return the greatest common divisor between a bignum and a fixnum; return
a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $gcd-bignum-bignum @vari{bn} @varii{bn}
Return the greatest common divisor between a bignum and a bignum; return
a bignum.
@end deffn


@deffn {Unsafe Operation} $gcd-bignum-flonum @var{bn} @var{fl}
Return the greatest common divisor between a bignum and a flonum; return
a flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $gcd-flonum-fixnum @var{fl} @var{fx}
Return the greatest common divisor between a flonum and a fixnum; return
a flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-flonum-bignum @var{fl} @var{bn}
Return the greatest common divisor between a flonum and a bignum; return
a flonum.
@end deffn


@deffn {Unsafe Operation} $gcd-flonum-flonum @vari{fl} @varii{fl}
Return the greatest common divisor between a flonum and a flonum; return
a flonum.
@end deffn

@c page
@node syslib numerics lcm
@subsection Least common multiple


@deffn {Unsafe Operation} $lcm-number @var{x}
Return the least common multiple of standalone @var{x}, an exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-number-number @vari{x} @varii{x}
Return the least common multiple between any couple of exact and inexact
integers; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exact or inexact integer as second argument


@deffn {Unsafe Operation} $lcm-fixnum-number @var{fx} @var{x}
Return the least common multiple between a fixnum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-bignum-number @var{bn} @var{x}
Return the least common multiple between a bignum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-flonum-number @var{fl} @var{x}
Return the least common multiple between a flonum and any exact or
inexact integer; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exact or inexact integer as first argument


@deffn {Unsafe Operation} $lcm-number-fixnum @var{x} @var{fx}
Return the least common multiple between any exact or inexact integer
and a fixnum; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-number-bignum @var{x} @var{bn}
Return the least common multiple between any exact or inexact integer
and a bignum; return a fixnum, bignum or flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-number-flonum @var{x} @var{fl}
Return the least common multiple between any exact or inexact integer
and a flonum; return a fixnum, bignum or flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $lcm-fixnum-fixnum @vari{fx} @varii{fx}
Return the least common multiple between a fixnum and a fixnum; return a
fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $lcm-fixnum-bignum @var{fx} @var{bn}
Return the least common multiple between a fixnum and a bignum; return a
fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $lcm-fixnum-flonum @var{fx} @var{fl}
Return the least common multiple between a fixnum and a flonum; return a
flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $lcm-bignum-fixnum @var{bn} @var{fx}
Return the least common multiple between a bignum and a fixnum; return a
fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $lcm-bignum-bignum @vari{bn} @varii{bn}
Return the least common multiple between a bignum and a bignum; return a
bignum.
@end deffn


@deffn {Unsafe Operation} $lcm-bignum-flonum @var{bn} @var{fl}
Return the least common multiple between a bignum and a flonum; return a
flonum.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $lcm-flonum-fixnum @var{fl} @var{fx}
Return the least common multiple between a flonum and a fixnum; return a
flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-flonum-bignum @var{fl} @var{bn}
Return the least common multiple between a flonum and a bignum; return a
flonum.
@end deffn


@deffn {Unsafe Operation} $lcm-flonum-flonum @vari{fl} @varii{fl}
Return the least common multiple between a flonum and a flonum; return a
flonum.
@end deffn

@c page
@node syslib numerics quorem
@subsection Quotient and remainder


These functions perform the integer division between exact and inexact
numbers and return two values: the quotient and the remainder.  For all
the functions: the second argument must be non--zero.

Note that considering:

@example
(quotient+remainder X Y)
@end example

@noindent
according to @rnrs{6}:

@example
(define (sign n)
  (cond ((negative? n) -1)
        ((positive? n) 1)
        (else 0)))

(define (quotient n1 n2)
  (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

(define (remainder n1 n2)
  (* (sign n1) (mod (abs n1) (abs n2))))

(define (modulo n1 n2)
  (* (sign n2) (mod (* (sign n2) n1) (abs n2))))
@end example

@noindent
so we have:

@example
sign(quotient)  = sign(X) * sign(Y)
sign(remainder) = sign(X)
sign(modulo)    = sign(Y)
@end example

@c ------------------------------------------------------------

@subsubheading Any number as first argument


@deffn {Unsafe Operation} $quotient+remainder-number-fixnum @var{num} @var{fx}
Perform the integer division between any exact or inexact integer and a
fixnum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-number-bignum @var{num} @var{bn}
Perform the integer division between any exact or inexact integer and a
bignum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-number-flonum @var{num} @var{fl}
Perform the integer division between any exact or inexact integer and a
flonum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $quotient+remainder-fixnum-number @var{fx} @var{num}
Perform the integer division between a fixnum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-bignum-number @var{bn} @var{num}
Perform the integer division between a bignum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-flonum-number @var{fl} @var{num}
Perform the integer division between a flonum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $quotient+remainder-fixnum-fixnum @vari{fx} @varii{fx}
Perform the integer division between a fixnum and a fixnum; return a
fixnum or bignum as quotient, return a fixnum as remainder.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-fixnum-bignum @var{fx} @var{bn}
Perform the integer division between a fixnum and a bignum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-fixnum-flonum @var{fx} @var{fl}
Perform the integer division between a fixnum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $quotient+remainder-bignum-fixnum @var{bn} @var{fx}
Perform the integer division between a bignum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-bignum-bignum @vari{bn} @varii{bn}
Perform the integer division between a bignum and a bignum; return
fixnums or bignums.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-bignum-flonum @var{bn} @var{fl}
Perform the integer division between a bignum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $quotient+remainder-flonum-fixnum @var{fl} @var{fx}
Perform the integer division between a flonum and a fixnum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-flonum-bignum @var{fl} @var{bn}
Perform the integer division between a flonum and a bignum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $quotient+remainder-flonum-flonum @vari{fl} @varii{fl}
Perform the integer division between a flonum and a flonum; return
flonums.
@end deffn

@c page
@node syslib numerics quotient
@subsection Quotient between numbers


These functions perform the integer division between exact and inexact
numbers and return the quotient.  For all the functions: the second
argument must be non--zero.  @ref{syslib numerics quorem} for more
details on the operations.

@c ------------------------------------------------------------

@subsubheading Any number as first argument


@deffn {Unsafe Operation} $quotient-number-fixnum @var{num} @var{fx}
Perform the integer division between any exact or inexact integer and a
fixnum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient-number-bignum @var{num} @var{bn}
Perform the integer division between any exact or inexact integer and a
bignum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient-number-flonum @var{num} @var{fl}
Perform the integer division between any exact or inexact integer and a
flonum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $quotient-fixnum-number @var{fx} @var{num}
Perform the integer division between a fixnum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient-bignum-number @var{bn} @var{num}
Perform the integer division between a bignum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $quotient-flonum-number @var{fl} @var{num}
Perform the integer division between a flonum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $quotient-fixnum-fixnum @vari{fx} @varii{fx}
Perform the integer division between a fixnum and a fixnum; return a
fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $quotient-fixnum-bignum @var{fx} @var{bn}
Perform the integer division between a fixnum and a bignum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $quotient-fixnum-flonum @var{fx} @var{fl}
Perform the integer division between a fixnum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $quotient-bignum-fixnum @var{bn} @var{fx}
Perform the integer division between a bignum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $quotient-bignum-bignum @vari{bn} @varii{bn}
Perform the integer division between a bignum and a bignum; return
fixnums or bignums.
@end deffn


@deffn {Unsafe Operation} $quotient-bignum-flonum @var{bn} @var{fl}
Perform the integer division between a bignum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $quotient-flonum-fixnum @var{fl} @var{fx}
Perform the integer division between a flonum and a fixnum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $quotient-flonum-bignum @var{fl} @var{bn}
Perform the integer division between a flonum and a bignum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $quotient-flonum-flonum @vari{fl} @varii{fl}
Perform the integer division between a flonum and a flonum; return
flonums.
@end deffn

@c page
@node syslib numerics remainder
@subsection Remainder between numbers


These functions perform the integer division between exact and inexact
numbers and return the remainder.  For all the functions: the second
argument must be non--zero.  @ref{syslib numerics quorem} for more
details on the operations.

@c ------------------------------------------------------------

@subsubheading Any number as first argument


@deffn {Unsafe Operation} $remainder-number-fixnum @var{num} @var{fx}
Perform the integer division between any exact or inexact integer and a
fixnum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $remainder-number-bignum @var{num} @var{bn}
Perform the integer division between any exact or inexact integer and a
bignum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $remainder-number-flonum @var{num} @var{fl}
Perform the integer division between any exact or inexact integer and a
flonum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $remainder-fixnum-number @var{fx} @var{num}
Perform the integer division between a fixnum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $remainder-bignum-number @var{bn} @var{num}
Perform the integer division between a bignum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $remainder-flonum-number @var{fl} @var{num}
Perform the integer division between a flonum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $remainder-fixnum-fixnum @vari{fx} @varii{fx}
Perform the integer division between a fixnum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $remainder-fixnum-bignum @var{fx} @var{bn}
Perform the integer division between a fixnum and a bignum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $remainder-fixnum-flonum @var{fx} @var{fl}
Perform the integer division between a fixnum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $remainder-bignum-fixnum @var{bn} @var{fx}
Perform the integer division between a bignum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $remainder-bignum-bignum @vari{bn} @varii{bn}
Perform the integer division between a bignum and a bignum; return
fixnums or bignums.
@end deffn


@deffn {Unsafe Operation} $remainder-bignum-flonum @var{bn} @var{fl}
Perform the integer division between a bignum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $remainder-flonum-fixnum @var{fl} @var{fx}
Perform the integer division between a flonum and a fixnum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $remainder-flonum-bignum @var{fl} @var{bn}
Perform the integer division between a flonum and a bignum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $remainder-flonum-flonum @vari{fl} @varii{fl}
Perform the integer division between a flonum and a flonum; return
flonums.
@end deffn

@c page
@node syslib numerics modulo
@subsection Modulo between numbers


These functions perform the integer division between exact and inexact
numbers and return the modulo.  For all the functions: the second
argument must be non--zero.  @ref{syslib numerics quorem} for more
details on the operations.

@c ------------------------------------------------------------

@subsubheading Any number as first argument


@deffn {Unsafe Operation} $modulo-number-fixnum @var{num} @var{fx}
Perform the integer division between any exact or inexact integer and a
fixnum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $modulo-number-bignum @var{num} @var{bn}
Perform the integer division between any exact or inexact integer and a
bignum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $modulo-number-flonum @var{num} @var{fl}
Perform the integer division between any exact or inexact integer and a
flonum.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $modulo-fixnum-number @var{fx} @var{num}
Perform the integer division between a fixnum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $modulo-bignum-number @var{bn} @var{num}
Perform the integer division between a bignum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn


@deffn {Unsafe Operation} $modulo-flonum-number @var{fl} @var{num}
Perform the integer division between a flonum and any exact or inexact
integer.  If @var{num} is not an integer: an error is raised.  Return
exact or inexact integers.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $modulo-fixnum-fixnum @vari{fx} @varii{fx}
Perform the integer division between a fixnum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $modulo-fixnum-bignum @var{fx} @var{bn}
Perform the integer division between a fixnum and a bignum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $modulo-fixnum-flonum @var{fx} @var{fl}
Perform the integer division between a fixnum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $modulo-bignum-fixnum @var{bn} @var{fx}
Perform the integer division between a bignum and a fixnum; return
fixnums.
@end deffn


@deffn {Unsafe Operation} $modulo-bignum-bignum @vari{bn} @varii{bn}
Perform the integer division between a bignum and a bignum; return
fixnums or bignums.
@end deffn


@deffn {Unsafe Operation} $modulo-bignum-flonum @var{bn} @var{fl}
Perform the integer division between a bignum and a flonum; return
flonums.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $modulo-flonum-fixnum @var{fl} @var{fx}
Perform the integer division between a flonum and a fixnum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $modulo-flonum-bignum @var{fl} @var{bn}
Perform the integer division between a flonum and a bignum; return
flonums.
@end deffn


@deffn {Unsafe Operation} $modulo-flonum-flonum @vari{fl} @varii{fl}
Perform the integer division between a flonum and a flonum; return
flonums.
@end deffn

@c page
@node syslib numerics max
@subsection Maximum between numbers


Notice that if one of the operands is @code{+nan.0} the result is
@code{+nan.0}.


@subsubheading Any number as first argument


@deffn {Unsafe Operation} $max-number-fixnum @var{num} @var{fx}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-number-bignum @var{num} @var{bn}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-number-ratnum @var{num} @var{rt}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-number-flonum @var{num} @var{fl}
Return the maximum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $max-fixnum-number @var{fx} @var{num}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-bignum-number @var{bn} @var{num}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-flonum-number @var{fl} @var{num}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-ratnum-number @var{rt} @var{num}
Return the maximum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $max-fixnum-fixnum @vari{fx} @varii{fx}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-fixnum-bignum @var{fx} @var{bn}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-fixnum-flonum @var{fx} @var{fl}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-fixnum-ratnum @var{fx} @var{rt}
Return the maximum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $max-bignum-fixnum @var{bn} @var{fx}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-bignum-bignum @vari{bn} @varii{bn}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-bignum-ratnum @var{bn} @var{rt}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-bignum-flonum @var{bn} @var{fl}
Return the maximum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $max-flonum-fixnum @var{fl} @var{fx}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-flonum-bignum @var{fl} @var{bn}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-flonum-ratnum @var{fl} @var{rt}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-flonum-flonum @vari{fl} @varii{fl}
Return the maximum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first argument


@deffn {Unsafe Operation} $max-ratnum-fixnum @var{rt} @var{fx}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-ratnum-bignum @var{rt} @var{bn}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-ratnum-ratnum @vari{rt} @varii{rt}
Return the maximum between the arguments.
@end deffn


@deffn {Unsafe Operation} $max-ratnum-flonum @var{rt} @var{fl}
Return the maximum between the arguments.
@end deffn

@c page
@node syslib numerics min
@subsection Minimum between numbers


Notice that if one of the operands is @code{+nan.0} the result is
@code{+nan.0}.


@subsubheading Any number as first argument


@deffn {Unsafe Operation} $min-number-fixnum @var{num} @var{fx}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-number-bignum @var{num} @var{bn}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-number-ratnum @var{num} @var{rt}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-number-flonum @var{num} @var{fl}
Return the minimum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Any number as second argument


@deffn {Unsafe Operation} $min-fixnum-number @var{fx} @var{num}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-bignum-number @var{bn} @var{num}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-flonum-number @var{fl} @var{num}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-ratnum-number @var{rt} @var{num}
Return the minimum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Fixnum as first argument


@deffn {Unsafe Operation} $min-fixnum-fixnum @vari{fx} @varii{fx}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-fixnum-bignum @var{fx} @var{bn}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-fixnum-flonum @var{fx} @var{fl}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-fixnum-ratnum @var{fx} @var{rt}
Return the minimum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Bignum as first argument


@deffn {Unsafe Operation} $min-bignum-fixnum @var{bn} @var{fx}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-bignum-bignum @vari{bn} @varii{bn}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-bignum-ratnum @var{bn} @var{rt}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-bignum-flonum @var{bn} @var{fl}
Return the minimum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Flonum as first argument


@deffn {Unsafe Operation} $min-flonum-fixnum @var{fl} @var{fx}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-flonum-bignum @var{fl} @var{bn}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-flonum-ratnum @var{fl} @var{rt}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-flonum-flonum @vari{fl} @varii{fl}
Return the minimum between the arguments.
@end deffn

@c ------------------------------------------------------------

@subsubheading Ratnum as first argument


@deffn {Unsafe Operation} $min-ratnum-fixnum @var{rt} @var{fx}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-ratnum-bignum @var{rt} @var{bn}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-ratnum-ratnum @vari{rt} @varii{rt}
Return the minimum between the arguments.
@end deffn


@deffn {Unsafe Operation} $min-ratnum-flonum @var{rt} @var{fl}
Return the minimum between the arguments.
@end deffn

@c page
@node syslib numerics abs
@subsection Absolute value of real numbers


@deffn {Unsafe Operation} $abs-fixnum @var{fx}
Compute the absolute value of a fixnum; return a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $abs-bignum @var{bn}
Compute the absolute value of a bignum; return a fixnum or bignum.
@end deffn


@deffn {Unsafe Operation} $abs-flonum @var{fl}
Compute the absolute value of a flonum; return a flonum.
@end deffn


@deffn {Unsafe Operation} $abs-ratnum
Compute the absolute value of a ratnum; return a ratnum.
@end deffn

@c page
@node syslib numerics sign
@subsection Sign of real numbers


@deffn {Unsafe Operation} $sign-fixnum @var{fx}
Return a fixnum representing the sign of @var{fx}: @code{+1} for
positive, @code{-1} for negative, @code{0} for zero.
@end deffn


@deffn {Unsafe Operation} $sign-bignum @var{bn}
Return a fixnum representing the sign of @var{bn}: @code{+1} for
positive, @code{-1} for negative.  Bignums do not represent zero.
@end deffn


@deffn {Unsafe Operation} $sign-flonum @var{fl}
Return a flonum representing the sign of @var{fx}: @code{+1.0} for
positive, including @code{+0.0} and @code{+inf.0}; @code{-1.0} for
negative, including @code{-0.0} and @code{-inf.0}; @code{+nan.0} for
not--a--number.
@end deffn


@deffn {Unsafe Operation} $sign-ratnum @var{rt}
Return a fixnum representing the sign of the numerator of @var{rt}:
@code{+1} for positive, @code{-1} for negative.  Ratnums do not
represent zero.
@end deffn

@c page
@node syslib numerics expt
@subsection Raising numbers to power


@menu
* syslib numerics expt any::            Any number as first argument.
* syslib numerics expt zero::           Exact zero exponent.
* syslib numerics expt posi::           Positive fixnum exponent.
* syslib numerics expt nega::           Negative fixnum exponent.
* syslib numerics expt fixnums::        Fixnum as first argument.
* syslib numerics expt bignums::        Bignum as first argument.
* syslib numerics expt ratnums::        Ratnum as first argument.
* syslib numerics expt flonums::        Flonum as first argument.
* syslib numerics expt compnums::       Compnum as first argument.
* syslib numerics expt cflonums::       Cflonum as first argument.
@end menu

@c page
@node syslib numerics expt any
@subsubsection Any number as first argument


@deffn {Unsafe Operation} $expt-number-fixnum @var{num} @var{fx}
Compute @var{num} raised to the power @var{fx}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $expt-number-bignum @var{num} @var{bn}
Compute @var{num} raised to the power @var{bn}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $expt-number-flonum @var{num} @var{fl}
Compute @var{num} raised to the power @var{fl}; return an unspecified
inexact number object.
@end deffn


@deffn {Unsafe Operation} $expt-number-ratnum @var{num} @var{rt}
Compute @var{num} raised to the power @var{rt}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $expt-number-compnum @var{num} @var{cn}
Compute @var{num} raised to the power @var{cn}; return an unspecified
number object, but most likely a complex number.
@end deffn


@deffn {Unsafe Operation} $expt-number-cflonum @var{num} @var{cfl}
Compute @var{num} raised to the power @var{cfl}; return an unspecified
inexact complex number object.
@end deffn

@c page
@node syslib numerics expt zero
@subsubsection Exact zero exponent


@deffn {Unsafe Operation} $expt-number-zero-fixnum @var{num}
Compute @var{num} raised to the power of exact zero; return an
unspecified number object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-zero-fixnum @var{fx}
Compute @var{fx} raised to the power of exact zero; return a fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-zero-fixnum @var{fl}
Compute @var{fl} raised to the power of exact zero; return a flonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-zero-fixnum @var{cn}
Compute @var{cn} raised to the power of exact zero; return an
unspecified number object.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-zero-fixnum @var{cfl}
Compute @var{cfl} raised to the power of exact zero; return a cflonum.
@end deffn

@c page
@node syslib numerics expt posi
@subsubsection Positive fixnum exponent


@deffn {Unsafe Operation} $expt-number-positive-fixnum @var{num} @var{fx}
Compute @var{num} raised to the power of positive @var{fx}; return an
unspecified number object.  @var{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-positive-fixnum @vari{fx} @varii{fx}
Compute @vari{fx} raised to the power of positive @varii{fx}; return an
exact number object.  @varii{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-positive-fixnum @var{bn} @var{fx}
Compute @var{bn} raised to the power of positive @var{fx}; return an
exact number object.  @var{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-positive-fixnum @var{rt} @var{fx}
Compute @var{rt} raised to the power of positive @var{fx}; return an
exact number object.  @var{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-positive-fixnum @var{fl} @var{fx}
Compute @var{fl} raised to the power of positive @var{fx}; return an
inexact number object.  @var{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-positive-fixnum @var{cn} @var{fx}
Compute @var{cn} raised to the power of positive @var{fx}; return a
cflonum.  @var{fx} must be a positive fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-positive-fixnum @var{cfl} @var{fx}
Compute @var{cfl} raised to the power of positive @var{fx}; return a
cflonum.  @var{fx} must be a positive fixnum.
@end deffn

@c page
@node syslib numerics expt nega
@subsubsection Negative fixnum exponent


@deffn {Unsafe Operation} $expt-number-negative-fixnum @var{num} @var{fx}
Compute @var{num} raised to the power of negative @var{fx}; return an
unspecified number object.  @var{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-negative-fixnum @vari{fx} @varii{fx}
Compute @vari{fx} raised to the power of negative @varii{fx}; return an
exact number object.  @varii{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-negative-fixnum @var{bn} @var{fx}
Compute @var{bn} raised to the power of negative @var{fx}; return an
exact number object.  @var{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-negative-fixnum @var{rt} @var{fx}
Compute @var{rt} raised to the power of negative @var{fx}; return an
exact number object.  @var{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-negative-fixnum @var{fl} @var{fx}
Compute @var{fl} raised to the power of negative @var{fx}; return an
inexact number object.  @var{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-negative-fixnum @var{cn} @var{fx}
Compute @var{cn} raised to the power of negative @var{fx}; return a
cflonum.  @var{fx} must be a negative fixnum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-negative-fixnum @var{cfl} @var{fx}
Compute @var{cfl} raised to the power of negative @var{fx}; return a
cflonum.  @var{fx} must be a negative fixnum.
@end deffn

@c page
@node syslib numerics expt fixnums
@subsubsection Fixnum as first argument


@deffn {Unsafe Operation} $expt-fixnum-fixnum @vari{fx} @varii{fx}
Compute @vari{fx} raised to the power @varii{fx}; return an exact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-bignum @var{fx} @var{bn}
Compute @var{fx} raised to the power @var{bn}; return an exact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-ratnum @var{fx} @var{rt}
Compute @var{fx} raised to the power @var{rt}; return an exact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-flonum @var{fx} @var{fl}
Compute @var{fx} raised to the power @var{fl}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-compnum @var{fx} @var{cn}
Compute @var{fx} raised to the power @var{cn}; return a complex number
object.
@end deffn


@deffn {Unsafe Operation} $expt-fixnum-cflonum @var{fx} @var{cfl}
Compute @var{fx} raised to the power @var{cfl}; return an inexact
complex number object.
@end deffn

@c page
@node syslib numerics expt bignums
@subsubsection Bignum as first argument


@deffn {Unsafe Operation} $expt-bignum-fixnum @var{bn} @var{fx}
Compute @var{bn} raised to the power of @var{fx}; return an exact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-bignum @vari{bn} @varii{bn}
Raise an implementation restriction violation.
@ignore
Compute @vari{bn} raised to the power @varii{bn}; return an exact number
object.
@end ignore
@end deffn


@deffn {Unsafe Operation} $expt-bignum-ratnum @var{bn} @var{rt}
Compute @var{bn} raised to the power @var{rt}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-flonum @var{bn} @var{fl}
Compute @var{bn} raised to the power @var{fl}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-compnum @var{bn} @var{cn}
Compute @var{bn} raised to the power @var{cn}; return an inexact complex
number object.
@end deffn


@deffn {Unsafe Operation} $expt-bignum-cflonum @var{bn} @var{cfl}
Compute @var{bn} raised to the power @var{cfl}; return an inexact
complex number object.
@end deffn

@c page
@node syslib numerics expt ratnums
@subsubsection Ratnum as first argument


@deffn {Unsafe Operation} $expt-ratnum-fixnum @var{rt} @var{fx}
Compute @var{rt} raised to the power of @var{fx}; return an exact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-bignum @var{rt} @var{bn}
Compute @var{rt} raised to the power @var{bn}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-ratnum @vari{rt} @varii{rt}
Compute @vari{rt} raised to the power @varii{rt}; return an inexact
number object.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-flonum @var{rt} @var{fl}
Compute @var{rt} raised to the power @var{fl}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-compnum @var{rt} @var{cn}
Compute @var{rt} raised to the power @var{cn}; return an inexact complex
number object.
@end deffn


@deffn {Unsafe Operation} $expt-ratnum-cflonum @var{rt} @var{cfl}
Compute @var{rt} raised to the power @var{cfl}; return an inexact
complex number object.
@end deffn

@c page
@node syslib numerics expt flonums
@subsubsection Flonum as first argument


@deffn {Unsafe Operation} $expt-flonum-fixnum @var{fl} @var{fx}
Compute @var{fl} raised to the power of @var{fx}; return an inexact
number object.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-bignum @var{fl} @var{bn}
Compute @var{fl} raised to the power @var{bn}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-ratnum @var{fl} @var{rt}
Compute @var{fl} raised to the power @var{rt}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-flonum @vari{fl} @varii{fl}
Compute @vari{fl} raised to the power @varii{fl}; return an inexact
number object.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-compnum @var{fl} @var{cn}
Compute @var{fl} raised to the power @var{cn}; return an inexact complex
number object.
@end deffn


@deffn {Unsafe Operation} $expt-flonum-cflonum @var{fl} @var{cfl}
Compute @var{fl} raised to the power @var{cfl}; return an inexact
complex number object.
@end deffn

@c page
@node syslib numerics expt compnums
@subsubsection Compnum as first argument


@deffn {Unsafe Operation} $expt-compnum-fixnum @var{cn} @var{fx}
Compute @var{cn} raised to the power of @var{fx}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-bignum @var{cn} @var{bn}
Compute @var{cn} raised to the power @var{bn}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-ratnum @var{cn} @var{rt}
Compute @var{cn} raised to the power @var{rt}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-flonum @var{cn} @var{fl}
Compute @var{cn} raised to the power @var{fl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-compnum @vari{cn} @varii{cn}
Compute @vari{cn} raised to the power @varii{cn}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-compnum-cflonum @var{cn} @var{cfl}
Compute @var{cn} raised to the power @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics expt cflonums
@subsubsection Cflonum as first argument


@deffn {Unsafe Operation} $expt-cflonum-fixnum @var{cfl} @var{fx}
Compute @var{cfl} raised to the power of @var{fx}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-bignum @var{cfl} @var{bn}
Compute @var{cfl} raised to the power @var{bn}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-ratnum @var{cfl} @var{rt}
Compute @var{cfl} raised to the power @var{rt}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-flonum @var{cfl} @var{fl}
Compute @var{cfl} raised to the power @var{fl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-compnum @var{cfl} @var{cn}
Compute @var{cfl} raised to the power @var{cfl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $expt-cflonum-cflonum @vari{cfl} @varii{cfl}
Compute @vari{cfl} raised to the power @varii{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics sqrt
@subsection Square root of numbers


@deffn {Unsafe Operation} $sqrt-fixnum @var{fx}
Compute the principal square root of @var{fx}; return an unspecified
number object.

@example
($sqrt-fixnum 0)       @result{} 0

($sqrt-fixnum +1)      @result{} +1
($sqrt-fixnum -1)      @result{} +1i

($sqrt-fixnum +4)      @result{} +2
($sqrt-fixnum -4)      @result{} +2i

($sqrt-fixnum +5)      @result{} 2.23606797749979
($sqrt-fixnum -5)      @result{} 0.0+2.23606797749979i
@end example
@end deffn


@deffn {Unsafe Operation} $sqrt-bignum @var{bn}
Compute the principal square root of @var{bn}; return an unspecified
number object.

@example
(define SMALLEST-POSITIVE-BIGNUM (-    (least-fixnum)))
(define SMALLEST-NEGATIVE-BIGNUM (+ -1 (least-fixnum)))

(define BN1 (+ +1  SMALLEST-POSITIVE-BIGNUM))
(define BN2 (+ +10 SMALLEST-POSITIVE-BIGNUM))
(define BN3 (+ -1  SMALLEST-NEGATIVE-BIGNUM))
(define BN4 (+ -10 SMALLEST-NEGATIVE-BIGNUM))

;; on a 32-bit host
($sqrt-bignum BN1)      @result{} 23170.475027499975
($sqrt-bignum BN2)      @result{} 23170.47522171265
($sqrt-bignum BN3)      @result{} 0.0+23170.475049079163i
($sqrt-bignum BN4)      @result{} 0.0+23170.47524329184i
@end example
@end deffn


@deffn {Unsafe Operation} $sqrt-ratnum @var{rt}
Compute the principal square root of @var{rt}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $sqrt-flonum @var{fl}
Compute the principal square root of @var{fl}; return a flonum, compnum
or cflonum.

@example
($sqrt-flonum +0.0)     @result{} +0.0
($sqrt-flonum -0.0)     @result{} +0.0i

($sqrt-flonum +4.0)     @result{} +2.0
($sqrt-flonum -4.0)     @result{} +2.0i

($sqrt-flonum +1.0)     @result{} +1.0
($sqrt-flonum -1.0)     @result{} +1.0i

($sqrt-flonum +5.0)     @result{} 2.23606797749979
($sqrt-flonum -5.0)     @result{} 0.0+2.23606797749979i

($sqrt-flonum +inf.0)   @result{} +inf.0
($sqrt-flonum -inf.0)   @result{} +inf.0i

($sqrt-flonum +nan.0)   @result{} +nan.0
@end example
@end deffn


@deffn {Unsafe Operation} $sqrt-compnum @var{cn}
Compute the principal square root of @var{cn}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $sqrt-cflonum @var{cfl}
Compute the principal square root of @var{cfl}; return a cflonum.
@end deffn

@c ------------------------------------------------------------


@deffn {Unsafe Operation} $exact-integer-sqrt-fixnum @var{fx}
Return two non--negative exact integer objects being the root and the
residual of @var{fx}.
@end deffn


@deffn {Unsafe Operation} $exact-integer-sqrt-bignum @var{bn}
Return two non--negative exact integer objects being the root and the
residual of @var{bn}.
@end deffn

@c page
@node syslib numerics cbrt
@subsection Cubic root of numbers


@deffn {Unsafe Operation} $cbrt-fixnum @var{fx}
Compute the principal cubic root of @var{fx}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $cbrt-bignum @var{bn}
Compute the principal cubic root of @var{bn}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $cbrt-ratnum @var{rt}
Compute the principal cubic root of @var{rt}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $cbrt-flonum @var{fl}
Compute the principal cubic root of @var{fl}; return a flonum, compnum
or cflonum.
@end deffn


@deffn {Unsafe Operation} $cbrt-compnum @var{cn}
Compute the principal cubic root of @var{cn}; return an unspecified
number object.
@end deffn


@deffn {Unsafe Operation} $cbrt-cflonum @var{cfl}
Compute the principal cubic root of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics log
@subsection Logarithms of numbers


@deffn {Unsafe Operation} $log-fixnum @var{fx}
Compute the natural logarithm of @var{fx}; return a fixnum, flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $log-bignum @var{bn}
Compute the natural logarithm of @var{fl}; return an inexact number
object.  cflonum.
@end deffn


@deffn {Unsafe Operation} $log-flonum @var{fl}
Compute the natural logarithm of @var{fl}; return a flonum or cflonum.
This function computes the result also when @var{fl} is a negative
flonum, whose logarithm is a complex number; this makes it different
from @func{$fllog}.
@end deffn


@deffn {Unsafe Operation} $log-ratnum @var{rt}
Compute the natural logarithm of @var{rt}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $log-compnum @var{cn}
Compute the natural logarithm of @var{cn}; return an inexact number
object.
@end deffn


@deffn {Unsafe Operation} $log-cflonum @var{cfl}
Compute the natural logarithm of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics exp
@subsection Exponentials of numbers


@deffn {Unsafe Operation} $exp-fixnum @var{fx}
Compute the base @math{e} exponential of @var{fx}; return a fixnum or
flonum.
@end deffn


@deffn {Unsafe Operation} $exp-bignum @var{bn}
Compute the base @math{e} exponential of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $exp-ratnum @var{rt}
Compute the base @math{e} exponential of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $exp-flonum @var{fl}
Compute the base @math{e} exponential of @var{fl}; return a flonum.
This is just an alias for @func{$flexp}.
@end deffn


@deffn {Unsafe Operation} $exp-compnum @var{cn}
Compute the base @math{e} exponential of @var{cn}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $exp-cflonum @var{cfl}
Compute the base @math{e} exponential of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics sin
@subsection Trigonometric sine


@deffn {Unsafe Operation} $sin-fixnum @var{fx}
Compute the trigonometric sine of @var{fx}; return a fixnum or flonum.
@end deffn


@deffn {Unsafe Operation} $sin-bignum @var{bn}
Compute the trigonometric sine of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $sin-ratnum @var{rt}
Compute the trigonometric sine of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $sin-flonum @var{fl}
Compute the trigonometric sine of @var{fl}; return a flonum.  This is an
alias for @func{$flsin}.
@end deffn


@deffn {Unsafe Operation} $sin-cflonum @var{cfl}
Compute the trigonometric sine of @var{cfl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $sin-compnum @var{cn}
Compute the trigonometric sine of @var{cn}; return a cflonum.
@end deffn

@c page
@node syslib numerics cos
@subsection Trigonometric cosine


@deffn {Unsafe Operation} $cos-fixnum @var{fx}
Compute the trigonometric cosine of @var{fx}; return a fixnum or flonum.
@end deffn


@deffn {Unsafe Operation} $cos-bignum @var{bn}
Compute the trigonometric cosine of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $cos-ratnum @var{rt}
Compute the trigonometric cosine of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $cos-flonum @var{fl}
Compute the trigonometric cosine of @var{fl}; return a flonum.  This is
an alias for @func{$flcos}.
@end deffn


@deffn {Unsafe Operation} $cos-cflonum @var{cfl}
Compute the trigonometric cosine of @var{cfl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $cos-compnum @var{cn}
Compute the trigonometric cosine of @var{cn}; return a cflonum.
@end deffn

@c page
@node syslib numerics tan
@subsection Trigonometric tangent


@deffn {Unsafe Operation} $tan-fixnum @var{fx}
Compute the trigonometric tangent of @var{fx}; return a fixnum or
flonum.
@end deffn


@deffn {Unsafe Operation} $tan-bignum @var{bn}
Compute the trigonometric tangent of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $tan-ratnum @var{rt}
Compute the trigonometric tangent of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $tan-flonum @var{fl}
Compute the trigonometric tangent of @var{fl}; return a flonum.  This is
an alias for @func{$fltan}.
@end deffn


@deffn {Unsafe Operation} $tan-cflonum @var{cfl}
Compute the trigonometric tangent of @var{cfl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $tan-compnum @var{cn}
Compute the trigonometric tangent of @var{cn}; return a cflonum.
@end deffn

@c page
@node syslib numerics asin
@subsection Trigonometric arc sine


@deffn {Unsafe Operation} $asin-fixnum @var{fx}
Compute the trigonometric arc sine of @var{fx}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $asin-bignum @var{bn}
Compute the trigonometric arc sine of @var{bn}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $asin-ratnum @var{rt}
Compute the trigonometric arc sine of @var{rt}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $asin-flonum @var{fl}
Compute the trigonometric arc sine of @var{fl}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $asin-cflonum @var{cfl}
Compute the trigonometric arc sine of @var{fl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $asin-compnum @var{cn}
Compute the trigonometric arc sine of @var{fl}; return a number object.
@end deffn

@c page
@node syslib numerics acos
@subsection Trigonometric arc cosine


@deffn {Unsafe Operation} $acos-fixnum @var{fx}
Compute the trigonometric arc cosine of @var{fx}; return a flonum or
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acos-bignum @var{bn}
Compute the trigonometric arc cosine of @var{bn}; return a flonum or
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acos-ratnum @var{rt}
Compute the trigonometric arc cosine of @var{rt}; return a flonum or
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acos-flonum @var{fl}
Compute the trigonometric arc cosine of @var{fl}; return a flonum or
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acos-cflonum @var{cfl}
Compute the trigonometric arc cosine of @var{fl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $acos-compnum @var{cn}
Compute the trigonometric arc cosine of @var{fl}; return a number
object.
@end deffn

@c page
@node syslib numerics atan
@subsection Trigonometric arc tangent


@deffn {Unsafe Operation} $atan2-real-real @var{imp} @var{rep}
Compute the principal value of the trigonometric arc tangent of flonum
@var{imp} over flonum @var{rep} using the signs of the arguments to
determine the quadrant of the result:

@example
\alpha = \atan (@var{imp}/@var{rep})
@end example

@noindent
in other words compute the angle @math{\alpha} such that:

@example
               \sin(\alpha)   @var{imp}
\tan(\alpha) = ------------ = ---
               \cos(\alpha)   @var{rep}
@end example

@noindent
in yet other words compute the angle of the complex number having the
flonum @var{rep} as real part and the flonum @var{imp} as imaginary
part:

@example
(angle (make-rectangular @var{rep} @var{imp}))
@end example

@noindent
return a flonum.  This operation is implemented using the @posix{}
function @cfunc{atan2}.
@end deffn


@deffn {Unsafe Operation} $atan-fixnum @var{fx}
Compute the trigonometric arc tangent of @var{fx}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $atan-bignum @var{bn}
Compute the trigonometric arc tangent of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $atan-ratnum @var{rt}
Compute the trigonometric arc tangent of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $atan-flonum @var{fl}
Compute the trigonometric arc tangent of @var{fl}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $atan-cflonum @var{cfl}
Compute the trigonometric arc tangent of @var{fl}; return a cflonum.
@end deffn


@deffn {Unsafe Operation} $atan-compnum @var{cn}
Compute the trigonometric arc tangent of @var{fl}; return a number
object.
@end deffn

@c page
@node syslib numerics sinh
@subsection Hyperbolic sine


@deffn {Unsafe Operation} $sinh-fixnum @var{fx}
Compute the hyperbolic sine of @var{fx}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $sinh-bignum @var{bn}
Compute the hyperbolic sine of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $sinh-ratnum @var{rt}
Compute the hyperbolic sine of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $sinh-flonum @var{fl}
Compute the hyperbolic sine of @var{fl}; return a flonum.  This is an
alias for @func{$flsinh}.
@end deffn


@deffn {Unsafe Operation} $sinh-compnum @var{cn}
Compute the hyperbolic sine of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $sinh-cflonum @var{cfl}
Compute the hyperbolic sine of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics cosh
@subsection Hyperbolic cosine


@deffn {Unsafe Operation} $cosh-fixnum @var{fx}
Compute the hyperbolic cosine of @var{fx}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $cosh-bignum @var{bn}
Compute the hyperbolic cosine of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $cosh-ratnum @var{rt}
Compute the hyperbolic cosine of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $cosh-flonum @var{fl}
Compute the hyperbolic cosine of @var{fl}; return a flonum.  This is an
alias for @func{$flcosh}.
@end deffn


@deffn {Unsafe Operation} $cosh-compnum @var{cn}
Compute the hyperbolic cosine of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $cosh-cflonum @var{cfl}
Compute the hyperbolic cosine of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics tanh
@subsection Hyperbolic tangent


@deffn {Unsafe Operation} $tanh-fixnum @var{fx}
Compute the hyperbolic tangent of @var{fx}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $tanh-bignum @var{bn}
Compute the hyperbolic tangent of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $tanh-ratnum @var{rt}
Compute the hyperbolic tangent of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $tanh-flonum @var{fl}
Compute the hyperbolic tangent of @var{fl}; return a flonum.  This is an
alias for @func{$fltanh}.
@end deffn


@deffn {Unsafe Operation} $tanh-compnum @var{cn}
Compute the hyperbolic tangent of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $tanh-cflonum @var{cfl}
Compute the hyperbolic tangent of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics asinh
@subsection Hyperbolic arc sine


@deffn {Unsafe Operation} $asinh-fixnum @var{fx}
Compute the inverse hyperbolic sine of @var{fx}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $asinh-bignum @var{bn}
Compute the inverse hyperbolic sine of @var{bn}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $asinh-ratnum @var{rt}
Compute the inverse hyperbolic sine of @var{rt}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $asinh-flonum @var{fl}
Compute the inverse hyperbolic sine of @var{fl}; return a flonum.  This
is an alias for @func{$flsinh}.
@end deffn


@deffn {Unsafe Operation} $asinh-compnum @var{cn}
Compute the inverse hyperbolic sine of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $asinh-cflonum @var{cfl}
Compute the inverse hyperbolic sine of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics acosh
@subsection Hyperbolic arc cosine


@deffn {Unsafe Operation} $acosh-fixnum @var{fx}
Compute the inverse hyperbolic cosine of @var{fx}; return a flonum,
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acosh-bignum @var{bn}
Compute the inverse hyperbolic cosine of @var{bn}; return a flonum,
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acosh-ratnum @var{rt}
Compute the inverse hyperbolic cosine of @var{rt}; return a flonum,
compnum or cflonum.
@end deffn


@deffn {Unsafe Operation} $acosh-flonum @var{fl}
Compute the inverse hyperbolic cosine of @var{fl}; return a flonum,
compnum or cflonum.  This is different from @func{$flacosh} whose return
value is a flonum begin @code{+nan.0} when the operand is out of the
domain for real numbers.
@end deffn


@deffn {Unsafe Operation} $acosh-compnum @var{cn}
Compute the inverse hyperbolic cosine of @var{cn}; return a number
object.
@end deffn


@deffn {Unsafe Operation} $acosh-cflonum @var{cfl}
Compute the inverse hyperbolic cosine of @var{cfl}; return a cflonum.
@end deffn

@c page
@node syslib numerics atanh
@subsection Hyperbolic arc tangent


@deffn {Unsafe Operation} $atanh-fixnum @var{fx}
Compute the inverse hyperbolic tangent of @var{fx}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $atanh-bignum @var{bn}
Compute the inverse hyperbolic tangent of @var{bn}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $atanh-ratnum @var{rt}
Compute the inverse hyperbolic tangent of @var{rt}; return a flonum or
cflonum.
@end deffn


@deffn {Unsafe Operation} $atanh-flonum @var{fl}
Compute the inverse hyperbolic tangent of @var{fl}; return a flonum or
cflonum.  This is different from @func{$flatanh} whose return value is a
flonum begin @code{+nan.0} when the operand is out of the domain for
real numbers.
@end deffn


@deffn {Unsafe Operation} $atanh-compnum @var{cn}
Compute the inverse hyperbolic tangent of @var{cn}; return a number
object.
@end deffn


@deffn {Unsafe Operation} $atanh-cflonum @var{cfl}
Compute the inverse hyperbolic tangent of @var{cfl}; return a cflonum.
@end deffn


@c page
@node syslib numerics conjugate
@subsection Complex conjugate


@deffn {Unsafe Operation} $complex-conjugate-compnum @var{cn}
Return a number object representing the complex conjugate of @var{cn}.
@end deffn


@deffn {Unsafe Operation} $complex-conjugate-cflonum @var{cfl}
Return a cflonum representing the complex conjugate of @var{cfl}.
@end deffn

@c page
@node syslib numerics magnitude
@subsection Magnitude of complex numbers


@deffn {Unsafe Operation} $magnitude-fixnum @var{fx}
Compute the magnitude of @var{fx}; return a fixnum.
@end deffn


@deffn {Unsafe Operation} $magnitude-bignum @var{bn}
Compute the magnitude of @var{bn}; return a bignum.
@end deffn


@deffn {Unsafe Operation} $magnitude-ratnum @var{rt}
Compute the magnitude of @var{rt}; return a ratnum.
@end deffn


@deffn {Unsafe Operation} $magnitude-flonum @var{fl}
Compute the magnitude of @var{fl}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $magnitude-compnum @var{cn}
Compute the magnitude of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $magnitude-cflonum @var{cfl}
Compute the magnitude of @var{cfl}; return a flonum.
@end deffn

@c page
@node syslib numerics angle
@subsection Angle of complex numbers


@deffn {Unsafe Operation} $angle-fixnum @var{fx}
Compute the angle of @var{fx}; return a fixnum or flonum.
@end deffn


@deffn {Unsafe Operation} $angle-bignum @var{bn}
Compute the angle of @var{bn}; return a fixnum or flonum.
@end deffn


@deffn {Unsafe Operation} $angle-ratnum @var{rt}
Compute the angle of @var{rt}; return a fixnum or flonum.
@end deffn


@deffn {Unsafe Operation} $angle-flonum @var{fl}
Compute the angle of @var{fl}; return a flonum.
@end deffn


@deffn {Unsafe Operation} $angle-compnum @var{cn}
Compute the angle of @var{cn}; return a number object.
@end deffn


@deffn {Unsafe Operation} $angle-cflonum @var{cfl}
Compute the angle of @var{cfl}; return a flonum.
@end deffn

@c page
@node syslib numerics bitnot
@subsection Bitwise logic not


@deffn {Unsafe Operation} $bitwise-not-fixnum @var{fx}
Apply the bitwise NOT operation to @var{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-not-bignum @var{bn}
Apply the bitwise NOT operation to @var{bn}.
@end deffn

@c page
@node syslib numerics bitand
@subsection Bitwise logic and


@deffn {Unsafe Operation} $bitwise-and-fixnum-number @var{fx} @var{num}
Apply the bitwise AND operation to the fixnum @var{fx} and the exact
integer object @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-and-bignum-number @var{bn} @var{num}
Apply the bitwise AND operation to the bignum @var{bn} and the exact
integer @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-and-fixnum-fixnum @vari{fx} @varii{fx}
Apply the bitwise AND operation to the fixnum @vari{fx} and the fixnum
@varii{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-and-fixnum-bignum @var{fx} @var{bn}
Apply the bitwise AND operation to the fixnum @var{fx} and the bignum
@var{bn}.
@end deffn


@deffn {Unsafe Operation} $bitwise-and-bignum-fixnum @var{bn} @var{fx}
Apply the bitwise AND operation to the bignum @var{bn} and the fixnum
@var{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-and-bignum-bignum @vari{bn} @varii{bn}
Apply the bitwise AND operation to the bignum @vari{bn} and the bignum
@varii{bn}.
@end deffn

@c page
@node syslib numerics bitior
@subsection Bitwise logic inclusive or


@deffn {Unsafe Operation} $bitwise-ior-fixnum-number @var{fx} @var{num}
Apply the bitwise inclusive OR operation to the fixnum @var{fx} and the
exact integer object @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-ior-bignum-number @var{bn} @var{num}
Apply the bitwise inclusive OR operation to the bignum @var{bn} and the
exact integer @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-ior-fixnum-fixnum @vari{fx} @varii{fx}
Apply the bitwise inclusive OR operation to the fixnum @vari{fx} and the
fixnum @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-ior-fixnum-bignum @var{fx} @var{bn}
Apply the bitwise inclusive OR operation to the fixnum @var{fx} and the
bignum @var{bn}.
@end deffn


@deffn {Unsafe Operation} $bitwise-ior-bignum-fixnum @var{bn} @var{fx}
Apply the bitwise inclusive OR operation to the bignum @var{bn} and the
fixnum @var{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-ior-bignum-bignum @vari{bn} @varii{bn}
Apply the bitwise inclusive OR operation to the bignum @vari{bn} and the
bignum @varii{bn}.
@end deffn

@c page
@node syslib numerics bitxor
@subsection Bitwise logic exclusive or


@deffn {Unsafe Operation} $bitwise-xor-fixnum-number @var{fx} @var{num}
Apply the bitwise exclusive OR operation to the fixnum @var{fx} and the
exact integer object @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-xor-bignum-number @var{bn} @var{num}
Apply the bitwise exclusive OR operation to the bignum @var{bn} and the
exact integer @var{num}.
@end deffn


@deffn {Unsafe Operation} $bitwise-xor-fixnum-fixnum @vari{fx} @varii{fx}
Apply the bitwise exclusive OR operation to the fixnum @vari{fx} and the
fixnum @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-xor-fixnum-bignum @var{fx} @var{bn}
Apply the bitwise exclusive OR operation to the fixnum @var{fx} and the
bignum @var{bn}.
@end deffn


@deffn {Unsafe Operation} $bitwise-xor-bignum-fixnum @var{bn} @var{fx}
Apply the bitwise exclusive OR operation to the bignum @var{bn} and the
fixnum @var{fx}.
@end deffn


@deffn {Unsafe Operation} $bitwise-xor-bignum-bignum @vari{bn} @varii{bn}
Apply the bitwise exclusive OR operation to the bignum @vari{bn} and the
bignum @varii{bn}.
@end deffn

@c page
@node syslib chars
@section Low level character operations


@cindex @library{vicare system $chars}, library
@cindex Library @library{vicare system $chars}


The arguments @var{ch} to these operations must be characters, the
arguments @var{fx} must be fixnums in the range @code{[0, #x10FFFF]} but
not in the range @code{[#xD800, #xDFFF]}.  The following bindings are
exported by the library @library{vicare system $chars}.


@deffn {Unsafe Operation} $char= @vari{ch} @varii{ch}
Evaluate to true if the operands are equal.
@end deffn


@deffn {Unsafe Operation} $char< @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is less than @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char<= @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is less than or equal to @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char> @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is greater than @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char>= @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is greater than or equal to
@varii{ch}.
@end deffn


@deffn {Unsafe Operation} $fixnum->char @var{fx}
Return a new character value whose code point equals @var{fx}.
@end deffn


@deffn {Unsafe Operation} $char->fixnum @var{ch}
Return a fixnum representing the code point of the operand.
@end deffn

@c page
@node syslib pairs
@section Low level pair operations


@cindex @library{vicare system $pairs}, library
@cindex Library @library{vicare system $pairs}


The arguments @var{P} to these operations must be pairs.  The following
bindings are exported by the library @library{vicare system $pairs}.
@ref{objects pairs} for details of pair representation.


@deffn {Unsafe Operation} $car @var{P}
Return the car of the operand.
@end deffn


@deffn {Unsafe Operation} $cdr @var{P}
Return the cdr of the operand.
@end deffn


@deffn {Unsafe Operation} $set-car! @var{P} @var{value}
Store @var{value} in the car location of @var{P}.
@end deffn


@deffn {Unsafe Operation} $set-cdr! @var{P} @var{value}
Store @var{value} in the cdr location of @var{P}.
@end deffn

@c page
@node syslib lists
@section Low level list operations


@cindex @library{vicare system $lists}, library
@cindex Library @library{vicare system $lists}


The following bindings are exported by the library @library{vicare
system $lists}.


@deffn {Unsafe Operation} $length @var{ell}
Assume @var{ell} is a proper list, null included: compute and return the
length of @var{ell}.
@end deffn

@c page
@node syslib structs
@section Low level structure operations


@cindex @library{vicare system $structs}, library
@cindex Library @library{vicare system $structs}


The arguments @var{stru} to these operations must be references to data
structures, the arguments @var{rtd} must be references to structure type
descriptors, the arguments @var{fx} must be fixnums of appropriate
value.  The following bindings are exported by the library
@library{vicare system $structs}.


@deffn {Unsafe Operation} base-rtd
Return a reference to the type descriptor used as type for all the type
descriptors.
@end deffn


@deffn {Unsafe Operation} $struct? @var{obj}
Evaluate to true if @var{obj} is the reference to a structure.
@end deffn


@deffn {Unsafe Operation} $struct/rtd? @var{stru} @var{rtd}
Evaluate to true if @var{stru} is a structure of type @var{rtd}.
@end deffn


@deffn {Unsafe Operation} $make-struct @var{rtd} @var{fx}
Allocate a new data structure of type @var{rtd} capable of holding
@var{fx} words and return a reference to it.

@quotation
@strong{NOTE} This operation initialises only the @code{std} field,
leaving all the other fields set to a machine word with all the bits set
to @code{1}.  We must be careful not to trigger a garbage collection
before those fields are initialised with valid values, else the
behaviour is undefined.
@end quotation
@end deffn


@deffn {Unsafe Operation} $struct-rtd @var{stru}
Return a reference to the type descriptor of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct-ref @var{stru} @var{fx}
Return the value in the field at index @var{fx} of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct-set! @var{stru} @var{fx} @var{value}
Store @var{value} in the field at index @var{fx} of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct @var{rtd} @var{value} ...
Allocate a new data structure of type @var{rtd} capable of holding as
many words as given @var{value} arguments and initialise the fields with
such values.  Return a reference to the structure.
@end deffn

@c ------------------------------------------------------------

@subsubheading Operations on struct type descriptors


@deffn {Unsafe Operation} $std-std @var{std}
@deffnx {Unsafe Operation} $set-std-std! @var{std} @var{new-std}
Given a struct type descriptor return its struct type descriptor or set
a new type descriptor.
@end deffn


@deffn {Unsafe Operation} $std-name @var{std}
@deffnx {Unsafe Operation} $set-std-name! @var{std} @var{new-name}
Given a struct type descriptor return its name as a string or set a new
name.
@end deffn


@deffn {Unsafe Operation} $std-length @var{std}
@deffnx {Unsafe Operation} $set-std-length! @var{std} @var{new-len}
Given a struct type descriptor return a non--negative fixnum
representing the number of fields or set a new number of fields.
@end deffn


@deffn {Unsafe Operation} $std-fields @var{std}
@deffnx {Unsafe Operation} $set-std-fields! @var{std} @var{fields}
Given a struct type descriptor return a list of symbols representing the
field names or set a new list of field names.
@end deffn


@deffn {Unsafe Operation} $std-printer @var{std}
@deffnx {Unsafe Operation} $set-std-printer! @var{std} @var{new-printer}
Given a struct type descriptor return its printer function or set a new
printer function.
@end deffn


@deffn {Unsafe Operation} $std-symbol @var{std}
@deffnx {Unsafe Operation} $set-std-symbol! @var{std} @var{new-uid}
Given a struct type descriptor return its @uid{} symbol or set a new
@uid{} symbol.  When setting a new struct @uid{} we must store the
struct type descriptor in the @code{value} slot of the @uid{}.
@end deffn


@deffn {Unsafe Operation} $std-destructor @var{std}
@deffnx {Unsafe Operation} $set-std-destructor! @var{std} @var{new-destr}
Given a struct type descriptor return @false{} or its destructor
function or set a new destructor function.
@end deffn

@c page
@node syslib vectors
@section Low level vector operations


@cindex @library{vicare system $vectors}, library
@cindex Library @library{vicare system $vectors}


The arguments @var{vec} to these operations must be fixnums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the library @library{vicare system $vectors}.


@deffn {Unsafe Operation} $make-vector @var{fx}
Allocate and return a new vector value of @var{fx} elements.

@quotation
@strong{NOTE} This operation does not initialise the data area, leaving
the items set to whatever is on the Scheme heap; this is bad for garbage
collection if the newly built vector is moved before the items are
initialised to correct Scheme values.  We should use the
@func{$make-clean-vector} operations from @library{vicare
unsafe-operations}.
@end quotation
@end deffn


@deffn {Unsafe Operation} $vector-length @var{vec}
Evaluate to a fixnum representing the numbe of values in @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-empty? @var{vec}
Return @true{} if the vector @var{vec} has zero length, otherwise return
@false{}.
@end deffn


@deffn {Unsafe Operation} $vector-ref @var{vec} @var{fx}
Return the value at index @var{fx} in @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-set! @var{vec} @var{fx} @var{value}
Store @var{value} at index @var{fx} in @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-map1 @var{func} @var{vec}
Like @func{vector-map}, but for only one vector argument: build and
return a new vector having the same size of @var{vec} and items equal to
the result of applying @var{func} to the items of @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-for-each1 @var{func} @var{vec}
Like @func{vector-for-each}, but for only one vector argument: apply
@var{func} to all the items of @var{vec} and discard the return values.
@end deffn


@deffn {Unsafe Operation} $vector-for-all1 @var{func} @var{vec}
Like @func{vector-for-all}, but for only one vector argument: return
true if @var{func} returns true for all the items in @var{vec}.  If the
application of @var{func} to the items of @var{vec} returns true up to
the penultimate item, the last application is performed as tail call.
@end deffn


@deffn {Unsafe Operation} $vector-for-exists1 @var{func} @var{vec}
Like @func{vector-exists}, but for only one vector argument: return
@false{} if @var{func} returns @false{} for all the items in @var{vec}.
If the application of @var{func} to the items of @var{vec} returns
@false{} up to the penultimate item, the last application is performed
as tail call.
@end deffn

@c page
@node syslib bytevectors
@section Low level bytevector operations


@cindex @library{vicare system $bytevectors}, library
@cindex Library @library{vicare system $bytevectors}


The arguments @var{bv} to these operations must be references to
bytevectors, the arguments @var{fx} must be fixnums in the appropriate
range, the arguments @var{fl} must be flonums.  The following bindings
are exported by the library @library{vicare system $bytevectors}.


@deffn {Unsafe Operation} $make-bytevector @var{fx}
Allocate a new bytevector capable of holding @var{fx} bytes and return a
reference to it.
@end deffn


@deffn {Unsafe Operation} $bytevector-empty? @var{bytevector}
Return @true{} if the bytevector @var{bytevector} has zero length,
otherwise return @false{}.
@end deffn


@deffn {Unsafe Operation} $bytevector-length @var{bv}
Return a fixnum representing the number of bytes in the operand.
@end deffn


@deffn {Unsafe Operation} $bytevector-u8-ref @var{bv} @var{fx}
Return a fixnum representing the octet at offset @var{fx} in @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-s8-ref @var{bv} @var{fx}
Return a fixnum representing the byte at offset @var{fx} in @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-set! @var{bv} @var{fx-index} @var{fx-value}
Store the octet or byte @var{fx-value} at index @var{fx-index} of
@var{bv}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Double--precision @ieee{} flonums


@deffn {Unsafe Operation} $bytevector-ieee-double-native-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-double-native-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-double-nonnative-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-double-nonnative-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Single--precision @ieee{} flonums


@deffn {Unsafe Operation} $bytevector-ieee-single-native-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-single-native-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-single-nonnative-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-single-nonnative-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Other unsafe operations


@defun $bytevector= @vari{bv} @varii{bv}
Return @true{} if the two arguments are equal.
@end defun


@defun $bytevector-total-length @var{init-len} @var{bvs}
Given the list of bytevectors @var{bvs}: compute the total length of the
bytevectors, add it to @var{ini-len} and return the result.  If
@var{init-len} is zero: the returned value is the total length of the
bytevectors in @var{bvs}.  The returned value may or may not be in the
range of the maximum bytevector size.
@end defun


@defun $bytevector-concatenate @var{total-len} @var{bvs}
Concatenate the bytevectors in the list @var{bvs}, return the result.
The resulting bytevector must have length @var{total-len}.  Assume the
arguments have been already validated.
@end defun


@defun $bytevector-reverse-and-concatenate @var{total-len} @var{bvs}
Reverse the list of bytevectors @var{bvs} and concatenate its items;
return the result.  The resulting bytevector must have length
@var{total-len}.  Assume the arguments have been already validated.
@end defun


@defun $octets-encoded-bytevector? @var{bytevector}
Always return @true{}.
@end defun


@defun $ascii-encoded-bytevector? @var{bytevector}
Return @true{} if @var{bytevector} can be interpreted as an @ascii{}
encoded string, otherwise return @false{}.  An octet @var{chi} is
considered an @ascii{} code point if:

@example
(<= #x00 chi #x7F)      @result{} #t
@end example
@end defun


@defun $latin1-encoded-bytevector? @var{bytevector}
Return @true{} if @var{bytevector} can be interpreted as a Latin1
encoded string, otherwise return @false{}.  An octet @var{chi} is
considered a Latin1 code point if:

@example
(or (<= #x20 chi #x7E)
    (<= #xA0 chi #xFF))
@result{} #t
@end example
@end defun


@defun $uri-encode @var{bytevector}
@defunx $uri-decode @var{bytevector}
Encode or decode a bytevector according to @rfc{} 3986 @uri{} percent
encoding; return a bytevector.  All the octets are encoded except the
ones having the following @ascii{} representation:

@example
ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
-._~
@end example
@end defun


@defun $uri-normalise-encoding @var{bytevector}
Given a bytevector encoded according to to @rfc{} 3986 @acronym{URI}
percent encoding: return an encoded and normalised bytevector, octets
that are encoded but should not are decoded.
@end defun


@defun $uri-encoded-bytevector? @var{bv}
@defunx $percent-encoded-bytevector? @var{bv}
Return @true{} if the argument is correctly percent--encoded bytevector
according to @rfc{} 3986.
@end defun


@defun $base64->bytevector @var{bytevector}
@defunx $bytevector->base64 @var{bytevector}
Convert to and from a Scheme bytevector containing octets and a Scheme
bytevector containing the @ascii{} Base64 representation of the octets.
If an error occurs in the conversion: the return value is @false{}.
@end defun


@defun $bytevector-copy @var{bytevector}
Build and return a copy of @var{bytevector}.
@end defun

@c page
@node syslib strings
@section Low level string operations


@cindex @library{vicare system $strings}, library
@cindex Library @library{vicare system $strings}


The arguments @var{str} to these operations must be references to
strings, the arguments @var{fx} must be fixnums in the appropriate
range, the arguments @var{ch} must be characters.  The following
bindings are exported by the library @library{vicare system $strings}.


@deffn {Unsafe Operation} $make-string @var{fx}
Allocate a new string capable of holding @var{fx} characters and return
a reference to it.
@end deffn


@deffn {Unsafe Operation} $string @var{ch} @dots{}
Allocate a new string and initialise it with the given characters.
@end deffn


@deffn {Unsafe Operation} $string-length @var{str}
Return a fixnum representing the length of the operand.
@end deffn


@deffn {Unsafe Operations} $string-empty? @var{str}
Return @true{} if the string @var{str} is empty, otherwise return
@false{}.
@end deffn


@deffn {Unsafe Operation} $string-ref @var{str} @var{fx}
Return the character at offset @var{fx} in @var{str}.
@end deffn


@deffn {Unsafe Operation} $string-set! @var{str} @var{fx} @var{ch}
Store @var{ch} at index @var{fx} of @var{str}.
@end deffn


@deffn {Unsafe Operation} $string= @vari{str} @varii{str}
Return @true{} if @vari{str} and @varii{str} represent the same string;
otherwise return @false{}.
@end deffn


@defun $string-total-length @var{init-len} @var{strs}
Given the list of strings @var{strs}: compute the total length of the
strings, add it to @var{ini-len} and return the result.  If
@var{init-len} is zero: the returned value is the total length of the
strings in @var{strs}.  The returned value may or may not be in the
range of the maximum string size.
@end defun


@defun $string-concatenate @var{total-len} @var{strs}
Concatenate the strings in the list @var{strs}, return the result.  The
resulting string must have length @var{total-len}.  Assume the arguments
have been already validated.
@end defun


@defun $string-reverse-and-concatenate @var{total-len} @var{strs}
Reverse the list of strings @var{strs} and concatenate its items; return
the result.  The resulting string must have length @var{total-len}.
Assume the arguments have been already validated.
@end defun


@deffn {Unsafe Operation} $interned-strings
Return a vector holding the currently interned strings.
@end deffn


@deffn {Unsafe Operation} $fixnum->string @var{fx} @var{base}
Return a string object representing @var{fx} in @var{base}.  @var{base}
must be one among: @math{2}, @math{8}, @math{10}, @math{16}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Conversion function


@defun $string->latin1 @var{string}
@defunx $latin1->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
Latin-1 encoding of the characters.  If a character in @var{string} is
out of range: raise an exception; this validation is @strong{not}
removed when arguments validation is disabled.
@end defun


@defun $string->octets @var{string}
@defunx $octets->string @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector holding the
raw octets encoding of the characters.  Octets are converted to
characters with @func{$fixnum->char}; characters are converted to octets
with @func{$char->fixnum}.  Raise an exception if the conversion is not
possible; this validation is @strong{not} removed when arguments
validation is disabled.
@end defun


@defun $string->ascii @var{string}
@defunx $ascii->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
@ascii{} encoding of the characters.  If a character in @var{string} is
out of range: raise an exception; this validation is @strong{not}
removed when arguments validation is disabled.
@end defun


@defun $octets-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as an octets encoded
string, otherwise return @false{}.  A character is considered
octets--encoded if its integer representation @var{chi} satisfies:

@example
(<= 0 @var{chi} 255)      @result{} #t
@end example
@end defun


@defun $ascii-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as an @ascii{} encoded
string, otherwise return @false{}.  A character is considered an
@ascii{} code point if its integer representation @var{chi} satisfies:

@example
(<= #x00 @var{chi} #x7F)      @result{} #t
@end example
@end defun


@defun $latin1-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as a Latin1 encoded
string, otherwise return @false{}.  A character in the string is
considered a Latin1 code point if its integer representation @var{chi}
satisfies:

@example
(or (<= #x20 @var{chi} #x7E)
    (<= #xA0 @var{chi} #xFF))
@result{} #t
@end example
@end defun


@defun $string-base64->bytevector @var{string}
@defunx $bytevector->string-base64 @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector.  The input
string contains the @ascii{} Base64 representation of the octets.  The
output string contains the @ascii{} Base64 representation of octets.  If
an error occurs in the conversion: an exception is raised.
@end defun


@defun $uri-encoded-string? @var{string}
@defunx $percent-encoded-string? @var{string}
Return @true{} if the argument is correctly percent--encoded string
according to @rfc{} 3986.  This means every character in the string is
associated to a character in the @ascii{} encoding and additionally the
constraints of @rfc{} 3986 are satisfied.

If the characters in @var{string} are invalid: raise an exception; this
validation is @strong{not} removed when arguments validation is
disabled.
@end defun

@c page
@node syslib ports
@section Low level port structures


@cindex @library{vicare system $io}, library
@cindex Library @library{vicare system $io}


The following bindings are exported by the library @library{vicare
system $io}.


@defun port? @var{obj}
Return true if @var{obj} is the reference to a port structure; return
false otherwise.
@end defun


@deffn {Unsafe Operation} $make-port @var{attrs} @var{idx} @var{sz} @var{buf} @var{tr} @var{id} @var{read} @var{write} @var{getp} @var{setp} @var{cl} @var{cookie}
Allocate a new port structure, initialise its fields with the arguments,
return a reference to it.
@end deffn


@deffn {Unsafe Operation} $port-index @var{port}
@deffnx {Unsafe Operation} $port-size @var{port}
@deffnx {Unsafe Operation} $port-buffer @var{port}
@deffnx {Unsafe Operation} $port-transcoder @var{port}
@deffnx {Unsafe Operation} $port-id @var{port}
@deffnx {Unsafe Operation} $port-read! @var{port}
@deffnx {Unsafe Operation} $port-write! @var{port}
@deffnx {Unsafe Operation} $port-get-position @var{port}
@deffnx {Unsafe Operation} $port-set-position! @var{port}
@deffnx {Unsafe Operation} $port-close @var{port}
@deffnx {Unsafe Operation} $port-cookie @var{port}
Accessors for the fields of a port structure.
@end deffn


@deffn {Unsafe Operation} $port-attrs @var{port}
Given a port value: return a fixnum representing the port attributes.
@end deffn


@deffn {Safe Operation} $port-tag @var{port}
Extract from a port reference a fixnum representing the port attributes;
if the argument is not a port reference the return value is zero.
@end deffn


@deffn {Unsafe Operation} $set-port-index! @var{port} @var{new-index}
Mutator for the buffer index field.
@end deffn


@deffn {Unsafe Operation} $set-port-size! @var{port} @var{new-used-size}
Mutator for the buffer used size field.
@end deffn


@deffn {Unsafe Operation} $set-port-attrs! @var{port} @var{new-attrs}
Mutator for the port attributes.
@end deffn

@c page
@node syslib transcoders
@section Low level transcoder operations


@cindex @library{vicare system $transcoders}, library
@cindex Library @library{vicare system $transcoders}


The arguments @var{tran} to these operations must be transcoders, the
arguments @var{fx} must be fixnums in the appropriate range.  The
following bindings are exported by the library @library{vicare system
$transcoders}.


@deffn {Unsafe Operation} $data->transcoder @var{fx}
Encode @var{fx} as payload bits of a transcoder word and return the
resulting transcoder.
@end deffn


@deffn {Unsafe Operation} $transcoder->data @var{tran}
Extract the payload bits from a transcoder and return them as fixnum.
@end deffn

@c page
@node syslib pointers
@section Low level pointer operations


@cindex @library{vicare system $pointers}, library
@cindex Library @library{vicare system $pointers}


In the following definitions the @var{ptr} arguments must be pointer
objects.  The following bindings are exported by the library
@library{vicare system $pointers}.


@deffn {Primitive Operation} $pointer? @var{obj}
Return @true{} if @var{obj} is a reference to a pointer memory block,
else return @false{}.
@end deffn


@deffn {Unsafe Operation} $pointer= @vari{ptr} @varii{ptr}
Return @true{} if @vari{ptr} and @varii{ptr} are equal, else return
@false{}.
@end deffn

@c page
@node syslib hashtables
@section Low level hashtable objects operations


@cindex @library{vicare system hashtables}, library
@cindex Library @library{vicare system hashtables}


The following bindings are exported by the library @library{vicare
system hashtables}.


@deffn {Unsafe Operation} $string-hash @var{string}
Return an integer hash value for @var{string}, based on its current
contents.  This hash function is suitable for use with @func{string=?}
as an equivalence function.
@end deffn


@deffn {Unsafe Operation} $string-ci-hash @var{string}
Return an integer hash value for @var{string} based on its current
contents, ignoring case.  This hash function is suitable for use with
@func{string-ci=?} as an equivalence function.
@end deffn


@deffn {Unsafe Operation} $symbol-hash @var{symbol}
Return an integer hash value for @var{symbol}.
@end deffn


@deffn {Unsafe Operation} $bytevector-hash @var{bytevector}
Return an integer hash value for @var{bytevector}, based on its current
contents.  This hash function is suitable for use with
@func{bytevector=?} as an equivalence function.
@end deffn

@c page
@node syslib codes
@section Low level code objects operations


@cindex @library{vicare system $codes}, library
@cindex Library @library{vicare system $codes}


In the following definitions: the @var{code} arguments must be code
objects.  The following bindings are exported by the library
@library{vicare system $codes}.


@defun code? @var{obj}
Return @true{} if @var{obj} is a code object.
@end defun


@deffn {Primitive Operation} $code-freevars @var{code}
Return a fixnum representing the number of free variables referenced by
@var{code}.
@end deffn


@deffn {Primitive Operation} $code-reloc-vector @var{code}
Return the relocation vector of @var{code}.  The relocation vector is a
Scheme vector, @ref{objects codes reloc}.
@end deffn


@deffn {Primitive Operation} $code-size @var{code}
Return a fixnum representing the number of bytes used in the data area
of @var{code}.
@end deffn


@deffn {Primitive Operation} $code-annotation @var{code}
Return an object used as annotation for @var{code}.  The default value
for the annotation is @false{}.
@end deffn


@deffn {Primitive Operation} $code->closure @var{code}
Return a closure object wrapping @var{code}.
@end deffn


@deffn {Primitive Operation} $code-ref @var{code} @var{index}
Return the byte at @var{index} in the data area of @var{code}.
@end deffn


@deffn {Primitive Operation} $code-set! @var{code} @var{index} @var{octet}
Store @var{octet} at @var{index} in the data area of @var{code}.  Both
@var{index} and @var{octet} must be fixnums; @var{octet} must be in the
range @math{[0, 255]}.
@end deffn


@deffn {Primitive Operation} $set-code-annotation @var{code} @var{obj}
Store @var{obj} in the annotation field of @var{code}.
@end deffn

@c page
@node syslib closures
@section Low level closures operations


@cindex @library{vicare system $codes}, library
@cindex Library @library{vicare system $codes}


In the following definitions the @var{closure} arguments must be closure
objects.  The following bindings are exported by the library
@library{vicare system $codes}.


@deffn {Primitive Operation} $closure-code @var{closure}
Return the code object wrapped by the @var{closure}.
@end deffn


@deffn {Primitive Operation} $cpref @var{closure} @var{idx}
Evaluate to the contents of the word at index @var{idx} (a non--negative
fixnum) in the array of free variables in the @var{closure} memory
block.

To know at run time how many free variables are associated to
@var{closure} we have to inspect the associated code object.
@end deffn

@c ------------------------------------------------------------

@subsubheading Annotating closure objects


Annotated procedures exists for debugging purposes, they allow the
association of an arbitrary annotation object to a function.

@example
(import (rnrs)
  (vicare system $codes))

(define (the-proc)
  123)

(define the-annotated
  ($make-annotated-procedure 456 the-proc))

(the-annotated)                         @result{} 123
($annotated-procedure-annotation)       @result{} 456
@end example


@defun $make-annotated-procedure @var{annotation} @var{clo}
Build and return a new closure object wrapping the closure object
@var{clo} and just adding an @var{annotation} object to it.  When such
annotated closure is applied: it applies @var{clo} to the arguments.

@var{annotation} can be any Scheme object.
@end defun


@defun $annotated-procedure-annotation @var{clo}
Given a closure object @var{clo} being an annotated procedure created by
@func{$make-annotated-procedure}: return the annotation object.
@end defun

@c page
@node syslib compiler
@section Low level interface to the compiler


@cindex @library{vicare system $compiler}, library
@cindex Library @library{vicare system $compiler}


@value{PRJNAME} is a compiler for the Scheme language; internally it
implements a multitude of passes, each of which performing a
transformation step from Scheme code to executable binary code.  The
library @library{vicare system $compiler} exports one binding for each
compiler pass, allowing inspection of the performed transformations.

This section contains some documentation for each pass; however, it is
almost impossible to truly understand what a pass does without reading
the source code, where additional documentation is present in the form
of comments.

@menu
* syslib compiler intro::          Introduction to the compilation
                                   process.
* syslib compiler conv::           Compiler coding conventions.
* syslib compiler topics::         By topic inspection of behaviour.
* syslib compiler options::        General configuration options.
* syslib compiler unparse::        Unparsing intermediate
                                   representations.

Compiler passes

* syslib compiler full::           The full transformation.
* syslib compiler recordize::      Scheme code to nested structs.
* syslib compiler dircalls::       Optimisation for direct calls.
* syslib compiler letrec::         Optimisation of @func{letrec} and
                                   @func{letrec*} forms.
* syslib compiler optimisation::   Source optimisation.
* syslib compiler refassig::       Rewriting references and assignments.
* syslib compiler tags::           Tagging known properties.
* syslib compiler sanitbind::      Sanitizing bindings.
* syslib compiler direct jumps::   Optimisation for direct jumps.
* syslib compiler global assign::  Inserting global assignments.
* syslib compiler vars::           Introducing storage locations.
* syslib compiler closure makers:: Introducing closure makers.
* syslib compiler lifting::        Closures optimization and @objtype{clambda}
                                   lifting.
* syslib compiler primcalls::      Introducing primitive calls.
* syslib compiler fix::            Removing fixes.
* syslib compiler engine::         Inserting engine checks.
* syslib compiler stack::          Inserting stack overflow checks.
* syslib compiler cogen::          Full assembly code generation.
* syslib compiler assember::       Binary code generation.

Code generation passes

* syslib compiler primop::         Expanding primitive operations.
* syslib compiler order::          Imposing calling convention and
                                   evaluation order.
* syslib compiler frame::          Assigning frame sizes.
* syslib compiler color::          Colorising by Chaitin.
* syslib compiler flatten::        Flattening codes.
@end menu

@c page
@node syslib compiler intro
@subsection Introduction to the compilation process


@cindex Core language


An expression in the core language is Scheme code fully expanded in
which: no syntactic bindings are present; all the lexical bindings have
a unique name represented by a lex gensym; all the top level lexical
bindings are associated to a loc gensym used to hold the binding's
current value.  The compiler is used to process:

@itemize
@item
Full @func{library} forms and full @rnrs{6} programs the expander has
transformed into @func{library-letrec*} core language forms.

@item
Standalone expressions from invocations of @rnrs{6}'s @func{eval}, for
example read by the @repl{}, either in the context of a stateless
environment or in the context of a stateful interactive environment.
@end itemize

@noindent
these symbolic expressions must be compiled after correct initialisation
of location gensyms for:

@itemize
@item
All the lexical bindings defined by the boot image.

@item
All the lexical bindings defined by the imported libraries.

@item
All the bindings previously defined in the stateful interactive
environment, if such was used for the expansion process.
@end itemize

The compiler recognises the following core language forms, whose
semantics is similar to the corresponding standard language syntax:

@example
(library-letrec* ((@meta{lhs} @meta{loc} @meta{rhs}) ...) @meta{body})
(quote @meta{datum})
(if @meta{test} @meta{consequent} @meta{alternate})
(set! @meta{lhs} @meta{rhs})
(begin @metao{body} @meta{body} ...)
(let     ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(letrec  ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(letrec* ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(case-lambda (@meta{formals} @meta{body}) ...)
(annotated-case-lambda @meta{annotation} (@meta{formals} @meta{body}) ...)
(lambda @meta{formals} @meta{body})
(foreign-call "@meta{function-name}" @meta{arg} ...)
(primitive @meta{prim})
(annotated-call @meta{annotation} @meta{fun} @meta{arg} ...)
@meta{lex}
(@meta{func} @meta{arg} ...)
@end example

@noindent
where: a standalone @meta{lex} atom is a lex gensym, interpreted as
reference to binding; @meta{lhs} stands for ``left--hand side'' and it
is a lex gensym; @meta{rhs} stands for ``right--hand side''; @meta{loc}
is a loc gensym; @meta{prim} is a symbol representing the public name of
a core lexical primitive.

@c page
@node syslib compiler conv
@subsection Compiler coding conventions


Throughout the compiler code variables with the following names appear:

@table @var
@item op
Scheme symbol representing an @strong{operation} to be directly
translated into assembly.  Examples: @samp{alloc}, @samp{mref},
@samp{mref32}, @samp{bref}, @samp{logand}, @samp{logxor}, @samp{logor},
@samp{int+}, @samp{int-}, @samp{int*}, @samp{int-quotient},
@samp{int-remainder}, @samp{sll}, @samp{sra}.

@item rator
Represents a reference to an @strong{operator}: a function coded in
assembly or C language.

@item rands
Scheme list holding the @strong{operands} to which an operation must be
applied.  These operands are in such a format that can be directly used
in the assembly S--expression like:

@example
(make-set eax (car rands))
@end example

@noindent
which generates an assignment operation to store the first element of
@var{rands} into the @code{eax} processor register.
@end table

@c page
@node syslib compiler topics
@subsection By topic inspection of behaviour


It is useful to inspect how the compiler handles specific code elements
throughout different passes.

@menu
* syslib compiler topics topbind::  Handling of lexical top level
                                    bindings.
* syslib compiler topics locbind::  Handling of lexical local bindings.
* syslib compiler topics clambda::  Handling of lambda expressions.
@end menu

@c page
@node syslib compiler topics topbind
@subsubsection Handling of lexical top level bindings


@subsubheading Core language representation

Bindings defined by the core language form @func{library-letrec*} are
named @dfn{top level bindings}; they are akin to the C language ``global
variables''.  The form @func{library-letrec*} has the format:

@example
(library-letrec* ((@meta{lex} @meta{loc} @meta{init}) ...) @meta{body})
@end example

@noindent
in which: @meta{lex} is a lexical gensym that uniquely identifies the
binding in the core language form; @meta{loc} is a location gensym which
will be used at run--time to hold the current value of the binding in
its @code{value} slot; @meta{init} is the initialisation expression.

References to top level bindings are represented by standalone
@meta{lex} gensyms; assignments to top level bindings are represented by
@func{set!} forms:

@example
(set! @meta{lex} @meta{rhs})
@end example

@noindent
where the right--hand side expression @meta{rhs} will, at run--time,
evaluate to the new binding's value.

@c ------------------------------------------------------------

@subsubheading Recordised language representation

The @func{library-letrec*} form is recordised into a @objtype{rec*bind}
form:

@example
(rec*bind ((@meta{prel} @meta{init}) ...) @meta{body})
@end example

@noindent
in which @meta{prel} is a @objtype{prelex} struct holding both the
@meta{lex} and @meta{loc} gensyms.  References to top level bindings are
represented by standalone @objtype{prelex} structs; assignments to top
level bindings are represented by @objtype{assign} structs:

@example
(assign @meta{prel} @meta{rhs})
@end example

@c ------------------------------------------------------------

@subsubheading Implementation of references and assignments

Since the actual value of a top level binding is stored in the
@code{value} field of a loc gensym:

@itemize
@item
References to top level bindings must be transformed into:

@example
(funcall (primref $symbol-value) (constant @meta{loc}))
@end example

@noindent
which extracts the value from slot @code{value} of @meta{loc}.

@item
Common assignments to top level bindings must be transformed into:

@example
(funcall (primref $set-symbol-value!)
         (constant @meta{loc})
         @meta{rhs})
@end example

@noindent
which stores a new value in the slot @code{value} of @meta{loc}.

@item
Single assignments to top level bindings which also serve as binding
initialisations must be transformed into:

@example
(funcall (primref $init-symbol-value!)
         (constant @meta{loc})
         @meta{rhs})
@end example

@noindent
which stores a new value in the slot @code{value} of @meta{loc} and,
only if the value is recognised at run--time as being closure object,
also stores value in the slot @code{proc}.
@end itemize

@c ------------------------------------------------------------

@subsubheading Results of optimising @objtype{rec*bind} forms

A compiler pass takes care of performing ``@func{letrec} optimisation'':
structs of type @objtype{rec*bind} are transformed into a nested
hierarchy of @objtype{bind}, @objtype{fix} and @objtype{assign} forms.
Different cases must be handled in different ways.

@itemize
@item
Some non--recursive ``simple'' and unassigned bindings end up defined as
follows:

@example
(bind ((@meta{prel} @meta{init}))
  @meta{body})
@end example

@noindent
the transformation of references is straightforward.  As example, let's
consider:

@example
(library-letrec*
    ((a.lex a.loc '1)
     (b.lex b.loc '2))
  ((primitive display) a.lex b.lex))
@end example

@noindent
which is recordised and transformed into:

@example
(bind ((a.lex_0 (constant 1)))
  (bind ((b.lex_0 (constant 2)))
    (funcall (primref display) (constant 1) (constant 2))))
@end example

@noindent
in which the references to bindings are integrated by the source
optimiser.

@item
Some non--recursive ``simple'' and assigned bindings end up defined as
follows:

@example
(bind ((@meta{prel} @meta{init}))
  @meta{body})
@end example

@noindent
the transformation of references and assignments is straightforward.  As
example, let's consider:

@example
(library-letrec*
    ((a.lex a.loc '1)
     (b.lex b.loc '2))
  (begin
    (set! a.lex '11)
    (set! b.lex '22)
    ((primitive display) a.lex b.lex)))
@end example

@noindent
which is recordised and transformed into:

@example
(bind ((a.lex_0 (constant 1)))
  (bind ((b.lex_0 (constant 2)))
    (seq
      (funcall (primref $set-symbol-value!)
               (constant a.loc)
               (constant 11))
      (funcall (primref $set-symbol-value!)
               (constant b.loc)
               (constant 22))
      (funcall (primref display)
               (funcall (primref $symbol-value)
                        (constant a.loc))
               (funcall (primref $symbol-value)
                        (constant b.loc))))))
@end example

@item
Some @strong{unassigned} top level bindings end up defined (roughly) as
follows:

@example
(bind ((@meta{prel} (constant #<void>)))
  (assign @meta{prel} @meta{init})
  @meta{body})
@end example

@noindent
this might happen when the initialisation expressions in the original
@objtype{rec*bind} need to access the machine words in which the
bindings' values are stored; so, at run--time, first we need to allocate
the loc gensyms and then we can evaluate the initialisation expressions
and store the resulting value in the gensym itself.

In this special case, since the binding is unassigned in the original
code, the @objtype{assign} struct is introduced by the compiler and it
is the only assignment for the binding.  The compiler recognises this
case and transforms:

@example
(assign @meta{prel} @meta{init})
@end example

@noindent
into:

@example
(funcall (primref $init-symbol-value!)
         (constant @meta{loc})
         @meta{init})
@end example

@noindent
in which @meta{loc} is the loc gensym of the binding.

@item
When top level bindings are unassigned and have initialisation
expression being a @objtype{clambda} form: they end up being defined by
a @objtype{fix} struct; the @func{letrec} optimiser takes care of
recognising and handling such case.  As example:

@example
(library-letrec*
    ((a.lex a.loc (lambda () '1))
     (b.lex a.loc (lambda () '2)))
  ((primitive display) (a.lex)))
@end example

@noindent
is transformed into:

@example
(fix ((a.lex_0 (lambda () (constant 1)))
      (b.lex_0 (lambda () (constant 2))))
  (funcall (primref display) (constant 1)))
@end example

@noindent
in which the call to @func{a.lex} is integrated by the source optimiser.
@end itemize

@c page
@node syslib compiler topics locbind
@subsubsection Handling of lexical local bindings


Lexical local bindings are defined in the core language by the forms:
@func{let}, @func{letrec}, @func{letrec*}, @func{lambda},
@func{case-lambda}, @func{annotated-case-lambda}.  These forms have
syntax:

@example
(let     ((@meta{lex} @meta{rhs}) ...) @meta{body})
(letrec  ((@meta{lex} @meta{rhs}) ...) @meta{body})
(letrec* ((@meta{lex} @meta{rhs}) ...) @meta{body})
(case-lambda (@meta{formals} @meta{body}) ...)
(annotated-case-lambda @meta{annotation} (@meta{formals} @meta{body}) ...)
(lambda @meta{formals} @meta{body})
@end example

@noindent
in which: @meta{lex} is a lexical gensym that uniquely identifies the
binding in the core language form; @meta{rhs} is the initialisation
expression; @meta{formals} is a proper or improper list of lex gensyms
uniquely identifying arguments to function.

References to local bindings are represented by standalone @meta{lex}
gensyms; assignments to local bindings are represented by @func{set!}
forms:

@example
(set! @meta{lex} @meta{rhs})
@end example

@noindent
where the right--hand side expression @meta{rhs} will, at run--time,
evaluate to the new binding's value.

@c ------------------------------------------------------------

@subsubheading Recordised language representation

The @func{let}, @func{letrec} and @func{letrec*} forms are recordised
into nested hierarchies of @objtype{bind}, @objtype{recbind} and
@objtype{rec*bind} structs:

@example
(bind     ((@meta{prel} @meta{rhs}) ...) @meta{body})
(recbind  ((@meta{prel} @meta{rhs}) ...) @meta{body})
(rec*bind ((@meta{prel} @meta{rhs}) ...) @meta{body})
@end example

@noindent
in which @meta{prel} is a @objtype{prelex} struct holding the @meta{lex}
gensym.

The @func{lambda}, @func{case-lambda} and @func{annotated-case-lambda}
forms are recordised as @objtype{clambda} structs:

@example
(clambda (@meta{prel-formals} @meta{body}) ...)
@end example

@noindent
in which @meta{prel-formals} is a a proper or improper list of
@objtype{prel} structs representing arguments to each @objtype{clambda}
clause.

References to local bindings are represented by standalone
@objtype{prelex} structs; assignments to local bindings are represented
by @objtype{assign} structs:

@example
(assign @meta{prel} @meta{rhs})
@end example

@c ------------------------------------------------------------

@subsubheading Implementation of references and assignments

We distinguish between bindings that are only referenced (unassigned,
read--only) and bindings that are also assigned (assigned, read--write).
Example of code in which the binding @code{X} is only referenced:

@example
(let ((X 123)) (display X))
@end example

@noindent
example of code in which the binding @code{X} is assigned and
referenced:

@example
(let ((X 123)) (set! X 456) (display X))
@end example

The implementation technique for continuations used by @value{PRJNAME}
mandates that: once an immediate Scheme object or reference to
non--immediate Scheme object is stored in a machine word on the Scheme
stack, such machine word @strong{must not be mutated}; this allows the
run--time system to copy stack frames at will.  As a consequence the
following implementation techniques for local bindings are adopted:

@itemize
@item
The value of unassigned lexical local bindings is stored in words
allocated on the Scheme stack, with no further troubles.

@item
The value of assigned lexical local bindings is stored in single--slot
vectors providing mutable memory locations: a vector of one slot for
each binding; a word allocated on the Scheme stack contains a reference
to the single--slot vector.
@end itemize

References to unassigned bindings must be implemented as Scheme stack
operations; references and assignments to assigned bindings must be
substituted with appropriate vector operations.

@c ------------------------------------------------------------

@subsubheading Recordisation and transformation of unassigned bindings

After the @func{letrec} optimiser has processed @objtype{recbind} and
@objtype{rec*bind} forms, unassigned local bindings always end up
defined as:

@example
(bind ((@meta{prel} @meta{rhs})) @meta{body})
@end example

@noindent
and references are represented by standalone @objtype{prelex} structs.
Whenever a @meta{rhs} expression is recognised to be of type
@objtype{clambda}, the corresponding @objtype{bind} is transformed into:

@example
(fix ((@meta{prel} @meta{rhs})) @meta{body})
@end example

@noindent
No further transformations are needed for recordised code.

@c ------------------------------------------------------------

@subsubheading Recordisation and transformation of assigned bindings

After the @func{letrec} optimiser has processed @objtype{recbind} and
@objtype{rec*bind} forms, assigned local bindings always end up defined
as:

@example
(bind ((@meta{prel} @meta{rhs})) @meta{body})
@end example

@noindent
references are represented by standalone @objtype{prelex} structs and
assignments are represented by @objtype{assign} structs.

@quotation
@strong{NOTE} No matter if a @meta{rhs} expression is of type
@objtype{clambda}: its associated @objtype{bind} struct is @strong{not}
transformed into a @objtype{fix} struct; only unassigned
@objtype{clambda} bindings can be defined by a @objtype{fix} struct.
@end quotation

Definitions, references and assignments are transformed by introducing
the appropriate vector operations; such operation are equivalent to the
following:

@example
(let ((x 123))
  (set! x 456)
  x)
@end example

@noindent
is transformed into:

@example
(let ((t 123))
  (let ((x (vector t)))
    ($vector-set! x 0 456)
    ($vector-ref  x 0)))
@end example

@noindent
where the temporary binding @code{t} is generated by the compiler; the
code always only access the first and single slot of the vector.  Using
recordised code:

@example
(bind ((x_0 123))
  (seq
    (assign x_0 456)
    x))
@end example

@noindent
is transformed into:

@example
(bind ((x_0 123))
  (bind ((x_1 (funcall (primref vector) x_0)))
    (seq
      (funcall (primref $vector-set!)
               x_1
               (constant 0)
               (constant 456))
      (funcall (primref $vector-ref)
               x_1
               (constant 0)))))
@end example

Formal bindings in @objtype{clambda} structs are also processed this
way; for example:

@example
(lambda (a)
  (display a)
  (set! a 1)
  a)
@end example

@noindent
is transformed into:

@example
(lambda (a_0)
  (bind ((a_1 (funcall (primref vector) a_0)))
    (seq
      (funcall (primref display)
               (funcall (primref $vector-ref)
                        a_1 (constant 0)))
      (funcall (primref $vector-set!)
               a_1 (constant 0) (constant 1))
      (funcall (primref $vector-ref)
               a_1 (constant 0)))))
@end example

@quotation
@strong{NOTE} Assigned local bindings whose RHS expression is a
@objtype{clambda} struct are also transformed by introducing a vector.
After this transformation: there are no more @objtype{bind} struct whose
RHS is a @objtype{clambda} struct.
@end quotation

@c page
@node syslib compiler topics clambda
@subsubsection Handling of lambda expressions


@c ------------------------------------------------------------

@subsubheading Handling of assigned @objtype{clambda} bindigns

If a binding is assigned, it is defined by a @objtype{bind} struct:

@example
(bind ((@meta{lhs} @meta{init}))
  (seq
    (assign @meta{lhs} @meta{rhs})
    @meta{rest}))
@end example

@noindent
and so it is transformed by introducing a vector to hold the read--write
machine word:

@example
(bind ((@meta{tmp} @meta{init}))
  (bind ((@meta{lhs} (funcall (primref vector) @meta{tmp})))
    (seq
      (funcall (primref $vector-set!)
               @meta{lhs} (constant 0) @meta{rhs})
      @meta{rest})))
@end example

@noindent
if its @meta{init} expression is a @objtype{clambda} struct, it is
further transformed as follows:

@example
(fix ((@meta{tmp} @meta{clambda}))
  (bind ((@meta{lhs} (funcall (primref vector) @meta{tmp})))
    (seq
      (funcall (primref $vector-set!)
               @meta{lhs} (constant 0) @meta{rhs})
      @meta{rest})))
@end example

@noindent
so, in the end, @objtype{clambda} expressions originally bound to
assigned bindings end up defined by @objtype{fix} forms.

@c page
@node syslib compiler options
@subsection General configuration options


The following bindings are exported by the library @library{vicare
system $compiler}.


@deffn Parameter $descriptive-labels
When set to true: attempt to generate descriptive pretty names for
gensyms used by the compiler as lexical gensyms, loc gensyms and code
labels; this is useful for debugging purposes and code generation
inspection.  When set to false: attempt to generate gensyms in the
fastest way.
@end deffn

@c page
@node syslib compiler unparse
@subsection Unparsing intermediate representations


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $unparse-recordized-code @var{input}
Given as argument a struct instance representing recordised code: build
and return a symbolic expression that can be printed in human readable
form.  @var{input} can be any structure that is produced by the compiler
passes.
@end defun


@defun $unparse-recordized-code/pretty @var{input}
Given as argument a struct instance representing recordised code: build
and return a symbolic expression that can be printed in human readable
form.  @var{input} can be any structure that is produced by the compiler
passes.

This function attempts to unparse recordised code and reconstruct a
Scheme--like symbolic expression; the returned sexp does @strong{not}
exactly represent the input.
@end defun


@defun $unparse-recordized-code/sexp @var{input}
Given as argument a struct instance representing recordised code: build
and return a symbolic expression that can be printed in human readable
form.  @var{input} can be any structure that is produced by the compiler
passes.  The output of this function is similar to
@func{$unparse-recordized-code} but more human readable.
@end defun

@c page
@node syslib compiler full
@subsection The full transformation


The sequence of compiler passes is:

@example
recordize
optimize-direct-calls
optimize-letrec
source-optimize
rewrite-references-and-assignments
introduce-tags (optional)
sanitize-bindings
optimize-for-direct-jumps
insert-global-assignments
introduce-vars
introduce-closure-makers
optimize-combinator-calls/lift-clambdas
@end example

@noindent
the sequence in which the passes are performed @strong{cannot} be
changed; they must be performed in the specified order.  The passes
functions are to be considered unsafe: if the input is invalid, the
behaviour is undefined.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $compile-core-expr->code @var{core-language-sexp}
@end defun

@c page
@node syslib compiler recordize
@subsection Scheme code to nested structs


The core language forms produced by the expander are converted to
``recordised code'' by the compiler before actually generating machine
code; recordised code is a nested hierarchy of struct instances.  The
struct types used for this recordisation are used to represent code in
the core language in a way which is better inspectable and optimisable.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $recordize @var{core-language-form}
Given a symbolic expression representing a form in the core language,
convert it into a nested hierarchy of struct instances; return the outer
struct instance.

This function expects a symbolic expression with perfect syntax: no
syntax errors are checked.  We expect this function to be executed
without errors, no exceptions should be raised unless an internal error
makes it happen.

In addition the following operations are performed:

@itemize
@item
Determine some properties of the code and store relative informations in
the struct instances.  For example: is a lexical binding ever referenced
or assigned?

@item
The application of some special lexical primitives is transformed into a
core language expression integrated in the original source code, then
recordised.  See below for details.
@end itemize
@end defun

@menu
* syslib compiler recordize bindings::  Recordisation of bindings.
* syslib compiler recordize specials::  Special lexical primitives.
* syslib compiler recordize examples::  Recordisation examples.
* syslib compiler recordize debug::     Introduction of debug calls.
@end menu

@c page
@node syslib compiler recordize bindings
@subsubsection Recordisation of bindings


The core language forms that define bindings are:

@example
(library-letrec* ((@meta{lhs} @meta{loc} @meta{rhs}) ...) @meta{body})
(let     ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(letrec  ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(letrec* ((@meta{lhs} @meta{rhs}) ...) @meta{body})
(lambda @meta{formals} @meta{body})
(case-lambda (@meta{formals} @meta{body}) ...)
(annotated-case-lambda @meta{annotation} (@meta{formals} @meta{body}) ...)
@end example

@noindent
and as special case:

@example
(set! @meta{lhs} @meta{rhs})
@end example

@noindent
when present at the top level.  In all these expressions @meta{lhs} is a
lexical gensym uniquely identifying the binding.

The recordisation process transforms:

@itemize
@item
@func{library-letrec*} and @func{letrec*} forms into @objtype{rec*bind}
structs, in which defined lex gensyms are substituted with
@objtype{prelex} structs.

@item
@func{letrec} forms into @objtype{recbind} structs, in which defined lex
gensyms are substituted with @objtype{prelex} structs.

@item
@func{let} forms into @objtype{bind} structs, in which defined lex
gensyms are substituted with @objtype{prelex} structs.

@item
@func{lambda}, @func{case-lambda} and @func{annotated-case-lambda} forms
into @objtype{clambda} structs, in which lex gensyms representing
bindings defined by function arguments are substituted with
@objtype{prelex} structs.
@end itemize

@c ------------------------------------------------------------

@subsubheading Undefined bindings and previously defined bindings

In the core language input expression: if a binding is defined by the
expression itself, its lex gensym is present as left--hand side in a
@func{let}, @func{letrec}, @func{letrec*}, @func{library-letrec*} form
or as formal argument in a @func{lambda}, @func{case-lambda},
@func{annotated-case-lambda} form.  Otherwise the lex gensym represents
an undefined binding or a binding defined outside the input form.

Every symbol in the input form not present as left--hand side in a
@objtype{bind}, @objtype{recbind}, @objtype{rec*bind} struct or formal
argument in a @objtype{clambda} struct is interpreted as a reference to
undefined or previously defined binding.  This interpretation includes:

@itemize
@item
Bindings defined by imported libraries.

@item
Bindings defined by expressions previously evaluated and added to an
interaction environment.

@item
Bindings that appear for the first time in top level assignment forms:

@example
(set! @meta{lhs} @meta{rhs})
@end example

@noindent
like the definitions of syntax transformers in the visit code generated
by the expander or standalone expressions evaluated at the @repl{}; such
assignments to undefined bindings cause a new binding to be generated.
@end itemize

@noindent
for all these cases: the lex gensym acts also as loc gensym.

After the recordisation process:

@itemize
@item
All the lex gensyms in reference position representing bindings not
defined by the input expression have been converted to:

@example
(funcall (primref top-level-value) (constant @meta{loc}))
@end example

@noindent
where @meta{loc} is the loc gensym of the binding.  If this binding is
truly undefined: the call to @func{top-level-value} will raise an
exception at run--time.

@item
All the lex gensyms in assignment position representing bindings not
defined by the input expression have been converted to:

@example
(funcall (primref $init-symbol-value!) (constant @meta{loc}) @meta{rhs})
@end example

@noindent
where @meta{loc} is the loc gensym of the binding; this is the run--time
definition of a new binding.
@end itemize

@noindent
so all the @objtype{prelex} structs introduced by @func{$recordize}
represent bindings defined by the input expression.

@quotation
@strong{NOTE} As specified by @rnrs{6}, bindings defined by imported
libraries must not be mutated; this means core language forms like:

@example
(set! @meta{loc} @meta{rhs})
@end example

@noindent
in which @meta{loc} is the loc gensym of an imported binding are
forbidden.  It is the responsibility of the expander not to generate
such assignment forms for bindings defined by imported libraries.
@end quotation

@quotation
@strong{NOTE} The special handling of core language assignment forms:

@example
(set! @meta{lex} @meta{rhs})
@end example

@noindent
in which @meta{lex} is both the lex and loc gensym of a binding not
defined by the input expression allows:

@itemize
@item
The correct handling of visit code generated by the expander.

@item
The definition of bindings by @func{eval} (for example at the @repl{})
using just @func{set!} rather than a proper binding form.  This case
allows bindings to be added to interaction environment using weird
syntaxes; here is an example session at the @repl{}:

@example
vicare> (let () (set! a 1) (set! b 2) #f)
$1 = #f

vicare> a
$1 = 1

vicare> b
$1 = 2
@end example

@noindent
It is the responsibility of the expander to forbid such definitions when
processing libraries and programs.
@end itemize
@end quotation

@c page
@node syslib compiler recordize specials
@subsubsection Special lexical primitives


Whenever, in the recordisation process, the compiler recognises the
application of some special lexical core primitives: it transforms such
application into an equivalent core language expression integrated in
the original source code.  This transformation is equivalent to the
source integration performed by the compiler's source optimiser when
compiling user defined code, but it acts upon primitives defined by the
boot image.


@deffn {Integrated Primitive} make-parameter @var{init}
@deffnx {Integrated Primitive} make-parameter @var{init} @var{guard}
Integration of the primitive function @func{make-parameter}, @ref{iklib
parameters, make-parameter}.
@end deffn

@c page
@node syslib compiler recordize examples
@subsubsection Recordisation examples


@subsubheading Handling of imported bindings

Let's imagine the following library:

@example
(library (libtest compiler-internals)
  (export a-func a-thunk a-const)
  (import (rnrs (6)))
  (define (a-func a b)
    (+ a b))
  (define (a-thunk)
    "ciao")
  (define a-const 123))
@end example

@noindent
it is recordised as follows:

@example
(rec*bind ((a-func_0  (lambda (a_0 b_0)
                        (funcall (primref +) a_0 b_0)))
           (a-thunk_0 (lambda ()
                        (constant "ciao")))
           (a-const_0 (constant 123)))
  (constant #<void>))
@end example

@noindent
if this library is imported as in:

@example
(library (recordize-demo-1)
  (export)
  (import (rnrs) (libtest compiler-internals))
  (list a-const (a-thunk) (a-func 1 2)))
@end example

@noindent
the resulting recordised code is:

@example
(rec*bind ()
  (funcall (primref list)
           (funcall (primref top-level-value)
                    (constant a-const))
           (funcall (funcall (primref top-level-value)
                             (constant a-thunk)))
           (funcall (funcall (primref top-level-value)
                             (constant a-func))
                             (constant 1)
                             (constant 2))))
@end example

@noindent
where the symbols @code{a-const}, @code{a-thunk}, @code{a-func} are the
location gensyms of the imported bindings.

@c page
@node syslib compiler recordize debug
@subsubsection Introduction of debug calls


Whenever debugging mode is enabled, application forms like:

@example
(@meta{func} @meta{arg} ...)
@end example

@noindent
are expanded and recordised into:

@example
(funcall (primref debug-call)
         @meta{annotation}
         @meta{rator} @meta{rand} ...)
@end example

@noindent
where: @meta{rator} is the recordised version of @meta{func};
@meta{rand} is the recordised version of @meta{arg}; @meta{annotation}
is a debugging annotation:

@example
(constant (@meta{annotation-source} . (@meta{func} @meta{arg} ...)))
@end example

@noindent
in which @meta{annotation-source} has one of the formats:

@example
#f
(@meta{port-identifier} . @meta{first-character-offset})
@end example

@noindent
the introducion of @func{debug-call} is performed no matter what
expression @meta{func} is.

@c ------------------------------------------------------------

@subsubheading Example: @func{lambda} application

The standard language form:

@example
((lambda (x) x) 1)
@end example

@noindent
is expanded into the core language form:

@example
(annotated-call @meta{annotation-struct}
                (annotated-case-lambda #'(lambda (x) x)
                                       ((x x)))
                (quote 1))
@end example

@noindent
which is recordised as:

@example
(funcall (primref debug-call)
         (constant (@meta{annotation-source} . ((lambda (x) x) '1)))
         (lambda (x_0) x_0)
         (constant 1))
@end example

@c ------------------------------------------------------------

@subsubheading Example: @func{let} application

The standard language form:

@example
((let ((f (lambda (y) y)))
   f)
  1)
@end example

@noindent
is expanded and recordised into:

@example
(funcall (primref debug-call)
         (constant (@meta{annotation-source}
                    . ((let ((f (lambda (x) x))) f) 1)))
         (bind ((f_0 (lambda (x_0) x_0))) f_0)
         (constant 1))
@end example

@c page
@node syslib compiler dircalls
@subsection Optimisation for direct calls


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $optimize-direct-calls @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.

Inspect application forms:

@example
(funcall @meta{operator} @meta{operand} ...)
@end example

@noindent
and attempt to integrate the @meta{operator} when possible.
@end defun

@menu
* syslib compiler dircalls lambda::  Examples of @code{clambda} integration.
* syslib compiler dircalls let::     Examples of bindings integration.
* syslib compiler dircalls cond::    Example: @func{cond} syntaxes.
* syslib compiler dircalls debug::   Examples of @func{debug-call} integration.
@end menu

@c page
@node syslib compiler dircalls lambda
@subsubsection Examples of @code{clambda} integration


By definition, a ``direct closure application'' like:

@example
((lambda (x) x) 123)
@end example

@noindent
can be transformed to:

@example
   (let ((x 123)) x)
@end example

@noindent
in which the operator @func{lambda} form is integrated; so it can be
converted to low level operations that more efficiently implement the
binding; direct calls optimisation attempts to perform such integration.
Notice that in the case:

@example
((case-lambda
   ((x) x)
   ((x y) y))
 123)
@end example

@noindent
the integration yields:

@example
(let ((x 123)) x)
@end example

@noindent
and the clause with two arguments is just discarded and never compiled.

@c page
@node syslib compiler dircalls let
@subsubsection Examples of bindings integration


There are other integration possibilities when the operator of an
application form is a complex expression:

@example
((let ((?lhs ?rhs) ...) ?body) ?rand ...)
===> (let ((?lhs ?rhs) ...)
       (?body ?rand ...))

((letrec ((?lhs ?rhs) ...) ?body) ?rand ...)
===> (letrec ((?lhs ?rhs) ...)
       (?body ?rand ...))

((letrec ((?lhs ?rhs) ...) ?body) ?rand ...)
===> (letrec* ((?lhs ?rhs) ...)
       (?body ?rand ...))
@end example

@c page
@node syslib compiler dircalls cond
@subsubsection Example: @func{cond} syntaxes


@func{cond} syntaxes are expanded as follows:

@example
(cond ((this X)
       => (lambda (Y)
            (that Y)))
      (else
       (those)))
@end example

@noindent
becomes:

@example
(let ((t (this X)))
  (if t
      ((lambda (Y) (that Y)) t)
    (those)))
@end example

@noindent
which contains a direct call, which will be optimised to:

@example
(let ((t (this X)))
  (if t
      (let ((Y t)) (that Y))
    (those)))
@end example

@c page
@node syslib compiler dircalls debug
@subsubsection Examples of @func{debug-call} integration


As example of integration, the standard language form:

@example
((lambda (x) x) 1)
@end example

@noindent
is expanded into the core language form:

@example
(annotated-call ?annotation-struct
                (annotated-case-lambda #'(lambda (x) x)
                                       ((x x)))
                (quote 1))
@end example

@noindent
which is recordised as:

@example
(funcall (primref debug-call)
         (constant (@meta{annotation-source} . ((lambda (x) x) '1)))
         (lambda (x_0) x_0)
         (constant 1))
@end example

@noindent
and integrated as:

@example
(bind ((x_0 (constant 1)))
  x_0)
@end example

@noindent
where we can see there is no more a function application.

Another example, the standard language form:

@example
((let ((f (lambda (y) y)))
   f)
 '1)
@end example

@noindent
is expanded and recordised into:

@example
(funcall (primref debug-call)
         (constant (@meta{annotation-source}
                    . ((let ((f (lambda (x) x))) f) 1)))
         (bind ((f_0 (lambda (x_0) x_0))) f_0)
         (constant 1))
@end example

@noindent
and integrated as:

@example
(bind ((f_0 (lambda (y_0) y_0)))
  (funcall (primref debug-call)
           (constant (@meta{annotation-source}
                      . ((let ((f (lambda (y) y))) f) 1)))
           f_0
           (constant 1)))
@end example

@noindent
where we can see the @func{debug-call} moved into the body.

@c page
@node syslib compiler letrec
@subsection Optimisation of @func{letrec} and @func{letrec*} forms


@value{PRJNAME}'s compiler offers multiple algorithms to implement and
optimise the core language forms @func{letrec}, @func{letrec*} and
@func{library-letrec*}, whose syntax is:

@example
(letrec ((@meta{lhs} @meta{rhs}) ...) @meta{body})

(letrec* ((@meta{lhs} @meta{rhs}) ...) @meta{body})

(library-letrec* ((@meta{lhs} @meta{loc} @meta{rhs}) ...) @meta{body})
@end example

@noindent
notice that the @meta{body} is a single form.  The transformations for
@func{letrec*} and @func{library-letrec*} are equal; the difference
between the two lies in the implementation of allocations, references
and assignments to the @meta{lhs}.

When this compiler pass is applied to the recordised code, the forms
have already been transformed into:

@example
(recbind  ((@meta{lhs} @meta{rhs}) ...) @meta{body})

(rec*bind ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
where instances of the structure @objtype{recbind} represent
@func{letrec} forms and instances of the structure @objtype{rec*bind}
represent @func{letrec*} and @func{library-letrec*} forms.

After this compiler pass has been applied: @objtype{recbind} and
@objtype{rec*bind} structs are no more present in the returned code,
having been substituted with @objtype{bind} and @objtype{fix} structs.
So in the returned code: every @objtype{prelex} struct represents a
binding defined either by @objtype{bind} or @objtype{fix}.

@menu
* syslib compiler letrec algo::   Introduction to the algorithms.
* syslib compiler letrec api::    Transformations programming interface.
* syslib compiler letrec notes::  General notes on the context of
                                  @func{letrec} optimisations.
* syslib compiler letrec basic::  The basic transformation algorithm.
* syslib compiler letrec wsd::    The @wsd{} transformation algorithm.
* syslib compiler letrec scc::    The @scc{} transformation algorithm.
@end menu

@c page
@node syslib compiler letrec algo
@subsubsection Introduction to the algorithms


The compiler implements three algorithms: @code{basic}, @code{waddell},
@code{scc}.  The default and more advanced is @code{scc}; there is
little reason to use the other algorithms when processing real code.

The @code{basic} transformation is the one that defines the
@func{letrec} syntax from the @rnrs{5} standard document.

The @code{waddell} transformation focuses on generating @code{fix}
structures representing recursive binding forms for unassigned
@func{lambda} expressions.  To understand this algorithm, and the code,
we @strong{must} read the following paper:

@quotation
[@wsd{}] Oscar Waddell, Dipanwita Sarkar, R. Kent Dybvig.
``Fixing Letrec: A Faithful Yet Efficient Implementation of Scheme's
Recursive Binding Construct''.
@end quotation

The @code{scc} algorithm is an evolution of the @code{waddell}
transformation that better processes bindings, taking into account their
actual dependency graph.  To understand this algorithm, and the code, we
@strong{must} read the following paper:

@quotation
[@scc{}] Abdulaziz Ghuloum, R. Kent Dybvig.  ``Fixing Letrec
(reloaded)''.  Workshop on Scheme and Functional Programming '09.
@end quotation

@noindent
the described algorithm makes use of Tarjan's algorithms to partition
the nodes of a graph into Strongly Connected Components (@scc{}):

@quotation
Tarjan, Robert Endre.  ``Depth--first search and linear graph
algorithms''.  SIAM Journal on Computing 1 (2): 146-160, 1972.
@end quotation

@noindent
for details on the @scc{} algorithm, we can also refer to the
Wikipedia article ``Tarjan's strongly connected components
algorithm''@footnote{@url{https:@//@//en.wikipedia.org@//wiki@//Tarjan%27s_strongly_connected_components_algorithm}}.

@c page
@node syslib compiler letrec api
@subsubsection Transformations programming interface


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $optimize-letrec @var{recordised-code}
Perform transformations and optimisations to convert the recordised
representation of @func{letrec}, @func{letrec*} and
@func{libary-letrec*} core language forms into a composition of low
level binding constructs and assignments.
@end defun


@deffn Parameter $check-for-illegal-letrec
If set to true: @func{$optimize-letrec} will perform an
additional recordized code pass to check for illegal binding references
in the right--hand sides of @func{letrec}, @func{letrec*} and
@func{library-letrec*} syntaxes, raising a syntax violation error if one
is found.  This is the default.

If set to false: the validating pass is not performed, faithfully hoping
for no problems in code.
@end deffn


@deffn Parameter $current-letrec-pass
Select the transformations performed by
@func{$optimize-letrec}; possible values are the symbols:

@table @code
@item basic
Perform the basic transformation.

@item waddell
Perform a transformation similar (but no equal) to the one described in
the [@wsd{}] paper.

@item scc
Perform a transformation similar (but no equal) to the one described in
the [@scc{}] paper.  This is the default.
@end table
@end deffn

@c page
@node syslib compiler letrec notes
@subsubsection General notes on the context of @func{letrec} optimisations


@subsubheading On @func{let} and @func{let*} bindings

Let's consider the following program:

@example
(import (rnrs))
(let ((A B))
  #t)
@end example

@noindent
it will fail with ``unbound identifier B''; we are @strong{not}
concerned with unbound identifiers in this compiler pass.  So let's move
on to the following program:

@example
(import (rnrs))
(let ((A 123))
  (let ((A A))
    #t))
@end example

@noindent
no errors here: the identifier @code{A} in reference position is
captured by the outer @func{let} binding for @code{A}.  Now this
program:

@example
(import (rnrs))
(let* ((A 123)
       (B A))
  #t)
@end example

@noindent
everything is all right; now this program:

@example
(import (rnrs))
(let* ((A 123)
       (A A))
  #t)
@end example

@noindent
again no error: the identifier @code{A} in reference position is
captured by the first @func{let*} binding for @code{A}; @func{let*}
allows us to create bindings with the same name.

@c ------------------------------------------------------------

@subsubheading @func{letrec} bindings

Let's move to the @func{letrec} syntax.  This program is legal:

@example
(import (rnrs))
(letrec ((A (lambda () A)))
  #t)
@end example

@noindent
because @func{letrec} defines recursive bindings, so we are allowed to
reference @code{A} in the right--hand side of the binding for @code{A}
itself, as long as we put such reference in the body of a @func{lambda}.

This program is also legal:

@example
(import (rnrs))
(letrec ((A (lambda () B))
         (B (lambda () A)))
  #t)
@end example

@noindent
because the cross references to @code{A} and @code{B} are in the body of
@func{lambda} syntaxes.

This program is illegal:

@example
(import (rnrs))
(letrec ((A (list A)))
  #t)
@end example

@noindent
because the identifier @code{A} in reference position is not in the body
of a @func{lambda} syntax: to evaluate the right--hand side of the
binding we need the value of the binding itself.  Notice that @code{A}
in reference position is @strong{not} an unbound identifier: it is
captured by the @code{A} in binding position; it is just ``illegal'' and
we must detect this situation, according to @rnrs{6}.

This program is illegal:

@example
(import (rnrs))
(letrec ((A 123)
         (B (list A)))
  #t)
@end example

@noindent
because the identifier @code{A} in reference position is not in the body
of a @func{lambda} syntax: @func{letrec} does not impose an order to the
evaluation of the init expressions, so to evaluate the right--hand side
of the binding we need the value of the binding itself.

@c ------------------------------------------------------------

@subsubheading On @func{letrec*} bindings

Let's move to the @func{letrec*} syntax; it is similar, but not equal,
to @func{letrec}.  This program is legal:

@example
(import (rnrs))
(letrec* ((A (lambda () A)))
  #t)
@end example

@noindent
because @func{letrec*} defines recursive bindings, so we are allowed to
reference @code{A} in the right--hand side of the binding for @code{A}
itself, as long as we put such reference in the body of a @func{lambda}.

This program is also legal:

@example
(import (rnrs))
(letrec* ((A (lambda () B))
          (B (lambda () A)))
  #t)
@end example

@noindent
because the cross references to @code{A} and @code{B} are in the body of
@func{lambda} syntaxes.

This program is illegal:

@example
(import (rnrs))
(letrec* ((A (list A)))
  #t)
@end example

@noindent
because the identifier @code{A} in reference position is not in the body
of a @func{lambda} syntax: to evaluate the right--hand side of the
binding we need the value of the binding itself.  Again, notice that
@code{A} in reference position is @strong{not} an unbound identifier: it
is captured by the @code{A} in binding position; it is just ``illegal''
and we must detect this situation, according to @rnrs{6}.

This program is legal:

@example
(import (rnrs))
(letrec* ((A 123)
          (B (list A)))
  #t)
@end example

@noindent
because @func{letrec*} imposes a left--to--right order to the evaluation
of the init expressions.

@c ------------------------------------------------------------

@subsubheading On illegal bindings

@rnrs{6} mandates that illegal references to bindings established by
@func{letrec} and @func{letrec*} are detected at run--time and cause an
assertion violation to be raised.  @value{PRJNAME} detects them at
compile--time, so some fully @rnrs{6}-compliant code will not work under
@value{PRJNAME}.

The following code is illegal under both @rnrs{6} and @value{PRJNAME}:

@example
(import (rnrs))
(letrec ((x y)
         (y x))
  'should-not-get-here)
@end example

The following program will run under a @rnrs{6}-compliant
implementation:

@example
(import (rnrs))
(letrec ((x (if (eq? (cons 1 2)
                     (cons 1 2))
                x
              1)))
  x)
@end example

@noindent
because the form @code{x} in reference position in the right--hand side
of the binding is never evaluated; under @value{PRJNAME} this code will
rather raise a syntax violation at compile--time.

@c ------------------------------------------------------------

@subsubheading Bindings on the Scheme stack

In the @objtype{recbind} forms the right--hand side expressions
@meta{rhs} have no imposed order of evaluation; the following two forms,
in which the order of the bindings is reversed, must be completely
equivalent:

@example
(recbind ((@metai{lhs} @metai{rhs})
          (@metaii{lhs} @metaii{rhs}))
  @meta{body})

(recbind ((@metaii{lhs} @metaii{rhs})
          (@metai{lhs} @metai{rhs}))
  @meta{body})
@end example

In the @func{rec*bind} forms the right-hand side expressions @meta{rhs}
must be evaluated in the same order in which they appear.

In a lower--level compiler pass: instances of struct @objtype{bind} will
be converted to code that evaluates the @meta{rhs} expressions and store
their return value into appropriately allocated Scheme stack machine
words; a machine word for every @meta{lhs} will be allocated, each
@meta{lhs} will represent an actual ``local variable''.

If we think about the Scheme stack, it is clear why @objtype{bind}
structures cannot represent recursive bindings; given the core language
expression:

@example
(letrec ((f (lambda () f)))
  @meta{body})
@end example

@noindent
the internal representation must be:

@example
(bind ((f_0 '#!void))
  (seq
    (assign f_0 (lambda () f_0))
    @meta{body}))
@end example

@noindent
so that: first @objtype{bind} reserves a Scheme stack machine word for
the local variable, initialised to @code{#<void>}; then a closure object
is created, referencing the local variable @code{f_0}; finally a
reference to the closure object is stored in @code{f_0}.  To create the
closure object, we must first know the address of the allocated machine
word.

When processing @objtype{recbind} and @objtype{rec*bind} structures: we
must make sure that a machine word is allocated on the Scheme stack
before the address of such word is needed by the @meta{rhs} expressions.
We do this by transforming @objtype{recbind} and @objtype{rec*bind}
instances into a composition of @objtype{bind} and @objtype{assign}
instances.

@c page
@node syslib compiler letrec basic
@subsubsection The basic transformation algorithm


The basic transformations are equivalent to:

@example
(letrec ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@expansion{} (let ((@meta{lhs} #!void) ...)
      (let ((@meta{tmp} @meta{rhs}) ...)
        (set! @meta{lhs} @meta{tmp}) ...
        @meta{body}))

(letrec* ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@expansion{} (let ((@meta{lhs} #!void) ...)
      (set! @meta{lhs} @meta{rhs}) ...
      @meta{body})
@end example

@noindent
and in recordised code are represented as:

@example
(recbind ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@expansion{} (bind ((@meta{lhs} #!void) ...)
      (bind ((@meta{tmp} @meta{rhs}) ...)
        (assign @meta{lhs} @meta{tmp}) ...
        @meta{body}))

(rec*bind ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@expansion{} (bind ((@meta{lhs} #!void) ...)
      (assign @meta{lhs} @meta{rhs}) ...
      @meta{body})
@end example

@noindent
as example, with these transformations the library:

@example
(library (optimize-letrec-basic-demo)
  (export a b c)
  (import (rnrs))
  (define (a) 1)
  (define (b) (a) 2)
  (define (c) (b) 3))
@end example

@noindent
is transformed into:

@example
(bind ((a_0 '#!void)
       (b_0 '#!void)
       (c_0 '#!void))
 (seq
   (set! a_0 (lambda () '1))
   (set! b_0 (lambda () (seq (funcall a_0) '2)))
   (set! c_0 (lambda () (seq (funcall b_0) '3)))
   (funcall void)))
@end example

@c page
@node syslib compiler letrec wsd
@subsubsection The @wsd{} transformation algorithm


The @wsd{} algorithm recognises some properties of the bindings
to allow: less assignment operations, more efficient generation of
unassigned function bindings in the same lexical contour.

When processing a @func{letrec} or @func{letrec*} core language form
@wsd{} classifies each binding into: @code{unreferenced},
@code{simple}, @code{complex} or @code{fixable}.  @value{PRJNAME}'s
implementation of @wsd{} leaves unreferenced bindings alone, in
this compiler pass, to be processed later by the source optimiser; an
unreferenced binding is classified as @code{simple}.  It also renames
the category @code{lambda} into @code{fixable}.

@c ------------------------------------------------------------

@subsubheading The @func{letrec} transformation

If the form is a @func{letrec}: we do @strong{not} care about the order
of evaluation of the right--hand sides, so given the core language form:

@example
(letrec ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
we transform it into:

@example
(let ((@meta{simple.lhs} @meta{simple.rhs}) ...)
  (let ((@meta{complex.lhs} '#!void) ...)
    (let ((@meta{fixable.lhs} @meta{fixable.rhs}) ...)
      (let ((@meta{tmp} @meta{complex.rhs}) ...)
        (set! @meta{complex.lhs} @meta{tmp}) ...
        @meta{body}))))
@end example

@noindent
in which the @meta{complex.rhs} expressions are evaluated in unspecified
order.  In recordised code, the input expression:

@example
(recbind ((@meta{lhs} @meta{rhs}) ...) ?body)
@end example

@noindent
is transformed into:

@example
(bind ((@meta{simple.lhs} @meta{simple.rhs}) ...)
  (bind ((@meta{complex.lhs} '#!void) ...)
    (fix ((@meta{fixable.lhs} @meta{fixable.rhs}) ...)
      (bind ((@meta{tmp} @meta{complex.rhs}) ...)
        (assign @meta{complex.lhs} @meta{tmp}) ...
        @meta{body}))))
@end example

@c ------------------------------------------------------------

@subsubheading The @func{letrec*} transformation

If the form is a @func{letrec*}: we @strong{do care} about the order of
evaluation of the right--hand sides, so given the core language form:

@example
(letrec* ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
we transform it into:

@example
(let ((@meta{simple.lhs} @meta{simple.rhs}) ...)
  (let ((@meta{complex.lhs} '#!void) ...)
    (let ((@meta{fixable.lhs} @meta{fixable.rhs}) ...)
      (set! @meta{complex.lhs} @meta{complex.rhs}) ...
      @meta{body})))
@end example

@noindent
in which the @meta{complex.rhs} expressions are evaluated in the same
order in which they appear in the core language form.  In recordised
code, the input expression:

@example
(rec*bind ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
is transformed into:

@example
(bind ((@meta{simple.lhs} @meta{simple.rhs}) ...)
  (bind ((@meta{complex.lhs} '#!void) ...)
    (fix ((@meta{fixable.lhs} @meta{fixable.rhs}) ...)
      (assign @meta{complex.lhs} @meta{complex.rhs}) ...
      @meta{body})))
@end example

@c ------------------------------------------------------------

@subsubheading Notes

The really important thing about the @wsd{} transformations is to
generate reliable @code{fix} bindings definitions: the classification of
``fixable'' bindings must be reliable.  This covers the very common case
of @func{library} forms whose top level function definitions are
unassigned; for example, the library:

@example
(library (optimize-letrec-waddell-demo)
  (export a b c)
  (import (rnrs))
  (define (a) 1)
  (define (b) (a) 2)
  (define (c) (b) 3))
@end example

@noindent
is transformed into:

@example
(bind ()        ;simple
  (bind ()      ;complex
    (fix ((a_0 (lambda () '1))
          (b_0 (lambda () (seq (funcall a_0) '2)))
          (c_0 (lambda () (seq (funcall b_0) '3))))
      (funcall void))))
@end example

The algorithm's implementation can be conservative and suboptimal in
classifying bindings as @code{complex}, even though they could be
@code{simple} or @code{fixable}, whenever the classification as
@code{simple} or @code{fixable} requires too much work or is unreliable;
in other words: when in doubt, just call it @code{complex}.  One of the
purposes of the @scc{} algorithm is exactly to improve such
classification.

@c page
@node syslib compiler letrec scc
@subsubsection The @scc{} transformation algorithm


The @scc{} algorithm builds a directed graph representation of the
bindings in a single @objtype{recbind} or @objtype{rec*bind} structure,
outlining the dependencies among right--hand side expressions; in the
graph each binding is a vertex (also called node).  It then applies
Tarjan's algorithm to the graph and partitions the bindings into
clusters of Strongly Connected Components (@scc{}).

Here is the gist of the algorithm:

@enumerate
@item
Given the core language @func{letrec} form:

@example
(letrec ((D (lambda () B))
         (C D)
         (B C)
         (A B))
  @meta{body})
@end example

@noindent
we build a directed graph of dependencies between the bindings; the
graph of dependencies for the given form is:

@example
A --> B --> C
      ^     |
      |     |
      D <---
@end example

@item
We perform a depth--first visit of the directed graph; during the visit
we step from the current vertex to a successor one, following an
outgoing edge, if it has not already been visited; a depth--first visit
is like entering a maze and always turn right at cross roads.  While
visiting the vertexes: we push each visited vertex on a stack; we rank
each vertex with a zero--based serial index.

The following picture shows an ongoing visit with path @samp{A},
@samp{B}, @samp{C}, @samp{D}; the serial index of each vertex is in
square brackets:

@example
A[0] --> B[1] --> C[2]     STK == A, B, C, D
           ^       |
           .       |
           .       |
         D[3] <----
@end example

@noindent
let's say we are visiting @samp{D} and considering the successor vertex
@samp{B} as next step.

@enumerate a
@item
@samp{B} has already been visited, so we do not enter it; the index of
@samp{B} is @samp{1}, less than the index of @samp{D} which is @samp{3},
so we mutate the index of @samp{D} to be @samp{1}:

@example
A[0] --> B[1] --> C[2]     STK == A, B, C, D
           ^        |
           .        |
           .        |
         D[1] <-----
@end example

@noindent
there are no more successor vertexes from @samp{D} so we step back to
@samp{C}; notice that we leave the stack unchanged.

@item
Upon stepping back to @samp{C}: we recognise that the index of @samp{C}
is @samp{2}, less than the index of @samp{D} which is @samp{1}; so we
mutate the index of @samp{C} to be @samp{1}:

@example
A[0] --> B[1] --> C[1]     STK == A, B, C, D
           ^        .
           .        .
           .        .
         D[1] <.....
@end example

@noindent
there are no more successor vertexes from @samp{C} so we step back to
@samp{B}; notice that we leave the stack unchanged.

@item
Upon stepping back to @samp{B}: we recognise that the index of @samp{B}
is @samp{1}, greater than or equal to the index of @samp{C} which is
@samp{1}; we leave the index of @samp{B} unchanged.  Now we recognise
that: after visiting all the vertexes successors to @samp{B}, the index
of @samp{B} is unchanged; we conclude that all the nodes on the stack up
to and including @samp{B} are part of a Strongly Connected Component:

@example
STK == A, B, C, D
         |-------| SCC
@end example

@noindent
so we pop them from the stack and form a cluster with them.  The
vertexes in a cluster are marked as ``done'' and will be skipped in
further steps of the visit, as if they are not there.
@end enumerate

@item
Clusters of @scc{}s are formed and accumulated while stepping back from
the depth--first visit, the accumulated clusters are in reverse order.
This implementation of Tarjan's algorithm guarantees that the returned
list of clusters is in the correct order for RHS evaluation in
@objtype{recbind} or @objtype{rec*bind} structs:

@itemize
@item
The RHS of bindings in the first cluster from the list, must be
evaluated before the RHS of bindings in the second cluster.

@item
The RHS of bindings in the second cluster from the list, must be
evaluated before the RHS of bindings in the third cluster.

@item
And so on.
@end itemize

So we can arrange the evaluation as if each cluster comes from a nested
binding form; if the returned list is:

@example
((@meta{cluster-binding-1} ...)
 (@meta{cluster-binding-2} ...)
 (@meta{cluster-binding-3} ...))
@end example

@noindent
the equivalent nested binding forms are:

@example
(recbind (@meta{cluster-binding-3} ...)
  (recbind (@meta{cluster-binding-2} ...)
    (recbind (@meta{cluster-binding-1} ...)
      @meta{body})))
@end example

@item
Each cluster of @scc{}s generates a nested hierarchy of bindings; first
the bindings are partitioned into fixable and non--fixable, the a form
like the following is generated:

@example
(bind ((@meta{complex.lhs} '#!void) ...)
  (fix ((@meta{fixable.lhs} @meta{fixable.rhs}) ...)
    (assign @meta{complex.lhs} @meta{complex.rhs}) ...
    @meta{body}))
@end example
@end enumerate

@c page
@node syslib compiler optimisation
@subsection Source optimisation


For an introduction to the source code see the thesis:

@quotation
Oscar Waddell.  ``Extending the Scope of Syntactic Abstraction''.  PhD.
Thesis.  Indiana University Computer Science Department.  August 1999.
@end quotation

@noindent
and the paper:

@quotation
Oscar Waddell, R. Kent Dybvig.  ``Fast and Effective Procedure
Inlining''.  Indiana University.  Computer Science Department.
Technical Report No. 484.
@end quotation

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $source-optimize @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.
@end defun


@deffn Parameter $source-optimizer-passes-count
Specify how many passes to perform with the source optimizer; it must be
a positive fixnum.  Defaults to @code{1}; it is set to 2 when the
optimisation level is @code{3}.

It makes sense to perform zero, one or two passes; it is unlikely that
more passes can do significant improvement.
@end deffn


The following bindings are exported by the library @library{vicare}.


@deffn Parameter optimize-level
The optimization level; accepted values are the fixnums @code{0},
@code{1}, @code{2}, @code{3}.  Defaults to @code{2}.
@end deffn


@deffn Parameter $cp0-effort-limit
The initial value of an "effort counter" that is decremented every time
an optimisation is performed by the source optimiser; when the counter
reaches zero: the current optimisation effort is abandoned and the
original input expression kept as is.  It is set every time the
optimiser enters specific subexpressions of the input.
@end deffn


@deffn Parameter $cp0-size-limit
The initial value of a (estimated) code size counter that is decremented
every time an optimisation is performed by the source optimiser; when
the counter reaches zero: the current optimisation effort is abandoned
and the original input expression kept as is.  It is set every time the
optimiser enters specific subexpressions of the input.
@end deffn

@c page
@node syslib compiler refassig
@subsection Rewriting references and assignments


References to bindings in recordised code are represented as standalone
@objtype{prelex} structures; assignments to bindings in recordised code
are represented as @objtype{assign} structs:

@example
(assign @meta{prel} @meta{rhs})
@end example

@noindent
in which @meta{prel} is a @objtype{prelex} structure and the right--hand
side @meta{rhs} is recordised code which, evaluated at run--time, will
return the new binding's value.

With respect to how references and assignments are actually implemented,
there are three kinds of lexical bindings:

@itemize
@item
Top level bindings, defined by @func{library-letrec*} core language
forms; @ref{syslib compiler topics topbind, Handling of lexical top
level bindings}.

@item
Unassigned (read--only) local bindings, defined by @func{let},
@func{letrec} and @func{letrec*} core language forms and never subjected
to a @func{set!} core language form; @ref{syslib compiler topics
locbind, Handling of lexical local bindings}.

@item
Assigned (read--write) local bindings, defined by @func{let},
@func{letrec} and @func{letrec*} core language forms and subjected to
one or more @func{set!} core language forms; @ref{syslib compiler topics
locbind, Handling of lexical local bindings}.
@end itemize

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $rewrite-references-and-assignments @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.

Transform references and assignments for top level lexical bindings and
unassigned local lexical bindings according to the implementation of
such operations.  Remembering that the actual value of a top level
binding is stored in the @code{value} field of a loc gensym, this
function performs the following transformations:

@itemize
@item
References to top level bindings are transformed into:

@example
(funcall (primref $symbol-value) (constant @meta{loc}))
@end example

@noindent
which extracts the value from slot @code{value} of the loc gensym
@meta{loc}.

@item
Common assignments to top level bindings are transformed into:

@example
(funcall (primref $set-symbol-value!)
         (constant @meta{loc})
         @meta{rhs})
@end example

@noindent
which stores a new value in the slot @code{value} of the log gensym
@meta{loc}.

@item
Single assignments to top level bindings which also serve as binding
initialisations are transformed into:

@example
(funcall (primref $init-symbol-value!)
         (constant @meta{loc})
         @meta{rhs})
@end example

@noindent
which stores a new value in the slot @code{value} of @meta{loc} and,
only if the value is recognised at run--time as being closure object,
also stores value in the slot @code{proc}.

@item
Definitions of assigned local bindings are transformed as follows:

@example
(bind ((@meta{prel} @meta{init})) @meta{body})
@expansion{} (bind ((@meta{tmp-prel} @meta{init}))
      (bind ((@meta{prel} (funcall (primref vector)
                             @meta{tmp-prel})))
        @meta{body}))
@end example

@item
References to assigned local bindings are transformed from standalone
@objtype{prelex} structs to:

@example
(funcall (primref $vector-ref) @meta{prel} (constant 0))
@end example

@item
Assignments to assigned local bindings are transformed as follows:

@example
(assign @meta{prel} @meta{rhs})
@expansion{} (funcall (primref $vector-set!)
            @meta{prel}
            (constant 0)
            @meta{rhs})
@end example
@end itemize

After this compiler pass: there are no more @objtype{assign} structs in
the returned recordised code.
@end defun

@c page
@node syslib compiler tags
@subsection Tagging known properties


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $introduce-tags @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.
@end defun


@deffn Parameter $perform-tag-analysis
When true the pass @func{$introduce-tags} is performed, else it is
skipped.  Defaults to @true{}.
@end deffn

@c page
@node syslib compiler sanitbind
@subsection Sanitizing bindings


This compiler pass makes sure that every @objtype{clamba} struct appears
as direct right--hand side expression in a @objtype{fix} struct:

@example
(fix ((@meta{lhs} @meta{clambda})) @meta{body})
@end example

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $sanitize-bindings @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.

Perform the following transformations:

@itemize
@item
@objtype{clambda} structs that already appear as RHS of @objtype{fix}
structs are left alone.

@item
@objtype{clambda} structs appearing as RHS in single--binding
@objtype{bind} structs cause the @objtype{bind} struct to be replaced by
a @objtype{fix} struct:

@example
(bind ((@meta{lhs} @meta{clambda})) @meta{body})
@expansion{} (fix ((@meta{lhs} @meta{clambda})) @meta{body})
@end example

@item
@objtype{clambda} structs appearing as RHS in multiple--binding
@objtype{bind} structs cause the @objtype{bind} struct to be split into
a @objtype{bind} struct and a @objtype{fix} struct in which the bindings
are partitioned:

@example
(bind ((@metao{lhs} @meta{clambda})
       (@metai{lhs} @meta{rhs}))
  @meta{body})
@expansion{} (bind ((@metai{lhs} @meta{rhs}))
      (fix ((@metao{lhs} @meta{clambda}))
        @meta{body}))
@end example

@item
@objtype{clambda} structs appearing as standalone expressions (that is:
not directly as RHS of a @objtype{bind} or @objtype{fix} struct) are
``lifted'' as follows:

@example
(clambda (@meta{formals} @meta{body}) ...)
@expansion{} (fix ((tmp (clambda (@meta{formals} @meta{body}) ...)))
      tmp)
@end example
@end itemize

In the returned struct of recordised code: all the @objtype{clambda}
structs appear in the code as right--hand side initialisation
expressions of @objtype{fix} structs; all the @objtype{bind} structs
have a non--@objtype{clambda} struct as right--hand side initialisation
expression.
@end defun

@c page
@node syslib compiler direct jumps
@subsection Optimisation for direct jumps


Let's consider the following code in which the @func{lambda} sexp has
not been integrated at the call site:

@example
(let ((f (lambda (x) x)))
  (f 123))
@end example

@noindent
by inspecting this code we can verify at compile--time that that
@code{f} references a @objtype{clambda} and the application form has the
correct number of operands; @value{PRJNAME} offers a technique to
implement a ``full closure object application'' @code{(f 123)} as a
faster ``direct jump call'' to the @objtype{clambda} clause with the
correct number of operands.  Another example, when the @objtype{clambda}
has multiple clauses:

@example
(let ((f (case-lambda
           ((x)   x)
           ((x y) (list x y)))))
  (f 1 2))
@end example

@noindent
by inspecting this code we can verify at compile--time that @code{f}
references a @objtype{clambda} and that it is called with 2 arguments:
there is technique that allows to implement the application @code{(f 1
2)} as a direct jump to the clause with 2 arguments.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $optimize-for-direct-jumps @var{input}
Perform code optimisation traversing the whole hierarchy in @var{input},
which must be a struct instance representing recordised code, and
building a new hierarchy of optimised, recordised code; return the new
hierarchy.

Transform @objtype{funcall} structs into @objtype{jmpcall} structs
whenever in the application form:

@example
(funcall @meta{operator} @meta{operand} ...)
@end example

@noindent
the operator is a binding reference known to reference a
@objtype{clambda} struct.

Upon entering this transformation: all the @objtype{clambda} structs
must appear in the input as right--hand side initialisation expressions
of @objtype{fix} structs; all the @objtype{bind} structs must have a
non--@objtype{clambda} struct as right--hand side initialisation
expression.
@end defun

@c ------------------------------------------------------------

@subsubheading Examples

Let's see some example in which we have disable function integration in
application forms.  The standard code:

@example
(let ((f (case-lambda
           ((a)   1)
           ((a b) 2))))
  (list (f 1) (f 1 2)))
@end example

@noindent
is transformed into:

@example
(fix ((f_0 (case-lambda
             ((a_0)     (constant 1))
             ((a_1 b_0) (constant 2)))))
  (funcall (primref list)
    (jmpcall asmlabel:f:clambda:case-1
             f_0 (constant 1))
    (jmpcall asmlabel:f:clambda:case-2
             f_0 (constant 1) (constant 2))))
@end example

@noindent
where @code{asmlabel:f:clambda:case-1} is a placeholder for the address
of the machine code entry point of the first case of the
@objtype{clambda} bound to @code{f_0} (the one with 1 argument);
@code{asmlabel:f:clambda:case-2} represents the machine code entry point
of the second case.

The following core language code defines a recursive function:

@example
(letrec ((f (case-lambda
              (()  (f '1))
              ((a) a))))
  ((primitive list) (f) (f '2)))
@end example

@noindent
and it is transformed into:

@example
(fix ((f_0 (case-lambda
             (()
              (jmpcall asmlabel:f:clambda:case-1
                       f_0 (constant 1)))
             ((a_0)
              a_0))))
  (funcall (primref list)
    (jmpcall asmlabel:f:clambda:case-0
             f_0)
    (jmpcall asmlabel:f:clambda:case-1
             f_0 (constant 2))))
@end example

@noindent
where we see the recursive function call is also optimised as direct
jump.

@c page
@node syslib compiler global assign
@subsection Inserting global assignments


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $insert-global-assignments @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of transformed, recordized code;
return the new hierarchy.

This module inserts global assignments forms that put the value of
lexical top level bindings in the slot @code{value} of the corresponding
loc gensym; for bindings whose value is a closure object: the value is
also stored in the @code{proc} slot of the loc gensym.
@end defun


As example, the library:

@example
(library (insert-global-assignments-demo-1)
  (export a b c d)
  (import (rnrs))
  (define (a) '1)
  (define (b) '2)
  (define (c) '3)
  (define d '4))
@end example

@noindent
is expanded into the core language form:

@example
(library-letrec*
    ((a.lex a.loc (lambda () '1))
     (b.lex b.loc (lambda () '2))
     (c.lex c.loc (lambda () '3))
     (d.lex d.loc '4))
  (quote #!void))
@end example

@noindent
then recordised and transformed into:

@example
(fix ((a.lex_0 (lambda () (constant 1)))
      (b.lex_0 (lambda () (constant 2)))
      (c.lex_0 (lambda () (constant 3))))
  (seq
    (funcall (primref $set-symbol-value/proc!)
             (constant a.loc) a.lex_0)
    (funcall (primref $init-symbol-value!)
             (constant b.loc) b.lex_0)
    (funcall (primref $init-symbol-value!)
             (constant c.loc) c.lex_0)
    (bind ((d.lex_0 (constant 4)))
      (seq
        (funcall (primref $init-symbol-value!)
                 (constant d.loc) d.lex_0)
        (constant #!void)))))
@end example

@c page
@node syslib compiler vars
@subsection Introducing storage locations


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $introduce-vars @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.

Replace all the @objtype{prelex} structs in recordised code with
@objtype{var} structs; this is because after this compiler pass we need
a different set of properties to handle variable bindings.
@end defun

@c page
@node syslib compiler closure makers
@subsection Introducing closure makers


We can think of @objtype{clambda} structs as representing code that,
once compiled, becomes the machine code stored in code objects
implementing Scheme functions.  This compiler pass wraps each
@objtype{clambda} struct into a @objtype{closure-maker} struct, which
represents code that, executed at run--time, builds and returns a
closure object using the @objtype{clambda}'s code object as
implementation.  While wrapping @objtype{clambda}, a list of variable
references that are free in the body of the @objtype{clambda} is
gathered for future use.

@quotation
@strong{NOTE} The @strong{true} purpose of this compiler pass is to
gather lists of free variables referenced by @objtype{clambda} bodies.
We might introduce the closure makers at a later pass and store the
lists of free variables in the @objtype{clambda} structs; we introduce
the closure makers here because it helps a bit in reasoning about the
transformations.
@end quotation

Upon entering this compiler pass:

@itemize
@item
For bindings defined by @objtype{bind} structs:

@example
(bind ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
the @meta{lhs} are @objtype{var} structs; the @meta{rhs} are
non--@objtype{clambda} structs; the @objtype{var} in @meta{lhs} do
@strong{not} appear in the @meta{rhs} expressions.

@item
For bindings defined by @objtype{fix} structs:

@example
(fix ((@meta{lhs} @meta{rhs}) ...) @meta{body})
@end example

@noindent
the @meta{lhs} are @objtype{var} structs; the @meta{rhs} are
@objtype{clambda} structs; the @objtype{var} in @meta{lhs} might appear
in the @meta{rhs} expressions.

@item
Structs of type @objtype{clambda} appear only as right--hand side
expressions of @objtype{fix} structs.
@end itemize

This compiler pass transforms:

@example
(fix ((@meta{lhs} @meta{clambda-rhs}) ...) @meta{body})
@end example

@noindent
into:

@example
(fix ((@meta{lhs} (closure-maker @meta{clambda-rhs})) ...) @meta{body})
@end example

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $introduce-closure-makers @var{input}
Perform code transformations traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code, and building a new hierarchy of recordised code; return the new
hierarchy.

This function wraps each @objtype{clambda} struct in the input
recordised code into @objtype{closure-maker} structures, compiling a
list of free variables referenced by each @objtype{clambda}.
@end defun

@c ------------------------------------------------------------

@subsubheading Examples

This example generates a function with no free variables:

@example
(lambda () '1)
@expansion{} (fix ((tmp_0 (closure-maker (lambda () (constant 1))
                                no-freevars)))
      tmp_0)
@end example

This example generates a multi--clause function with no free variables:

@example
(case-lambda
 (() '1)
 ((a) a))
@expansion{} (fix ((tmp_0 (closure-maker (case-lambda
                                 (()    (constant 1))
                                 ((a_0) a_0))
                                no-freevars)))
      tmp_0)
@end example

This example generates a function with a free variable:

@example
(let ((a ((primitive read))))
  (lambda () a))
@expansion{} (bind ((a_0 (funcall (primref read))))
      (fix ((tmp_0 (closure-maker (lambda () a_0)
                                  (freevars: a_0))))
        tmp_0))
@end example

This example generates a recursive function with no free variables other
than the reference to itself:

@example
(letrec ((f (lambda () (f))))
  f)
@expansion{} (fix ((f_0 (closure-maker
                  (lambda ()
                    (jmpcall asmlabel:f:clambda:case-0 f_0))
                  (freevars: f_0))))
      f_0)
@end example

The core language form:

@example
(library-letrec*
    ((a a.loc (lambda () '1))
     (b b.loc (lambda () '2))
     (c c.loc (lambda () '3))
     (d d.loc '4))
  (quote #!void))
@end example

@noindent
is transformed into:

@example
(fix ((a_0 (closure-maker (lambda () (constant 1)) no-freevars))
      (b_0 (closure-maker (lambda () (constant 2)) no-freevars))
      (c_0 (closure-maker (lambda () (constant 3)) no-freevars)))
  (seq
    (funcall (primref $set-symbol-value/proc!)
             (constant a.loc) a_0)
    (funcall (primref $init-symbol-value!)
             (constant b.loc) b_0)
    (funcall (primref $init-symbol-value!)
             (constant c.loc) c_0)
    (bind ((d_0 (constant 4)))
      (seq
        (funcall (primref $init-symbol-value!)
                 (constant d.loc) d_0)
        (constant #!void)))))
@end example

@c page
@node syslib compiler lifting
@subsection Closures optimization and @objtype{clambda} lifting


This compiler pass performs @objtype{clambda} lifting and optimisation
of calls to functions without free variables.  To discuss the
transformations we define:

@table @emph
@item combinator
A Scheme function without free variables; a combinator does not capture
any binding.  The closure object implementing a combinator can be
created once and for all; for example:

@example
(define (compute x y z)
  (define (lincomb a b c)
    (+ (* a b) (* a c)))
  (lincomb x y z))
@end example

@noindent
assuming function integration is disabled: the closure object
implementing the function @func{lincomb} can be created once and reused
at every call to @func{compute}.

@item non--combinator
A Scheme function with free variables, whose current value is captured
every time the closure object is created.  The closure object
implementing a non--combinator must be created every time to capture the
current values of the free variables; for example:

@example
(define (adder x)
  (lambda (x)
    (+ x y)))
@end example

@noindent
at every call to the function @func{adder} a new closure object must be
created and returned, capturing the value of the argument @code{x}.
@end table

@menu
* syslib compiler lifting intro::  Introduction to @objtype{clambda} lifting.
* syslib compiler lifting req::    Prerequisites for codes lifting.
* syslib compiler lifting combin:: Optimisation of combinator calls.
* syslib compiler lifting noncom:: Combinators and non--combinators.
* syslib compiler lifting api::    @objtype{clambda} lifting @api{}.
@end menu

@c page
@node syslib compiler lifting intro
@subsubsection Introduction to @objtype{clambda} lifting


The purpose of this compiler pass is to partition the input expression
into: the code that will be compiled to code objects implementing
closure objects; code that will be compiled to a code object
implementing the main body of the expression.  As example, the library:

@example
(library (clambda-lifting-demo-0)
  (export a b c d)
  (import (rnrs))
  (define (a) '1)
  (define (b) '2)
  (define (c) '3)
  (define d 4))
@end example

@noindent
is expanded into:

@example
(library-letrec*
    ((a a.loc (lambda () '1))
     (b b.loc (lambda () '2))
     (c c.loc (lambda () '3))
     (d d.loc '4))
  (quote #!void))
@end example

@noindent
before this compiler pass it is transformed into:

@example
(fix ((a_0 (closure-maker (lambda () (constant 1)) no-freevars))
      (b_0 (closure-maker (lambda () (constant 2)) no-freevars))
      (c_0 (closure-maker (lambda () (constant 3)) no-freevars)))
  (seq
    (funcall (primref $set-symbol-value/proc!)
             (constant a.loc) a_0)
    (funcall (primref $init-symbol-value!)
             (constant b.loc) b_0)
    (funcall (primref $init-symbol-value!)
             (constant c.loc) c_0)
    (bind ((d_0 (constant 4)))
      (seq
        (funcall (primref $init-symbol-value!)
                 (constant d.loc) d_0)
        (constant #!void)))))
@end example

@noindent
and after this compiler pass it will become:

@example
(codes
  ((lambda (label: asmlabel:c:clambda) () (constant 3))
   (lambda (label: asmlabel:b:clambda) () (constant 2))
   (lambda (label: asmlabel:a:clambda) () (constant 1)))
  (seq
    (funcall (primref $set-symbol-value/proc!)
      (constant a.loc)
      (closure-maker (code-loc asmlabel:a:clambda) no-freevars))
    (funcall (primref $init-symbol-value!)
      (constant b.loc)
      (closure-maker (code-loc asmlabel:b:clambda) no-freevars))
    (funcall (primref $init-symbol-value!)
      (constant c.loc)
      (closure-maker (code-loc asmlabel:c:clambda) no-freevars))
    (bind ((d_0 (constant 4)))
      (seq
        (funcall (primref $init-symbol-value!)
          (constant d.loc) d_0)
        (constant #!void)))))
@end example

We see the result of the transformation is a struct of type
@objtype{codes} in which the @objtype{clambda} forms have been extracted
and separated; in addition, the top level @objtype{fix} struct has been
removed and references to the @objtype{fix} bindings have been replaced
by @objtype{closure-maker} forms.

The @objtype{closure-maker} form:

@example
(closure-maker (code-loc asmlabel:a:clambda) no-freevars)
@end example

@noindent
will be compiled to code that return a closure object implementing the
function @code{a}, with assembly entry point label
@code{asmlabel:a:clambda}.

@c page
@node syslib compiler lifting req
@subsubsection Prerequisites for codes lifting


When arriving at this compiler pass the input recordised code is such
that:

@itemize
@item
All the @objtype{clambda} structs are wrapped into
@objtype{closure-maker} structs.

@item
All the @objtype{closure-maker} structs appear as right--hand side
expressions of bindings defined by @objtype{fix} structs.

@item
Bindings defined by @objtype{fix} structs are immutable and their
right--hand side expressions are all @objtype{closure-maker} structs.

@item
Bindings defined by @objtype{bind} structs have right--hand side
expressions of type different from @objtype{closure-maker} and
@objtype{clambda}.

@item
If the right--hand side expression of a binding defined by
@objtype{bind} is a @objtype{var} struct: such binding is immutable.
For example:

@example
(bind ((a @meta{rhs}))
  (bind ((b a))
    @meta{body}))
@end example

@noindent
the binding @code{b} is immutable, so @code{b} is a synonym of @code{a};
it is perfectly all right to substitute all the occurrences of the
@objtype{var} @code{b} in @meta{body} with occurrences of the
@objtype{var} @code{a}.
@end itemize

@c page
@node syslib compiler lifting combin
@subsubsection Optimisation of combinator calls


If a Scheme function is a combinator it does not need to capture the
current value of any binding; this means we might create a single
closure object for every combinator function and use it everywhere the
function is referenced (including in function applications).

Conversely, if a Scheme function is a combinator: there is no need to
allocate a closure object for it and keep it in memory forever; we can
delay the creation until the function is actually referenced (including
in function applications).  This compiler pass assumes that delaying the
creation of closure objects for combinators is advantageous.

Let's see some examples in which function integration has been disabled:

@itemize
@item
This core language expression:

@example
(lambda () ((primitive read)))
@end example

@noindent
is transformed into:

@example
(codes
 ((lambda (label: asmlabel:anonymous:clambda)
    () (funcall (primref read))))
 (closure-maker (code-loc asmlabel:anonymous:clambda)
                no-freevars))
@end example

@item
In this core language expression:

@example
(let ((f (lambda () '1))
      (g (lambda () '2)))
  ((primitive list) (f) (g)))
@end example

@noindent
the @objtype{closure-maker} struct is introduced at the functions call
site:

@example
(codes
  ((lambda (label: asmlabel:g:clambda) () (constant 2))
   (lambda (label: asmlabel:f:clambda) () (constant 1)))
  (funcall (primref list)
    (jmpcall asmlabel:f:clambda:case-0
             (closure-maker (code-loc asmlabel:f:clambda)
                            no-freevars))
    (jmpcall asmlabel:g:clambda:case-0
             (closure-maker (code-loc asmlabel:g:clambda)
                            no-freevars))))
@end example

@item
In this core languge form:

@example
(let ((f (lambda () '1)))
   ((primitive list) (f) (f)))
@end example

@noindent
multiple @objtype{closure-maker} structs are introduced for the same
function:

@example
 (codes
  ((lambda (label: asmlabel:f:clambda) () (constant 1)))
  (funcall (primref list)
    (jmpcall asmlabel:f:clambda:case-0
             (closure-maker (code-loc asmlabel:f:clambda)
                            no-freevars))
    (jmpcall asmlabel:f:clambda:case-0
             (closure-maker (code-loc asmlabel:f:clambda)
                            no-freevars))))
@end example
@end itemize

The fact that we introduce multiple @objtype{closure-maker} structs to
create closure objects with the same @objtype{clambda} implementation,
takes advantage of the @rnrs{6} statement that we cannot assume Scheme
functions are @func{eq?} to themselves:

@example
(define (func) @meta{body})
(eq? func func) @result{} unspecified
@end example

@noindent
for example, the following core language
form:

@example
(let ((a (lambda () '1)))
  (eq? a a))
@end example

@noindent
is transformed into:

@example
(codes
  ((lambda (label: asmlabel:a:clambda) () (constant 1)))
  (funcall (funcall (primref top-level-value) (constant eq?))
    (closure-maker (code-loc asmlabel:a:clambda) no-freevars)
    (closure-maker (code-loc asmlabel:a:clambda) no-freevars))
@end example

@noindent
further transformations of the code might recognise the operands of
@func{eq?} as being references to the same function, but in more complex
cases this may not happen.

@c page
@node syslib compiler lifting noncom
@subsubsection Combinators and non--combinators


We want to discuss how to recognise combinators and non--combinators
among the bindings defined by a @objtype{fix} struct.

Let's consider the recordised code:

@example
(bind ((@metai{lhs} @metai{rhs}) ...)
  (fix ((@metao{lhs} @metao{rhs}) ...)
    (bind ((@metaii{lhs} @metaii{rhs}) ...)
      @meta{body})))
@end example

@noindent
at this point in the sequence of compiler passes, we know that all the
@metao{rhs} are @objtype{closure-maker} structs.  The @objtype{var}
structs @metao{lhs} and @metai{lhs} may appear in the body of each
@metao{rhs}, while the internally defined @objtype{var} structs
@metaii{lhs} cannot; so the @metaii{lhs} do not influence the nature of
the @metao{rhs} expressions.  We can ignore all the internally defined
bindings.

Let's switch to inspect the recordised code:

@example
(bind ((@metai{lhs} @metai{rhs}) ...)
  (fix ((@metao{lhs} @metao{rhs}) ...)
    @meta{body}))
@end example

@noindent
the @objtype{var} structs @metao{lhs} and @metai{lhs} may appear in the
body of each @metao{rhs}; this includes the case of recursive
@metao{rhs}, in which a @metao{lhs} @objtype{var} appears in the list of
free variables of the associated @metao{rhs}.

@itemize
@item
If a list of free variables is empty: the corresponding @metao{rhs} is a
combinator.  For example, in the recordised code:

@example
(bind ((a @meta{rhs-a}) (b @meta{rhs-b}))
  (fix ((f (closure-maker (lambda () '3) no-freevars))
        (g (closure-maker (lambda () '4) no-freevars)))
    @meta{body}))
@end example

@noindent
both the @objtype{fix}--bound @objtype{clambda} have empty list of free
variables, so both functions are combinators.

@item
If a list of free variables contains only externally defined @metai{lhs}
structs: the corresponding @metao{rhs} is a non--combinator.  For
example, in the recordised code:

@example
(bind ((a @meta{rhs-a}) (b @meta{rhs-b}))
  (fix ((f (closure-maker (lambda () a)
                          (freevars: a)))
        (g (closure-maker (lambda () (constant 3))
                          no-freevars)))
    @meta{body}))
@end example

@noindent
the @objtype{clambda} bound to @code{f} has the @objtype{var} @code{a}
in its free variables list; the value of the free variable @code{a} is
known only at run--time, so the closure maker must capture a run--time
value, so the function @code{f} is a non--combinator.

@item
If a list of free variables contains only @metao{lhs} structs defined at
by the same @objtype{fix} and bound to combinators: the corresponding
@metao{rhs} is a combinator.  For example, in the recordised code:

@example
(bind ((a @meta{rhs-a}) (b @meta{rhs-b}))
  (fix ((f (closure-maker (lambda () (constant 3))
                          no-freevars))
        (g (closure-maker (lambda () (funcall f))
                          (freevars: f))))
    @meta{body}))
@end example

@noindent
the @objtype{clambda} bound to @code{f} is has no free variables, so it
is a combinator; the @objtype{clambda} bound to @code{g} has @code{f} in
its list of free variables; the value of @code{f} is known at
compile--time, so the closure maker of @code{g} does not need to capture
a free variable run--time value, so the function @code{g} is a
combinator too.

@item
If every list of free variables contains only @metao{lhs} structs
defined by the same @objtype{fix}: all the corresponding @metao{rhs} are
combinators.  For example, in the recordised code:

@example
(bind ((a @meta{rhs-a}) (b @meta{rhs-b}))
  (fix ((f (closure-maker (lambda () (funcall g))
                          (freevars: g)))
        (g (closure-maker (lambda () (funcall f))
                          (freevars: f))))
    @meta{body}))
@end example

@noindent
both @objtype{clambda} structs have lists of free variables including
only @objtype{var} structs defined by the same @objtype{fix}; the values
of the free variables is known at compile--time, so the closure makers
do not need to capture the free variables' run--time values, so both the
functions are combinators.

@item
If a list of free variables contains a @metao{lhs} struct bound to a
non--combinator, the corresponding @metao{rhs} is a non--combinator too.
For example, in the recordised code:

@example
(bind ((a @meta{rhs-a}) (b @meta{rhs-b}))
  (fix ((f (closure-maker (lambda () a)
                          (freevars: a)))
        (g (closure-maker (lambda () (funcall f))
                          (freevars: f))))
    @meta{body}))
@end example

@noindent
the @objtype{clambda} bound to @code{f} is a non--combinator; the
@objtype{clambda} bound to @code{g} has @code{f} in its free variables
list; the value of @code{f} includes the run--time value of @code{a}, so
the value of the free variable @code{f} is known only at run--time, so
the closure maker of @code{g} must capture the run--time value, so the
function @code{g} is a non--combinator.
@end itemize

@c ------------------------------------------------------------

Let's consider some examples of code creating a function and reason
about the function being a combinator or a non--combinator:

@itemize
@item
In the recordised code:

@example
(bind ((a_0 (constant 1)))
  (lambda () a_0))
@end example

@noindent
the returned function is a non--combinator because its return value
depends upon the value of the binding @code{a_0} at the time the closure
object is created; @code{a_0} is a free variable in the body of the
function and the function is closed upon it.  Indeed such form is
transformed into:

@example
(codes
  ((lambda (label: asmlabel:anonymous:clambda) () a_0))
  (bind ((a_0 (funcall (primref read))))
    (fix ((tmp_0 (closure-maker
                   (code-loc asmlabel:anonymous:clambda)
                   (freevars: a_0))))
      tmp_0)))
@end example

@item
In the following recordised code:

@example
(lambda ()
  ((primitive list) 1 2))
@end example

@noindent
the returned function looks like it is closed upon the binding
@func{list}, but in truth @func{list} is a primitive function whose
binding never mutates; so the returned function is a ``combinator'', a
function without free variables.

@item
In this example a single non--combinator is called twice:

@example
(let ((a ((primitive read))))
  (let ((f (lambda () a)))
    ((primitive list) (f) (f))))
@end example

@noindent
the result of the transformation is:

@example
(codes
  ((lambda (label: asmlabel:f:clambda) () a_0))
  (bind ((a_0 (funcall (primref read))))
    (fix ((f_0 (closure-maker (code-loc asmlabel:f:clambda)
                              (freevars: a_0))))
      (funcall (primref list)
               (jmpcall asmlabel:f:clambda:case-0 f_0)
               (jmpcall asmlabel:f:clambda:case-0 f_0)))))
@end example

@noindent
we see that a single @objtype{closure-maker} is introduced.

@item
The following standard code:

@example
(letrec* ((a (lambda () (b)))
          (b (lambda () (a))))
  @meta{body})
@end example

@noindent
is recordised and processed to:

@example
(fix ((a_0 (lambda () (funcall b_0)))
      (b_0 (lambda () (funcall a_0))))
  @meta{body})
@end example

@noindent
so the functions are just combinators, because it is known at
compile--time that @code{a_0} and @code{b_0} are immutable bindings
referencing closures and it is also known which closures are referenced.

@item
In the following recordised code:

@example
(fix ((a_0 (lambda () @meta{body})))
  (bind ((b_0 a_0))
    (fix ((c_0 (lambda () (funcall b_0))))
      c_0)))
@end example

@noindent
the returned value looks like a closure upon the binding @code{b_0}, but
in truth it is known at compile--time that @code{b_0} is an immutable
binding referencing a @objtype{clambda} struct and also which
@objtype{clambda} is referenced; so the function bound to @code{c_0} is
just a combinator.

More: everywhere a reference to @code{b_0} appears we can substitute it
with a reference to @code{a_0}, and so we can transform the code to:

@example
(fix ((a_0 (lambda () @meta{body})))
  (bind ((b_0 a_0))
    (fix ((c_0 (lambda () (funcall a_0))))
      c_0)))
@end example

@item
We may think that a self reference in a recursive function makes it a
closure, but this is not true.  For example:

@example
(fix ((f (lambda () (f))))
  @meta{body})
@end example

@noindent
defines @code{f} as a combinator because the recursive call to @code{f}
can be implemented as a @objtype{jmpcall} to the assembly entry point of
the function and there are no other free variables.  Instead:

@example
(bind ((a @meta{rhs}))
  (fix ((f (lambda (b) (f a))))
    @meta{body}))
@end example

@noindent
defines @code{f} as a non--combinator: the recursive call to @code{f}
can be implemented as a @objtype{jmpcall} to the assembly entry point of
the function, but the function is closed upon the variable @code{a}.  It
is the free variable @code{a} that makes @code{f} a non--combinator.
@end itemize

@c page
@node syslib compiler lifting api
@subsubsection @objtype{clambda} lifting @api{}


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $optimize-combinator-calls/lift-clambdas @var{input}
Perform code transformation traversing the whole hierarchy in
@var{input}, which must be a struct instance representing recordised
code in the core language, and building a new hierarchy of transformed,
recordised code; return a @objtype{codes} struct.

Perform @objtype{clambda} lifting and optimisation of calls to functions
without free variables.
@end defun

@c page
@node syslib compiler primcalls
@subsection Introducing primitive calls


The purpose of this compiler pass is to examine all the function calls:

@example
(@meta{operator} @meta{operand} ...)
@end example

@noindent
which, in recordized code, are represented by struct instances of type
@objtype{funcall}; everything else is left untouched.  If the
@meta{operator} is a struct instance of type @objtype{primref}
representing a primitive operation: such struct is replaced by an
appropriate struct instance of type @objtype{primcall}.  So recordised
code like:

@example
(funcall (primref @meta{name}) (@meta{operand} ...))
@end example

@noindent
is transformed into:

@example
(primcall @meta{name} (@meta{operand} ...))
@end example

If the @objtype{funcall} struct represents a call to a proper lexical
core primitive function (not operation): it is left untouched as
@objtype{funcall} struct.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $introduce-primcalls @var{input}
Perform code transformation traversing the whole hierarchy in
@var{input}, which must be a @objtype{codes} struct representing
recordised code; build and return a new @objtype{codes} struct.

Transform @objtype{funcall} structs representing core primitive
operation applications into @objtype{primcall} structs.
@end defun

@c page
@node syslib compiler fix
@subsection Removing fixes


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $eliminate-fix @var{input}
@end defun

@c page
@node syslib compiler engine
@subsection Inserting engine checks


This compiler pass traverses all the function bodies and, if the body
contains at least one @objtype{jmpcall} struct or one @objtype{funcall}
struct (in which the operator is @strong{not} a @objtype{primref}), it
transforms the @meta{?body} into:

@example
(seq
  (primcall $do-event ())
  @meta{body})
@end example

@noindent
the call to the primitive operation @func{$do-event} suspends the
execution of Scheme code for the current internal process and enters an
internal subprocess which can take actions asynchronously.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $insert-engine-checks @var{input}
Perform code transformation traversing the whole hierarchy in
@var{input}, which must be a @objtype{codes} struct representing
recordised code; build and return a new @objtype{codes} struct.

Insert calls to the primitive operation @func{$do-event} when
appropriate.
@end defun

@c page
@node syslib compiler stack
@subsection Inserting stack overflow checks


This compiler pass traverses all the function bodies and: if a
@meta{body} contains code that will cause further use of the Scheme
stack, it transforms it as follows:

@example
(seq
  (primcall $stack-overflow-check ())
  @meta{body})
@end example

@noindent
so that, right after entering the execution of a function, the call to
the primitive operation @func{$stack-overflow-check} checks if the
current Scheme stack is about to be exhausted.  If a @meta{body} does
not make further use of the stack: its function execution is a ``stack
tail''.

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $insert-stack-overflow-check @var{input}
Perform code transformation traversing the whole hierarchy in
@var{input}, which must be a @objtype{codes} struct representing
recordised code; build and return a new @objtype{codes} struct.

Insert calls to the primitive operation @func{$stack-overflow-check}
when appropriate.
@end defun

@c page
@node syslib compiler cogen
@subsection Full assembly code generation


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $alt-cogen @var{input}
@end defun

@c page
@node syslib compiler assember
@subsection Binary code generation


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $assemble-sources @var{input}
@end defun

@c page
@node syslib compiler primop
@subsection Expanding primitive operations


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $specify-representation @var{input}
@end defun

@c page
@node syslib compiler order
@subsection Imposing calling convention and evaluation order


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $impose-calling-convention/evaluation-order @var{input}
@end defun

@c page
@node syslib compiler frame
@subsection Assigning frame sizes


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $assign-frame-sizes @var{input}
@end defun

@c page
@node syslib compiler color
@subsection Colorising by Chaitin


For an introduction to register allocation see:

@center @url{http://en.wikipedia.org/wiki/Register_allocation}

The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $color-by-chaitin @var{input}
@end defun

@c page
@node syslib compiler flatten
@subsection Flattening codes


The following bindings are exported by the library @library{vicare
system $compiler}.


@defun $flatten-codes @var{input}
@end defun

@c end of file
