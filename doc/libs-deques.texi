@node deques
@chapter Simple double--ended queues


@cindex @library{vicare containers deques}, library
@cindex Library @library{vicare containers deques}


The library @library{vicare containers deques} implements deques
(pronounced ``decks'') holding arbitrary Scheme objects and designed for
efficient insertion and removal at both ends.

@menu
* deques objects::              Deque objects.
* deques inspection::           Inspecting deque objects.
* deques access::               Deque accessors and mutators.
* deques folding::              Folding over deques.
* deques ops::                  Operations over deques.
* deques conversion::           Converting deques to other objects.
@end menu

@c page
@node deques objects
@section Deque objects


The following syntactic bindings are exported by the library
@library{vicare containers deques}.


@deftp {@rnrs{6} Record Type} <deque>
@cindex @var{deque} argument
@cindex Argument @var{deque}
Record type representing a deque object.  The @objtype{<deque>} type is
non--generative and available for subtyping.  In this documentation
@objtype{<deque>} object arguments to functions are indicated as
@var{deque}.
@end deftp


@defun make-deque
@defunx make-deque @var{buffer-length}
Build and return a new @objtype{<deque>} object.  The optional argument
@var{buffer-length} must be a non--negative fixnum representing the
number of slots in the internal object buffers; when not given, it
defaults to @math{15}.
@end defun


@defun deque? @var{obj}
Return @true{} if @var{obj} is a record of type @objtype{<deque>};
otherwise return @false{}.
@end defun


@defun deque @var{obj} @dots{}
Build and return a @objtype{<deque>} object holding the given objects,
which are pushed on the deque left to right from the rear side.  The
size of the internal buffers is set to the default.

@lisp
(define D
  (deque 0 1 2))

(deque-front D)         @result{} 0
(deque-rear  D)         @result{} 2
@end lisp
@end defun

@c ------------------------------------------------------------

@subsubheading Object properties


@defun deque-putprop @var{deque} @var{key} @var{value}
@defunx $deque-putprop @var{deque} @var{key} @var{value}
Add a new property @var{key} to the property list of @var{deque};
@var{key} must be a symbol.  If @var{key} is already set: the old entry
is mutated to reference the new @var{value}.
@end defun


@defun deque-getprop @var{deque} @var{key}
@defunx $deque-getprop @var{deque} @var{key}
Return the value of the property @var{key} in the property list of
@var{deque}; if @var{key} is not set: return @false{}.  @var{key} must
be a symbol.
@end defun


@defun deque-remprop @var{deque} @var{key}
@defunx $deque-remprop @var{deque} @var{key}
Remove the property @var{key} from the property list of @var{deque}; if
@var{key} is not set: nothing happens.  @var{key} must be a symbol.
@end defun


@defun deque-property-list @var{deque}
@defunx $deque-property-list @var{deque}
Return a new association list representing the property list of
@var{deque}.  The order of the entries is the same as the property
creation order.
@end defun

@c ------------------------------------------------------------

@subsubheading Other operations


@defun deque-hash @var{deque}
@defunx $deque-hash @var{deque}
Return an exact integer to be used as hashtable key for @var{deque}.
Hashtables having a @objtype{<deque>} as key can be instantiated as
follows:

@example
(make-hashtable deque-hash eq?)
@end example
@end defun

@c page
@node deques inspection
@section Inspecting deque objects


The following syntactic bindings are exported by the library
@library{vicare containers deques}.  The syntactic bindings whose name
is prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun deque-empty? @var{deque}
@defunx $deque-empty? @var{deque}
Return @true{} if @var{deque} is empty; otherwise return @false{}.
@end defun


@defun deque-not-empty? @var{deque}
@defunx $deque-not-empty? @var{deque}
Return @true{} if @var{deque} is @strong{not} empty; otherwise return
@false{}.
@end defun


@defun deque-size? @var{deque}
@defunx $deque-size? @var{deque}
Return an exact integer representing the number of objects in @var{deque}.
@end defun

@c page
@node deques access
@section Deque accessors and mutators


The following syntactic bindings are exported by the library
@library{vicare containers deques}.  The syntactic bindings whose name
is prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun deque-front @var{deque}
@defunx $deque-front @var{deque}
Return the object at the front of the deque.  Raise an assertion violation
if @var{deque} is empty.
@end defun


@defun deque-rear @var{deque}
@defunx $deque-rear @var{deque}
Return the object at the rear of the deque.  Raise an assertion
violation if @var{deque} is empty.
@end defun


@defun deque-push-front! @var{deque} @var{obj}
@defunx $deque-push-front! @var{deque} @var{obj}
Push @var{obj} on the front of the @var{deque}.
@end defun


@defun deque-push-rear! @var{deque} @var{obj}
@defunx $deque-push-rear! @var{deque} @var{obj}
Push @var{obj} on the rear of the @var{deque}.
@end defun


@defun deque-pop-front! @var{deque}
@defunx $deque-pop-front! @var{deque}
Remove the object at the front of the deque and return it.  Raise an
assertion violation if @var{deque} is empty.
@end defun


@defun deque-pop-rear! @var{deque}
@defunx $deque-pop-rear! @var{deque}
Remove the object at the rear of the deque and return it.  Raise an
assertion violation if @var{deque} is empty.
@end defun


@defun deque-purge! @var{deque}
@defunx $deque-purge! @var{deque}
Remove all the elements from @var{deque}.
@end defun

@c page
@node deques folding
@section Folding over deques


The following syntactic bindings are exported by the library
@library{vicare containers deques}.  The syntactic bindings whose name
is prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun deque-fold-front @var{kons} @var{knil} @var{deque}
@defunx $deque-fold-front @var{kons} @var{knil} @var{deque}
Analogous to @func{fold-left} for lists.  Fold the procedure @var{kons}
of the the objects from @var{deque}.

@lisp
(define D
  (deque 0 1 2 3 4 5))

(deque-fold-front (lambda (knil obj)
                    (cons obj knil))
  '() D)
@result{} (5 4 3 2 1 0)
@end lisp
@end defun


@defun deque-fold-rear @var{kons} @var{knil} @var{deque}
@defunx $deque-fold-rear @var{kons} @var{knil} @var{deque}
Analogous to @func{fold-right} for lists.  Fold the procedure @var{kons}
of the the objects from @var{deque}.

@lisp
(define D
  (deque 0 1 2 3 4 5))

(deque-fold-rear (lambda (obj knil)
                   (cons obj knil))
  '() D)
@result{} (0 1 2 3 4 5)
@end lisp
@end defun

@c page
@node deques ops
@section Operations over deques


The following syntactic bindings are exported by the library
@library{vicare containers deques}.  The syntactic bindings whose name
is prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun deque-copy @var{dst-deque} @var{src-deque}
@defunx $deque-copy @var{dst-deque} @var{src-deque}
Iterate over all the objects in @var{src-deque}, starting from the front
side, and push them in the rear side of @var{dst-deque}.  This is a
shallow copy: the very objects from the source deque are added to the
destination deque; if we need to duplicate the objects, we can use the
map operation.

The @var{dst-deque} argument allows us to build the destination deque
with the desired configuration.
@end defun


@defun deque-map-front @var{dst-deque} @var{fun} @var{src-deque}
@defunx $deque-map-front @var{dst-deque} @var{fun} @var{src-deque}
Iterate over all the objects in @var{src-deque}, starting from the front
side, apply @var{fun} to them, finally push them in the rear side of
@var{dst-deque}.

@lisp
(deque->list
  (deque-map-front (deque) - (deque 0 1 2 3)))
@result{} (0 -1 -2 -3)
@end lisp

The @var{dst-deque} argument allows us to build the destination deque
with the desired configuration.
@end defun


@defun deque-map-rear @var{dst-deque} @var{fun} @var{src-deque}
@defunx $deque-map-rear @var{dst-deque} @var{fun} @var{src-deque}
Iterate over all the objects in @var{src-deque}, starting from the rear
side, apply @var{fun} to them, finally push them in the front side of
@var{dst-deque}.

@lisp
(deque->list
  (deque-map-rear (deque) - (deque 0 1 2 3)))
@result{} (0 -1 -2 -3)
@end lisp

The @var{dst-deque} argument allows us to build the destination deque
with the desired configuration.
@end defun


@defun deque-for-each-front @var{fun} @var{deque}
@defunx $deque-for-each-front @var{fun} @var{deque}
Iterate over all the objects in @var{deque}, starting from the front
side, and apply @var{fun} to them discarding the return value.
@end defun


@defun deque-for-each-rear @var{fun} @var{deque}
@defunx $deque-for-each-rear @var{fun} @var{deque}
Iterate over all the objects in @var{deque}, starting from the rear
side, and apply @var{fun} to them discarding the return value.
@end defun

@c page
@node deques conversion
@section Converting deques to other objects


The following syntactic bindings are exported by the library
@library{vicare containers deques}.  The syntactic bindings whose name
is prefixed with @code{$} are unsafe operations: they do @strong{not}
validate their arguments before accessing them.


@defun deque->list @var{deque}
@defunx $deque->list @var{deque}
@defunx list->deque @var{list}
@defunx $list->deque @var{list}
Convert to and from a deque and a proper list.  Objects from the list
are pushed on the deque left--to--right from the rear side.

@lisp
(define D
  (list->deque '(0 1 2)))

(deque-front  D)        @result{} 0
(deque-rear   D)        @result{} 2
(list->vector D)        @result{} (0 1 2)
@end lisp
@end defun


@defun deque->vector @var{deque}
@defunx $deque->vector @var{deque}
@defunx vector->deque @var{vector}
@defunx $vector->deque @var{vector}
Convert to and from a deque and a vector.  Objects from the list are
pushed on the deque left--to--right from the rear side.

@lisp
(define D
  (vector->deque '#(0 1 2)))

(deque-front   D)       @result{} 0
(deque-rear    D)       @result{} 2
(deque->vector D)       @result{} #(0 1 2)
@end lisp
@end defun

@c end of file
